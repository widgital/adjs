(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Request, currentName, events, sf, stream, utils;

  currentName = window.name;

  sf = require('../node_modules/safeframe/lib/js/ext/ext')(true);

  events = require('./shared/event')(["request", "load", "view", "click", "expanded", "collapsed", "engage", "unview", "unload"]);

  utils = require('./shared/utils');

  Request = require('./request');

  stream = require('./shared/stream');

  (function(sf, window) {
    var AdJS, VIEWED_STRIKE, attributes, didShow, forceNuke, height, host, isViewedInterval, location, onUpdate, referrerLevel, registerAdJSendpoints, registerForEvents, registered, request, requested, setSessionInfo, sfDom, showAd, showAdTimer, showPage, unviewedTicks, updateIsViewed, updateReferrer, viewedTicks, width;
    request = new Request();
    request.change(function() {
      return stream.event(request);
    });
    sfDom = sf.lib.dom;
    AdJS = {};
    VIEWED_STRIKE = 9;
    viewedTicks = 0;
    unviewedTicks = 0;
    width = window.innerWidth;
    height = window.innerHeight;
    registered = false;
    didShow = false;
    requested = false;
    attributes = {};
    AdJS.setDimensions = function(w, h) {
      width = w;
      return height = h;
    };
    registerForEvents = function() {
      registered = true;
      return $sf.ext.register(width, height, onUpdate);
    };
    registerAdJSendpoints = function() {
      return true;
    };
    setSessionInfo = function(cookieData) {
      return request.set(utils.fromQuery(cookieData));
    };
    updateReferrer = function(level) {
      if (level == null) {
        level = "all";
      }
      switch (level) {
        case "all":
          return true;
        case "host":
          utils.defineProperty(document, "referrer", {
            get: function() {
              return "" + document.location.protocol + "//" + host;
            }
          });
          return true;
        case "none":
          return false;
        default:
          return true;
      }
    };
    onUpdate = function(status, data) {
      switch (status) {
        case "expanded":
          return function() {
            return AdJS.expanded();
          };
        case "collapsed":
          return function() {
            return AdJS.collapsed();
          };
        case "geom-update":
          return showAd();
        case "cookie-update":
          return setSessionInfo(unescape(data.value));
        case "engaged":
          return AdJS.engage();
        case "requested":
          if (!requested) {
            return AdJS.request();
          }
      }
    };
    isViewedInterval = null;
    updateIsViewed = function() {
      var _base, _base1;
      if (!AdJS.isViewed && (typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 50 && $sf.ext.winHasFocus()) {
        viewedTicks++;
      } else if (AdJS.isViewed && ((typeof (_base1 = $sf.ext).inViewPercentage === "function" ? _base1.inViewPercentage() : void 0) < 50 || !$sf.ext.winHasFocus())) {
        unviewedTicks++;
      } else {
        unviewedTicks = viewedTicks = 0;
      }
      if (viewedTicks === VIEWED_STRIKE) {
        if (!AdJS.isViewed) {
          AdJS.view();
        }
        AdJS.isViewed = true;
      }
      if (unviewedTicks === VIEWED_STRIKE) {
        if (!AdJS.isunViewed) {
          AdJS.unview();
        }
        AdJS.isunViewed = true;
        return clearInterval(isViewedInterval);
      }
    };
    showAdTimer = null;
    showAd = function(show) {
      var startTime, _base;
      if (((typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 5 && !didShow) || show) {
        if (showAdTimer) {
          clearInterval(showAdTimer);
        }
        startTime = utils.now();
        AdJS.request();
        $sf.ext.showAd(function() {
          return AdJS.load();
        });
        return didShow = true;
      } else if (!(showAdTimer || didShow)) {
        return showAdTimer = setInterval(forceNuke, 50);
      }
    };
    forceNuke = function() {
      var _base;
      if ((typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 5 && showAdTimer) {
        clearInterval(showAdTimer);
        showAdTimer = null;
        return $sf.ext.reload();
      }
    };
    sf.lib.lang.mix(AdJS, events);
    AdJS.on = function(event, cb) {
      return events.on.apply(this, [event, cb]);
    };
    AdJS.expand = function(deltaXorDesc, deltaY, p) {
      return $sf.ext.expand(deltaXorDesc, deltaY, p);
    };
    AdJS.collapse = function() {
      return $sf.ext.collapse();
    };
    AdJS.cookie = function(cookieName, cookieData) {
      return $sf.ext.cookie(coookieName, cookieData);
    };
    AdJS.supports = function(key) {
      return $sf.ext.supports(key);
    };
    AdJS.sendMessage = function(content) {
      return setTimeout(function() {
        return $sf.ext.message(encodeURIComponent(content));
      }, 1);
    };
    sfDom.attach(document.body, "mouseup", function() {
      AdJS.click();
      return true;
    });
    window.$ad = AdJS;
    registerAdJSendpoints();
    AdJS.click(function() {
      return sf.ext.click();
    });
    AdJS.view(function() {
      return sf.ext.viewed();
    });
    AdJS.unview(function() {
      return sf.ext.unviewed();
    });
    AdJS.load(function() {
      return registerForEvents();
    });
    AdJS.load(function() {
      return isViewedInterval = setInterval(updateIsViewed, 100);
    });
    AdJS.load(function() {
      AdJS.frameCount = utils.countFrames(window);
      return request.set({
        frame_count: AdJS.frameCount
      });
    });
    AdJS.request(function() {
      AdJS.requestTime = utils.now();
      return request.set({
        requested: true,
        requestedAt: utils.now()
      });
    });
    AdJS.load(function() {
      AdJS.loadTime = utils.now();
      sfDom.attach(window, "unload", function() {
        return $ad.unload();
      });
      return request.set({
        loaded: true,
        loadedAt: utils.now()
      });
    });
    AdJS.view(function() {
      AdJS.viewTime = utils.now();
      return request.set({
        viewed: true,
        viewedAt: utils.now()
      });
    });
    AdJS.engage(function() {
      AdJS.engageTime = utils.now();
      return request.set({
        engaged: true,
        engagedAt: utils.now()
      });
    });
    AdJS.click(function() {
      AdJS.clickTime = utils.now();
      return request.set({
        clicked: true,
        clickedAt: utils.now()
      });
    });
    AdJS.unview(function() {
      AdJS.unviewTime = utils.now();
      return request.set({
        unviewed: true,
        unviewedAt: utils.now()
      });
    });
    AdJS.unload(function() {
      AdJS.unloadTime = utils.now();
      return request.set({
        unloaded: true,
        unloadedAt: utils.now()
      });
    });
    sf.ext.render(false);
    didShow = !sf.lib.lang.cbool(sf.ext.meta("inview", "extended"));
    referrerLevel = sf.ext.meta("referrer", "extended") || "all";
    host = sf.ext.meta("host", "extended");
    sf.ext.deleteMeta("host", "extended");
    location = sf.ext.meta("location", "extended");
    sf.ext.deleteMeta("location", "extended");
    setSessionInfo(sf.ext.meta("session", "extended"), {
      silent: true
    });
    sf.ext.deleteMeta("session", "extended");
    $ad.slotId = sf.ext.meta("slot_id", "extended");
    $ad.count = sf.ext.meta("slot_count", "extended");
    request.set({
      slot_id: sf.ext.meta("slot_id", "extended"),
      slot_count: sf.ext.meta("slot_count", "extended"),
      page_url: location,
      page_host: host
    }, {
      silent: true
    });
    showPage = document.location.href === document.referrer || updateReferrer(referrerLevel);
    if (showPage) {
      showAd(didShow);
    } else {
      window.name = currentName;
      document.location = document.location;
    }
    return AdJS;
  })(sf, window);

}).call(this);

},{"../node_modules/safeframe/lib/js/ext/ext":10,"./request":2,"./shared/event":5,"./shared/stream":6,"./shared/utils":7}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.JSON || (window.JSON = require('json'));

  utils = require('./shared/utils');

  Base = require('./shared/base');

  module.exports = (function(window) {
    var Request;
    Request = (function(_super) {
      var REQ_INTERVAL;

      __extends(Request, _super);

      REQ_INTERVAL = 50;

      function Request(clientId, sessionId) {
        Request.__super__.constructor.apply(this, arguments);
      }

      Request.prototype.sendRequest = function() {
        if (!this.requestInProcess) {
          this.requestInProcess = true;
          clearTimeout(this.timeoutId);
          this.timeoutId = null;
          return utils.sendRequest("http://127.0.0.1/test", {
            data: this.attributes,
            success: function(data) {
              this.requestInProcess = false;
              return this.set(data, {
                silent: true
              });
            }
          });
        } else {
          if (!this.timeoutId) {
            this.waiting = true;
            return this.timeoutId = setTimeout((function(_this) {
              return function() {
                clearTimeout(_this.timeoutId);
                _this.timeoutId = null;
                return _this.sendRequest();
              };
            })(this));
          }
        }
      };

      return Request;

    })(Base);
    return Request;
  })(window);

}).call(this);

},{"./shared/base":3,"./shared/utils":7,"json":8}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.attributes || (this.attributes = {});
        this._events = [];
      }

      Base.prototype.set = function(attrs, options) {
        var changed, changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        changed = false;
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
          }
          this.attributes[k] = v;
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      return Base;

    })();
  })();

}).call(this);

},{}],4:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html'
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//endpoint.adjs.io/1",
        cdn_url: process.env.CDN_URL
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html'
      };
    }
  })();

}).call(this);

}).call(this,require("8DwohR"))
},{"8DwohR":16}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(eventNames) {
    return (function() {
      var event, events, utils, _i, _len;
      utils = require('./utils');
      events = {
        on: function(event, cb) {
          var eventList;
          this.events || (this.events = {});
          eventList = this.events[event] || [];
          eventList.push(cb);
          this.events[event] = eventList;
          return this;
        },

        /*
          optionalData needs to be fixed
         */
        trigger: function(event, data, optionalData) {
          var e, ex, _i, _len, _ref;
          this.events || (this.events = {});
          _ref = this.events[event] || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            try {
              e.call(this, data, optionalData);
            } catch (_error) {
              ex = _error;
            }
          }
          this.notify(event, data || this);
          return this;
        },
        notify: function(event, data) {
          var endpoint, params, _i, _len, _ref, _ref1, _results;
          _ref1 = ((_ref = this.eventEndpoints) != null ? _ref[event] : void 0) || [];
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            endpoint = _ref1[_i];
            params = (data != null ? typeof data.getParams === "function" ? data.getParams() : void 0 : void 0) || {};
            params.event = event;
            _results.push(utils.sendRequest(endpoint, {
              data: params
            }));
          }
          return _results;
        }
      };
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        event = eventNames[_i];
        events[event] = (function(event) {
          var f;
          return f = function(data) {
            if (typeof data === "function") {
              return this.on(event, data);
            } else {
              return this.trigger(event, data);
            }
          };
        })(event);
        events["" + event + "RegisterEndpoint"] = (function(event) {
          var f;
          return f = function(endpoint) {
            var _base;
            this.eventEndpoints || (this.eventEndpoints = {});
            (_base = this.eventEndpoints)[event] || (_base[event] = []);
            return this.eventEndpoints[event].push(endpoint);
          };
        })(event);
      }
      return events;
    })();
  };

}).call(this);

},{"./utils":7}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var config, reqwest;

  reqwest = require('reqwest');

  config = require('./config');

  module.exports = (function() {
    var pendingRequests, prefix, send, sendingRequests;
    prefix = config.api;
    pendingRequests = {};
    sendingRequests = {};
    send = function(url, data, success, error) {
      return reqwest({
        url: url,
        type: 'jsonp',
        data: data,
        success: success,
        error: error
      });
    };
    return {
      page: function(session) {
        var error, success;
        success = function(resp) {
          return session.set(resp, {
            silent: true
          });
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        return send(prefix + '/page', session.attributes, success, error);
      },
      event: function(request, cb, isAttempt) {
        var error, success;
        success = function(resp) {
          request.set(resp, {
            silent: true
          });
          if (typeof cb === "function") {
            cb(resp);
          }
          return delete sendingRequests[request.id];
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        if (!sendingRequests[request.id]) {
          delete pendingRequests[request.id];
          sendingRequests[request.id] = true;
          return send(prefix + '/event', request.attributes, success, error);
        } else if (!pendingRequests[request.id] || isAttempt) {
          pendingRequests[request.id];
          return setTimeout((function(_this) {
            return function() {
              return _this.event(request, cb, true);
            };
          })(this), 500);
        }
      }
    };
  })();

}).call(this);

},{"./config":4,"reqwest":9}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  window.reqwest || (window.reqwest = require('reqwest'));

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf, window) {
    var capitalizeString, countFrames, defineProperty, fromQuery, now, reqwest, sendRequest, toNumber, toQuery;
    reqwest = window.reqwest;
    sendRequest = function(url, options) {
      return reqwest({
        url: url,
        type: 'jsonp',
        success: options.success,
        error: options.error,
        data: options.data
      });
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        }
      } catch (_error) {
        e = _error;
        return console.log(e);
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    capitalizeString = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return {
      sendRequest: sendRequest,
      toQuery: toQuery,
      fromQuery: fromQuery,
      toNumber: toNumber,
      now: now,
      defineProperty: defineProperty,
      countFrames: countFrames,
      capitalizeString: capitalizeString
    };
  })($sf, window);

}).call(this);

},{"json":8,"reqwest":9}],8:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],9:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@fileOverview This file contains JavaScript code that handles the HTML document where HTML is rendered for a SafeFrame, as well as defining the External Vendor/Client API.
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.3
 */


/*
@namespace $sf.ext The external vendor / client API for functionality inside a SafeFrame
@name $sf.ext
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require("../shared/base");

  module.exports = function(isExternal) {
    return (function(window, sf) {
      var COLLAPSE_COMMAND, DG, DOM_WATCH_INTERVAL, DP, DS, ERROR_COMMAND, EXPAND_COMMAND, GUID_VALID_TIME, IE_ATTACH, IE_DETACH, LOAD, MAX_MSG_WAIT_TIME, MSG, NOTIFY_CLICKED, NOTIFY_COLLAPSE, NOTIFY_COLLAPSED, NOTIFY_EXPAND, NOTIFY_FAILURE, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, NOTIFY_LOADED, NOTIFY_READ_COOKIE, NOTIFY_RELOAD, NOTIFY_REQUESTED, NOTIFY_UNVIEWED, NOTIFY_VIEWED, NOTIFY_WRITE_COOKIE, OBJ, ONLOAD, ONMSG, ONUNLOAD, ON_STR, OUR_TAG_CLS_NAME, ParamHash, STATUS_COLLAPSED, STATUS_COLLAPSING, STATUS_EXPANDED, STATUS_EXPANDING, TOLOWERCASE, UNLOAD, W3C_ATTACH, W3C_DETACH, adShown, can_use_html5, click, cmdRetries, collapse, cookie, d, deleteMeta, dom, env, err_msg_timer_id, err_msgs, expand, force_collapse, frame_id, geom, geom_info, guid, hasLoaded, host_cname, ie_old_attach, ie_old_detach, iframes, inViewPercentage, init_height, init_width, inline_handler_timer_id, isAdShown, isIE, is_expanded, is_registered, lang, lib, loaded, message, meta, msgclient_fb, originalWrite, orphan_timer_id, par, pending_msg, pos_id, pos_meta, register, reload, render, render_conf, render_params, sandbox_cb, showAd, status, supports, unload_handlers, unviewed, viewed, w3c_old_attach, w3c_old_detach, win, winHasFocus, win_has_focus, _append, _attach, _attach_override, _attr, _call_client_fb, _call_raw_evt_func, _check_orphaned, _cnum, _collapse, _construction, _create_stylesheet, _cstr, _destruction, _detach, _detach_override, _detect_bad_iframe, _elt, _fire_sandbox_callback, _handle_err, _handle_load, _handle_msg, _handle_unload, _nuke_doc, _purge, _reattach_messaging, _receive_msg, _render, _report_errs, _requested, _reset_inline_handlers, _send_cmd, _send_msg, _set_alignment, _set_hyperlink_targets, _setup_win_evt_props, _tags, _ue, _wrapiFrame;
      win = window;
      LOAD = "load";
      ON_STR = "on";
      MSG = "message";
      UNLOAD = "un" + LOAD;
      ONUNLOAD = ON_STR + UNLOAD;
      ONMSG = ON_STR + MSG;
      ONLOAD = ON_STR + LOAD;
      DG = "__defineGetter__";
      DS = "__defineSetter__";
      DP = "__defineProperty__";
      W3C_ATTACH = "addEventListener";
      W3C_DETACH = "removeEventListener";
      IE_ATTACH = "attachEvent";
      IE_DETACH = "detachEvent";
      TOLOWERCASE = "toLowerCase";
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_EXPAND = "expand";
      NOTIFY_FOCUS_CHANGE = "focus-change";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_COLLAPSED = NOTIFY_COLLAPSE + "d";
      NOTIFY_FAILURE = "failed";
      NOTIFY_READ_COOKIE = "read-cookie";
      NOTIFY_WRITE_COOKIE = "write-cookie";
      NOTIFY_CLICKED = "clicked";
      NOTIFY_VIEWED = "viewed";
      NOTIFY_UNVIEWED = "unviewed";
      NOTIFY_LOADED = "loaded";
      NOTIFY_REQUESTED = "requested";
      NOTIFY_RELOAD = "reload";
      STATUS_COLLAPSED = NOTIFY_COLLAPSED;
      STATUS_EXPANDED = NOTIFY_EXPAND + "ed";
      STATUS_COLLAPSING = "collapsing";
      STATUS_EXPANDING = NOTIFY_EXPAND + "ing";
      OUR_TAG_CLS_NAME = "sf";
      MAX_MSG_WAIT_TIME = 4000;
      DOM_WATCH_INTERVAL = 3000;
      GUID_VALID_TIME = 30000;
      OBJ = "object";
      d = win && win.document;
      par = win && win.parent;
      lib = sf.lib;
      env = sf.env;
      lang = lib.lang;
      ParamHash = lang.ParamHash;
      dom = lib.dom;
      iframes = dom.iframes;
      msgclient_fb = dom.msgclient_fb;
      isIE = env.isIE;
      _ue = win.unescape;
      _cstr = lang.cstr;
      _cnum = lang.cnum;
      _append = dom.append;
      _tags = dom.tags;
      _elt = dom && dom.elt;
      _purge = dom && dom.purge;
      _attach = dom && dom.attach;
      _detach = dom && dom.detach;
      _attr = dom && dom.attr;
      hasLoaded = false;
      is_expanded = false;
      force_collapse = false;
      is_registered = false;
      init_width = 0;
      init_height = 0;
      sandbox_cb = null;
      pending_msg = null;
      geom_info = null;
      pos_meta = null;
      win_has_focus = false;
      guid = "";
      host_cname = "";
      can_use_html5 = false;
      frame_id = "";
      pos_id = "";
      err_msg_timer_id = 0;
      orphan_timer_id = 0;
      inline_handler_timer_id = 0;
      err_msgs = [];
      unload_handlers = [];
      render_params = void 0;
      render_conf = void 0;
      ie_old_attach = void 0;
      w3c_old_attach = void 0;
      ie_old_detach = void 0;
      w3c_old_detach = void 0;
      isAdShown = false;

      /*
      Creates and appends a style sheet for any custom CSS passed
      
      @name $sf.ext-_create_stylesheet
      @function
      @static
      @private
      @param {String} cssText A string of CSS rules, or a URL string
      @param {String} [id] The id attribute of the tag created and appended
       */
      _create_stylesheet = function(cssText, id) {
        var e, oHead, oSS, oTxt;
        oHead = void 0;
        oSS = void 0;
        oTxt = void 0;
        e = void 0;
        try {
          oHead = _tags("head")[0];
          if (cssText.search(/\{[^\}]*}/g) === -1) {
            oSS = dom.make("link");
            oSS.type = "text/css";
            oSS.rel = "stylesheet";
            oSS.href = cssText;
          } else {
            oSS = dom.make("style");
            oSS.type = "text/css";
            if (isIE) {
              oSS.styleSheet.cssText = cssText;
            } else {
              oTxt = d.createTextNode(cssText);
              _append(oSS, oTxt);
            }
          }
          if (id) {
            oSS.id = id;
          }
          _append(oHead, oSS);
        } catch (_error) {}
      };

      /*
      Fires of unload event handlers and performs the necessary clean up when a SafeFrame is destroyed
      
      @name $sf.ext-_destruction
      @function
      @static
      @private
      @param {HTMLEvent} [evt] The raw dom event object if it exists
       */
      _destruction = function(evt) {
        var e, grand_par, handler, success, w;
        handler = void 0;
        w = window;
        success = 1;
        e = void 0;
        try {
          evt = evt || w.event || {};
        } catch (_error) {
          e = _error;
          evt = {
            type: UNLOAD
          };
        }
        while (handler = unload_handlers.shift()) {
          try {
            handler(evt);
          } catch (_error) {}
        }
        try {
          if (ie_old_attach) {
            w[IE_ATTACH] = ie_old_attach;
            w[IE_DETACH] = ie_old_detach;
          }
        } catch (_error) {}
        try {
          if (w3c_old_attach) {
            w[W3C_ATTACH] = w3c_old_attach;
            w[W3C_DETACH] = w3c_old_detach;
          }
        } catch (_error) {}
        if (!hasLoaded) {
          _detach(w, LOAD, _handle_load);
        }
        _detach(w, UNLOAD, _handle_unload);
        try {
          w.onerror = null;
        } catch (_error) {}
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (orphan_timer_id) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        w = ie_old_attach = w3c_old_attach = ie_old_detach = w3c_old_detach = d = _ue = par = handler = grand_par = null;
        return success;
      };

      /*
      Maintains that the window.onmessage property remains unset.
      We don't want content in our document listening to HTML5 messages.
      We override attaching to listeners below to maintain that functionality,
      however IE won't let you override properties directly hangning off of the
      window object, so we have a timer as a fallback for that purpose
      
      @name $sf.ext-_reset_inline_handlers
      @function
      @static
      @private
       */
      _reset_inline_handlers = function() {
        var e;
        e = void 0;
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (isIE && win.onmessage) {
            win.onmessage = null;
          }
        } catch (_error) {}
        try {
          win.onerror = _handle_err;
        } catch (_error) {}
        inline_handler_timer_id = setTimeout(_reset_inline_handlers, DOM_WATCH_INTERVAL);
      };

      /*
      Clears out the HTML document (which will force an unload event as well).
      
      @name $sf.ext-_nuke_doc
      @function
      @static
      @private
       */
      _nuke_doc = function() {
        var e;
        e = void 0;
        try {
          document.open("text/html", "replace");
          document.write("");
          document.close();
        } catch (_error) {}
      };

      /*
      Iteratively checks to see if the IFRAME HTML document is no longer
      attached to the main dom, doing this by checking that our internal
      window reference is still valid. . .as well as running the checks to make
      sure invalid iframes (iframes from origin) are not created.
      
      If we detect that the IFRAME has been removed from the main dom of the
      publisher, then we call to destroy the HTML document, forcing onunload
      event and subsquent cleanup
      
      @name $sf.ext-_check_orphaned
      @function
      @static
      @private
       */
      _check_orphaned = function() {
        var e, is_orphaned;
        is_orphaned = false;
        e = void 0;
        _detect_bad_iframe();
        if (!isIE) {
          return;
        }
        try {
          if (orphan_timer_id && orphan_timer_id !== -1) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          is_orphaned = win === top && orphan_timer_id !== -1;
        } catch (_error) {
          e = _error;
          is_orphaned = false;
        }
        if (is_orphaned) {
          orphan_timer_id = -1;
          _destruction();
          _nuke_doc();
          return;
        }
        try {
          if (!orphan_timer_id) {
            orphan_timer_id = setTimeout(_check_orphaned, DOM_WATCH_INTERVAL);
          }
        } catch (_error) {}
      };

      /*
      Detect whether or not an IFRAME tag has been inserted into the DOM that has the same
      origin / cname as the publisher, which should not be allowed as it's a security issue
      If said IFRAME tag(s) are found, remove them.
      
      @name $sf.ext-_detect_bad_iframe
      @function
      @static
      @private
       */
      _detect_bad_iframe = function() {
        var idx, srcHost, tag, written;
        iframes = _tags("iframe");
        idx = 0;
        srcHost = "";
        written = false;
        tag = void 0;
        if (host_cname) {
          while (tag = iframes[idx++]) {
            srcHost = _attr(tag, "src");
            srcHost = (srcHost && srcHost.length >= 9 ? srcHost.substring(0, srcHost.indexOf("/", 9))[TOLOWERCASE]() : "");
            if (srcHost && srcHost === host_cname && tag.className !== OUR_TAG_CLS_NAME) {
              try {
                _purge(tag);
              } catch (_error) {}
            }
          }
        }
      };

      /*
      Make sure that all hyperlinks in the document are set with the property "target" attribute
      such that links will navigate to the right window properly.
      
      @name $sf.ext-_set_hyperlink_targets
      @function
      @static
      @private
       */
      _set_hyperlink_targets = function() {
        var atgt, idx, ln, lns, ttgt;
        idx = 0;
        ttgt = (render_conf && render_conf.tgt) || "_top";
        ln = void 0;
        atgt = void 0;
        lns = void 0;
        lns = _tags("a");
        if (ttgt === "_self") {
          ttgt = "_top";
        }
        while (ln = lns[idx++]) {
          atgt = _attr(ln, "target");
          if (atgt !== ttgt) {
            _attr(ln, "target", ttgt);
          }
          if (idx > 10) {
            break;
          }
        }
      };

      /*
      Handle the onunload event from the HTML document of the IFRAME, which in turn will trigger clean up
      
      @name $sf.ext-_handle_unload
      @function
      @static
      @private
      @param {HTMLEvent} evt The raw DOM event object
       */
      _handle_unload = function(evt) {
        _destruction(evt);
        _nuke_doc();
      };

      /*
      Handle the load event from the HTML document of the IFRAME, which will also setup
      to make sure link targets are set properly
      
      @name $sf.ext-_handle_load
      @function
      @static
      @private
       */
      _handle_load = function() {
        if (loaded) {
          return;
        }
        hasLoaded = true;
        _detach(win, LOAD, _handle_load);
        _set_hyperlink_targets();
      };

      /*
      Handle onmessage HTML5 x-domain events. We always cancel the event
      never allowing it to go to other listeners besides our own, as we don't allow HTML5 messaging
      beyond us and the publisher / host.
      
      @name $sf.ext-_handle_msg
      @function
      @static
      @private
       */
      _handle_msg = function(evt) {
        var e, msg_guid, msg_obj, msg_params, org, src, str;
        str = void 0;
        src = void 0;
        org = void 0;
        e = void 0;
        msg_params = void 0;
        msg_guid = void 0;
        msg_obj = void 0;

        /*
        TODO, also validate origin
         */
        try {
          str = evt.data;
          src = evt.source;
          org = evt.origin;
        } catch (_error) {}
        dom.evtCncl(evt);
        if (str && src && src === top) {
          msg_params = ParamHash(str, null, null, true, true);
          msg_guid = msg_params.guid;
          msg_obj = msg_params.msg;
          if (guid === msg_guid && msg_obj && typeof msg_obj === OBJ) {
            try {
              setTimeout((function() {
                _receive_msg(msg_obj, evt);
                msg_params = evt = msg_guid = msg_obj = null;
              }), 1);
            } catch (_error) {}
          }
        }
      };

      /*
      This SafeFrames implementation internally handles all event attachment to maintain that the listener order
      for events that it cares about (onload, onunload, onbeforeunload, onmessage).
      This is done to make sure that proper clean up and intialization happens, as well as to enforce
      security.
      
      For events that it SafeFrames does not care about we allow the attachment listeners
      to proceed as normal, so we call the raw attachEvent / addEventListener functions.
      
      @name $sf.ext-_call_raw_evt_func
      @function
      @static
      @private
      @param {String} type The name of the event for which to attach/detach a listener
      @param {Function} f The callback function to use as a listener for said event
      @param {Boolean} [remove] If set to true, remove/detach this function as a listener, otherwise add
       */
      _call_raw_evt_func = function(type, f, remove) {
        var bOK, e, ie_f, w3c_f;
        bOK = false;
        ie_f = void 0;
        w3c_f = void 0;
        e = void 0;
        if (remove) {
          ie_f = ie_old_detach || w3c_old_detach;
          w3c_f = w3c_old_detach;
        } else {
          ie_f = ie_old_attach || w3c_old_attach;
          w3c_f = w3c_old_attach;
        }
        if (ie_f) {
          try {
            ie_f(type, f);
            bOK = true;
          } catch (_error) {
            e = _error;
            bOK = false;
          }
          if (!bOK) {
            try {
              ie_f.call(win, type, f);
              bOK = true;
            } catch (_error) {
              e = _error;
              bOK = false;
            }
          }
        }
        if (w3c_f && !bOK) {
          try {
            w3c_f.call(win, type, f, false);
          } catch (_error) {}
        }
      };

      /*
      Override default event attachment, and send load, beforeunload, and unload handlers into our
      own ques, so that we can enforce the proper firing order.  if message event is passed in,
      we do not allow attachment, since we do not want n-party code listening to HTML5 messages
      
      @name $sf.ext-_attach_override
      @function
      @static
      @private
      @param {String} type the event name to listen too
      @param {Function} f The function to be called whenever the event fires
       */
      _attach_override = function(type, f) {
        var bDoDefault;
        bDoDefault = false;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            unload_handlers.push(f);
            break;
          case MSG:
          case ONMSG:
            true;
            break;
          default:
            bDoDefault = true;
        }
        if (bDoDefault) {
          _call_raw_evt_func(type, f);
        }
      };

      /*
      Override default event detachment, and remove load, beforeunload, and unload handlers
      from our own que.  if message event is passed in, we do nothing (since we don't alllow
      attachment either).  If not one of those event types, then we call the default event detachment
      
      @name $sf.ext-_detach_override
      @function
      @static
      @private
      @param {String} type the event name to unlisten too
      @param {Function} f The function to no longer be called for the specific event
       */
      _detach_override = function(type, f) {
        var handler, handlers, idx;
        idx = 0;
        handler = void 0;
        handlers = void 0;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            handlers = unload_handlers;
            break;
          case MSG:
          case ONMSG:
            true;
        }
        if (handlers != null ? handlers.length : void 0) {
          while (handler = handlers[idx]) {
            if (handler === f) {
              handlers.splice(idx, 1);
              break;
            }
            idx++;
          }
        } else {

        }
        _call_raw_evt_func(type, f, true);
      };

      /*
      Report any internal uncaught JavaScript errors up to the publisher / host
      
      @name $sf.ext-_report_errs
      @static
      @function
      @private
       */
      _report_errs = function() {
        var cmd_str, e, errs;
        e = void 0;
        errs = void 0;
        try {
          if (err_msgs.length > 0) {
            errs = err_msgs[0];
            cmd_str = ["cmd=", ERROR_COMMAND, "&pos=", pos_id, "&errors=", errs];
            _send_msg(_cstr(cmd_str), ERROR_COMMAND);
          }
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        err_msgs = [];
      };

      /*
      Handle any uncaught JavaScript errors
      
      @name $sf.ext-_handle_err
      @static
      @function
      @private
      @param {String} a The the error message / description string
      @param {String} b The URL / file that the JavaScript error occured within
      @param {Number} c The line number that the error occured on. . .
       */
      _handle_err = function(a, b, c) {
        var e;
        e = void 0;
        err_msgs.push(_cstr(["Error occurred inside SafeFrame:\nMessage: ", a, "\nURL:", b, "\nLine:", c]));
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
          err_msg_timer_id = setTimeout(_report_errs, DOM_WATCH_INTERVAL);
        } catch (_error) {}
        return true;
      };

      /*
      Override native window methods and properties so that we can control
      how the events that we need to manage
      
      @name $sf.ext-_setup_win_evt_props
      @static
      @function
      @private
      @param {Object} obj The window object / prototype
       */
      _setup_win_evt_props = function(obj) {
        var O, e, n, nobj, ret;
        n = lang.noop;
        O = Object;
        nobj = {
          get: n,
          set: n
        };
        ret = false;
        if (obj) {
          if (ie_old_attach) {
            obj[IE_ATTACH] = _attach_override;
            obj[IE_DETACH] = _detach_override;
          }
          if (w3c_old_attach) {
            obj[W3C_ATTACH] = _attach_override;
            obj[W3C_DETACH] = _detach_override;
          }
          if (obj[DG]) {
            try {
              obj[DG](ONLOAD, n);
              obj[DS](ONLOAD, n);
              obj[DG](ONUNLOAD, n);
              obj[DS](ONUNLOAD, n);
              obj[DG](ONMSG, n);
              obj[DS](ONMSG, n);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
          if (!ret && O[DP]) {
            try {
              O[DP](obj, ONLOAD, nobj);
              O[DP](obj, ONUNLOAD, nobj);
              O[DP](obj, ONMSG, nobg);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Intialize / setup the safeframe, the environment according to the configuration found within the serialized
      window.name property.
      
      @name $sf.ext-_construction
      @param {Object} [details] An optional object to pass in status / error information into
      @static
      @private
      @function
       */
      _construction = function(details) {
        var cont, cur_time, e, el, guid_time, nm, ret, temp, time_delta;
        cont = false;
        ret = true;
        el = void 0;
        nm = void 0;
        temp = void 0;
        cur_time = void 0;
        guid_time = void 0;
        time_delta = void 0;
        e = void 0;
        details = (details && (details instanceof Object) ? details : {});
        try {
          nm = win.name;
        } catch (_error) {}
        try {
          win.name = "";
        } catch (_error) {}
        if (!nm) {
          details.status = 500.101;
          return cont;
        }
        try {
          if (top === par) {
            render_params = ParamHash(nm, null, null, true, true);
            cur_time = lang.time();
            guid = render_params.guid;
            guid_time = _cnum(guid.replace(/[^_]*_(\d+)_\d+_\d+/g, "$1"), 0);
            time_delta = cur_time - guid_time;
            cont = guid && guid_time && time_delta > 0 && time_delta < GUID_VALID_TIME;
            if (render_params.loc) {
              render_params.loc = unescape(render_params.loc);
            }
            if (!cont) {
              details.status = 500.104;
            }
          } else {
            details.status = 500.102;
          }
        } catch (_error) {
          e = _error;
          render_params = guid = null;
          cont = false;
          details.status = 500.103;
        }
        if (cont) {
          try {
            render_conf = render_params.conf;
            frame_id = win.name = render_conf.dest;
            pos_id = render_conf.id;
            pos_meta = render_params.meta;
            host_cname = render_params.host;
            geom_info = render_params.geom;
            can_use_html5 = lang.cbool(render_params.html5);
            win_has_focus = lang.cbool(render_params.has_focus);
            temp = render_conf.bg;
            if (geom_info) {
              geom_info = ParamHash(_ue(geom_info), null, null, true, true);
              if (!geom_info.self || !geom_info.exp) {
                geom_info = null;
              }
            }
            if (!host_cname) {
              host_cname = d.referrer;
              host_cname = host_cname.substring(0, host_cname.indexOf("/", 9));
            }
            if (temp) {
              _create_stylesheet(_cstr(["#sf_body { background-color: ", temp, "; }"]), "sf_bg_css");
            }
            temp = render_conf.tgt;
            if (temp === "_self") {
              render_conf.tgt = "_top";
            }
            if (!temp) {
              render_conf.tgt = "_top";
            }
            if (temp !== "_top") {
              while (_purge(_tags("base")[0])) {
                true;
              }
            }
            el = dom.make("base");
            _attr(el, "target", temp);
            _append(_tags("head")[0], el);
            if (isIE) {
              ie_old_attach = win[IE_ATTACH];
              ie_old_detach = win[IE_DETACH];
            }
            w3c_old_attach = win[W3C_ATTACH];
            w3c_old_detach = win[W3C_DETACH];
            _attach(win, UNLOAD, _handle_unload);
            _attach(win, LOAD, _handle_load);
            _attach(win, MSG, _handle_msg);
            _setup_win_evt_props(win);
            _setup_win_evt_props(win.__proto__);
            _setup_win_evt_props(win.Window && win.Window.prototype);
          } catch (_error) {
            e = _error;
            details.status = 500.105;
            render_params = render_conf = guid = null;
            ret = false;
          }
        } else {
          render_params = guid = null;
          ret = false;
        }
        return ret;
      };
      _wrapiFrame = function(html, cbName) {
        return "<iframe style=\"width:100%;height:100%;\" allowtransparency=\"true\"\nscrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" onload='" + cbName + "()'>\n<html><head><base target=\"_top\"></head><body style=\"margin: 0; padding: 0\">\n<script>\n  $ad = window.parent.$ad\n  $sf = window.parent.$sf\n</script>\n  " + html + "\n</html>\n</iframe>";
      };
      originalWrite = document.write;

      /*
      Render the HTML and CSS content passed in through the window.name message via a document.write
      
      @name $sf.ext-_render
      @function
      @static
      @private
       */
      _render = function(callback) {
        var cbName, css, e, html, otherCallbackApplied;
        if (callback == null) {
          callback = function() {};
        }
        cbName = lib.lang.guid("load_cb");
        otherCallbackApplied = false;
        window[cbName] = function(fromFrame) {
          return (sf.lib.lang.wrap(callback, function() {
            if (fromFrame || !otherCallbackApplied) {
              callback.apply(sf, arguments);
              if (pending_msg) {
                setTimeout((function(_this) {
                  return function() {
                    _handle_load();
                    return loaded();
                  };
                })(this), 300);
              } else {
                _handle_load();
                loaded();
              }
              document.write = originalWrite;
              return delete window[cbName];
            }
          }))();
        };
        document.write = function(str) {
          var domElem, iframe, oldOnload, _i, _len, _ref;
          if (!(hasLoaded || otherCallbackApplied)) {
            domElem = document.createElement("div");
            domElem.innerHTML = "_" + str;
            _ref = domElem.getElementsByTagName("iframe");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              iframe = _ref[_i];
              if (_cnum(_attr(iframe, "width"), 0) > 1) {
                otherCallbackApplied = true;
                if (oldOnload = _attr(iframe, "onload")) {
                  _attr(iframe, "onload", "" + cbName + "(true);" + oldOnload + ";");
                } else {
                  _attr(iframe, "onload", "" + cbName + "(true);");
                }
                break;
              }
            }
            if (otherCallbackApplied) {
              str = domElem.innerHTML.substring(1);
            }
          }
          return originalWrite.call(this, str);
        };
        html = void 0;
        css = void 0;
        isAdShown = true;
        css = _cstr(render_conf && render_conf.css);
        html = _cstr(render_params && render_params.html);
        if (css) {
          css = _ue(css);
          _create_stylesheet(css, "sf_custom_css");
        }
        if (html) {
          html = _ue(html);
          try {
            _reattach_messaging();
            _requested();
            document.write(html + "<scr" + ("ipt> " + cbName + "() ;</scr") + "ipt>");
            _check_orphaned();
            _reset_inline_handlers();
          } catch (_error) {
            e = _error;
            _handle_err("Error while rendering content: " + e[MSG]);
          }
        }
      };

      /*
      Call into the fallback x-msging library client if possible when no HTML5 style messaging
      exists
      
      @name $sf.ext-_call_client_fb
      @function
      @private
      @static
      @param {String} methName The name of the message in the library to call
      @param {*} [arg1] An arbitrary argument to hand into the library
      @param {*} [arg2] An arbitrary argument to hand into the library
       */
      _call_client_fb = function(methName, arg1, arg2) {
        var msg_clientfb;
        if (msgclient_fb) {
          msg_clientfb = dom.msgclient_fb;
        }
        return methName && msgclient_fb && msgclient_fb[methName] && msgclient_fb[methName](arg1, arg2);
      };

      /*
      Process a validated message to notify the contents of the SafeFrame of state updates
      
      @name $sf.ext-_receive_msg
      @function
      @private
      @static
      @param {$sf.lib.lang.ParamHash} params The message parameter hash object containing information about what has occured
      @param {HTMLEvent} [evt] The raw DOM event from the x-domain message
      @return {Boolean} Whether or not the message received could be handled
       */
      _receive_msg = function(params, evt) {
        var cmd, data, e, g, msg, ret;
        ret = false;
        msg = void 0;
        cmd = void 0;
        g = void 0;
        e = void 0;
        data = {};
        if (params) {
          g = params.geom || "";
          cmd = params.cmd;
          if (g) {
            geom_info = ParamHash(_ue(g), null, null, true, true);
          }
        }
        data.cmd = cmd;
        data.value = data.info = params && params.value;
        data.reason = params && params.reason;
        if (cmd === NOTIFY_COLLAPSED) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            force_collapse = true;
            _collapse();
            force_collapse = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
          }
        } else if (cmd === NOTIFY_COLLAPSE) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
          }
        } else if (cmd === NOTIFY_EXPAND) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            is_expanded = true;
            _fire_sandbox_callback(NOTIFY_EXPAND + "ed");
          }
        } else if (cmd === NOTIFY_GEOM_UPDATE) {
          _fire_sandbox_callback(NOTIFY_GEOM_UPDATE);
        } else if (cmd === NOTIFY_FOCUS_CHANGE) {
          data.info = data.value = lang.cbool(data.value);
          win_has_focus = data.value;
          _fire_sandbox_callback(NOTIFY_FOCUS_CHANGE, data);
        } else if (cmd === NOTIFY_READ_COOKIE) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            data = params && params.value;
            _fire_sandbox_callback(NOTIFY_READ_COOKIE, data);
          }
        } else if ([NOTIFY_WRITE_COOKIE, NOTIFY_FAILURE, NOTIFY_CLICKED, NOTIFY_VIEWED, NOTIFY_UNVIEWED, NOTIFY_LOADED, NOTIFY_REQUESTED, NOTIFY_RELOAD].indexOf(cmd) > -1) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
        } else {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
        }
        params = null;
        return ret;
      };
      cmdRetries = {};

      /*
      Send a command message up to the SafeFrames publisher / host code
      
      @name $sf.ext-_send_msg
      @private
      @function
      @static
      @param {String} str An encoded string (query-string/$sf.lib.lang.ParamHash format) that contains the command message to send
      @param {String} cmd The command to be sent itself (note that this string should also be present in the 1st argument)
       */
      _send_msg = function(str, cmd) {
        var e, id, params, sent, sent_time;
        id = lang.guid("sf_pnd_cmd");
        frame_id = render_params.dest;
        sent = false;
        sent_time = lang.time();
        params = void 0;
        if (!str || !cmd || pending_msg) {
          return;
        }
        params = ParamHash({
          msg: str,
          id: frame_id,
          guid: guid,
          cmd: cmd
        });
        pending_msg = {
          id: id,
          sent: sent_time,
          cmd: cmd
        };
        setTimeout((function() {
          if (pending_msg && pending_msg.id === id) {
            if (cmd === EXPAND_COMMAND || cmd === "exp-push") {
              force_collapse = true;
              _collapse();
              force_collapse = false;
            }
            _fire_sandbox_callback(NOTIFY_FAILURE + ":" + cmd + ":timeout");
          }
          id = sent = sent_time = cmd = str = pending_msg = params = null;
        }), MAX_MSG_WAIT_TIME);
        if (can_use_html5) {
          try {
            top.postMessage(params.toString(), (host_cname === "file" || host_cname === "" ? "*" : host_cname));
            sent = true;
          } catch (_error) {
            e = _error;
            sent = false;
          }
        }
        if (!sent) {
          _call_client_fb("send", params);
        }
      };

      /*
      Fire a notification off to the SafeFrame contents if a callback function was specified
      
      @name $sf.ext-_fire_sandbox_callback
      @private
      @function
      @static
      @param {String} msg The status update / message to send
      @param {Object} data The data from the response
       */
      _fire_sandbox_callback = function(msg, data) {
        var e;
        e = void 0;
        try {
          if (typeof sandbox_cb === "function") {
            sandbox_cb(msg, data);
          }
        } catch (_error) {}
      };

      /*
      Set the alignment of our internal DIV whenever expansion occurs uni-directionaly
      
      @name $sf.ext-_set_alignment
      @private
      @function
      @static
      @param {Boolean} xn Whether or not horizontal axis is growing to the left or right (xn == true == left)
      @param {Boolean} yn Whether or not vertical axis is growing to the top or bottom (yn == true == top)
       */
      _set_alignment = function(xn, yn) {
        var fcDiv, fcDivStyle, preTxt, xTxt, yTxt;
        fcDiv = _elt("sf_align");
        fcDivStyle = fcDiv.style;
        xTxt = void 0;
        yTxt = void 0;
        preTxt = "position:absolute;";
        if (xn) {
          xTxt = "right:0px;";
        } else {
          xTxt = "left:0px;";
        }
        if (yn) {
          yTxt = "bottom:0px;";
        } else {
          yTxt = "top:0px;";
        }
        fcDivStyle.cssText = preTxt + xTxt + yTxt;
        fcDiv = fcDivStyle = null;
      };

      /*
      Internal function for collapsing the SafeFrame, which checks that there is
      not some other pending state which may get in the way
      
      @name $sf.ext._collapse
      @private
      @function
      @static
       */
      _collapse = function() {
        if (!force_collapse && (!is_registered || !is_expanded || pending_msg)) {
          return false;
        }
        _set_alignment(0, 0);
        return true;
      };
      _reattach_messaging = function() {
        if (ie_old_attach) {
          ie_old_detach(ONMSG, _handle_msg);
          return ie_old_attach(ONMSG, _handle_msg);
        } else if (w3c_old_attach) {
          w3c_old_detach(MSG, _handle_msg);
          return w3c_old_attach(MSG, _handle_msg);
        }
      };

      /*
      Intialize the SafeFrame external vendor/client API, so that other features may be used
      This method MUST be called prior to using any other rich-media functionality (like expansion).
      
      @name $sf.ext.register
      @public
      @function
      @static
      @param {Number} initWidth The initial width (in pixels) expected of the content within the SafeFrame container
      @param {Number} initHeight The initial height (in pixels) expected of the content within the SafeFrame container
      @param {Function} [notify] A callback function that content can specify to be notified of status updates
       */
      register = function(initWidth, initHeight, notify) {
        if (is_registered || !guid) {
          return;
        }
        initWidth = _cnum(initWidth, 0, 0);
        initHeight = _cnum(initHeight, 0, 0);
        init_width = initWidth;
        init_height = initHeight;
        is_registered = true;
        if (lang.callable(notify)) {
          sandbox_cb = notify;
        } else {
          sandbox_cb = null;
        }
      };

      /*
      Make a request to expand the SafeFrame container to a certain size. Note that you may only call $sf.ext.expand
      to expand to the largest size needed, followed by calling collapse (and then repeat the same process if needed).
      Tweening or animation done, should be reserved for your own content, and you cannot make multiple calls to expand
      without a corresponding collapse.
      
      Note that when setting t, l, b, and r offset values, expansion will not cause the content inside the SafeFrame
      to hold it's current alignment, whereas using dx/dy or only setting partial offfsets (e.g {t:100,l:100} ==  dx:-100,dy:-100) will cause expansion to
      hold it's current alignment.
      
      @name $sf.ext.expand
      @public
      @static
      @function
      @param {Number|Object} deltaXorDesc If a number is specifed, SafeFrame will grow in size by this amount in pixels along the horizontal axis. Specifiy a negative value to grow to the left, and a postive value to grow to the right. <br />
      If an object is specified, it should contain "t","l","r","b" properties (top,left,bottom,right) for the amount in pixels to grow the container in each dimension
      @param {Number} deltaXorDesc.t Specifies to shift the top position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.l Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.b Specifies to shift the bottom position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Number} deltaXorDesc.r Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Boolean}deltaXorDesc.push  When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      @param {Number} deltaY If a number is specifed, SafeFrame will grow in size by this amount in pixels along the vertical axis. Specifiy a negative value to grow to the top, and a postive value to grow to the bottom. <br />
      Note that this value is ignored if deltaXorDesc is passed in as an object.
      
      @param {Boolean} push When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      
      @return {Boolean} true/false if the request to expand the container was sent. This does not mean that expansion is complete as expansion is an asynchronous process. Pass in a callback function to $sf.ext.register to get status updates.
       */
      expand = function(deltaXorDesc, deltaY, p) {
        var align_buffer, align_el, align_el_st, b, cmd_nm, cmd_str, doAlign, dx, dy, l, r, t, xn, yn;
        xn = false;
        yn = false;
        doAlign = false;
        cmd_nm = (p ? "exp-push" : EXPAND_COMMAND);
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id];
        dx = 0;
        dy = 0;
        r = void 0;
        b = void 0;
        t = void 0;
        l = void 0;
        align_el = void 0;
        align_el_st = void 0;
        align_buffer = void 0;
        if (!is_registered || pending_msg) {
          return;
        }
        if (p && !supports("exp-push")) {
          return;
        }
        if (deltaXorDesc && typeof deltaXorDesc === OBJ) {
          r = _cnum(deltaXorDesc.r, 0, 0);
          b = _cnum(deltaXorDesc.b, 0, 0);
          t = _cnum(deltaXorDesc.t, 0, 0);
          l = _cnum(deltaXorDesc.l, 0, 0);
          if (deltaXorDesc.push) {
            if (!supports("exp-push")) {
              return;
            }
            cmd_nm = "exp-push";
            cmd_str[1] = cmd_nm;
          }
          if (!r && l) {
            xn = true;
            dx = -1 * l;
          }
          if (r && !l) {
            dx = r;
          }
          if (!b && t) {
            yn = true;
            dy = -1 * t;
          }
          if (b && !t) {
            dy = b;
          }
          if ((t && b) || (l && r)) {
            doAlign = false;
          } else {
            doAlign = true;
          }
          if (doAlign) {
            _set_alignment(xn, yn);
            cmd_str.push("&dx=", dx, "&dy=", dy);
            _send_msg(_cstr(cmd_str), cmd_nm);
          } else {
            align_el = _elt("sf_align");
            align_el_st = align_el && align_el.style;
            align_buffer = ["position:absolute;"];
            if (t && b) {
              align_buffer.push("top:", t, "px;");
            } else if (t) {
              align_buffer.push("bottom:0px;");
            } else {
              if (b) {
                align_buffer.push("top:0px;");
              }
            }
            if (l && r) {
              align_buffer.push("left:", l, "px;");
            } else if (l) {
              align_buffer.push("right:0px;");
            } else {
              if (b) {
                align_buffer.push("left:0px;");
              }
            }
            if (align_el_st) {
              align_el_st.cssText = _cstr(align_buffer);
            }
            cmd_str.push("&exp_obj=", escape(ParamHash(deltaXorDesc)));
            _send_msg(_cstr(cmd_str), cmd_nm);
          }
        } else {
          deltaXorDesc = _cnum(deltaXorDesc, 0);
          deltaY = _cnum(deltaY, 0);
          if (deltaXorDesc <= 0 && deltaY <= 0) {
            return;
          }
          xn = deltaXorDesc <= 0;
          yn = deltaY <= 0;
          _set_alignment(xn, yn);
          cmd_str.push("&dx=", deltaXorDesc, "&dy=", deltaY);
          _send_msg(_cstr(cmd_str), cmd_nm);
        }
        return true;
      };

      /*
      Collapse the SafeFrame container after having called to expand. If no previous call to expand has been made, this call will do nothing.
      
      @name $sf.ext.collapse
      @public
      @static
      @function
       */
      collapse = function() {
        if (_collapse()) {
          _send_msg(_cstr(["cmd=", COLLAPSE_COMMAND, "&pos=", pos_id]), COLLAPSE_COMMAND);
        }
      };
      click = function() {
        return _send_cmd(NOTIFY_CLICKED);
      };
      viewed = function() {
        return _send_cmd(NOTIFY_VIEWED);
      };
      loaded = function() {
        return _send_cmd(NOTIFY_LOADED);
      };
      unviewed = function() {
        return _send_cmd(NOTIFY_UNVIEWED);
      };
      reload = function() {
        return _send_cmd(NOTIFY_RELOAD);
      };
      _requested = function() {
        _fire_sandbox_callback(NOTIFY_REQUESTED);
        return _send_cmd(NOTIFY_REQUESTED);
      };
      _send_cmd = function(cmd) {
        return _send_msg(_cstr(["cmd=", cmd, "&pos=", pos_id]), cmd);
      };

      /*
      Return geometric information about the SafeFrame container and it's status within a page
      
      @name $sf.ext.geom
      @public
      @static
      @function
      @return {Object} geom_info
       */
      geom = function() {
        return geom_info;
      };

      /*
      Return meta-data information that may have been specified by the publisher / host.
      
      @name $sf.ext.meta
      @public
      @static
      @function
      @param {String} propName the key name of the meta-data value to be retrieved
      @param {String} [owner_key] the super key name of the data to be retrieved
      @return {String} The value of some meta-data that may have been specified by the publisher / host or "".
       */
      meta = function(propName, owner_key) {
        var ret, shared;
        ret = "";
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              ret = _cstr(pos_meta[owner_key][propName]);
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                ret = _cstr(pos_meta.non_shared[owner_key][propName]);
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              ret = _cstr(shared[propName]);
            }
          }
        }
        return ret;
      };
      deleteMeta = function(propName, owner_key) {
        var shared;
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              return delete pos_meta[owner_key][propName];
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                return delete pos_meta.non_shared[owner_key][propName];
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              return delete shared[propName];
            }
          }
        }
      };

      /*
      Return the current status of the SafeFrame container, in cases where
      a command may be pending. If an empty string is returned ("") container is idle.
      
      @name $sf.ext.status
      @public
      @static
      @function
      @return {String} of any pending status, otherwise empty string.
       */
      status = function() {
        if (pending_msg) {
          if (pending_msg.cmd === EXPAND_COMMAND) {
            return STATUS_EXPANDING;
          } else {
            if (pending_msg.cmd === COLLAPSE_COMMAND) {
              return STATUS;
            }
          }
        }
        if (is_expanded) {
          return STATUS_EXPANDED;
        } else {
          return STATUS_COLLAPSED;
        }
      };

      /*
      Requests the host read or write a cookie to the host domain.
      The host domain must grant permission for the cookie to be written.
      
      @name $sf.ext.cookie
      @public
      @static
      @function
      @param {String} [cookieName] The name of the cookie to set or read
      @param {Object} [cookieData] An object hash containing the value and an optional expires
      @return {Number}
       */
      cookie = function(cookieName, cookieData) {
        var cmd_nm, cmd_str, isRead;
        isRead = !(cookieData != null);
        cmd_nm = (isRead ? "read-cookie" : "write-cookie");
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id, "&cookie=", cookieName];
        if (!isRead) {
          cmd_str.push("&value=");
          cmd_str.push(cookieData.value);
        }
        _send_msg(_cstr(cmd_str), cmd_nm);
      };

      /*
      Send a message to the host
      
      @name $sf.ext.message
      @public
      @static
      @function
       */
      message = function(content) {
        _send_msg(_cstr(["cmd=", "msg", "&pos=", pos_id, "&msg=", content]), "msg");
      };

      /*
      Return the percentage that the SafeFrame container is viewable within the browser window
      
      @name $sf.ext.inViewPercentage
      @public
      @static
      @function
      @return {Number}
       */
      inViewPercentage = function() {
        var iv, tv;
        iv = _cnum(geom_info && geom_info.self && geom_info.self.iv, -1, 0);
        tv = void 0;
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      winHasFocus = function() {
        return win_has_focus;
      };

      /*
      Return whether or not a particular feature is supported, or an object containing
      key/value pairs denoting all features and whether or not they are supported
      
      By default SafeFrames version 1 supports the following feature:
      
      "exp-ovr": Expansion of the container by overlaying on top of other content
      
      Later in other versions there are expexted to be more feature with their own
      string name, that can be checked by the content in the SafeFrame, so that
      it knows what things can be done.
      
      @name $sf.ext.supports
      @public
      @static
      @function
      @param {String} [key] If specifed, checks to see if that specific feature has been enabled
      @return {Boolean|Object}
       */
      supports = function(key) {
        var conf, sup;
        conf = render_params.conf;
        sup = (conf && conf.supports) || false;
        if (sup) {
          key = _cstr(key);
          if (key) {
            sup = sup[key] || false;
            if (sup === "0") {
              sup = false;
            }
          } else {
            sup = lang.mix({}, sup);
          }
        }
        return sup;
      };
      render = function(showAd, cb) {
        var err_info;
        err_info = {};
        if (_construction(err_info)) {
          if (showAd) {
            return _render(cb);
          }
        }
      };
      showAd = function(cb) {
        if (!isAdShown) {
          return _render(cb);
        }
      };
      adShown = function() {
        return isAdShown;
      };
      lang.mix(sf.ext, {
        register: register,
        expand: expand,
        collapse: collapse,
        geom: geom,
        meta: meta,
        deleteMeta: deleteMeta,
        status: status,
        supports: supports,
        cookie: cookie,
        message: message,
        inViewPercentage: inViewPercentage,
        winHasFocus: winHasFocus,
        click: click,
        viewed: viewed,
        unviewed: unviewed,
        showAd: showAd,
        adShown: adShown,
        reload: reload
      });
      if (!isExternal) {
        window.$sf = sf;
        render();
      } else {
        window.$sf = sf;
        sf.ext.render = render;
      }
      return sf;
    })(window, sf);
  };

}).call(this);

},{"../shared/base":11}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":12,"./env":13,"./lang":14,"./logger":15}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":13,"./lang":14}],13:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./lang":14,"8DwohR":16}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, wrap, _es, _keys, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    _keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + _keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray,
      wrap: wrap
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],16:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL2ZyYW1lLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9saWIvcmVxdWVzdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3NoYXJlZC9iYXNlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9saWIvc2hhcmVkL2NvbmZpZy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3NoYXJlZC9ldmVudC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3NoYXJlZC9zdHJlYW0uanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL2xpYi9zaGFyZWQvdXRpbHMuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9qc29uL2pzb24yLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvcmVxd2VzdC9yZXF3ZXN0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9leHQvZXh0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvYmFzZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2RvbS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2Vudi5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2xhbmcuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9sb2dnZXIuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgUmVxdWVzdCwgY3VycmVudE5hbWUsIGV2ZW50cywgc2YsIHN0cmVhbSwgdXRpbHM7XG5cbiAgY3VycmVudE5hbWUgPSB3aW5kb3cubmFtZTtcblxuICBzZiA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL2V4dC9leHQnKSh0cnVlKTtcblxuICBldmVudHMgPSByZXF1aXJlKCcuL3NoYXJlZC9ldmVudCcpKFtcInJlcXVlc3RcIiwgXCJsb2FkXCIsIFwidmlld1wiLCBcImNsaWNrXCIsIFwiZXhwYW5kZWRcIiwgXCJjb2xsYXBzZWRcIiwgXCJlbmdhZ2VcIiwgXCJ1bnZpZXdcIiwgXCJ1bmxvYWRcIl0pO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi9zaGFyZWQvdXRpbHMnKTtcblxuICBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XG5cbiAgc3RyZWFtID0gcmVxdWlyZSgnLi9zaGFyZWQvc3RyZWFtJyk7XG5cbiAgKGZ1bmN0aW9uKHNmLCB3aW5kb3cpIHtcbiAgICB2YXIgQWRKUywgVklFV0VEX1NUUklLRSwgYXR0cmlidXRlcywgZGlkU2hvdywgZm9yY2VOdWtlLCBoZWlnaHQsIGhvc3QsIGlzVmlld2VkSW50ZXJ2YWwsIGxvY2F0aW9uLCBvblVwZGF0ZSwgcmVmZXJyZXJMZXZlbCwgcmVnaXN0ZXJBZEpTZW5kcG9pbnRzLCByZWdpc3RlckZvckV2ZW50cywgcmVnaXN0ZXJlZCwgcmVxdWVzdCwgcmVxdWVzdGVkLCBzZXRTZXNzaW9uSW5mbywgc2ZEb20sIHNob3dBZCwgc2hvd0FkVGltZXIsIHNob3dQYWdlLCB1bnZpZXdlZFRpY2tzLCB1cGRhdGVJc1ZpZXdlZCwgdXBkYXRlUmVmZXJyZXIsIHZpZXdlZFRpY2tzLCB3aWR0aDtcbiAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0LmNoYW5nZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJlYW0uZXZlbnQocmVxdWVzdCk7XG4gICAgfSk7XG4gICAgc2ZEb20gPSBzZi5saWIuZG9tO1xuICAgIEFkSlMgPSB7fTtcbiAgICBWSUVXRURfU1RSSUtFID0gOTtcbiAgICB2aWV3ZWRUaWNrcyA9IDA7XG4gICAgdW52aWV3ZWRUaWNrcyA9IDA7XG4gICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGRpZFNob3cgPSBmYWxzZTtcbiAgICByZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgQWRKUy5zZXREaW1lbnNpb25zID0gZnVuY3Rpb24odywgaCkge1xuICAgICAgd2lkdGggPSB3O1xuICAgICAgcmV0dXJuIGhlaWdodCA9IGg7XG4gICAgfTtcbiAgICByZWdpc3RlckZvckV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gJHNmLmV4dC5yZWdpc3Rlcih3aWR0aCwgaGVpZ2h0LCBvblVwZGF0ZSk7XG4gICAgfTtcbiAgICByZWdpc3RlckFkSlNlbmRwb2ludHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgc2V0U2Vzc2lvbkluZm8gPSBmdW5jdGlvbihjb29raWVEYXRhKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQodXRpbHMuZnJvbVF1ZXJ5KGNvb2tpZURhdGEpKTtcbiAgICB9O1xuICAgIHVwZGF0ZVJlZmVycmVyID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgIGxldmVsID0gXCJhbGxcIjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgY2FzZSBcImFsbFwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIFwiaG9zdFwiOlxuICAgICAgICAgIHV0aWxzLmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCBcInJlZmVycmVyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiICsgZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9uVXBkYXRlID0gZnVuY3Rpb24oc3RhdHVzLCBkYXRhKSB7XG4gICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZXhwYW5kZWRcIjpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQWRKUy5leHBhbmRlZCgpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJjb2xsYXBzZWRcIjpcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQWRKUy5jb2xsYXBzZWQoKTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZ2VvbS11cGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gc2hvd0FkKCk7XG4gICAgICAgIGNhc2UgXCJjb29raWUtdXBkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHNldFNlc3Npb25JbmZvKHVuZXNjYXBlKGRhdGEudmFsdWUpKTtcbiAgICAgICAgY2FzZSBcImVuZ2FnZWRcIjpcbiAgICAgICAgICByZXR1cm4gQWRKUy5lbmdhZ2UoKTtcbiAgICAgICAgY2FzZSBcInJlcXVlc3RlZFwiOlxuICAgICAgICAgIGlmICghcmVxdWVzdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQWRKUy5yZXF1ZXN0KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaXNWaWV3ZWRJbnRlcnZhbCA9IG51bGw7XG4gICAgdXBkYXRlSXNWaWV3ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYmFzZSwgX2Jhc2UxO1xuICAgICAgaWYgKCFBZEpTLmlzVmlld2VkICYmICh0eXBlb2YgKF9iYXNlID0gJHNmLmV4dCkuaW5WaWV3UGVyY2VudGFnZSA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2UuaW5WaWV3UGVyY2VudGFnZSgpIDogdm9pZCAwKSA+IDUwICYmICRzZi5leHQud2luSGFzRm9jdXMoKSkge1xuICAgICAgICB2aWV3ZWRUaWNrcysrO1xuICAgICAgfSBlbHNlIGlmIChBZEpTLmlzVmlld2VkICYmICgodHlwZW9mIChfYmFzZTEgPSAkc2YuZXh0KS5pblZpZXdQZXJjZW50YWdlID09PSBcImZ1bmN0aW9uXCIgPyBfYmFzZTEuaW5WaWV3UGVyY2VudGFnZSgpIDogdm9pZCAwKSA8IDUwIHx8ICEkc2YuZXh0Lndpbkhhc0ZvY3VzKCkpKSB7XG4gICAgICAgIHVudmlld2VkVGlja3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVudmlld2VkVGlja3MgPSB2aWV3ZWRUaWNrcyA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodmlld2VkVGlja3MgPT09IFZJRVdFRF9TVFJJS0UpIHtcbiAgICAgICAgaWYgKCFBZEpTLmlzVmlld2VkKSB7XG4gICAgICAgICAgQWRKUy52aWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgQWRKUy5pc1ZpZXdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodW52aWV3ZWRUaWNrcyA9PT0gVklFV0VEX1NUUklLRSkge1xuICAgICAgICBpZiAoIUFkSlMuaXN1blZpZXdlZCkge1xuICAgICAgICAgIEFkSlMudW52aWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgQWRKUy5pc3VuVmlld2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaXNWaWV3ZWRJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaG93QWRUaW1lciA9IG51bGw7XG4gICAgc2hvd0FkID0gZnVuY3Rpb24oc2hvdykge1xuICAgICAgdmFyIHN0YXJ0VGltZSwgX2Jhc2U7XG4gICAgICBpZiAoKCh0eXBlb2YgKF9iYXNlID0gJHNmLmV4dCkuaW5WaWV3UGVyY2VudGFnZSA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2UuaW5WaWV3UGVyY2VudGFnZSgpIDogdm9pZCAwKSA+IDUgJiYgIWRpZFNob3cpIHx8IHNob3cpIHtcbiAgICAgICAgaWYgKHNob3dBZFRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChzaG93QWRUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIEFkSlMucmVxdWVzdCgpO1xuICAgICAgICAkc2YuZXh0LnNob3dBZChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQWRKUy5sb2FkKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlkU2hvdyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEoc2hvd0FkVGltZXIgfHwgZGlkU2hvdykpIHtcbiAgICAgICAgcmV0dXJuIHNob3dBZFRpbWVyID0gc2V0SW50ZXJ2YWwoZm9yY2VOdWtlLCA1MCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3JjZU51a2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYmFzZTtcbiAgICAgIGlmICgodHlwZW9mIChfYmFzZSA9ICRzZi5leHQpLmluVmlld1BlcmNlbnRhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IF9iYXNlLmluVmlld1BlcmNlbnRhZ2UoKSA6IHZvaWQgMCkgPiA1ICYmIHNob3dBZFRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoc2hvd0FkVGltZXIpO1xuICAgICAgICBzaG93QWRUaW1lciA9IG51bGw7XG4gICAgICAgIHJldHVybiAkc2YuZXh0LnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2YubGliLmxhbmcubWl4KEFkSlMsIGV2ZW50cyk7XG4gICAgQWRKUy5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBjYikge1xuICAgICAgcmV0dXJuIGV2ZW50cy5vbi5hcHBseSh0aGlzLCBbZXZlbnQsIGNiXSk7XG4gICAgfTtcbiAgICBBZEpTLmV4cGFuZCA9IGZ1bmN0aW9uKGRlbHRhWG9yRGVzYywgZGVsdGFZLCBwKSB7XG4gICAgICByZXR1cm4gJHNmLmV4dC5leHBhbmQoZGVsdGFYb3JEZXNjLCBkZWx0YVksIHApO1xuICAgIH07XG4gICAgQWRKUy5jb2xsYXBzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICRzZi5leHQuY29sbGFwc2UoKTtcbiAgICB9O1xuICAgIEFkSlMuY29va2llID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llRGF0YSkge1xuICAgICAgcmV0dXJuICRzZi5leHQuY29va2llKGNvb29raWVOYW1lLCBjb29raWVEYXRhKTtcbiAgICB9O1xuICAgIEFkSlMuc3VwcG9ydHMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiAkc2YuZXh0LnN1cHBvcnRzKGtleSk7XG4gICAgfTtcbiAgICBBZEpTLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkc2YuZXh0Lm1lc3NhZ2UoZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICAgIH0sIDEpO1xuICAgIH07XG4gICAgc2ZEb20uYXR0YWNoKGRvY3VtZW50LmJvZHksIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMuY2xpY2soKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHdpbmRvdy4kYWQgPSBBZEpTO1xuICAgIHJlZ2lzdGVyQWRKU2VuZHBvaW50cygpO1xuICAgIEFkSlMuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2YuZXh0LmNsaWNrKCk7XG4gICAgfSk7XG4gICAgQWRKUy52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNmLmV4dC52aWV3ZWQoKTtcbiAgICB9KTtcbiAgICBBZEpTLnVudmlldyhmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZi5leHQudW52aWV3ZWQoKTtcbiAgICB9KTtcbiAgICBBZEpTLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJGb3JFdmVudHMoKTtcbiAgICB9KTtcbiAgICBBZEpTLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNWaWV3ZWRJbnRlcnZhbCA9IHNldEludGVydmFsKHVwZGF0ZUlzVmlld2VkLCAxMDApO1xuICAgIH0pO1xuICAgIEFkSlMubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMuZnJhbWVDb3VudCA9IHV0aWxzLmNvdW50RnJhbWVzKHdpbmRvdyk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICBmcmFtZV9jb3VudDogQWRKUy5mcmFtZUNvdW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnJlcXVlc3QoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLnJlcXVlc3RUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICByZXF1ZXN0ZWQ6IHRydWUsXG4gICAgICAgIHJlcXVlc3RlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgQWRKUy5sb2FkVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgc2ZEb20uYXR0YWNoKHdpbmRvdywgXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkYWQudW5sb2FkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgbG9hZGVkQXQ6IHV0aWxzLm5vdygpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLnZpZXdUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICB2aWV3ZWQ6IHRydWUsXG4gICAgICAgIHZpZXdlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy5lbmdhZ2UoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLmVuZ2FnZVRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIGVuZ2FnZWQ6IHRydWUsXG4gICAgICAgIGVuZ2FnZWRBdDogdXRpbHMubm93KClcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEFkSlMuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLmNsaWNrVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgY2xpY2tlZDogdHJ1ZSxcbiAgICAgICAgY2xpY2tlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy51bnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLnVudmlld1RpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIHVudmlld2VkOiB0cnVlLFxuICAgICAgICB1bnZpZXdlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy51bmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLnVubG9hZFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIHVubG9hZGVkOiB0cnVlLFxuICAgICAgICB1bmxvYWRlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc2YuZXh0LnJlbmRlcihmYWxzZSk7XG4gICAgZGlkU2hvdyA9ICFzZi5saWIubGFuZy5jYm9vbChzZi5leHQubWV0YShcImludmlld1wiLCBcImV4dGVuZGVkXCIpKTtcbiAgICByZWZlcnJlckxldmVsID0gc2YuZXh0Lm1ldGEoXCJyZWZlcnJlclwiLCBcImV4dGVuZGVkXCIpIHx8IFwiYWxsXCI7XG4gICAgaG9zdCA9IHNmLmV4dC5tZXRhKFwiaG9zdFwiLCBcImV4dGVuZGVkXCIpO1xuICAgIHNmLmV4dC5kZWxldGVNZXRhKFwiaG9zdFwiLCBcImV4dGVuZGVkXCIpO1xuICAgIGxvY2F0aW9uID0gc2YuZXh0Lm1ldGEoXCJsb2NhdGlvblwiLCBcImV4dGVuZGVkXCIpO1xuICAgIHNmLmV4dC5kZWxldGVNZXRhKFwibG9jYXRpb25cIiwgXCJleHRlbmRlZFwiKTtcbiAgICBzZXRTZXNzaW9uSW5mbyhzZi5leHQubWV0YShcInNlc3Npb25cIiwgXCJleHRlbmRlZFwiKSwge1xuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgc2YuZXh0LmRlbGV0ZU1ldGEoXCJzZXNzaW9uXCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgJGFkLnNsb3RJZCA9IHNmLmV4dC5tZXRhKFwic2xvdF9pZFwiLCBcImV4dGVuZGVkXCIpO1xuICAgICRhZC5jb3VudCA9IHNmLmV4dC5tZXRhKFwic2xvdF9jb3VudFwiLCBcImV4dGVuZGVkXCIpO1xuICAgIHJlcXVlc3Quc2V0KHtcbiAgICAgIHNsb3RfaWQ6IHNmLmV4dC5tZXRhKFwic2xvdF9pZFwiLCBcImV4dGVuZGVkXCIpLFxuICAgICAgc2xvdF9jb3VudDogc2YuZXh0Lm1ldGEoXCJzbG90X2NvdW50XCIsIFwiZXh0ZW5kZWRcIiksXG4gICAgICBwYWdlX3VybDogbG9jYXRpb24sXG4gICAgICBwYWdlX2hvc3Q6IGhvc3RcbiAgICB9LCB7XG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgICBzaG93UGFnZSA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPT09IGRvY3VtZW50LnJlZmVycmVyIHx8IHVwZGF0ZVJlZmVycmVyKHJlZmVycmVyTGV2ZWwpO1xuICAgIGlmIChzaG93UGFnZSkge1xuICAgICAgc2hvd0FkKGRpZFNob3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubmFtZSA9IGN1cnJlbnROYW1lO1xuICAgICAgZG9jdW1lbnQubG9jYXRpb24gPSBkb2N1bWVudC5sb2NhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIEFkSlM7XG4gIH0pKHNmLCB3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQmFzZSwgdXRpbHMsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgd2luZG93LkpTT04gfHwgKHdpbmRvdy5KU09OID0gcmVxdWlyZSgnanNvbicpKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4vc2hhcmVkL3V0aWxzJyk7XG5cbiAgQmFzZSA9IHJlcXVpcmUoJy4vc2hhcmVkL2Jhc2UnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgUmVxdWVzdDtcbiAgICBSZXF1ZXN0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgdmFyIFJFUV9JTlRFUlZBTDtcblxuICAgICAgX19leHRlbmRzKFJlcXVlc3QsIF9zdXBlcik7XG5cbiAgICAgIFJFUV9JTlRFUlZBTCA9IDUwO1xuXG4gICAgICBmdW5jdGlvbiBSZXF1ZXN0KGNsaWVudElkLCBzZXNzaW9uSWQpIHtcbiAgICAgICAgUmVxdWVzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgUmVxdWVzdC5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RJblByb2Nlc3MpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2Nlc3MgPSB0cnVlO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB1dGlscy5zZW5kUmVxdWVzdChcImh0dHA6Ly8xMjcuMC4wLjEvdGVzdFwiLCB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoZGF0YSwge1xuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICB0aGlzLndhaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gUmVxdWVzdDtcblxuICAgIH0pKEJhc2UpO1xuICAgIHJldHVybiBSZXF1ZXN0O1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgQmFzZTtcbiAgICByZXR1cm4gQmFzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEJhc2UoKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyB8fCAodGhpcy5hdHRyaWJ1dGVzID0ge30pO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzLCBmLCBrLCB2LCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBjaGFuZ2VkQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gYXR0cnMpIHtcbiAgICAgICAgICB2ID0gYXR0cnNba107XG4gICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlc1trXSAhPT0gdikge1xuICAgICAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXMucHVzaChrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50ICYmIGNoYW5nZWRBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBfcmVmID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmID0gX3JlZltfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGYuYXBwbHkodGhpcywgW3RoaXMsIGNoYW5nZWRBdHRyaWJ1dGVzXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIEJhc2UucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgaWYgKGYgJiYgdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMucHVzaChmKTtcbiAgICAgICAgfSBlbHNlIGlmICghZikge1xuICAgICAgICAgIF9yZWYgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGYgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQmFzZTtcblxuICAgIH0pKCk7XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuRU5WID09PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBpOiAnLy9lbmRwb2ludC5hZGpzLmRldjo4MDgwLzEnLFxuICAgICAgICBjZG5fdXJsOiAnYmFzZS9saWIvaHRtbC9hZGpzZnJhbWUuaHRtbCdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcGk6IFwiLy9lbmRwb2ludC5hZGpzLmlvLzFcIixcbiAgICAgICAgY2RuX3VybDogcHJvY2Vzcy5lbnYuQ0ROX1VSTFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBpOiAnLy9lbmRwb2ludC5hZGpzLmRldjo4MDgwLzEnLFxuICAgICAgICBjZG5fdXJsOiAnLi4vbGliL2h0bWwvYWRqc2ZyYW1lLmh0bWwnXG4gICAgICB9O1xuICAgIH1cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCBldmVudHMsIHV0aWxzLCBfaSwgX2xlbjtcbiAgICAgIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgICAgZXZlbnRzID0ge1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdDtcbiAgICAgICAgICB0aGlzLmV2ZW50cyB8fCAodGhpcy5ldmVudHMgPSB7fSk7XG4gICAgICAgICAgZXZlbnRMaXN0ID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKGNiKTtcbiAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBldmVudExpc3Q7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICBvcHRpb25hbERhdGEgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhLCBvcHRpb25hbERhdGEpIHtcbiAgICAgICAgICB2YXIgZSwgZXgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICAgIHRoaXMuZXZlbnRzIHx8ICh0aGlzLmV2ZW50cyA9IHt9KTtcbiAgICAgICAgICBfcmVmID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZSA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZS5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbmFsRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXggPSBfZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubm90aWZ5KGV2ZW50LCBkYXRhIHx8IHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBub3RpZnk6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZHBvaW50LCBwYXJhbXMsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjEgPSAoKF9yZWYgPSB0aGlzLmV2ZW50RW5kcG9pbnRzKSAhPSBudWxsID8gX3JlZltldmVudF0gOiB2b2lkIDApIHx8IFtdO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICBwYXJhbXMgPSAoZGF0YSAhPSBudWxsID8gdHlwZW9mIGRhdGEuZ2V0UGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBkYXRhLmdldFBhcmFtcygpIDogdm9pZCAwIDogdm9pZCAwKSB8fCB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh1dGlscy5zZW5kUmVxdWVzdChlbmRwb2ludCwge1xuICAgICAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBldmVudE5hbWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnROYW1lc1tfaV07XG4gICAgICAgIGV2ZW50c1tldmVudF0gPSAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICByZXR1cm4gZiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgZXZlbnRzW1wiXCIgKyBldmVudCArIFwiUmVnaXN0ZXJFbmRwb2ludFwiXSA9IChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIHJldHVybiBmID0gZnVuY3Rpb24oZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBfYmFzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbmRwb2ludHMgfHwgKHRoaXMuZXZlbnRFbmRwb2ludHMgPSB7fSk7XG4gICAgICAgICAgICAoX2Jhc2UgPSB0aGlzLmV2ZW50RW5kcG9pbnRzKVtldmVudF0gfHwgKF9iYXNlW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50RW5kcG9pbnRzW2V2ZW50XS5wdXNoKGVuZHBvaW50KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KShldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH0pKCk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBjb25maWcsIHJlcXdlc3Q7XG5cbiAgcmVxd2VzdCA9IHJlcXVpcmUoJ3JlcXdlc3QnKTtcblxuICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nUmVxdWVzdHMsIHByZWZpeCwgc2VuZCwgc2VuZGluZ1JlcXVlc3RzO1xuICAgIHByZWZpeCA9IGNvbmZpZy5hcGk7XG4gICAgcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgIHJldHVybiByZXF3ZXN0KHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHR5cGU6ICdqc29ucCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZTogZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB2YXIgZXJyb3IsIHN1Y2Nlc3M7XG4gICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgcmV0dXJuIHNlc3Npb24uc2V0KHJlc3AsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVSUk9SOlwiICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbmQocHJlZml4ICsgJy9wYWdlJywgc2Vzc2lvbi5hdHRyaWJ1dGVzLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICB9LFxuICAgICAgZXZlbnQ6IGZ1bmN0aW9uKHJlcXVlc3QsIGNiLCBpc0F0dGVtcHQpIHtcbiAgICAgICAgdmFyIGVycm9yLCBzdWNjZXNzO1xuICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHJlcXVlc3Quc2V0KHJlc3AsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2IocmVzcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWxldGUgc2VuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVSUk9SOlwiICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF0pIHtcbiAgICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICAgIHNlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHNlbmQocHJlZml4ICsgJy9ldmVudCcsIHJlcXVlc3QuYXR0cmlidXRlcywgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFwZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF0gfHwgaXNBdHRlbXB0KSB7XG4gICAgICAgICAgcGVuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXZlbnQocmVxdWVzdCwgY2IsIHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSh0aGlzKSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5yZXF3ZXN0IHx8ICh3aW5kb3cucmVxd2VzdCA9IHJlcXVpcmUoJ3JlcXdlc3QnKSk7XG5cbiAgd2luZG93LkpTT04gfHwgKHdpbmRvdy5KU09OID0gcmVxdWlyZSgnanNvbicpKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigkc2YsIHdpbmRvdykge1xuICAgIHZhciBjYXBpdGFsaXplU3RyaW5nLCBjb3VudEZyYW1lcywgZGVmaW5lUHJvcGVydHksIGZyb21RdWVyeSwgbm93LCByZXF3ZXN0LCBzZW5kUmVxdWVzdCwgdG9OdW1iZXIsIHRvUXVlcnk7XG4gICAgcmVxd2VzdCA9IHdpbmRvdy5yZXF3ZXN0O1xuICAgIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxd2VzdCh7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICB0eXBlOiAnanNvbnAnLFxuICAgICAgICBzdWNjZXNzOiBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBvcHRpb25zLmVycm9yLFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnJvbVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnksIGRlbGltKSB7XG4gICAgICB2YXIgaXRlbSwga2V5LCBwYXJhbXMsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAocXVlcnkgPT0gbnVsbCkge1xuICAgICAgICBxdWVyeSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoZGVsaW0gPT0gbnVsbCkge1xuICAgICAgICBkZWxpbSA9IFwiJlwiO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0ge307XG4gICAgICBfcmVmID0gcXVlcnkuc3BsaXQoZGVsaW0pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBfcmVmW19pXTtcbiAgICAgICAgX3JlZjEgPSBpdGVtLnNwbGl0KFwiPVwiKSwga2V5ID0gX3JlZjFbMF0sIHZhbHVlID0gX3JlZjFbMV07XG4gICAgICAgIHBhcmFtc1trZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgICB0b1F1ZXJ5ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIHJlcXdlc3QudG9RdWVyeVN0cmluZyhhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIHRvTnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJHNmICE9IG51bGwgPyAkc2YubGliLmxhbmcuY251bSh2YWwsIDApIDogdm9pZCAwO1xuICAgIH07XG4gICAgbm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcImRlZmluZVByb3BlcnR5XCIgaW4gT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiX19kZWZpbmVHZXR0ZXJfX1wiIGluIG9iaikge1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLndyaXRhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbFtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKHByb3AsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmouX19kZWZpbmVTZXR0ZXJfXyhwcm9wLCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY291bnRGcmFtZXMgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgIHZhciBjb3VudCwgZnJhbWUsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgY291bnQgPSB3aW4uZnJhbWVzLmxlbmd0aDtcbiAgICAgIF9yZWYgPSB3aW4uZnJhbWVzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGZyYW1lID0gX3JlZltfaV07XG4gICAgICAgIGlmIChmcmFtZSAhPT0gd2luKSB7XG4gICAgICAgICAgY291bnQgKz0gY291bnRGcmFtZXMoZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICBjYXBpdGFsaXplU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmRSZXF1ZXN0OiBzZW5kUmVxdWVzdCxcbiAgICAgIHRvUXVlcnk6IHRvUXVlcnksXG4gICAgICBmcm9tUXVlcnk6IGZyb21RdWVyeSxcbiAgICAgIHRvTnVtYmVyOiB0b051bWJlcixcbiAgICAgIG5vdzogbm93LFxuICAgICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5LFxuICAgICAgY291bnRGcmFtZXM6IGNvdW50RnJhbWVzLFxuICAgICAgY2FwaXRhbGl6ZVN0cmluZzogY2FwaXRhbGl6ZVN0cmluZ1xuICAgIH07XG4gIH0pKCRzZiwgd2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qXG4gICAgaHR0cDovL3d3dy5KU09OLm9yZy9qc29uMi5qc1xuICAgIDIwMTEtMDItMjNcblxuICAgIFB1YmxpYyBEb21haW4uXG5cbiAgICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG5cbiAgICBTZWUgaHR0cDovL3d3dy5KU09OLm9yZy9qcy5odG1sXG5cblxuICAgIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4gICAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4gICAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbiAgICBOT1QgQ09OVFJPTC5cblxuXG4gICAgVGhpcyBmaWxlIGNyZWF0ZXMgYSBnbG9iYWwgSlNPTiBvYmplY3QgY29udGFpbmluZyB0d28gbWV0aG9kczogc3RyaW5naWZ5XG4gICAgYW5kIHBhcnNlLlxuXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG5cbiAgICAgICAgICAgIHJlcGxhY2VyICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRldGVybWluZXMgaG93IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFyZSBzdHJpbmdpZmllZCBmb3Igb2JqZWN0cy4gSXQgY2FuIGJlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG5cbiAgICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzICdcXHQnIG9yICcmbmJzcDsnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHByb2R1Y2VzIGEgSlNPTiB0ZXh0IGZyb20gYSBKYXZhU2NyaXB0IHZhbHVlLlxuXG4gICAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuICAgICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbiAgICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuICAgICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4gICAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWVcblxuICAgICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWic7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4gICAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4gICAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbiAgICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbiAgICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4gICAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4gICAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuICAgICAgICAgICAgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuICAgICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbiAgICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuICAgICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuICAgICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbiAgICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbiAgICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4gICAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXFxuXFx0XCJlXCIsXFxuXFx0e1xcblxcdFxcdFwicGx1cmlidXNcIjogXCJ1bnVtXCJcXG5cXHR9XFxuXSdcblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtuZXcgRGF0ZSgpXSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgICAgICAgICAgICAgICdEYXRlKCcgKyB0aGlzW2tleV0gKyAnKScgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG5cbiAgICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuICAgICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4gICAgICAgICAgICB0cmFuc2Zvcm0gdGhlIHJlc3VsdHMuIEl0IHJlY2VpdmVzIGVhY2ggb2YgdGhlIGtleXMgYW5kIHZhbHVlcyxcbiAgICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHVuZGVmaW5lZCB0aGVuIHRoZSBtZW1iZXIgaXMgZGVsZXRlZC5cblxuICAgICAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIGNvbnZlcnRlZCB0byBEYXRlIG9iamVjdHMuXG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhID1cbi9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgNSkgPT09ICdEYXRlKCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4gICAgcmVkaXN0cmlidXRlLlxuKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgcmVnZXhwOiBmYWxzZSAqL1xuXG4vKm1lbWJlcnMgXCJcIiwgXCJcXGJcIiwgXCJcXHRcIiwgXCJcXG5cIiwgXCJcXGZcIiwgXCJcXHJcIiwgXCJcXFwiXCIsIEpTT04sIFwiXFxcXFwiLCBhcHBseSxcbiAgICBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxudmFyIEpTT047XG5pZiAoIUpTT04pIHtcbiAgICBKU09OID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICAgICAgLCBKU09OID0gZ2xvYmFsLkpTT05cbiAgICAgIDtcblxuICAgIGlmICghSlNPTikge1xuICAgICAgSlNPTiA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICAgKyAnLScgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWicgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUudG9KU09OICAgICAgPVxuICAgICAgICAgICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gID1cbiAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBnYXAsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbi8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgICAgICBwYXJ0aWFsLFxuICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICB9XG5cbi8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4vLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcblxuLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4vLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuLy8gbnVsbC5cblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbi8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gJyc7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbi8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICAgICAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgSlNPTi5wYXJzZSA9IGZ1bmN0aW9uICh0ZXh0LCByZXZpdmVyKSB7XG5cbi8vIFRoZSBwYXJzZSBtZXRob2QgdGFrZXMgYSB0ZXh0IGFuZCBhbiBvcHRpb25hbCByZXZpdmVyIGZ1bmN0aW9uLCBhbmQgcmV0dXJuc1xuLy8gYSBKYXZhU2NyaXB0IHZhbHVlIGlmIHRoZSB0ZXh0IGlzIGEgdmFsaWQgSlNPTiB0ZXh0LlxuXG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuXG4vLyBUaGUgd2FsayBtZXRob2QgaXMgdXNlZCB0byByZWN1cnNpdmVseSB3YWxrIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlIHNvXG4vLyB0aGF0IG1vZGlmaWNhdGlvbnMgY2FuIGJlIG1hZGUuXG5cbiAgICAgICAgICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGN4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGN4LCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCAnKCknIGFuZCAnbmV3J1xuLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgJz0nIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoICdAJyAoYSBub24tSlNPTiBjaGFyYWN0ZXIpLiBTZWNvbmQsIHdlXG4vLyByZXBsYWNlIGFsbCBzaW1wbGUgdmFsdWUgdG9rZW5zIHdpdGggJ10nIGNoYXJhY3RlcnMuIFRoaXJkLCB3ZSBkZWxldGUgYWxsXG4vLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbi8vIHdlIGxvb2sgdG8gc2VlIHRoYXQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFyZSBvbmx5IHdoaXRlc3BhY2Ugb3IgJ10nIG9yXG4vLyAnLCcgb3IgJzonIG9yICd7JyBvciAnfScuIElmIHRoYXQgaXMgc28sIHRoZW4gdGhlIHRleHQgaXMgc2FmZSBmb3IgZXZhbC5cblxuICAgICAgICAgICAgaWYgKC9eW1xcXSw6e31cXHNdKiQvXG4gICAgICAgICAgICAgICAgICAgIC50ZXN0KHRleHQucmVwbGFjZSgvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csICddJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZywgJycpKSkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlICd7JyBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuLy8gaW4gSmF2YVNjcmlwdDogaXQgY2FuIGJlZ2luIGEgYmxvY2sgb3IgYW4gb2JqZWN0IGxpdGVyYWwuIFdlIHdyYXAgdGhlIHRleHRcbi8vIGluIHBhcmVucyB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eS5cblxuICAgICAgICAgICAgICAgIGogPSBldmFsKCcoJyArIHRleHQgKyAnKScpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgd2Fsayh7Jyc6IGp9LCAnJykgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSlNPTi5wYXJzZScpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdsb2JhbC5KU09OID0gSlNPTjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEpTT047XG59KCkpO1xuIiwiLyohXG4gICogUmVxd2VzdCEgQSBnZW5lcmFsIHB1cnBvc2UgWEhSIGNvbm5lY3Rpb24gbWFuYWdlclxuICAqIGxpY2Vuc2UgTUlUIChjKSBEdXN0aW4gRGlheiAyMDE0XG4gICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9yZXF3ZXN0XG4gICovXG5cbiFmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0oJ3JlcXdlc3QnLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHdpbiA9IHdpbmRvd1xuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIHR3b0h1bmRvID0gL14oMjBcXGR8MTIyMykkL1xuICAgICwgYnlUYWcgPSAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnXG4gICAgLCByZWFkeVN0YXRlID0gJ3JlYWR5U3RhdGUnXG4gICAgLCBjb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnXG4gICAgLCByZXF1ZXN0ZWRXaXRoID0gJ1gtUmVxdWVzdGVkLVdpdGgnXG4gICAgLCBoZWFkID0gZG9jW2J5VGFnXSgnaGVhZCcpWzBdXG4gICAgLCB1bmlxaWQgPSAwXG4gICAgLCBjYWxsYmFja1ByZWZpeCA9ICdyZXF3ZXN0XycgKyAoK25ldyBEYXRlKCkpXG4gICAgLCBsYXN0VmFsdWUgLy8gZGF0YSBzdG9yZWQgYnkgdGhlIG1vc3QgcmVjZW50IEpTT05QIGNhbGxiYWNrXG4gICAgLCB4bWxIdHRwUmVxdWVzdCA9ICdYTUxIdHRwUmVxdWVzdCdcbiAgICAsIHhEb21haW5SZXF1ZXN0ID0gJ1hEb21haW5SZXF1ZXN0J1xuICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgICAsIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gQXJyYXkuaXNBcnJheVxuICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgfVxuXG4gICAgLCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICAgICAnY29udGVudFR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAsICdyZXF1ZXN0ZWRXaXRoJzogeG1sSHR0cFJlcXVlc3RcbiAgICAgICAgLCAnYWNjZXB0Jzoge1xuICAgICAgICAgICAgICAnKic6ICAndGV4dC9qYXZhc2NyaXB0LCB0ZXh0L2h0bWwsIGFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwsICovKidcbiAgICAgICAgICAgICwgJ3htbCc6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCdcbiAgICAgICAgICAgICwgJ2h0bWwnOiAndGV4dC9odG1sJ1xuICAgICAgICAgICAgLCAndGV4dCc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgLCAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICAsICdqcyc6ICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQsIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsIHhociA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgLy8gaXMgaXQgeC1kb21haW5cbiAgICAgICAgaWYgKG9bJ2Nyb3NzT3JpZ2luJ10gPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgeGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbFxuICAgICAgICAgIGlmICh4aHIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyXG4gICAgICAgICAgfSBlbHNlIGlmICh3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2luW3htbEh0dHBSZXF1ZXN0XSkge1xuICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCBnbG9iYWxTZXR1cE9wdGlvbnMgPSB7XG4gICAgICAgIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlYWR5U3RhdGUociwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdXNlIF9hYm9ydGVkIHRvIG1pdGlnYXRlIGFnYWluc3QgSUUgZXJyIGMwMGMwMjNmXG4gICAgICAvLyAoY2FuJ3QgcmVhZCBwcm9wcyBvbiBhYm9ydGVkIHJlcXVlc3Qgb2JqZWN0cylcbiAgICAgIGlmIChyLl9hYm9ydGVkKSByZXR1cm4gZXJyb3Ioci5yZXF1ZXN0KVxuICAgICAgaWYgKHIucmVxdWVzdCAmJiByLnJlcXVlc3RbcmVhZHlTdGF0ZV0gPT0gNCkge1xuICAgICAgICByLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcFxuICAgICAgICBpZiAodHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSkgc3VjY2VzcyhyLnJlcXVlc3QpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlcnJvcihyLnJlcXVlc3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGVhZGVycyhodHRwLCBvKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBvWydoZWFkZXJzJ10gfHwge31cbiAgICAgICwgaFxuXG4gICAgaGVhZGVyc1snQWNjZXB0J10gPSBoZWFkZXJzWydBY2NlcHQnXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddW29bJ3R5cGUnXV1cbiAgICAgIHx8IGRlZmF1bHRIZWFkZXJzWydhY2NlcHQnXVsnKiddXG5cbiAgICAvLyBicmVha3MgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIHdpdGggbGVnYWN5IGJyb3dzZXJzXG4gICAgaWYgKCFvWydjcm9zc09yaWdpbiddICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnNbJ3JlcXVlc3RlZFdpdGgnXVxuICAgIGlmICghaGVhZGVyc1tjb250ZW50VHlwZV0pIGhlYWRlcnNbY29udGVudFR5cGVdID0gb1snY29udGVudFR5cGUnXSB8fCBkZWZhdWx0SGVhZGVyc1snY29udGVudFR5cGUnXVxuICAgIGZvciAoaCBpbiBoZWFkZXJzKVxuICAgICAgaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoKSAmJiAnc2V0UmVxdWVzdEhlYWRlcicgaW4gaHR0cCAmJiBodHRwLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pIHtcbiAgICBpZiAodHlwZW9mIG9bJ3dpdGhDcmVkZW50aWFscyddICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhb1snd2l0aENyZWRlbnRpYWxzJ11cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2soZGF0YSkge1xuICAgIGxhc3RWYWx1ZSA9IGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHVybGFwcGVuZCAodXJsLCBzKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKSB7XG4gICAgdmFyIHJlcUlkID0gdW5pcWlkKytcbiAgICAgICwgY2JrZXkgPSBvWydqc29ucENhbGxiYWNrJ10gfHwgJ2NhbGxiYWNrJyAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICwgY2J2YWwgPSBvWydqc29ucENhbGxiYWNrTmFtZSddIHx8IHJlcXdlc3QuZ2V0Y2FsbGJhY2tQcmVmaXgocmVxSWQpXG4gICAgICAsIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpXG4gICAgICAsIG1hdGNoID0gdXJsLm1hdGNoKGNicmVnKVxuICAgICAgLCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICwgbG9hZGVkID0gMFxuICAgICAgLCBpc0lFMTAgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgMTAuMCcpICE9PSAtMVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAobWF0Y2hbM10gPT09ICc/Jykge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCkgLy8gd2lsZGNhcmQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYnZhbCA9IG1hdGNoWzNdIC8vIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBjYmtleSArICc9JyArIGNidmFsKSAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgfVxuXG4gICAgd2luW2NidmFsXSA9IGdlbmVyYWxDYWxsYmFja1xuXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlICE9PSAndW5kZWZpbmVkJyAmJiAhaXNJRTEwKSB7XG4gICAgICAvLyBuZWVkIHRoaXMgZm9yIElFIGR1ZSB0byBvdXQtb2Ytb3JkZXIgb25yZWFkeXN0YXRlY2hhbmdlKCksIGJpbmRpbmcgc2NyaXB0XG4gICAgICAvLyBleGVjdXRpb24gdG8gYW4gZXZlbnQgbGlzdGVuZXIgZ2l2ZXMgdXMgY29udHJvbCBvdmVyIHdoZW4gdGhlIHNjcmlwdFxuICAgICAgLy8gaXMgZXhlY3V0ZWQuIFNlZSBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkID0gJ19yZXF3ZXN0XycgKyByZXFJZFxuICAgIH1cblxuICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKChzY3JpcHRbcmVhZHlTdGF0ZV0gJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnY29tcGxldGUnICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2xvYWRlZCcpIHx8IGxvYWRlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgc2NyaXB0Lm9uY2xpY2sgJiYgc2NyaXB0Lm9uY2xpY2soKVxuICAgICAgLy8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayB3aXRoIHRoZSBsYXN0IHZhbHVlIHN0b3JlZCBhbmQgY2xlYW4gdXAgdmFsdWVzIGFuZCBzY3JpcHRzLlxuICAgICAgZm4obGFzdFZhbHVlKVxuICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICAgIGxvYWRlZCA9IDFcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHNjcmlwdCB0byB0aGUgRE9NIGhlYWRcbiAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcblxuICAgIC8vIEVuYWJsZSBKU09OUCB0aW1lb3V0XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSlcbiAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgICBsb2FkZWQgPSAxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdChmbiwgZXJyKSB7XG4gICAgdmFyIG8gPSB0aGlzLm9cbiAgICAgICwgbWV0aG9kID0gKG9bJ21ldGhvZCddIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG4gICAgICAsIHVybCA9IHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgICAgLy8gY29udmVydCBub24tc3RyaW5nIG9iamVjdHMgdG8gcXVlcnktc3RyaW5nIGZvcm0gdW5sZXNzIG9bJ3Byb2Nlc3NEYXRhJ10gaXMgZmFsc2VcbiAgICAgICwgZGF0YSA9IChvWydwcm9jZXNzRGF0YSddICE9PSBmYWxzZSAmJiBvWydkYXRhJ10gJiYgdHlwZW9mIG9bJ2RhdGEnXSAhPT0gJ3N0cmluZycpXG4gICAgICAgID8gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKG9bJ2RhdGEnXSlcbiAgICAgICAgOiAob1snZGF0YSddIHx8IG51bGwpXG4gICAgICAsIGh0dHBcbiAgICAgICwgc2VuZFdhaXQgPSBmYWxzZVxuXG4gICAgLy8gaWYgd2UncmUgd29ya2luZyBvbiBhIEdFVCByZXF1ZXN0IGFuZCB3ZSBoYXZlIGRhdGEgdGhlbiB3ZSBzaG91bGQgYXBwZW5kXG4gICAgLy8gcXVlcnkgc3RyaW5nIHRvIGVuZCBvZiBVUkwgYW5kIG5vdCBwb3N0IGRhdGFcbiAgICBpZiAoKG9bJ3R5cGUnXSA9PSAnanNvbnAnIHx8IG1ldGhvZCA9PSAnR0VUJykgJiYgZGF0YSkge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgZGF0YSlcbiAgICAgIGRhdGEgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKG9bJ3R5cGUnXSA9PSAnanNvbnAnKSByZXR1cm4gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKVxuXG4gICAgLy8gZ2V0IHRoZSB4aHIgZnJvbSB0aGUgZmFjdG9yeSBpZiBwYXNzZWRcbiAgICAvLyBpZiB0aGUgZmFjdG9yeSByZXR1cm5zIG51bGwsIGZhbGwtYmFjayB0byBvdXJzXG4gICAgaHR0cCA9IChvLnhociAmJiBvLnhocihvKSkgfHwgeGhyKG8pXG5cbiAgICBodHRwLm9wZW4obWV0aG9kLCB1cmwsIG9bJ2FzeW5jJ10gPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKVxuICAgIHNldEhlYWRlcnMoaHR0cCwgbylcbiAgICBzZXRDcmVkZW50aWFscyhodHRwLCBvKVxuICAgIGlmICh3aW5beERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiB3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgIGh0dHAub25sb2FkID0gZm5cbiAgICAgICAgaHR0cC5vbmVycm9yID0gZXJyXG4gICAgICAgIC8vIE5PVEU6IHNlZVxuICAgICAgICAvLyBodHRwOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvaWV3ZWJkZXZlbG9wbWVudC90aHJlYWQvMzBlZjNhZGQtNzY3Yy00NDM2LWI4YTktZjFjYTE5YjQ4MTJlXG4gICAgICAgIGh0dHAub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge31cbiAgICAgICAgc2VuZFdhaXQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlUmVhZHlTdGF0ZSh0aGlzLCBmbiwgZXJyKVxuICAgIH1cbiAgICBvWydiZWZvcmUnXSAmJiBvWydiZWZvcmUnXShodHRwKVxuICAgIGlmIChzZW5kV2FpdCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0dHAuc2VuZChkYXRhKVxuICAgICAgfSwgMjAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICB9XG4gICAgcmV0dXJuIGh0dHBcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXdlc3QobywgZm4pIHtcbiAgICB0aGlzLm8gPSBvXG4gICAgdGhpcy5mbiA9IGZuXG5cbiAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFR5cGUoaGVhZGVyKSB7XG4gICAgLy8ganNvbiwgamF2YXNjcmlwdCwgdGV4dC9wbGFpbiwgdGV4dC9odG1sLCB4bWxcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqc29uJykpIHJldHVybiAnanNvbidcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqYXZhc2NyaXB0JykpIHJldHVybiAnanMnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgndGV4dCcpKSByZXR1cm4gJ2h0bWwnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgneG1sJykpIHJldHVybiAneG1sJ1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdChvLCBmbikge1xuXG4gICAgdGhpcy51cmwgPSB0eXBlb2YgbyA9PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcblxuICAgIC8vIHdoZXRoZXIgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQgZm9yIHB1cnBvc2VcbiAgICAvLyBvZiB0cmFja2luZyB0aGUgUHJvbWlzZXNcbiAgICB0aGlzLl9mdWxmaWxsZWQgPSBmYWxzZVxuICAgIC8vIHN1Y2Nlc3MgaGFuZGxlcnNcbiAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uKCl7fVxuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMgPSBbXVxuICAgIC8vIGVycm9yIGhhbmRsZXJzXG4gICAgdGhpcy5fZXJyb3JIYW5kbGVycyA9IFtdXG4gICAgLy8gY29tcGxldGUgKGJvdGggc3VjY2VzcyBhbmQgZmFpbCkgaGFuZGxlcnNcbiAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzID0gW11cbiAgICB0aGlzLl9lcnJlZCA9IGZhbHNlXG4gICAgdGhpcy5fcmVzcG9uc2VBcmdzID0ge31cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgaWYgKG9bJ3RpbWVvdXQnXSkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYWJvcnQoKVxuICAgICAgfSwgb1sndGltZW91dCddKVxuICAgIH1cblxuICAgIGlmIChvWydzdWNjZXNzJ10pIHtcbiAgICAgIHRoaXMuX3N1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydzdWNjZXNzJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvWydlcnJvciddKSB7XG4gICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydlcnJvciddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG9bJ2NvbXBsZXRlJ10pIHtcbiAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ2NvbXBsZXRlJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSAocmVzcCkge1xuICAgICAgb1sndGltZW91dCddICYmIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG4gICAgICBzZWxmLnRpbWVvdXQgPSBudWxsXG4gICAgICB3aGlsZSAoc2VsZi5fY29tcGxldGVIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuX2NvbXBsZXRlSGFuZGxlcnMuc2hpZnQoKShyZXNwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1Y2Nlc3MgKHJlc3ApIHtcbiAgICAgIHZhciB0eXBlID0gb1sndHlwZSddIHx8IHNldFR5cGUocmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykpXG4gICAgICByZXNwID0gKHR5cGUgIT09ICdqc29ucCcpID8gc2VsZi5yZXF1ZXN0IDogcmVzcFxuICAgICAgLy8gdXNlIGdsb2JhbCBkYXRhIGZpbHRlciBvbiByZXNwb25zZSB0ZXh0XG4gICAgICB2YXIgZmlsdGVyZWRSZXNwb25zZSA9IGdsb2JhbFNldHVwT3B0aW9ucy5kYXRhRmlsdGVyKHJlc3AucmVzcG9uc2VUZXh0LCB0eXBlKVxuICAgICAgICAsIHIgPSBmaWx0ZXJlZFJlc3BvbnNlXG4gICAgICB0cnkge1xuICAgICAgICByZXNwLnJlc3BvbnNlVGV4dCA9IHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gY2FuJ3QgYXNzaWduIHRoaXMgaW4gSUU8PTgsIGp1c3QgaWdub3JlXG4gICAgICB9XG4gICAgICBpZiAocikge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3AgPSB3aW4uSlNPTiA/IHdpbi5KU09OLnBhcnNlKHIpIDogZXZhbCgnKCcgKyByICsgJyknKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKHJlc3AsICdDb3VsZCBub3QgcGFyc2UgSlNPTiBpbiByZXNwb25zZScsIGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnanMnOlxuICAgICAgICAgIHJlc3AgPSBldmFsKHIpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgcmVzcCA9IHJcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgIHJlc3AgPSByZXNwLnJlc3BvbnNlWE1MXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvciAvLyBJRSB0cm9sb2xvXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5lcnJvckNvZGVcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLnJlYXNvblxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fZnVsZmlsbGVkID0gdHJ1ZVxuICAgICAgZm4ocmVzcClcbiAgICAgIHNlbGYuX3N1Y2Nlc3NIYW5kbGVyKHJlc3ApXG4gICAgICB3aGlsZSAoc2VsZi5fZnVsZmlsbG1lbnRIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3AgPSBzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cblxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihyZXNwLCBtc2csIHQpIHtcbiAgICAgIHJlc3AgPSBzZWxmLnJlcXVlc3RcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLm1zZyA9IG1zZ1xuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnQgPSB0XG4gICAgICBzZWxmLl9lcnJlZCA9IHRydWVcbiAgICAgIHdoaWxlIChzZWxmLl9lcnJvckhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fZXJyb3JIYW5kbGVycy5zaGlmdCgpKHJlc3AsIG1zZywgdClcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlKHJlc3ApXG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0ID0gZ2V0UmVxdWVzdC5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9yKVxuICB9XG5cbiAgUmVxd2VzdC5wcm90b3R5cGUgPSB7XG4gICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlXG4gICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKVxuICAgIH1cblxuICAsIHJldHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbml0LmNhbGwodGhpcywgdGhpcy5vLCB0aGlzLmZuKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNtYWxsIGRldmlhdGlvbiBmcm9tIHRoZSBQcm9taXNlcyBBIENvbW1vbkpzIHNwZWNpZmljYXRpb25cbiAgICAgKiBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Qcm9taXNlcy9BXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBgdGhlbmAgd2lsbCBleGVjdXRlIHVwb24gc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICAgICAqL1xuICAsIHRoZW46IGZ1bmN0aW9uIChzdWNjZXNzLCBmYWlsKSB7XG4gICAgICBzdWNjZXNzID0gc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgZmFpbCA9IGZhaWwgfHwgZnVuY3Rpb24gKCkge31cbiAgICAgIGlmICh0aGlzLl9mdWxmaWxsZWQpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AgPSBzdWNjZXNzKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmYWlsKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwLCB0aGlzLl9yZXNwb25zZUFyZ3MubXNnLCB0aGlzLl9yZXNwb25zZUFyZ3MudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMucHVzaChzdWNjZXNzKVxuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZmFpbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGFsd2F5c2Agd2lsbCBleGVjdXRlIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZHMgb3IgZmFpbHNcbiAgICAgKi9cbiAgLCBhbHdheXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCB8fCB0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGZhaWxgIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZSByZXF1ZXN0IGZhaWxzXG4gICAgICovXG4gICwgZmFpbDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZm4odGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXF3ZXN0KG8sIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIG5ld2xpbmUgdmFyaWFudHMgYWNjb3JkaW5nIHRvIHNwZWMgLT4gQ1JMRlxuICBmdW5jdGlvbiBub3JtYWxpemUocykge1xuICAgIHJldHVybiBzID8gcy5yZXBsYWNlKC9cXHI/XFxuL2csICdcXHJcXG4nKSA6ICcnXG4gIH1cblxuICBmdW5jdGlvbiBzZXJpYWwoZWwsIGNiKSB7XG4gICAgdmFyIG4gPSBlbC5uYW1lXG4gICAgICAsIHQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICwgb3B0Q2IgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgIC8vIElFIGdpdmVzIHZhbHVlPVwiXCIgZXZlbiB3aGVyZSB0aGVyZSBpcyBubyB2YWx1ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAvLyAnc3BlY2lmaWVkJyByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvY29yZS5odG1sI0lELTg2MjUyOTI3M1xuICAgICAgICAgIGlmIChvICYmICFvWydkaXNhYmxlZCddKVxuICAgICAgICAgICAgY2Iobiwgbm9ybWFsaXplKG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXSAmJiBvWydhdHRyaWJ1dGVzJ11bJ3ZhbHVlJ11bJ3NwZWNpZmllZCddID8gb1sndmFsdWUnXSA6IG9bJ3RleHQnXSkpXG4gICAgICAgIH1cbiAgICAgICwgY2gsIHJhLCB2YWwsIGlcblxuICAgIC8vIGRvbid0IHNlcmlhbGl6ZSBlbGVtZW50cyB0aGF0IGFyZSBkaXNhYmxlZCBvciB3aXRob3V0IGEgbmFtZVxuICAgIGlmIChlbC5kaXNhYmxlZCB8fCAhbikgcmV0dXJuXG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpZiAoIS9yZXNldHxidXR0b258aW1hZ2V8ZmlsZS9pLnRlc3QoZWwudHlwZSkpIHtcbiAgICAgICAgY2ggPSAvY2hlY2tib3gvaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHJhID0gL3JhZGlvL2kudGVzdChlbC50eXBlKVxuICAgICAgICB2YWwgPSBlbC52YWx1ZVxuICAgICAgICAvLyBXZWJLaXQgZ2l2ZXMgdXMgXCJcIiBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIGNoZWNrYm94IGhhcyBubyB2YWx1ZSwgc28gY29ycmVjdCBpdCBoZXJlXG4gICAgICAgIDsoIShjaCB8fCByYSkgfHwgZWwuY2hlY2tlZCkgJiYgY2Iobiwgbm9ybWFsaXplKGNoICYmIHZhbCA9PT0gJycgPyAnb24nIDogdmFsKSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgY2Iobiwgbm9ybWFsaXplKGVsLnZhbHVlKSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGlmIChlbC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3Qtb25lJykge1xuICAgICAgICBvcHRDYihlbC5zZWxlY3RlZEluZGV4ID49IDAgPyBlbC5vcHRpb25zW2VsLnNlbGVjdGVkSW5kZXhdIDogbnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGVsLmxlbmd0aCAmJiBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbC5vcHRpb25zW2ldLnNlbGVjdGVkICYmIG9wdENiKGVsLm9wdGlvbnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gY29sbGVjdCB1cCBhbGwgZm9ybSBlbGVtZW50cyBmb3VuZCBmcm9tIHRoZSBwYXNzZWQgYXJndW1lbnQgZWxlbWVudHMgYWxsXG4gIC8vIHRoZSB3YXkgZG93biB0byBjaGlsZCBlbGVtZW50czsgcGFzcyBhICc8Zm9ybT4nIG9yIGZvcm0gZmllbGRzLlxuICAvLyBjYWxsZWQgd2l0aCAndGhpcyc9Y2FsbGJhY2sgdG8gdXNlIGZvciBzZXJpYWwoKSBvbiBlYWNoIGVsZW1lbnRcbiAgZnVuY3Rpb24gZWFjaEZvcm1FbGVtZW50KCkge1xuICAgIHZhciBjYiA9IHRoaXNcbiAgICAgICwgZSwgaVxuICAgICAgLCBzZXJpYWxpemVTdWJ0YWdzID0gZnVuY3Rpb24gKGUsIHRhZ3MpIHtcbiAgICAgICAgICB2YXIgaSwgaiwgZmFcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmEgPSBlW2J5VGFnXSh0YWdzW2ldKVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZhLmxlbmd0aDsgaisrKSBzZXJpYWwoZmFbal0sIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZSA9IGFyZ3VtZW50c1tpXVxuICAgICAgaWYgKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWEvaS50ZXN0KGUudGFnTmFtZSkpIHNlcmlhbChlLCBjYilcbiAgICAgIHNlcmlhbGl6ZVN1YnRhZ3MoZSwgWyAnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJyBdKVxuICAgIH1cbiAgfVxuXG4gIC8vIHN0YW5kYXJkIHF1ZXJ5IHN0cmluZyBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5U3RyaW5nKCkge1xuICAgIHJldHVybiByZXF3ZXN0LnRvUXVlcnlTdHJpbmcocmVxd2VzdC5zZXJpYWxpemVBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKVxuICB9XG5cbiAgLy8geyAnbmFtZSc6ICd2YWx1ZScsIC4uLiB9IHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplSGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IHt9XG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgaW4gaGFzaCkge1xuICAgICAgICBoYXNoW25hbWVdICYmICFpc0FycmF5KGhhc2hbbmFtZV0pICYmIChoYXNoW25hbWVdID0gW2hhc2hbbmFtZV1dKVxuICAgICAgICBoYXNoW25hbWVdLnB1c2godmFsdWUpXG4gICAgICB9IGVsc2UgaGFzaFtuYW1lXSA9IHZhbHVlXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvLyBbIHsgbmFtZTogJ25hbWUnLCB2YWx1ZTogJ3ZhbHVlJyB9LCAuLi4gXSBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIHJlcXdlc3Quc2VyaWFsaXplQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyciA9IFtdXG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgYXJyLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIHJlcXdlc3Quc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgICB2YXIgb3B0LCBmblxuICAgICAgLCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuXG4gICAgb3B0ID0gYXJncy5wb3AoKVxuICAgIG9wdCAmJiBvcHQubm9kZVR5cGUgJiYgYXJncy5wdXNoKG9wdCkgJiYgKG9wdCA9IG51bGwpXG4gICAgb3B0ICYmIChvcHQgPSBvcHQudHlwZSlcblxuICAgIGlmIChvcHQgPT0gJ21hcCcpIGZuID0gc2VyaWFsaXplSGFzaFxuICAgIGVsc2UgaWYgKG9wdCA9PSAnYXJyYXknKSBmbiA9IHJlcXdlc3Quc2VyaWFsaXplQXJyYXlcbiAgICBlbHNlIGZuID0gc2VyaWFsaXplUXVlcnlTdHJpbmdcblxuICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG5cbiAgcmVxd2VzdC50b1F1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKG8sIHRyYWQpIHtcbiAgICB2YXIgcHJlZml4LCBpXG4gICAgICAsIHRyYWRpdGlvbmFsID0gdHJhZCB8fCBmYWxzZVxuICAgICAgLCBzID0gW11cbiAgICAgICwgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAsIGFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gICAgICAgICAgdmFsdWUgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlKSA/IHZhbHVlKCkgOiAodmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpXG4gICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmMoa2V5KSArICc9JyArIGVuYyh2YWx1ZSlcbiAgICAgICAgfVxuICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgaWYgKGlzQXJyYXkobykpIHtcbiAgICAgIGZvciAoaSA9IDA7IG8gJiYgaSA8IG8ubGVuZ3RoOyBpKyspIGFkZChvW2ldWyduYW1lJ10sIG9baV1bJ3ZhbHVlJ10pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgIGZvciAocHJlZml4IGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJlZml4KSkgYnVpbGRQYXJhbXMocHJlZml4LCBvW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BhY2VzIHNob3VsZCBiZSArIGFjY29yZGluZyB0byBzcGVjXG4gICAgcmV0dXJuIHMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgIHZhciBuYW1lLCBpLCB2XG4gICAgICAsIHJicmFja2V0ID0gL1xcW1xcXSQvXG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgIGZvciAoaSA9IDA7IG9iaiAmJiBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHYgPSBvYmpbaV1cbiAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xuICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICBhZGQocHJlZml4LCB2KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyBpIDogJycpICsgJ10nLCB2LCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArIG5hbWUgKyAnXScsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICBhZGQocHJlZml4LCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxd2VzdC5nZXRjYWxsYmFja1ByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2tQcmVmaXhcbiAgfVxuXG4gIC8vIGpRdWVyeSBhbmQgWmVwdG8gY29tcGF0aWJpbGl0eSwgZGlmZmVyZW5jZXMgY2FuIGJlIHJlbWFwcGVkIGhlcmUgc28geW91IGNhbiBjYWxsXG4gIC8vIC5hamF4LmNvbXBhdChvcHRpb25zLCBjYWxsYmFjaylcbiAgcmVxd2VzdC5jb21wYXQgPSBmdW5jdGlvbiAobywgZm4pIHtcbiAgICBpZiAobykge1xuICAgICAgb1sndHlwZSddICYmIChvWydtZXRob2QnXSA9IG9bJ3R5cGUnXSkgJiYgZGVsZXRlIG9bJ3R5cGUnXVxuICAgICAgb1snZGF0YVR5cGUnXSAmJiAob1sndHlwZSddID0gb1snZGF0YVR5cGUnXSlcbiAgICAgIG9bJ2pzb25wQ2FsbGJhY2snXSAmJiAob1snanNvbnBDYWxsYmFja05hbWUnXSA9IG9bJ2pzb25wQ2FsbGJhY2snXSkgJiYgZGVsZXRlIG9bJ2pzb25wQ2FsbGJhY2snXVxuICAgICAgb1snanNvbnAnXSAmJiAob1snanNvbnBDYWxsYmFjayddID0gb1snanNvbnAnXSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgcmVxd2VzdC5hamF4U2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgZm9yICh2YXIgayBpbiBvcHRpb25zKSB7XG4gICAgICBnbG9iYWxTZXR1cE9wdGlvbnNba10gPSBvcHRpb25zW2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXdlc3Rcbn0pO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuXG4vKlxuQGZpbGVPdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgSmF2YVNjcmlwdCBjb2RlIHRoYXQgaGFuZGxlcyB0aGUgSFRNTCBkb2N1bWVudCB3aGVyZSBIVE1MIGlzIHJlbmRlcmVkIGZvciBhIFNhZmVGcmFtZSwgYXMgd2VsbCBhcyBkZWZpbmluZyB0aGUgRXh0ZXJuYWwgVmVuZG9yL0NsaWVudCBBUEkuXG5AYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86c3NuaWRlckB5YWhvby1pbmMuY29tXCI+U2VhbiBTbmlkZXI8L2E+XG5AYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Y2NvbGVbQVRdZW1pbmF0aW9uLmNvbVwiPkNocmlzIENvbGU8L2E+XG5AdmVyc2lvbiAxLjAuM1xuICovXG5cblxuLypcbkBuYW1lc3BhY2UgJHNmLmV4dCBUaGUgZXh0ZXJuYWwgdmVuZG9yIC8gY2xpZW50IEFQSSBmb3IgZnVuY3Rpb25hbGl0eSBpbnNpZGUgYSBTYWZlRnJhbWVcbkBuYW1lICRzZi5leHRcbiAqL1xuXG5cbi8qXG5AaWdub3JlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Jhc2VcIik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0V4dGVybmFsKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbih3aW5kb3csIHNmKSB7XG4gICAgICB2YXIgQ09MTEFQU0VfQ09NTUFORCwgREcsIERPTV9XQVRDSF9JTlRFUlZBTCwgRFAsIERTLCBFUlJPUl9DT01NQU5ELCBFWFBBTkRfQ09NTUFORCwgR1VJRF9WQUxJRF9USU1FLCBJRV9BVFRBQ0gsIElFX0RFVEFDSCwgTE9BRCwgTUFYX01TR19XQUlUX1RJTUUsIE1TRywgTk9USUZZX0NMSUNLRUQsIE5PVElGWV9DT0xMQVBTRSwgTk9USUZZX0NPTExBUFNFRCwgTk9USUZZX0VYUEFORCwgTk9USUZZX0ZBSUxVUkUsIE5PVElGWV9GT0NVU19DSEFOR0UsIE5PVElGWV9HRU9NX1VQREFURSwgTk9USUZZX0xPQURFRCwgTk9USUZZX1JFQURfQ09PS0lFLCBOT1RJRllfUkVMT0FELCBOT1RJRllfUkVRVUVTVEVELCBOT1RJRllfVU5WSUVXRUQsIE5PVElGWV9WSUVXRUQsIE5PVElGWV9XUklURV9DT09LSUUsIE9CSiwgT05MT0FELCBPTk1TRywgT05VTkxPQUQsIE9OX1NUUiwgT1VSX1RBR19DTFNfTkFNRSwgUGFyYW1IYXNoLCBTVEFUVVNfQ09MTEFQU0VELCBTVEFUVVNfQ09MTEFQU0lORywgU1RBVFVTX0VYUEFOREVELCBTVEFUVVNfRVhQQU5ESU5HLCBUT0xPV0VSQ0FTRSwgVU5MT0FELCBXM0NfQVRUQUNILCBXM0NfREVUQUNILCBhZFNob3duLCBjYW5fdXNlX2h0bWw1LCBjbGljaywgY21kUmV0cmllcywgY29sbGFwc2UsIGNvb2tpZSwgZCwgZGVsZXRlTWV0YSwgZG9tLCBlbnYsIGVycl9tc2dfdGltZXJfaWQsIGVycl9tc2dzLCBleHBhbmQsIGZvcmNlX2NvbGxhcHNlLCBmcmFtZV9pZCwgZ2VvbSwgZ2VvbV9pbmZvLCBndWlkLCBoYXNMb2FkZWQsIGhvc3RfY25hbWUsIGllX29sZF9hdHRhY2gsIGllX29sZF9kZXRhY2gsIGlmcmFtZXMsIGluVmlld1BlcmNlbnRhZ2UsIGluaXRfaGVpZ2h0LCBpbml0X3dpZHRoLCBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCwgaXNBZFNob3duLCBpc0lFLCBpc19leHBhbmRlZCwgaXNfcmVnaXN0ZXJlZCwgbGFuZywgbGliLCBsb2FkZWQsIG1lc3NhZ2UsIG1ldGEsIG1zZ2NsaWVudF9mYiwgb3JpZ2luYWxXcml0ZSwgb3JwaGFuX3RpbWVyX2lkLCBwYXIsIHBlbmRpbmdfbXNnLCBwb3NfaWQsIHBvc19tZXRhLCByZWdpc3RlciwgcmVsb2FkLCByZW5kZXIsIHJlbmRlcl9jb25mLCByZW5kZXJfcGFyYW1zLCBzYW5kYm94X2NiLCBzaG93QWQsIHN0YXR1cywgc3VwcG9ydHMsIHVubG9hZF9oYW5kbGVycywgdW52aWV3ZWQsIHZpZXdlZCwgdzNjX29sZF9hdHRhY2gsIHczY19vbGRfZGV0YWNoLCB3aW4sIHdpbkhhc0ZvY3VzLCB3aW5faGFzX2ZvY3VzLCBfYXBwZW5kLCBfYXR0YWNoLCBfYXR0YWNoX292ZXJyaWRlLCBfYXR0ciwgX2NhbGxfY2xpZW50X2ZiLCBfY2FsbF9yYXdfZXZ0X2Z1bmMsIF9jaGVja19vcnBoYW5lZCwgX2NudW0sIF9jb2xsYXBzZSwgX2NvbnN0cnVjdGlvbiwgX2NyZWF0ZV9zdHlsZXNoZWV0LCBfY3N0ciwgX2Rlc3RydWN0aW9uLCBfZGV0YWNoLCBfZGV0YWNoX292ZXJyaWRlLCBfZGV0ZWN0X2JhZF9pZnJhbWUsIF9lbHQsIF9maXJlX3NhbmRib3hfY2FsbGJhY2ssIF9oYW5kbGVfZXJyLCBfaGFuZGxlX2xvYWQsIF9oYW5kbGVfbXNnLCBfaGFuZGxlX3VubG9hZCwgX251a2VfZG9jLCBfcHVyZ2UsIF9yZWF0dGFjaF9tZXNzYWdpbmcsIF9yZWNlaXZlX21zZywgX3JlbmRlciwgX3JlcG9ydF9lcnJzLCBfcmVxdWVzdGVkLCBfcmVzZXRfaW5saW5lX2hhbmRsZXJzLCBfc2VuZF9jbWQsIF9zZW5kX21zZywgX3NldF9hbGlnbm1lbnQsIF9zZXRfaHlwZXJsaW5rX3RhcmdldHMsIF9zZXR1cF93aW5fZXZ0X3Byb3BzLCBfdGFncywgX3VlLCBfd3JhcGlGcmFtZTtcbiAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIExPQUQgPSBcImxvYWRcIjtcbiAgICAgIE9OX1NUUiA9IFwib25cIjtcbiAgICAgIE1TRyA9IFwibWVzc2FnZVwiO1xuICAgICAgVU5MT0FEID0gXCJ1blwiICsgTE9BRDtcbiAgICAgIE9OVU5MT0FEID0gT05fU1RSICsgVU5MT0FEO1xuICAgICAgT05NU0cgPSBPTl9TVFIgKyBNU0c7XG4gICAgICBPTkxPQUQgPSBPTl9TVFIgKyBMT0FEO1xuICAgICAgREcgPSBcIl9fZGVmaW5lR2V0dGVyX19cIjtcbiAgICAgIERTID0gXCJfX2RlZmluZVNldHRlcl9fXCI7XG4gICAgICBEUCA9IFwiX19kZWZpbmVQcm9wZXJ0eV9fXCI7XG4gICAgICBXM0NfQVRUQUNIID0gXCJhZGRFdmVudExpc3RlbmVyXCI7XG4gICAgICBXM0NfREVUQUNIID0gXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XG4gICAgICBJRV9BVFRBQ0ggPSBcImF0dGFjaEV2ZW50XCI7XG4gICAgICBJRV9ERVRBQ0ggPSBcImRldGFjaEV2ZW50XCI7XG4gICAgICBUT0xPV0VSQ0FTRSA9IFwidG9Mb3dlckNhc2VcIjtcbiAgICAgIEVYUEFORF9DT01NQU5EID0gXCJleHAtb3ZyXCI7XG4gICAgICBDT0xMQVBTRV9DT01NQU5EID0gXCJjb2xsYXBzZVwiO1xuICAgICAgRVJST1JfQ09NTUFORCA9IFwiZXJyb3JcIjtcbiAgICAgIE5PVElGWV9HRU9NX1VQREFURSA9IFwiZ2VvbS11cGRhdGVcIjtcbiAgICAgIE5PVElGWV9FWFBBTkQgPSBcImV4cGFuZFwiO1xuICAgICAgTk9USUZZX0ZPQ1VTX0NIQU5HRSA9IFwiZm9jdXMtY2hhbmdlXCI7XG4gICAgICBOT1RJRllfQ09MTEFQU0UgPSBDT0xMQVBTRV9DT01NQU5EO1xuICAgICAgTk9USUZZX0NPTExBUFNFRCA9IE5PVElGWV9DT0xMQVBTRSArIFwiZFwiO1xuICAgICAgTk9USUZZX0ZBSUxVUkUgPSBcImZhaWxlZFwiO1xuICAgICAgTk9USUZZX1JFQURfQ09PS0lFID0gXCJyZWFkLWNvb2tpZVwiO1xuICAgICAgTk9USUZZX1dSSVRFX0NPT0tJRSA9IFwid3JpdGUtY29va2llXCI7XG4gICAgICBOT1RJRllfQ0xJQ0tFRCA9IFwiY2xpY2tlZFwiO1xuICAgICAgTk9USUZZX1ZJRVdFRCA9IFwidmlld2VkXCI7XG4gICAgICBOT1RJRllfVU5WSUVXRUQgPSBcInVudmlld2VkXCI7XG4gICAgICBOT1RJRllfTE9BREVEID0gXCJsb2FkZWRcIjtcbiAgICAgIE5PVElGWV9SRVFVRVNURUQgPSBcInJlcXVlc3RlZFwiO1xuICAgICAgTk9USUZZX1JFTE9BRCA9IFwicmVsb2FkXCI7XG4gICAgICBTVEFUVVNfQ09MTEFQU0VEID0gTk9USUZZX0NPTExBUFNFRDtcbiAgICAgIFNUQVRVU19FWFBBTkRFRCA9IE5PVElGWV9FWFBBTkQgKyBcImVkXCI7XG4gICAgICBTVEFUVVNfQ09MTEFQU0lORyA9IFwiY29sbGFwc2luZ1wiO1xuICAgICAgU1RBVFVTX0VYUEFORElORyA9IE5PVElGWV9FWFBBTkQgKyBcImluZ1wiO1xuICAgICAgT1VSX1RBR19DTFNfTkFNRSA9IFwic2ZcIjtcbiAgICAgIE1BWF9NU0dfV0FJVF9USU1FID0gNDAwMDtcbiAgICAgIERPTV9XQVRDSF9JTlRFUlZBTCA9IDMwMDA7XG4gICAgICBHVUlEX1ZBTElEX1RJTUUgPSAzMDAwMDtcbiAgICAgIE9CSiA9IFwib2JqZWN0XCI7XG4gICAgICBkID0gd2luICYmIHdpbi5kb2N1bWVudDtcbiAgICAgIHBhciA9IHdpbiAmJiB3aW4ucGFyZW50O1xuICAgICAgbGliID0gc2YubGliO1xuICAgICAgZW52ID0gc2YuZW52O1xuICAgICAgbGFuZyA9IGxpYi5sYW5nO1xuICAgICAgUGFyYW1IYXNoID0gbGFuZy5QYXJhbUhhc2g7XG4gICAgICBkb20gPSBsaWIuZG9tO1xuICAgICAgaWZyYW1lcyA9IGRvbS5pZnJhbWVzO1xuICAgICAgbXNnY2xpZW50X2ZiID0gZG9tLm1zZ2NsaWVudF9mYjtcbiAgICAgIGlzSUUgPSBlbnYuaXNJRTtcbiAgICAgIF91ZSA9IHdpbi51bmVzY2FwZTtcbiAgICAgIF9jc3RyID0gbGFuZy5jc3RyO1xuICAgICAgX2NudW0gPSBsYW5nLmNudW07XG4gICAgICBfYXBwZW5kID0gZG9tLmFwcGVuZDtcbiAgICAgIF90YWdzID0gZG9tLnRhZ3M7XG4gICAgICBfZWx0ID0gZG9tICYmIGRvbS5lbHQ7XG4gICAgICBfcHVyZ2UgPSBkb20gJiYgZG9tLnB1cmdlO1xuICAgICAgX2F0dGFjaCA9IGRvbSAmJiBkb20uYXR0YWNoO1xuICAgICAgX2RldGFjaCA9IGRvbSAmJiBkb20uZGV0YWNoO1xuICAgICAgX2F0dHIgPSBkb20gJiYgZG9tLmF0dHI7XG4gICAgICBoYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgIGlzX2V4cGFuZGVkID0gZmFsc2U7XG4gICAgICBmb3JjZV9jb2xsYXBzZSA9IGZhbHNlO1xuICAgICAgaXNfcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgaW5pdF93aWR0aCA9IDA7XG4gICAgICBpbml0X2hlaWdodCA9IDA7XG4gICAgICBzYW5kYm94X2NiID0gbnVsbDtcbiAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgIGdlb21faW5mbyA9IG51bGw7XG4gICAgICBwb3NfbWV0YSA9IG51bGw7XG4gICAgICB3aW5faGFzX2ZvY3VzID0gZmFsc2U7XG4gICAgICBndWlkID0gXCJcIjtcbiAgICAgIGhvc3RfY25hbWUgPSBcIlwiO1xuICAgICAgY2FuX3VzZV9odG1sNSA9IGZhbHNlO1xuICAgICAgZnJhbWVfaWQgPSBcIlwiO1xuICAgICAgcG9zX2lkID0gXCJcIjtcbiAgICAgIGVycl9tc2dfdGltZXJfaWQgPSAwO1xuICAgICAgb3JwaGFuX3RpbWVyX2lkID0gMDtcbiAgICAgIGlubGluZV9oYW5kbGVyX3RpbWVyX2lkID0gMDtcbiAgICAgIGVycl9tc2dzID0gW107XG4gICAgICB1bmxvYWRfaGFuZGxlcnMgPSBbXTtcbiAgICAgIHJlbmRlcl9wYXJhbXMgPSB2b2lkIDA7XG4gICAgICByZW5kZXJfY29uZiA9IHZvaWQgMDtcbiAgICAgIGllX29sZF9hdHRhY2ggPSB2b2lkIDA7XG4gICAgICB3M2Nfb2xkX2F0dGFjaCA9IHZvaWQgMDtcbiAgICAgIGllX29sZF9kZXRhY2ggPSB2b2lkIDA7XG4gICAgICB3M2Nfb2xkX2RldGFjaCA9IHZvaWQgMDtcbiAgICAgIGlzQWRTaG93biA9IGZhbHNlO1xuXG4gICAgICAvKlxuICAgICAgQ3JlYXRlcyBhbmQgYXBwZW5kcyBhIHN0eWxlIHNoZWV0IGZvciBhbnkgY3VzdG9tIENTUyBwYXNzZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fY3JlYXRlX3N0eWxlc2hlZXRcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0IEEgc3RyaW5nIG9mIENTUyBydWxlcywgb3IgYSBVUkwgc3RyaW5nXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2lkXSBUaGUgaWQgYXR0cmlidXRlIG9mIHRoZSB0YWcgY3JlYXRlZCBhbmQgYXBwZW5kZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZV9zdHlsZXNoZWV0ID0gZnVuY3Rpb24oY3NzVGV4dCwgaWQpIHtcbiAgICAgICAgdmFyIGUsIG9IZWFkLCBvU1MsIG9UeHQ7XG4gICAgICAgIG9IZWFkID0gdm9pZCAwO1xuICAgICAgICBvU1MgPSB2b2lkIDA7XG4gICAgICAgIG9UeHQgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb0hlYWQgPSBfdGFncyhcImhlYWRcIilbMF07XG4gICAgICAgICAgaWYgKGNzc1RleHQuc2VhcmNoKC9cXHtbXlxcfV0qfS9nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9TUyA9IGRvbS5tYWtlKFwibGlua1wiKTtcbiAgICAgICAgICAgIG9TUy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICAgICAgb1NTLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuICAgICAgICAgICAgb1NTLmhyZWYgPSBjc3NUZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvU1MgPSBkb20ubWFrZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgb1NTLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgICBvU1Muc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9UeHQgPSBkLmNyZWF0ZVRleHROb2RlKGNzc1RleHQpO1xuICAgICAgICAgICAgICBfYXBwZW5kKG9TUywgb1R4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgb1NTLmlkID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9hcHBlbmQob0hlYWQsIG9TUyk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBGaXJlcyBvZiB1bmxvYWQgZXZlbnQgaGFuZGxlcnMgYW5kIHBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgY2xlYW4gdXAgd2hlbiBhIFNhZmVGcmFtZSBpcyBkZXN0cm95ZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fZGVzdHJ1Y3Rpb25cbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBbZXZ0XSBUaGUgcmF3IGRvbSBldmVudCBvYmplY3QgaWYgaXQgZXhpc3RzXG4gICAgICAgKi9cbiAgICAgIF9kZXN0cnVjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgZSwgZ3JhbmRfcGFyLCBoYW5kbGVyLCBzdWNjZXNzLCB3O1xuICAgICAgICBoYW5kbGVyID0gdm9pZCAwO1xuICAgICAgICB3ID0gd2luZG93O1xuICAgICAgICBzdWNjZXNzID0gMTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQgPSBldnQgfHwgdy5ldmVudCB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBldnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBVTkxPQURcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChoYW5kbGVyID0gdW5sb2FkX2hhbmRsZXJzLnNoaWZ0KCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGFuZGxlcihldnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgICB3W0lFX0FUVEFDSF0gPSBpZV9vbGRfYXR0YWNoO1xuICAgICAgICAgICAgd1tJRV9ERVRBQ0hdID0gaWVfb2xkX2RldGFjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodzNjX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICAgIHdbVzNDX0FUVEFDSF0gPSB3M2Nfb2xkX2F0dGFjaDtcbiAgICAgICAgICAgIHdbVzNDX0RFVEFDSF0gPSB3M2Nfb2xkX2RldGFjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgaWYgKCFoYXNMb2FkZWQpIHtcbiAgICAgICAgICBfZGV0YWNoKHcsIExPQUQsIF9oYW5kbGVfbG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgX2RldGFjaCh3LCBVTkxPQUQsIF9oYW5kbGVfdW5sb2FkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGVycl9tc2dfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlcnJfbXNnX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIGVycl9tc2dfdGltZXJfaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChvcnBoYW5fdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvcnBoYW5fdGltZXJfaWQpO1xuICAgICAgICAgICAgb3JwaGFuX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaW5saW5lX2hhbmRsZXJfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCk7XG4gICAgICAgICAgICBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHcgPSBpZV9vbGRfYXR0YWNoID0gdzNjX29sZF9hdHRhY2ggPSBpZV9vbGRfZGV0YWNoID0gdzNjX29sZF9kZXRhY2ggPSBkID0gX3VlID0gcGFyID0gaGFuZGxlciA9IGdyYW5kX3BhciA9IG51bGw7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE1haW50YWlucyB0aGF0IHRoZSB3aW5kb3cub25tZXNzYWdlIHByb3BlcnR5IHJlbWFpbnMgdW5zZXQuXG4gICAgICBXZSBkb24ndCB3YW50IGNvbnRlbnQgaW4gb3VyIGRvY3VtZW50IGxpc3RlbmluZyB0byBIVE1MNSBtZXNzYWdlcy5cbiAgICAgIFdlIG92ZXJyaWRlIGF0dGFjaGluZyB0byBsaXN0ZW5lcnMgYmVsb3cgdG8gbWFpbnRhaW4gdGhhdCBmdW5jdGlvbmFsaXR5LFxuICAgICAgaG93ZXZlciBJRSB3b24ndCBsZXQgeW91IG92ZXJyaWRlIHByb3BlcnRpZXMgZGlyZWN0bHkgaGFuZ25pbmcgb2ZmIG9mIHRoZVxuICAgICAgd2luZG93IG9iamVjdCwgc28gd2UgaGF2ZSBhIHRpbWVyIGFzIGEgZmFsbGJhY2sgZm9yIHRoYXQgcHVycG9zZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9yZXNldF9pbmxpbmVfaGFuZGxlcnNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3Jlc2V0X2lubGluZV9oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaW5saW5lX2hhbmRsZXJfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCk7XG4gICAgICAgICAgICBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGlzSUUgJiYgd2luLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgd2luLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luLm9uZXJyb3IgPSBfaGFuZGxlX2VycjtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCA9IHNldFRpbWVvdXQoX3Jlc2V0X2lubGluZV9oYW5kbGVycywgRE9NX1dBVENIX0lOVEVSVkFMKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDbGVhcnMgb3V0IHRoZSBIVE1MIGRvY3VtZW50ICh3aGljaCB3aWxsIGZvcmNlIGFuIHVubG9hZCBldmVudCBhcyB3ZWxsKS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fbnVrZV9kb2NcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX251a2VfZG9jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY3VtZW50Lm9wZW4oXCJ0ZXh0L2h0bWxcIiwgXCJyZXBsYWNlXCIpO1xuICAgICAgICAgIGRvY3VtZW50LndyaXRlKFwiXCIpO1xuICAgICAgICAgIGRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBJdGVyYXRpdmVseSBjaGVja3MgdG8gc2VlIGlmIHRoZSBJRlJBTUUgSFRNTCBkb2N1bWVudCBpcyBubyBsb25nZXJcbiAgICAgIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvbSwgZG9pbmcgdGhpcyBieSBjaGVja2luZyB0aGF0IG91ciBpbnRlcm5hbFxuICAgICAgd2luZG93IHJlZmVyZW5jZSBpcyBzdGlsbCB2YWxpZC4gLiAuYXMgd2VsbCBhcyBydW5uaW5nIHRoZSBjaGVja3MgdG8gbWFrZVxuICAgICAgc3VyZSBpbnZhbGlkIGlmcmFtZXMgKGlmcmFtZXMgZnJvbSBvcmlnaW4pIGFyZSBub3QgY3JlYXRlZC5cbiAgICAgIFxuICAgICAgSWYgd2UgZGV0ZWN0IHRoYXQgdGhlIElGUkFNRSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1haW4gZG9tIG9mIHRoZVxuICAgICAgcHVibGlzaGVyLCB0aGVuIHdlIGNhbGwgdG8gZGVzdHJveSB0aGUgSFRNTCBkb2N1bWVudCwgZm9yY2luZyBvbnVubG9hZFxuICAgICAgZXZlbnQgYW5kIHN1YnNxdWVudCBjbGVhbnVwXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2NoZWNrX29ycGhhbmVkXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9jaGVja19vcnBoYW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSwgaXNfb3JwaGFuZWQ7XG4gICAgICAgIGlzX29ycGhhbmVkID0gZmFsc2U7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIF9kZXRlY3RfYmFkX2lmcmFtZSgpO1xuICAgICAgICBpZiAoIWlzSUUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAob3JwaGFuX3RpbWVyX2lkICYmIG9ycGhhbl90aW1lcl9pZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvcnBoYW5fdGltZXJfaWQpO1xuICAgICAgICAgICAgb3JwaGFuX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpc19vcnBoYW5lZCA9IHdpbiA9PT0gdG9wICYmIG9ycGhhbl90aW1lcl9pZCAhPT0gLTE7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgaXNfb3JwaGFuZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfb3JwaGFuZWQpIHtcbiAgICAgICAgICBvcnBoYW5fdGltZXJfaWQgPSAtMTtcbiAgICAgICAgICBfZGVzdHJ1Y3Rpb24oKTtcbiAgICAgICAgICBfbnVrZV9kb2MoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIW9ycGhhbl90aW1lcl9pZCkge1xuICAgICAgICAgICAgb3JwaGFuX3RpbWVyX2lkID0gc2V0VGltZW91dChfY2hlY2tfb3JwaGFuZWQsIERPTV9XQVRDSF9JTlRFUlZBTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgRGV0ZWN0IHdoZXRoZXIgb3Igbm90IGFuIElGUkFNRSB0YWcgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NIHRoYXQgaGFzIHRoZSBzYW1lXG4gICAgICBvcmlnaW4gLyBjbmFtZSBhcyB0aGUgcHVibGlzaGVyLCB3aGljaCBzaG91bGQgbm90IGJlIGFsbG93ZWQgYXMgaXQncyBhIHNlY3VyaXR5IGlzc3VlXG4gICAgICBJZiBzYWlkIElGUkFNRSB0YWcocykgYXJlIGZvdW5kLCByZW1vdmUgdGhlbS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fZGV0ZWN0X2JhZF9pZnJhbWVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX2RldGVjdF9iYWRfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZHgsIHNyY0hvc3QsIHRhZywgd3JpdHRlbjtcbiAgICAgICAgaWZyYW1lcyA9IF90YWdzKFwiaWZyYW1lXCIpO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBzcmNIb3N0ID0gXCJcIjtcbiAgICAgICAgd3JpdHRlbiA9IGZhbHNlO1xuICAgICAgICB0YWcgPSB2b2lkIDA7XG4gICAgICAgIGlmIChob3N0X2NuYW1lKSB7XG4gICAgICAgICAgd2hpbGUgKHRhZyA9IGlmcmFtZXNbaWR4KytdKSB7XG4gICAgICAgICAgICBzcmNIb3N0ID0gX2F0dHIodGFnLCBcInNyY1wiKTtcbiAgICAgICAgICAgIHNyY0hvc3QgPSAoc3JjSG9zdCAmJiBzcmNIb3N0Lmxlbmd0aCA+PSA5ID8gc3JjSG9zdC5zdWJzdHJpbmcoMCwgc3JjSG9zdC5pbmRleE9mKFwiL1wiLCA5KSlbVE9MT1dFUkNBU0VdKCkgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChzcmNIb3N0ICYmIHNyY0hvc3QgPT09IGhvc3RfY25hbWUgJiYgdGFnLmNsYXNzTmFtZSAhPT0gT1VSX1RBR19DTFNfTkFNRSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wdXJnZSh0YWcpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTWFrZSBzdXJlIHRoYXQgYWxsIGh5cGVybGlua3MgaW4gdGhlIGRvY3VtZW50IGFyZSBzZXQgd2l0aCB0aGUgcHJvcGVydHkgXCJ0YXJnZXRcIiBhdHRyaWJ1dGVcbiAgICAgIHN1Y2ggdGhhdCBsaW5rcyB3aWxsIG5hdmlnYXRlIHRvIHRoZSByaWdodCB3aW5kb3cgcHJvcGVybHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3NldF9oeXBlcmxpbmtfdGFyZ2V0c1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfc2V0X2h5cGVybGlua190YXJnZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdGd0LCBpZHgsIGxuLCBsbnMsIHR0Z3Q7XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIHR0Z3QgPSAocmVuZGVyX2NvbmYgJiYgcmVuZGVyX2NvbmYudGd0KSB8fCBcIl90b3BcIjtcbiAgICAgICAgbG4gPSB2b2lkIDA7XG4gICAgICAgIGF0Z3QgPSB2b2lkIDA7XG4gICAgICAgIGxucyA9IHZvaWQgMDtcbiAgICAgICAgbG5zID0gX3RhZ3MoXCJhXCIpO1xuICAgICAgICBpZiAodHRndCA9PT0gXCJfc2VsZlwiKSB7XG4gICAgICAgICAgdHRndCA9IFwiX3RvcFwiO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsbiA9IGxuc1tpZHgrK10pIHtcbiAgICAgICAgICBhdGd0ID0gX2F0dHIobG4sIFwidGFyZ2V0XCIpO1xuICAgICAgICAgIGlmIChhdGd0ICE9PSB0dGd0KSB7XG4gICAgICAgICAgICBfYXR0cihsbiwgXCJ0YXJnZXRcIiwgdHRndCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZHggPiAxMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIHRoZSBvbnVubG9hZCBldmVudCBmcm9tIHRoZSBIVE1MIGRvY3VtZW50IG9mIHRoZSBJRlJBTUUsIHdoaWNoIGluIHR1cm4gd2lsbCB0cmlnZ2VyIGNsZWFuIHVwXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2hhbmRsZV91bmxvYWRcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBET00gZXZlbnQgb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfdW5sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF9kZXN0cnVjdGlvbihldnQpO1xuICAgICAgICBfbnVrZV9kb2MoKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIGxvYWQgZXZlbnQgZnJvbSB0aGUgSFRNTCBkb2N1bWVudCBvZiB0aGUgSUZSQU1FLCB3aGljaCB3aWxsIGFsc28gc2V0dXBcbiAgICAgIHRvIG1ha2Ugc3VyZSBsaW5rIHRhcmdldHMgYXJlIHNldCBwcm9wZXJseVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9oYW5kbGVfbG9hZFxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfaGFuZGxlX2xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBfZGV0YWNoKHdpbiwgTE9BRCwgX2hhbmRsZV9sb2FkKTtcbiAgICAgICAgX3NldF9oeXBlcmxpbmtfdGFyZ2V0cygpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSBvbm1lc3NhZ2UgSFRNTDUgeC1kb21haW4gZXZlbnRzLiBXZSBhbHdheXMgY2FuY2VsIHRoZSBldmVudFxuICAgICAgbmV2ZXIgYWxsb3dpbmcgaXQgdG8gZ28gdG8gb3RoZXIgbGlzdGVuZXJzIGJlc2lkZXMgb3VyIG93biwgYXMgd2UgZG9uJ3QgYWxsb3cgSFRNTDUgbWVzc2FnaW5nXG4gICAgICBiZXlvbmQgdXMgYW5kIHRoZSBwdWJsaXNoZXIgLyBob3N0LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9oYW5kbGVfbXNnXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfbXNnID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBlLCBtc2dfZ3VpZCwgbXNnX29iaiwgbXNnX3BhcmFtcywgb3JnLCBzcmMsIHN0cjtcbiAgICAgICAgc3RyID0gdm9pZCAwO1xuICAgICAgICBzcmMgPSB2b2lkIDA7XG4gICAgICAgIG9yZyA9IHZvaWQgMDtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgbXNnX3BhcmFtcyA9IHZvaWQgMDtcbiAgICAgICAgbXNnX2d1aWQgPSB2b2lkIDA7XG4gICAgICAgIG1zZ19vYmogPSB2b2lkIDA7XG5cbiAgICAgICAgLypcbiAgICAgICAgVE9ETywgYWxzbyB2YWxpZGF0ZSBvcmlnaW5cbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RyID0gZXZ0LmRhdGE7XG4gICAgICAgICAgc3JjID0gZXZ0LnNvdXJjZTtcbiAgICAgICAgICBvcmcgPSBldnQub3JpZ2luO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIGRvbS5ldnRDbmNsKGV2dCk7XG4gICAgICAgIGlmIChzdHIgJiYgc3JjICYmIHNyYyA9PT0gdG9wKSB7XG4gICAgICAgICAgbXNnX3BhcmFtcyA9IFBhcmFtSGFzaChzdHIsIG51bGwsIG51bGwsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG1zZ19ndWlkID0gbXNnX3BhcmFtcy5ndWlkO1xuICAgICAgICAgIG1zZ19vYmogPSBtc2dfcGFyYW1zLm1zZztcbiAgICAgICAgICBpZiAoZ3VpZCA9PT0gbXNnX2d1aWQgJiYgbXNnX29iaiAmJiB0eXBlb2YgbXNnX29iaiA9PT0gT0JKKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfcmVjZWl2ZV9tc2cobXNnX29iaiwgZXZ0KTtcbiAgICAgICAgICAgICAgICBtc2dfcGFyYW1zID0gZXZ0ID0gbXNnX2d1aWQgPSBtc2dfb2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFRoaXMgU2FmZUZyYW1lcyBpbXBsZW1lbnRhdGlvbiBpbnRlcm5hbGx5IGhhbmRsZXMgYWxsIGV2ZW50IGF0dGFjaG1lbnQgdG8gbWFpbnRhaW4gdGhhdCB0aGUgbGlzdGVuZXIgb3JkZXJcbiAgICAgIGZvciBldmVudHMgdGhhdCBpdCBjYXJlcyBhYm91dCAob25sb2FkLCBvbnVubG9hZCwgb25iZWZvcmV1bmxvYWQsIG9ubWVzc2FnZSkuXG4gICAgICBUaGlzIGlzIGRvbmUgdG8gbWFrZSBzdXJlIHRoYXQgcHJvcGVyIGNsZWFuIHVwIGFuZCBpbnRpYWxpemF0aW9uIGhhcHBlbnMsIGFzIHdlbGwgYXMgdG8gZW5mb3JjZVxuICAgICAgc2VjdXJpdHkuXG4gICAgICBcbiAgICAgIEZvciBldmVudHMgdGhhdCBpdCBTYWZlRnJhbWVzIGRvZXMgbm90IGNhcmUgYWJvdXQgd2UgYWxsb3cgdGhlIGF0dGFjaG1lbnQgbGlzdGVuZXJzXG4gICAgICB0byBwcm9jZWVkIGFzIG5vcm1hbCwgc28gd2UgY2FsbCB0aGUgcmF3IGF0dGFjaEV2ZW50IC8gYWRkRXZlbnRMaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2NhbGxfcmF3X2V2dF9mdW5jXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIGF0dGFjaC9kZXRhY2ggYSBsaXN0ZW5lclxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdXNlIGFzIGEgbGlzdGVuZXIgZm9yIHNhaWQgZXZlbnRcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbW92ZV0gSWYgc2V0IHRvIHRydWUsIHJlbW92ZS9kZXRhY2ggdGhpcyBmdW5jdGlvbiBhcyBhIGxpc3RlbmVyLCBvdGhlcndpc2UgYWRkXG4gICAgICAgKi9cbiAgICAgIF9jYWxsX3Jhd19ldnRfZnVuYyA9IGZ1bmN0aW9uKHR5cGUsIGYsIHJlbW92ZSkge1xuICAgICAgICB2YXIgYk9LLCBlLCBpZV9mLCB3M2NfZjtcbiAgICAgICAgYk9LID0gZmFsc2U7XG4gICAgICAgIGllX2YgPSB2b2lkIDA7XG4gICAgICAgIHczY19mID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgaWVfZiA9IGllX29sZF9kZXRhY2ggfHwgdzNjX29sZF9kZXRhY2g7XG4gICAgICAgICAgdzNjX2YgPSB3M2Nfb2xkX2RldGFjaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZV9mID0gaWVfb2xkX2F0dGFjaCB8fCB3M2Nfb2xkX2F0dGFjaDtcbiAgICAgICAgICB3M2NfZiA9IHczY19vbGRfYXR0YWNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZV9mKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGllX2YodHlwZSwgZik7XG4gICAgICAgICAgICBiT0sgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIGJPSyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWJPSykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWVfZi5jYWxsKHdpbiwgdHlwZSwgZik7XG4gICAgICAgICAgICAgIGJPSyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgYk9LID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3M2NfZiAmJiAhYk9LKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHczY19mLmNhbGwod2luLCB0eXBlLCBmLCBmYWxzZSk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgT3ZlcnJpZGUgZGVmYXVsdCBldmVudCBhdHRhY2htZW50LCBhbmQgc2VuZCBsb2FkLCBiZWZvcmV1bmxvYWQsIGFuZCB1bmxvYWQgaGFuZGxlcnMgaW50byBvdXJcbiAgICAgIG93biBxdWVzLCBzbyB0aGF0IHdlIGNhbiBlbmZvcmNlIHRoZSBwcm9wZXIgZmlyaW5nIG9yZGVyLiAgaWYgbWVzc2FnZSBldmVudCBpcyBwYXNzZWQgaW4sXG4gICAgICB3ZSBkbyBub3QgYWxsb3cgYXR0YWNobWVudCwgc2luY2Ugd2UgZG8gbm90IHdhbnQgbi1wYXJ0eSBjb2RlIGxpc3RlbmluZyB0byBIVE1MNSBtZXNzYWdlc1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9hdHRhY2hfb3ZlcnJpZGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0b29cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgZXZlbnQgZmlyZXNcbiAgICAgICAqL1xuICAgICAgX2F0dGFjaF9vdmVycmlkZSA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtcbiAgICAgICAgdmFyIGJEb0RlZmF1bHQ7XG4gICAgICAgIGJEb0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IF9jc3RyKHR5cGUpW1RPTE9XRVJDQVNFXSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFVOTE9BRDpcbiAgICAgICAgICBjYXNlIE9OVU5MT0FEOlxuICAgICAgICAgICAgdW5sb2FkX2hhbmRsZXJzLnB1c2goZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1TRzpcbiAgICAgICAgICBjYXNlIE9OTVNHOlxuICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBiRG9EZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYkRvRGVmYXVsdCkge1xuICAgICAgICAgIF9jYWxsX3Jhd19ldnRfZnVuYyh0eXBlLCBmKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE92ZXJyaWRlIGRlZmF1bHQgZXZlbnQgZGV0YWNobWVudCwgYW5kIHJlbW92ZSBsb2FkLCBiZWZvcmV1bmxvYWQsIGFuZCB1bmxvYWQgaGFuZGxlcnNcbiAgICAgIGZyb20gb3VyIG93biBxdWUuICBpZiBtZXNzYWdlIGV2ZW50IGlzIHBhc3NlZCBpbiwgd2UgZG8gbm90aGluZyAoc2luY2Ugd2UgZG9uJ3QgYWxsbG93XG4gICAgICBhdHRhY2htZW50IGVpdGhlcikuICBJZiBub3Qgb25lIG9mIHRob3NlIGV2ZW50IHR5cGVzLCB0aGVuIHdlIGNhbGwgdGhlIGRlZmF1bHQgZXZlbnQgZGV0YWNobWVudFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9kZXRhY2hfb3ZlcnJpZGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lIHRvIHVubGlzdGVuIHRvb1xuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdG8gbm8gbG9uZ2VyIGJlIGNhbGxlZCBmb3IgdGhlIHNwZWNpZmljIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIF9kZXRhY2hfb3ZlcnJpZGUgPSBmdW5jdGlvbih0eXBlLCBmKSB7XG4gICAgICAgIHZhciBoYW5kbGVyLCBoYW5kbGVycywgaWR4O1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBoYW5kbGVyID0gdm9pZCAwO1xuICAgICAgICBoYW5kbGVycyA9IHZvaWQgMDtcbiAgICAgICAgdHlwZSA9IF9jc3RyKHR5cGUpW1RPTE9XRVJDQVNFXSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFVOTE9BRDpcbiAgICAgICAgICBjYXNlIE9OVU5MT0FEOlxuICAgICAgICAgICAgaGFuZGxlcnMgPSB1bmxvYWRfaGFuZGxlcnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1TRzpcbiAgICAgICAgICBjYXNlIE9OTVNHOlxuICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlcnMgIT0gbnVsbCA/IGhhbmRsZXJzLmxlbmd0aCA6IHZvaWQgMCkge1xuICAgICAgICAgIHdoaWxlIChoYW5kbGVyID0gaGFuZGxlcnNbaWR4XSkge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IGYpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgIH1cbiAgICAgICAgX2NhbGxfcmF3X2V2dF9mdW5jKHR5cGUsIGYsIHRydWUpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlcG9ydCBhbnkgaW50ZXJuYWwgdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvcnMgdXAgdG8gdGhlIHB1Ymxpc2hlciAvIGhvc3RcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fcmVwb3J0X2VycnNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3JlcG9ydF9lcnJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbWRfc3RyLCBlLCBlcnJzO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBlcnJzID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChlcnJfbXNncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnJzID0gZXJyX21zZ3NbMF07XG4gICAgICAgICAgICBjbWRfc3RyID0gW1wiY21kPVwiLCBFUlJPUl9DT01NQU5ELCBcIiZwb3M9XCIsIHBvc19pZCwgXCImZXJyb3JzPVwiLCBlcnJzXTtcbiAgICAgICAgICAgIF9zZW5kX21zZyhfY3N0cihjbWRfc3RyKSwgRVJST1JfQ09NTUFORCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJfbXNnX3RpbWVyX2lkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZXJyX21zZ190aW1lcl9pZCk7XG4gICAgICAgICAgICBlcnJfbXNnX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgZXJyX21zZ3MgPSBbXTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgYW55IHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3JzXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2hhbmRsZV9lcnJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBhIFRoZSB0aGUgZXJyb3IgbWVzc2FnZSAvIGRlc2NyaXB0aW9uIHN0cmluZ1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IGIgVGhlIFVSTCAvIGZpbGUgdGhhdCB0aGUgSmF2YVNjcmlwdCBlcnJvciBvY2N1cmVkIHdpdGhpblxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGxpbmUgbnVtYmVyIHRoYXQgdGhlIGVycm9yIG9jY3VyZWQgb24uIC4gLlxuICAgICAgICovXG4gICAgICBfaGFuZGxlX2VyciA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGVycl9tc2dzLnB1c2goX2NzdHIoW1wiRXJyb3Igb2NjdXJyZWQgaW5zaWRlIFNhZmVGcmFtZTpcXG5NZXNzYWdlOiBcIiwgYSwgXCJcXG5VUkw6XCIsIGIsIFwiXFxuTGluZTpcIiwgY10pKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZXJyX21zZ190aW1lcl9pZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVycl9tc2dfdGltZXJfaWQpO1xuICAgICAgICAgICAgZXJyX21zZ190aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycl9tc2dfdGltZXJfaWQgPSBzZXRUaW1lb3V0KF9yZXBvcnRfZXJycywgRE9NX1dBVENIX0lOVEVSVkFMKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBPdmVycmlkZSBuYXRpdmUgd2luZG93IG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gY29udHJvbFxuICAgICAgaG93IHRoZSBldmVudHMgdGhhdCB3ZSBuZWVkIHRvIG1hbmFnZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9zZXR1cF93aW5fZXZ0X3Byb3BzXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwcml2YXRlXG4gICAgICBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSB3aW5kb3cgb2JqZWN0IC8gcHJvdG90eXBlXG4gICAgICAgKi9cbiAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBPLCBlLCBuLCBub2JqLCByZXQ7XG4gICAgICAgIG4gPSBsYW5nLm5vb3A7XG4gICAgICAgIE8gPSBPYmplY3Q7XG4gICAgICAgIG5vYmogPSB7XG4gICAgICAgICAgZ2V0OiBuLFxuICAgICAgICAgIHNldDogblxuICAgICAgICB9O1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgIGlmIChpZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgICBvYmpbSUVfQVRUQUNIXSA9IF9hdHRhY2hfb3ZlcnJpZGU7XG4gICAgICAgICAgICBvYmpbSUVfREVUQUNIXSA9IF9kZXRhY2hfb3ZlcnJpZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3M2Nfb2xkX2F0dGFjaCkge1xuICAgICAgICAgICAgb2JqW1czQ19BVFRBQ0hdID0gX2F0dGFjaF9vdmVycmlkZTtcbiAgICAgICAgICAgIG9ialtXM0NfREVUQUNIXSA9IF9kZXRhY2hfb3ZlcnJpZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmpbREddKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvYmpbREddKE9OTE9BRCwgbik7XG4gICAgICAgICAgICAgIG9ialtEU10oT05MT0FELCBuKTtcbiAgICAgICAgICAgICAgb2JqW0RHXShPTlVOTE9BRCwgbik7XG4gICAgICAgICAgICAgIG9ialtEU10oT05VTkxPQUQsIG4pO1xuICAgICAgICAgICAgICBvYmpbREddKE9OTVNHLCBuKTtcbiAgICAgICAgICAgICAgb2JqW0RTXShPTk1TRywgbik7XG4gICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmV0ICYmIE9bRFBdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBPW0RQXShvYmosIE9OTE9BRCwgbm9iaik7XG4gICAgICAgICAgICAgIE9bRFBdKG9iaiwgT05VTkxPQUQsIG5vYmopO1xuICAgICAgICAgICAgICBPW0RQXShvYmosIE9OTVNHLCBub2JnKTtcbiAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBJbnRpYWxpemUgLyBzZXR1cCB0aGUgc2FmZWZyYW1lLCB0aGUgZW52aXJvbm1lbnQgYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGZvdW5kIHdpdGhpbiB0aGUgc2VyaWFsaXplZFxuICAgICAgd2luZG93Lm5hbWUgcHJvcGVydHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2NvbnN0cnVjdGlvblxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzXSBBbiBvcHRpb25hbCBvYmplY3QgdG8gcGFzcyBpbiBzdGF0dXMgLyBlcnJvciBpbmZvcm1hdGlvbiBpbnRvXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9jb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbihkZXRhaWxzKSB7XG4gICAgICAgIHZhciBjb250LCBjdXJfdGltZSwgZSwgZWwsIGd1aWRfdGltZSwgbm0sIHJldCwgdGVtcCwgdGltZV9kZWx0YTtcbiAgICAgICAgY29udCA9IGZhbHNlO1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICBlbCA9IHZvaWQgMDtcbiAgICAgICAgbm0gPSB2b2lkIDA7XG4gICAgICAgIHRlbXAgPSB2b2lkIDA7XG4gICAgICAgIGN1cl90aW1lID0gdm9pZCAwO1xuICAgICAgICBndWlkX3RpbWUgPSB2b2lkIDA7XG4gICAgICAgIHRpbWVfZGVsdGEgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGRldGFpbHMgPSAoZGV0YWlscyAmJiAoZGV0YWlscyBpbnN0YW5jZW9mIE9iamVjdCkgPyBkZXRhaWxzIDoge30pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5tID0gd2luLm5hbWU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW4ubmFtZSA9IFwiXCI7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgaWYgKCFubSkge1xuICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwMTtcbiAgICAgICAgICByZXR1cm4gY29udDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0b3AgPT09IHBhcikge1xuICAgICAgICAgICAgcmVuZGVyX3BhcmFtcyA9IFBhcmFtSGFzaChubSwgbnVsbCwgbnVsbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjdXJfdGltZSA9IGxhbmcudGltZSgpO1xuICAgICAgICAgICAgZ3VpZCA9IHJlbmRlcl9wYXJhbXMuZ3VpZDtcbiAgICAgICAgICAgIGd1aWRfdGltZSA9IF9jbnVtKGd1aWQucmVwbGFjZSgvW15fXSpfKFxcZCspX1xcZCtfXFxkKy9nLCBcIiQxXCIpLCAwKTtcbiAgICAgICAgICAgIHRpbWVfZGVsdGEgPSBjdXJfdGltZSAtIGd1aWRfdGltZTtcbiAgICAgICAgICAgIGNvbnQgPSBndWlkICYmIGd1aWRfdGltZSAmJiB0aW1lX2RlbHRhID4gMCAmJiB0aW1lX2RlbHRhIDwgR1VJRF9WQUxJRF9USU1FO1xuICAgICAgICAgICAgaWYgKHJlbmRlcl9wYXJhbXMubG9jKSB7XG4gICAgICAgICAgICAgIHJlbmRlcl9wYXJhbXMubG9jID0gdW5lc2NhcGUocmVuZGVyX3BhcmFtcy5sb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250KSB7XG4gICAgICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5zdGF0dXMgPSA1MDAuMTAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICByZW5kZXJfcGFyYW1zID0gZ3VpZCA9IG51bGw7XG4gICAgICAgICAgY29udCA9IGZhbHNlO1xuICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJfY29uZiA9IHJlbmRlcl9wYXJhbXMuY29uZjtcbiAgICAgICAgICAgIGZyYW1lX2lkID0gd2luLm5hbWUgPSByZW5kZXJfY29uZi5kZXN0O1xuICAgICAgICAgICAgcG9zX2lkID0gcmVuZGVyX2NvbmYuaWQ7XG4gICAgICAgICAgICBwb3NfbWV0YSA9IHJlbmRlcl9wYXJhbXMubWV0YTtcbiAgICAgICAgICAgIGhvc3RfY25hbWUgPSByZW5kZXJfcGFyYW1zLmhvc3Q7XG4gICAgICAgICAgICBnZW9tX2luZm8gPSByZW5kZXJfcGFyYW1zLmdlb207XG4gICAgICAgICAgICBjYW5fdXNlX2h0bWw1ID0gbGFuZy5jYm9vbChyZW5kZXJfcGFyYW1zLmh0bWw1KTtcbiAgICAgICAgICAgIHdpbl9oYXNfZm9jdXMgPSBsYW5nLmNib29sKHJlbmRlcl9wYXJhbXMuaGFzX2ZvY3VzKTtcbiAgICAgICAgICAgIHRlbXAgPSByZW5kZXJfY29uZi5iZztcbiAgICAgICAgICAgIGlmIChnZW9tX2luZm8pIHtcbiAgICAgICAgICAgICAgZ2VvbV9pbmZvID0gUGFyYW1IYXNoKF91ZShnZW9tX2luZm8pLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKCFnZW9tX2luZm8uc2VsZiB8fCAhZ2VvbV9pbmZvLmV4cCkge1xuICAgICAgICAgICAgICAgIGdlb21faW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdF9jbmFtZSkge1xuICAgICAgICAgICAgICBob3N0X2NuYW1lID0gZC5yZWZlcnJlcjtcbiAgICAgICAgICAgICAgaG9zdF9jbmFtZSA9IGhvc3RfY25hbWUuc3Vic3RyaW5nKDAsIGhvc3RfY25hbWUuaW5kZXhPZihcIi9cIiwgOSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXApIHtcbiAgICAgICAgICAgICAgX2NyZWF0ZV9zdHlsZXNoZWV0KF9jc3RyKFtcIiNzZl9ib2R5IHsgYmFja2dyb3VuZC1jb2xvcjogXCIsIHRlbXAsIFwiOyB9XCJdKSwgXCJzZl9iZ19jc3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wID0gcmVuZGVyX2NvbmYudGd0O1xuICAgICAgICAgICAgaWYgKHRlbXAgPT09IFwiX3NlbGZcIikge1xuICAgICAgICAgICAgICByZW5kZXJfY29uZi50Z3QgPSBcIl90b3BcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGVtcCkge1xuICAgICAgICAgICAgICByZW5kZXJfY29uZi50Z3QgPSBcIl90b3BcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wICE9PSBcIl90b3BcIikge1xuICAgICAgICAgICAgICB3aGlsZSAoX3B1cmdlKF90YWdzKFwiYmFzZVwiKVswXSkpIHtcbiAgICAgICAgICAgICAgICB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbCA9IGRvbS5tYWtlKFwiYmFzZVwiKTtcbiAgICAgICAgICAgIF9hdHRyKGVsLCBcInRhcmdldFwiLCB0ZW1wKTtcbiAgICAgICAgICAgIF9hcHBlbmQoX3RhZ3MoXCJoZWFkXCIpWzBdLCBlbCk7XG4gICAgICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgICBpZV9vbGRfYXR0YWNoID0gd2luW0lFX0FUVEFDSF07XG4gICAgICAgICAgICAgIGllX29sZF9kZXRhY2ggPSB3aW5bSUVfREVUQUNIXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHczY19vbGRfYXR0YWNoID0gd2luW1czQ19BVFRBQ0hdO1xuICAgICAgICAgICAgdzNjX29sZF9kZXRhY2ggPSB3aW5bVzNDX0RFVEFDSF07XG4gICAgICAgICAgICBfYXR0YWNoKHdpbiwgVU5MT0FELCBfaGFuZGxlX3VubG9hZCk7XG4gICAgICAgICAgICBfYXR0YWNoKHdpbiwgTE9BRCwgX2hhbmRsZV9sb2FkKTtcbiAgICAgICAgICAgIF9hdHRhY2god2luLCBNU0csIF9oYW5kbGVfbXNnKTtcbiAgICAgICAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzKHdpbik7XG4gICAgICAgICAgICBfc2V0dXBfd2luX2V2dF9wcm9wcyh3aW4uX19wcm90b19fKTtcbiAgICAgICAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzKHdpbi5XaW5kb3cgJiYgd2luLldpbmRvdy5wcm90b3R5cGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwNTtcbiAgICAgICAgICAgIHJlbmRlcl9wYXJhbXMgPSByZW5kZXJfY29uZiA9IGd1aWQgPSBudWxsO1xuICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcl9wYXJhbXMgPSBndWlkID0gbnVsbDtcbiAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICAgIF93cmFwaUZyYW1lID0gZnVuY3Rpb24oaHRtbCwgY2JOYW1lKSB7XG4gICAgICAgIHJldHVybiBcIjxpZnJhbWUgc3R5bGU9XFxcIndpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7XFxcIiBhbGxvd3RyYW5zcGFyZW5jeT1cXFwidHJ1ZVxcXCJcXG5zY3JvbGxpbmc9XFxcIm5vXFxcIiBtYXJnaW53aWR0aD1cXFwiMFxcXCIgbWFyZ2luaGVpZ2h0PVxcXCIwXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgb25sb2FkPSdcIiArIGNiTmFtZSArIFwiKCknPlxcbjxodG1sPjxoZWFkPjxiYXNlIHRhcmdldD1cXFwiX3RvcFxcXCI+PC9oZWFkPjxib2R5IHN0eWxlPVxcXCJtYXJnaW46IDA7IHBhZGRpbmc6IDBcXFwiPlxcbjxzY3JpcHQ+XFxuICAkYWQgPSB3aW5kb3cucGFyZW50LiRhZFxcbiAgJHNmID0gd2luZG93LnBhcmVudC4kc2ZcXG48L3NjcmlwdD5cXG4gIFwiICsgaHRtbCArIFwiXFxuPC9odG1sPlxcbjwvaWZyYW1lPlwiO1xuICAgICAgfTtcbiAgICAgIG9yaWdpbmFsV3JpdGUgPSBkb2N1bWVudC53cml0ZTtcblxuICAgICAgLypcbiAgICAgIFJlbmRlciB0aGUgSFRNTCBhbmQgQ1NTIGNvbnRlbnQgcGFzc2VkIGluIHRocm91Z2ggdGhlIHdpbmRvdy5uYW1lIG1lc3NhZ2UgdmlhIGEgZG9jdW1lbnQud3JpdGVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fcmVuZGVyXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9yZW5kZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2JOYW1lLCBjc3MsIGUsIGh0bWwsIG90aGVyQ2FsbGJhY2tBcHBsaWVkO1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjYk5hbWUgPSBsaWIubGFuZy5ndWlkKFwibG9hZF9jYlwiKTtcbiAgICAgICAgb3RoZXJDYWxsYmFja0FwcGxpZWQgPSBmYWxzZTtcbiAgICAgICAgd2luZG93W2NiTmFtZV0gPSBmdW5jdGlvbihmcm9tRnJhbWUpIHtcbiAgICAgICAgICByZXR1cm4gKHNmLmxpYi5sYW5nLndyYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZyb21GcmFtZSB8fCAhb3RoZXJDYWxsYmFja0FwcGxpZWQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2YsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nX21zZykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF9oYW5kbGVfbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVkKCk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKHRoaXMpLCAzMDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9oYW5kbGVfbG9hZCgpO1xuICAgICAgICAgICAgICAgIGxvYWRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvY3VtZW50LndyaXRlID0gb3JpZ2luYWxXcml0ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSB3aW5kb3dbY2JOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICB2YXIgZG9tRWxlbSwgaWZyYW1lLCBvbGRPbmxvYWQsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICAgIGlmICghKGhhc0xvYWRlZCB8fCBvdGhlckNhbGxiYWNrQXBwbGllZCkpIHtcbiAgICAgICAgICAgIGRvbUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZG9tRWxlbS5pbm5lckhUTUwgPSBcIl9cIiArIHN0cjtcbiAgICAgICAgICAgIF9yZWYgPSBkb21FbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaWZyYW1lXCIpO1xuICAgICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGlmcmFtZSA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgICBpZiAoX2NudW0oX2F0dHIoaWZyYW1lLCBcIndpZHRoXCIpLCAwKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBvdGhlckNhbGxiYWNrQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE9ubG9hZCA9IF9hdHRyKGlmcmFtZSwgXCJvbmxvYWRcIikpIHtcbiAgICAgICAgICAgICAgICAgIF9hdHRyKGlmcmFtZSwgXCJvbmxvYWRcIiwgXCJcIiArIGNiTmFtZSArIFwiKHRydWUpO1wiICsgb2xkT25sb2FkICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfYXR0cihpZnJhbWUsIFwib25sb2FkXCIsIFwiXCIgKyBjYk5hbWUgKyBcIih0cnVlKTtcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXJDYWxsYmFja0FwcGxpZWQpIHtcbiAgICAgICAgICAgICAgc3RyID0gZG9tRWxlbS5pbm5lckhUTUwuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxXcml0ZS5jYWxsKHRoaXMsIHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIGh0bWwgPSB2b2lkIDA7XG4gICAgICAgIGNzcyA9IHZvaWQgMDtcbiAgICAgICAgaXNBZFNob3duID0gdHJ1ZTtcbiAgICAgICAgY3NzID0gX2NzdHIocmVuZGVyX2NvbmYgJiYgcmVuZGVyX2NvbmYuY3NzKTtcbiAgICAgICAgaHRtbCA9IF9jc3RyKHJlbmRlcl9wYXJhbXMgJiYgcmVuZGVyX3BhcmFtcy5odG1sKTtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgIGNzcyA9IF91ZShjc3MpO1xuICAgICAgICAgIF9jcmVhdGVfc3R5bGVzaGVldChjc3MsIFwic2ZfY3VzdG9tX2Nzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgIGh0bWwgPSBfdWUoaHRtbCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9yZWF0dGFjaF9tZXNzYWdpbmcoKTtcbiAgICAgICAgICAgIF9yZXF1ZXN0ZWQoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LndyaXRlKGh0bWwgKyBcIjxzY3JcIiArIChcImlwdD4gXCIgKyBjYk5hbWUgKyBcIigpIDs8L3NjclwiKSArIFwiaXB0PlwiKTtcbiAgICAgICAgICAgIF9jaGVja19vcnBoYW5lZCgpO1xuICAgICAgICAgICAgX3Jlc2V0X2lubGluZV9oYW5kbGVycygpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIF9oYW5kbGVfZXJyKFwiRXJyb3Igd2hpbGUgcmVuZGVyaW5nIGNvbnRlbnQ6IFwiICsgZVtNU0ddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDYWxsIGludG8gdGhlIGZhbGxiYWNrIHgtbXNnaW5nIGxpYnJhcnkgY2xpZW50IGlmIHBvc3NpYmxlIHdoZW4gbm8gSFRNTDUgc3R5bGUgbWVzc2FnaW5nXG4gICAgICBleGlzdHNcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fY2FsbF9jbGllbnRfZmJcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBtZXRoTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBpbiB0aGUgbGlicmFyeSB0byBjYWxsXG4gICAgICBAcGFyYW0geyp9IFthcmcxXSBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gaGFuZCBpbnRvIHRoZSBsaWJyYXJ5XG4gICAgICBAcGFyYW0geyp9IFthcmcyXSBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gaGFuZCBpbnRvIHRoZSBsaWJyYXJ5XG4gICAgICAgKi9cbiAgICAgIF9jYWxsX2NsaWVudF9mYiA9IGZ1bmN0aW9uKG1ldGhOYW1lLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIHZhciBtc2dfY2xpZW50ZmI7XG4gICAgICAgIGlmIChtc2djbGllbnRfZmIpIHtcbiAgICAgICAgICBtc2dfY2xpZW50ZmIgPSBkb20ubXNnY2xpZW50X2ZiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRoTmFtZSAmJiBtc2djbGllbnRfZmIgJiYgbXNnY2xpZW50X2ZiW21ldGhOYW1lXSAmJiBtc2djbGllbnRfZmJbbWV0aE5hbWVdKGFyZzEsIGFyZzIpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFByb2Nlc3MgYSB2YWxpZGF0ZWQgbWVzc2FnZSB0byBub3RpZnkgdGhlIGNvbnRlbnRzIG9mIHRoZSBTYWZlRnJhbWUgb2Ygc3RhdGUgdXBkYXRlc1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9yZWNlaXZlX21zZ1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHskc2YubGliLmxhbmcuUGFyYW1IYXNofSBwYXJhbXMgVGhlIG1lc3NhZ2UgcGFyYW1ldGVyIGhhc2ggb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXMgb2NjdXJlZFxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IFtldnRdIFRoZSByYXcgRE9NIGV2ZW50IGZyb20gdGhlIHgtZG9tYWluIG1lc3NhZ2VcbiAgICAgIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBtZXNzYWdlIHJlY2VpdmVkIGNvdWxkIGJlIGhhbmRsZWRcbiAgICAgICAqL1xuICAgICAgX3JlY2VpdmVfbXNnID0gZnVuY3Rpb24ocGFyYW1zLCBldnQpIHtcbiAgICAgICAgdmFyIGNtZCwgZGF0YSwgZSwgZywgbXNnLCByZXQ7XG4gICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICBtc2cgPSB2b2lkIDA7XG4gICAgICAgIGNtZCA9IHZvaWQgMDtcbiAgICAgICAgZyA9IHZvaWQgMDtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgZyA9IHBhcmFtcy5nZW9tIHx8IFwiXCI7XG4gICAgICAgICAgY21kID0gcGFyYW1zLmNtZDtcbiAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgZ2VvbV9pbmZvID0gUGFyYW1IYXNoKF91ZShnKSwgbnVsbCwgbnVsbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEuY21kID0gY21kO1xuICAgICAgICBkYXRhLnZhbHVlID0gZGF0YS5pbmZvID0gcGFyYW1zICYmIHBhcmFtcy52YWx1ZTtcbiAgICAgICAgZGF0YS5yZWFzb24gPSBwYXJhbXMgJiYgcGFyYW1zLnJlYXNvbjtcbiAgICAgICAgaWYgKGNtZCA9PT0gTk9USUZZX0NPTExBUFNFRCkge1xuICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzX2V4cGFuZGVkKSB7XG4gICAgICAgICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICAgICAgICBpc19leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yY2VfY29sbGFwc2UgPSB0cnVlO1xuICAgICAgICAgICAgX2NvbGxhcHNlKCk7XG4gICAgICAgICAgICBmb3JjZV9jb2xsYXBzZSA9IGZhbHNlO1xuICAgICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfQ09MTEFQU0VEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSBOT1RJRllfQ09MTEFQU0UpIHtcbiAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIGlmIChpc19leHBhbmRlZCkge1xuICAgICAgICAgICAgcGVuZGluZ19tc2cgPSBudWxsO1xuICAgICAgICAgICAgaXNfZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX0NPTExBUFNFRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0VYUEFORCkge1xuICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICAgICAgICBpc19leHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9FWFBBTkQgKyBcImVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IE5PVElGWV9HRU9NX1VQREFURSkge1xuICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX0dFT01fVVBEQVRFKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IE5PVElGWV9GT0NVU19DSEFOR0UpIHtcbiAgICAgICAgICBkYXRhLmluZm8gPSBkYXRhLnZhbHVlID0gbGFuZy5jYm9vbChkYXRhLnZhbHVlKTtcbiAgICAgICAgICB3aW5faGFzX2ZvY3VzID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9GT0NVU19DSEFOR0UsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX1JFQURfQ09PS0lFKSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocGVuZGluZ19tc2cpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICAgIGRhdGEgPSBwYXJhbXMgJiYgcGFyYW1zLnZhbHVlO1xuICAgICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfUkVBRF9DT09LSUUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChbTk9USUZZX1dSSVRFX0NPT0tJRSwgTk9USUZZX0ZBSUxVUkUsIE5PVElGWV9DTElDS0VELCBOT1RJRllfVklFV0VELCBOT1RJRllfVU5WSUVXRUQsIE5PVElGWV9MT0FERUQsIE5PVElGWV9SRVFVRVNURUQsIE5PVElGWV9SRUxPQURdLmluZGV4T2YoY21kKSA+IC0xKSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocGVuZGluZ19tc2cpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhjbWQsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soY21kLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICAgIGNtZFJldHJpZXMgPSB7fTtcblxuICAgICAgLypcbiAgICAgIFNlbmQgYSBjb21tYW5kIG1lc3NhZ2UgdXAgdG8gdGhlIFNhZmVGcmFtZXMgcHVibGlzaGVyIC8gaG9zdCBjb2RlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3NlbmRfbXNnXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0ge1N0cmluZ30gc3RyIEFuIGVuY29kZWQgc3RyaW5nIChxdWVyeS1zdHJpbmcvJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCBmb3JtYXQpIHRoYXQgY29udGFpbnMgdGhlIGNvbW1hbmQgbWVzc2FnZSB0byBzZW5kXG4gICAgICBAcGFyYW0ge1N0cmluZ30gY21kIFRoZSBjb21tYW5kIHRvIGJlIHNlbnQgaXRzZWxmIChub3RlIHRoYXQgdGhpcyBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcHJlc2VudCBpbiB0aGUgMXN0IGFyZ3VtZW50KVxuICAgICAgICovXG4gICAgICBfc2VuZF9tc2cgPSBmdW5jdGlvbihzdHIsIGNtZCkge1xuICAgICAgICB2YXIgZSwgaWQsIHBhcmFtcywgc2VudCwgc2VudF90aW1lO1xuICAgICAgICBpZCA9IGxhbmcuZ3VpZChcInNmX3BuZF9jbWRcIik7XG4gICAgICAgIGZyYW1lX2lkID0gcmVuZGVyX3BhcmFtcy5kZXN0O1xuICAgICAgICBzZW50ID0gZmFsc2U7XG4gICAgICAgIHNlbnRfdGltZSA9IGxhbmcudGltZSgpO1xuICAgICAgICBwYXJhbXMgPSB2b2lkIDA7XG4gICAgICAgIGlmICghc3RyIHx8ICFjbWQgfHwgcGVuZGluZ19tc2cpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gUGFyYW1IYXNoKHtcbiAgICAgICAgICBtc2c6IHN0cixcbiAgICAgICAgICBpZDogZnJhbWVfaWQsXG4gICAgICAgICAgZ3VpZDogZ3VpZCxcbiAgICAgICAgICBjbWQ6IGNtZFxuICAgICAgICB9KTtcbiAgICAgICAgcGVuZGluZ19tc2cgPSB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHNlbnQ6IHNlbnRfdGltZSxcbiAgICAgICAgICBjbWQ6IGNtZFxuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocGVuZGluZ19tc2cgJiYgcGVuZGluZ19tc2cuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICBpZiAoY21kID09PSBFWFBBTkRfQ09NTUFORCB8fCBjbWQgPT09IFwiZXhwLXB1c2hcIikge1xuICAgICAgICAgICAgICBmb3JjZV9jb2xsYXBzZSA9IHRydWU7XG4gICAgICAgICAgICAgIF9jb2xsYXBzZSgpO1xuICAgICAgICAgICAgICBmb3JjZV9jb2xsYXBzZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfRkFJTFVSRSArIFwiOlwiICsgY21kICsgXCI6dGltZW91dFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWQgPSBzZW50ID0gc2VudF90aW1lID0gY21kID0gc3RyID0gcGVuZGluZ19tc2cgPSBwYXJhbXMgPSBudWxsO1xuICAgICAgICB9KSwgTUFYX01TR19XQUlUX1RJTUUpO1xuICAgICAgICBpZiAoY2FuX3VzZV9odG1sNSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0b3AucG9zdE1lc3NhZ2UocGFyYW1zLnRvU3RyaW5nKCksIChob3N0X2NuYW1lID09PSBcImZpbGVcIiB8fCBob3N0X2NuYW1lID09PSBcIlwiID8gXCIqXCIgOiBob3N0X2NuYW1lKSk7XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICBzZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2VudCkge1xuICAgICAgICAgIF9jYWxsX2NsaWVudF9mYihcInNlbmRcIiwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEZpcmUgYSBub3RpZmljYXRpb24gb2ZmIHRvIHRoZSBTYWZlRnJhbWUgY29udGVudHMgaWYgYSBjYWxsYmFjayBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2ZpcmVfc2FuZGJveF9jYWxsYmFja1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IG1zZyBUaGUgc3RhdHVzIHVwZGF0ZSAvIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAgQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAqL1xuICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayA9IGZ1bmN0aW9uKG1zZywgZGF0YSkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNhbmRib3hfY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2FuZGJveF9jYihtc2csIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFNldCB0aGUgYWxpZ25tZW50IG9mIG91ciBpbnRlcm5hbCBESVYgd2hlbmV2ZXIgZXhwYW5zaW9uIG9jY3VycyB1bmktZGlyZWN0aW9uYWx5XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3NldF9hbGlnbm1lbnRcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0geG4gV2hldGhlciBvciBub3QgaG9yaXpvbnRhbCBheGlzIGlzIGdyb3dpbmcgdG8gdGhlIGxlZnQgb3IgcmlnaHQgKHhuID09IHRydWUgPT0gbGVmdClcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0geW4gV2hldGhlciBvciBub3QgdmVydGljYWwgYXhpcyBpcyBncm93aW5nIHRvIHRoZSB0b3Agb3IgYm90dG9tICh5biA9PSB0cnVlID09IHRvcClcbiAgICAgICAqL1xuICAgICAgX3NldF9hbGlnbm1lbnQgPSBmdW5jdGlvbih4biwgeW4pIHtcbiAgICAgICAgdmFyIGZjRGl2LCBmY0RpdlN0eWxlLCBwcmVUeHQsIHhUeHQsIHlUeHQ7XG4gICAgICAgIGZjRGl2ID0gX2VsdChcInNmX2FsaWduXCIpO1xuICAgICAgICBmY0RpdlN0eWxlID0gZmNEaXYuc3R5bGU7XG4gICAgICAgIHhUeHQgPSB2b2lkIDA7XG4gICAgICAgIHlUeHQgPSB2b2lkIDA7XG4gICAgICAgIHByZVR4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7XCI7XG4gICAgICAgIGlmICh4bikge1xuICAgICAgICAgIHhUeHQgPSBcInJpZ2h0OjBweDtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4VHh0ID0gXCJsZWZ0OjBweDtcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeW4pIHtcbiAgICAgICAgICB5VHh0ID0gXCJib3R0b206MHB4O1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlUeHQgPSBcInRvcDowcHg7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZmNEaXZTdHlsZS5jc3NUZXh0ID0gcHJlVHh0ICsgeFR4dCArIHlUeHQ7XG4gICAgICAgIGZjRGl2ID0gZmNEaXZTdHlsZSA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNvbGxhcHNpbmcgdGhlIFNhZmVGcmFtZSwgd2hpY2ggY2hlY2tzIHRoYXQgdGhlcmUgaXNcbiAgICAgIG5vdCBzb21lIG90aGVyIHBlbmRpbmcgc3RhdGUgd2hpY2ggbWF5IGdldCBpbiB0aGUgd2F5XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuX2NvbGxhcHNlXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cbiAgICAgIF9jb2xsYXBzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWZvcmNlX2NvbGxhcHNlICYmICghaXNfcmVnaXN0ZXJlZCB8fCAhaXNfZXhwYW5kZWQgfHwgcGVuZGluZ19tc2cpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRfYWxpZ25tZW50KDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBfcmVhdHRhY2hfbWVzc2FnaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgaWVfb2xkX2RldGFjaChPTk1TRywgX2hhbmRsZV9tc2cpO1xuICAgICAgICAgIHJldHVybiBpZV9vbGRfYXR0YWNoKE9OTVNHLCBfaGFuZGxlX21zZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodzNjX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICB3M2Nfb2xkX2RldGFjaChNU0csIF9oYW5kbGVfbXNnKTtcbiAgICAgICAgICByZXR1cm4gdzNjX29sZF9hdHRhY2goTVNHLCBfaGFuZGxlX21zZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBJbnRpYWxpemUgdGhlIFNhZmVGcmFtZSBleHRlcm5hbCB2ZW5kb3IvY2xpZW50IEFQSSwgc28gdGhhdCBvdGhlciBmZWF0dXJlcyBtYXkgYmUgdXNlZFxuICAgICAgVGhpcyBtZXRob2QgTVVTVCBiZSBjYWxsZWQgcHJpb3IgdG8gdXNpbmcgYW55IG90aGVyIHJpY2gtbWVkaWEgZnVuY3Rpb25hbGl0eSAobGlrZSBleHBhbnNpb24pLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LnJlZ2lzdGVyXG4gICAgICBAcHVibGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBpbml0V2lkdGggVGhlIGluaXRpYWwgd2lkdGggKGluIHBpeGVscykgZXhwZWN0ZWQgb2YgdGhlIGNvbnRlbnQgd2l0aGluIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyXG4gICAgICBAcGFyYW0ge051bWJlcn0gaW5pdEhlaWdodCBUaGUgaW5pdGlhbCBoZWlnaHQgKGluIHBpeGVscykgZXhwZWN0ZWQgb2YgdGhlIGNvbnRlbnQgd2l0aGluIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbbm90aWZ5XSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY29udGVudCBjYW4gc3BlY2lmeSB0byBiZSBub3RpZmllZCBvZiBzdGF0dXMgdXBkYXRlc1xuICAgICAgICovXG4gICAgICByZWdpc3RlciA9IGZ1bmN0aW9uKGluaXRXaWR0aCwgaW5pdEhlaWdodCwgbm90aWZ5KSB7XG4gICAgICAgIGlmIChpc19yZWdpc3RlcmVkIHx8ICFndWlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluaXRXaWR0aCA9IF9jbnVtKGluaXRXaWR0aCwgMCwgMCk7XG4gICAgICAgIGluaXRIZWlnaHQgPSBfY251bShpbml0SGVpZ2h0LCAwLCAwKTtcbiAgICAgICAgaW5pdF93aWR0aCA9IGluaXRXaWR0aDtcbiAgICAgICAgaW5pdF9oZWlnaHQgPSBpbml0SGVpZ2h0O1xuICAgICAgICBpc19yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxhbmcuY2FsbGFibGUobm90aWZ5KSkge1xuICAgICAgICAgIHNhbmRib3hfY2IgPSBub3RpZnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FuZGJveF9jYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBNYWtlIGEgcmVxdWVzdCB0byBleHBhbmQgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgdG8gYSBjZXJ0YWluIHNpemUuIE5vdGUgdGhhdCB5b3UgbWF5IG9ubHkgY2FsbCAkc2YuZXh0LmV4cGFuZFxuICAgICAgdG8gZXhwYW5kIHRvIHRoZSBsYXJnZXN0IHNpemUgbmVlZGVkLCBmb2xsb3dlZCBieSBjYWxsaW5nIGNvbGxhcHNlIChhbmQgdGhlbiByZXBlYXQgdGhlIHNhbWUgcHJvY2VzcyBpZiBuZWVkZWQpLlxuICAgICAgVHdlZW5pbmcgb3IgYW5pbWF0aW9uIGRvbmUsIHNob3VsZCBiZSByZXNlcnZlZCBmb3IgeW91ciBvd24gY29udGVudCwgYW5kIHlvdSBjYW5ub3QgbWFrZSBtdWx0aXBsZSBjYWxscyB0byBleHBhbmRcbiAgICAgIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNvbGxhcHNlLlxuICAgICAgXG4gICAgICBOb3RlIHRoYXQgd2hlbiBzZXR0aW5nIHQsIGwsIGIsIGFuZCByIG9mZnNldCB2YWx1ZXMsIGV4cGFuc2lvbiB3aWxsIG5vdCBjYXVzZSB0aGUgY29udGVudCBpbnNpZGUgdGhlIFNhZmVGcmFtZVxuICAgICAgdG8gaG9sZCBpdCdzIGN1cnJlbnQgYWxpZ25tZW50LCB3aGVyZWFzIHVzaW5nIGR4L2R5IG9yIG9ubHkgc2V0dGluZyBwYXJ0aWFsIG9mZmZzZXRzIChlLmcge3Q6MTAwLGw6MTAwfSA9PSAgZHg6LTEwMCxkeTotMTAwKSB3aWxsIGNhdXNlIGV4cGFuc2lvbiB0b1xuICAgICAgaG9sZCBpdCdzIGN1cnJlbnQgYWxpZ25tZW50LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LmV4cGFuZFxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge051bWJlcnxPYmplY3R9IGRlbHRhWG9yRGVzYyBJZiBhIG51bWJlciBpcyBzcGVjaWZlZCwgU2FmZUZyYW1lIHdpbGwgZ3JvdyBpbiBzaXplIGJ5IHRoaXMgYW1vdW50IGluIHBpeGVscyBhbG9uZyB0aGUgaG9yaXpvbnRhbCBheGlzLiBTcGVjaWZpeSBhIG5lZ2F0aXZlIHZhbHVlIHRvIGdyb3cgdG8gdGhlIGxlZnQsIGFuZCBhIHBvc3RpdmUgdmFsdWUgdG8gZ3JvdyB0byB0aGUgcmlnaHQuIDxiciAvPlxuICAgICAgSWYgYW4gb2JqZWN0IGlzIHNwZWNpZmllZCwgaXQgc2hvdWxkIGNvbnRhaW4gXCJ0XCIsXCJsXCIsXCJyXCIsXCJiXCIgcHJvcGVydGllcyAodG9wLGxlZnQsYm90dG9tLHJpZ2h0KSBmb3IgdGhlIGFtb3VudCBpbiBwaXhlbHMgdG8gZ3JvdyB0aGUgY29udGFpbmVyIGluIGVhY2ggZGltZW5zaW9uXG4gICAgICBAcGFyYW0ge051bWJlcn0gZGVsdGFYb3JEZXNjLnQgU3BlY2lmaWVzIHRvIHNoaWZ0IHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgYnkgdGhlIG51bWJlciBvZiBwaXhlbHMgc3BlY2lmaWVkLCByZWxhdGl2ZSB0byBvcmlnaW5hbCBsb2NhdGlvbiAobmVnYXRpdmUgdmFsdWVzIG5vdCBhbGxvd2VkKS5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhvckRlc2MubCBTcGVjaWZpZXMgdG8gc2hpZnQgdGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgYnkgdGhlIG51bWJlciBvZiBwaXhlbHMgc3BlY2lmaWVkLCByZWxhdGl2ZSB0byBvcmlnaW5hbCBsb2NhdGlvbiAobmVnYXRpdmUgdmFsdWVzIG5vdCBhbGxvd2VkKS5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhvckRlc2MuYiBTcGVjaWZpZXMgdG8gc2hpZnQgdGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBieSB0aGUgbnVtYmVyIG9mIHBpeGVscyBzcGVjaWZpZWQsIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiAobmVnYXRpdmUgdmFsdWVzIG5vdCBhbGxvd2VkKS5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhvckRlc2MuciBTcGVjaWZpZXMgdG8gc2hpZnQgdGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgYnkgdGhlIG51bWJlciBvZiBwaXhlbHMgc3BlY2lmaWVkLCByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgbG9jYXRpb24gKG5lZ2F0aXZlIHZhbHVlcyBub3QgYWxsb3dlZCkuXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59ZGVsdGFYb3JEZXNjLnB1c2ggIFdoZW4gZXhwYW5kaW5nLCBwdXNoIG90aGVyIHBhZ2UgY29udGVudCByYXRoZXIgdGhhbiBkb2luZyBhbiBvdmVybGF5LiAgTm90ZSB0aGF0IHNldHRpbmcgdGhpcyB2YWx1ZSB0byB0cnVlIHdpbGwgb25seSB3b3JrIGlmIHRoZSBwdWJsaXNoZXIgLyBob3N0IGV4cGxpY2l0bHkgYWxsb3dzIHB1c2ggZXhwYW5zaW9uXG4gICAgICBDaGVjayAkc2YuZXh0LnN1cHBvcnRzKFwiZXhwLXB1c2hcIiksIGFoZWFkIG9mIHRpbWUgdG8gdmVyaWZ5XG4gICAgICBcbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVkgSWYgYSBudW1iZXIgaXMgc3BlY2lmZWQsIFNhZmVGcmFtZSB3aWxsIGdyb3cgaW4gc2l6ZSBieSB0aGlzIGFtb3VudCBpbiBwaXhlbHMgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMuIFNwZWNpZml5IGEgbmVnYXRpdmUgdmFsdWUgdG8gZ3JvdyB0byB0aGUgdG9wLCBhbmQgYSBwb3N0aXZlIHZhbHVlIHRvIGdyb3cgdG8gdGhlIGJvdHRvbS4gPGJyIC8+XG4gICAgICBOb3RlIHRoYXQgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIGlmIGRlbHRhWG9yRGVzYyBpcyBwYXNzZWQgaW4gYXMgYW4gb2JqZWN0LlxuICAgICAgXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IHB1c2ggV2hlbiBleHBhbmRpbmcsIHB1c2ggb3RoZXIgcGFnZSBjb250ZW50IHJhdGhlciB0aGFuIGRvaW5nIGFuIG92ZXJsYXkuICBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIHZhbHVlIHRvIHRydWUgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIHB1Ymxpc2hlciAvIGhvc3QgZXhwbGljaXRseSBhbGxvd3MgcHVzaCBleHBhbnNpb25cbiAgICAgIENoZWNrICRzZi5leHQuc3VwcG9ydHMoXCJleHAtcHVzaFwiKSwgYWhlYWQgb2YgdGltZSB0byB2ZXJpZnlcbiAgICAgIFxuICAgICAgXG4gICAgICBAcmV0dXJuIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIHRoZSByZXF1ZXN0IHRvIGV4cGFuZCB0aGUgY29udGFpbmVyIHdhcyBzZW50LiBUaGlzIGRvZXMgbm90IG1lYW4gdGhhdCBleHBhbnNpb24gaXMgY29tcGxldGUgYXMgZXhwYW5zaW9uIGlzIGFuIGFzeW5jaHJvbm91cyBwcm9jZXNzLiBQYXNzIGluIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gJHNmLmV4dC5yZWdpc3RlciB0byBnZXQgc3RhdHVzIHVwZGF0ZXMuXG4gICAgICAgKi9cbiAgICAgIGV4cGFuZCA9IGZ1bmN0aW9uKGRlbHRhWG9yRGVzYywgZGVsdGFZLCBwKSB7XG4gICAgICAgIHZhciBhbGlnbl9idWZmZXIsIGFsaWduX2VsLCBhbGlnbl9lbF9zdCwgYiwgY21kX25tLCBjbWRfc3RyLCBkb0FsaWduLCBkeCwgZHksIGwsIHIsIHQsIHhuLCB5bjtcbiAgICAgICAgeG4gPSBmYWxzZTtcbiAgICAgICAgeW4gPSBmYWxzZTtcbiAgICAgICAgZG9BbGlnbiA9IGZhbHNlO1xuICAgICAgICBjbWRfbm0gPSAocCA/IFwiZXhwLXB1c2hcIiA6IEVYUEFORF9DT01NQU5EKTtcbiAgICAgICAgY21kX3N0ciA9IFtcImNtZD1cIiwgY21kX25tLCBcIiZwb3M9XCIsIHBvc19pZF07XG4gICAgICAgIGR4ID0gMDtcbiAgICAgICAgZHkgPSAwO1xuICAgICAgICByID0gdm9pZCAwO1xuICAgICAgICBiID0gdm9pZCAwO1xuICAgICAgICB0ID0gdm9pZCAwO1xuICAgICAgICBsID0gdm9pZCAwO1xuICAgICAgICBhbGlnbl9lbCA9IHZvaWQgMDtcbiAgICAgICAgYWxpZ25fZWxfc3QgPSB2b2lkIDA7XG4gICAgICAgIGFsaWduX2J1ZmZlciA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFpc19yZWdpc3RlcmVkIHx8IHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwICYmICFzdXBwb3J0cyhcImV4cC1wdXNoXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YVhvckRlc2MgJiYgdHlwZW9mIGRlbHRhWG9yRGVzYyA9PT0gT0JKKSB7XG4gICAgICAgICAgciA9IF9jbnVtKGRlbHRhWG9yRGVzYy5yLCAwLCAwKTtcbiAgICAgICAgICBiID0gX2NudW0oZGVsdGFYb3JEZXNjLmIsIDAsIDApO1xuICAgICAgICAgIHQgPSBfY251bShkZWx0YVhvckRlc2MudCwgMCwgMCk7XG4gICAgICAgICAgbCA9IF9jbnVtKGRlbHRhWG9yRGVzYy5sLCAwLCAwKTtcbiAgICAgICAgICBpZiAoZGVsdGFYb3JEZXNjLnB1c2gpIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydHMoXCJleHAtcHVzaFwiKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbWRfbm0gPSBcImV4cC1wdXNoXCI7XG4gICAgICAgICAgICBjbWRfc3RyWzFdID0gY21kX25tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXIgJiYgbCkge1xuICAgICAgICAgICAgeG4gPSB0cnVlO1xuICAgICAgICAgICAgZHggPSAtMSAqIGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyICYmICFsKSB7XG4gICAgICAgICAgICBkeCA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYiAmJiB0KSB7XG4gICAgICAgICAgICB5biA9IHRydWU7XG4gICAgICAgICAgICBkeSA9IC0xICogdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGIgJiYgIXQpIHtcbiAgICAgICAgICAgIGR5ID0gYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCh0ICYmIGIpIHx8IChsICYmIHIpKSB7XG4gICAgICAgICAgICBkb0FsaWduID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvQWxpZ24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9BbGlnbikge1xuICAgICAgICAgICAgX3NldF9hbGlnbm1lbnQoeG4sIHluKTtcbiAgICAgICAgICAgIGNtZF9zdHIucHVzaChcIiZkeD1cIiwgZHgsIFwiJmR5PVwiLCBkeSk7XG4gICAgICAgICAgICBfc2VuZF9tc2coX2NzdHIoY21kX3N0ciksIGNtZF9ubSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsaWduX2VsID0gX2VsdChcInNmX2FsaWduXCIpO1xuICAgICAgICAgICAgYWxpZ25fZWxfc3QgPSBhbGlnbl9lbCAmJiBhbGlnbl9lbC5zdHlsZTtcbiAgICAgICAgICAgIGFsaWduX2J1ZmZlciA9IFtcInBvc2l0aW9uOmFic29sdXRlO1wiXTtcbiAgICAgICAgICAgIGlmICh0ICYmIGIpIHtcbiAgICAgICAgICAgICAgYWxpZ25fYnVmZmVyLnB1c2goXCJ0b3A6XCIsIHQsIFwicHg7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0KSB7XG4gICAgICAgICAgICAgIGFsaWduX2J1ZmZlci5wdXNoKFwiYm90dG9tOjBweDtcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgIGFsaWduX2J1ZmZlci5wdXNoKFwidG9wOjBweDtcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsICYmIHIpIHtcbiAgICAgICAgICAgICAgYWxpZ25fYnVmZmVyLnB1c2goXCJsZWZ0OlwiLCBsLCBcInB4O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobCkge1xuICAgICAgICAgICAgICBhbGlnbl9idWZmZXIucHVzaChcInJpZ2h0OjBweDtcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgIGFsaWduX2J1ZmZlci5wdXNoKFwibGVmdDowcHg7XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ25fZWxfc3QpIHtcbiAgICAgICAgICAgICAgYWxpZ25fZWxfc3QuY3NzVGV4dCA9IF9jc3RyKGFsaWduX2J1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbWRfc3RyLnB1c2goXCImZXhwX29iaj1cIiwgZXNjYXBlKFBhcmFtSGFzaChkZWx0YVhvckRlc2MpKSk7XG4gICAgICAgICAgICBfc2VuZF9tc2coX2NzdHIoY21kX3N0ciksIGNtZF9ubSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWG9yRGVzYyA9IF9jbnVtKGRlbHRhWG9yRGVzYywgMCk7XG4gICAgICAgICAgZGVsdGFZID0gX2NudW0oZGVsdGFZLCAwKTtcbiAgICAgICAgICBpZiAoZGVsdGFYb3JEZXNjIDw9IDAgJiYgZGVsdGFZIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgeG4gPSBkZWx0YVhvckRlc2MgPD0gMDtcbiAgICAgICAgICB5biA9IGRlbHRhWSA8PSAwO1xuICAgICAgICAgIF9zZXRfYWxpZ25tZW50KHhuLCB5bik7XG4gICAgICAgICAgY21kX3N0ci5wdXNoKFwiJmR4PVwiLCBkZWx0YVhvckRlc2MsIFwiJmR5PVwiLCBkZWx0YVkpO1xuICAgICAgICAgIF9zZW5kX21zZyhfY3N0cihjbWRfc3RyKSwgY21kX25tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDb2xsYXBzZSB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBhZnRlciBoYXZpbmcgY2FsbGVkIHRvIGV4cGFuZC4gSWYgbm8gcHJldmlvdXMgY2FsbCB0byBleHBhbmQgaGFzIGJlZW4gbWFkZSwgdGhpcyBjYWxsIHdpbGwgZG8gbm90aGluZy5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5jb2xsYXBzZVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGNvbGxhcHNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfY29sbGFwc2UoKSkge1xuICAgICAgICAgIF9zZW5kX21zZyhfY3N0cihbXCJjbWQ9XCIsIENPTExBUFNFX0NPTU1BTkQsIFwiJnBvcz1cIiwgcG9zX2lkXSksIENPTExBUFNFX0NPTU1BTkQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kX2NtZChOT1RJRllfQ0xJQ0tFRCk7XG4gICAgICB9O1xuICAgICAgdmlld2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VuZF9jbWQoTk9USUZZX1ZJRVdFRCk7XG4gICAgICB9O1xuICAgICAgbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VuZF9jbWQoTk9USUZZX0xPQURFRCk7XG4gICAgICB9O1xuICAgICAgdW52aWV3ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kX2NtZChOT1RJRllfVU5WSUVXRUQpO1xuICAgICAgfTtcbiAgICAgIHJlbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlbmRfY21kKE5PVElGWV9SRUxPQUQpO1xuICAgICAgfTtcbiAgICAgIF9yZXF1ZXN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfUkVRVUVTVEVEKTtcbiAgICAgICAgcmV0dXJuIF9zZW5kX2NtZChOT1RJRllfUkVRVUVTVEVEKTtcbiAgICAgIH07XG4gICAgICBfc2VuZF9jbWQgPSBmdW5jdGlvbihjbWQpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kX21zZyhfY3N0cihbXCJjbWQ9XCIsIGNtZCwgXCImcG9zPVwiLCBwb3NfaWRdKSwgY21kKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm4gZ2VvbWV0cmljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGFuZCBpdCdzIHN0YXR1cyB3aXRoaW4gYSBwYWdlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuZ2VvbVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcmV0dXJuIHtPYmplY3R9IGdlb21faW5mb1xuICAgICAgICovXG4gICAgICBnZW9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZW9tX2luZm87XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJuIG1ldGEtZGF0YSBpbmZvcm1hdGlvbiB0aGF0IG1heSBoYXZlIGJlZW4gc3BlY2lmaWVkIGJ5IHRoZSBwdWJsaXNoZXIgLyBob3N0LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0Lm1ldGFcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIHRoZSBrZXkgbmFtZSBvZiB0aGUgbWV0YS1kYXRhIHZhbHVlIHRvIGJlIHJldHJpZXZlZFxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtvd25lcl9rZXldIHRoZSBzdXBlciBrZXkgbmFtZSBvZiB0aGUgZGF0YSB0byBiZSByZXRyaWV2ZWRcbiAgICAgIEByZXR1cm4ge1N0cmluZ30gVGhlIHZhbHVlIG9mIHNvbWUgbWV0YS1kYXRhIHRoYXQgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIHB1Ymxpc2hlciAvIGhvc3Qgb3IgXCJcIi5cbiAgICAgICAqL1xuICAgICAgbWV0YSA9IGZ1bmN0aW9uKHByb3BOYW1lLCBvd25lcl9rZXkpIHtcbiAgICAgICAgdmFyIHJldCwgc2hhcmVkO1xuICAgICAgICByZXQgPSBcIlwiO1xuICAgICAgICBzaGFyZWQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChwb3NfbWV0YSkge1xuICAgICAgICAgIGlmIChvd25lcl9rZXkpIHtcbiAgICAgICAgICAgIGlmIChvd25lcl9rZXkgaW4gcG9zX21ldGEpIHtcbiAgICAgICAgICAgICAgcmV0ID0gX2NzdHIocG9zX21ldGFbb3duZXJfa2V5XVtwcm9wTmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHBvc19tZXRhLm5vbl9zaGFyZWQgJiYgb3duZXJfa2V5IGluIHBvc19tZXRhLm5vbl9zaGFyZWQpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBfY3N0cihwb3NfbWV0YS5ub25fc2hhcmVkW293bmVyX2tleV1bcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFyZWQgPSBwb3NfbWV0YS5zaGFyZWQ7XG4gICAgICAgICAgICBpZiAoc2hhcmVkICYmIHR5cGVvZiBzaGFyZWQgPT09IE9CSikge1xuICAgICAgICAgICAgICByZXQgPSBfY3N0cihzaGFyZWRbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgICBkZWxldGVNZXRhID0gZnVuY3Rpb24ocHJvcE5hbWUsIG93bmVyX2tleSkge1xuICAgICAgICB2YXIgc2hhcmVkO1xuICAgICAgICBzaGFyZWQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChwb3NfbWV0YSkge1xuICAgICAgICAgIGlmIChvd25lcl9rZXkpIHtcbiAgICAgICAgICAgIGlmIChvd25lcl9rZXkgaW4gcG9zX21ldGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBwb3NfbWV0YVtvd25lcl9rZXldW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwb3NfbWV0YS5ub25fc2hhcmVkICYmIG93bmVyX2tleSBpbiBwb3NfbWV0YS5ub25fc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBwb3NfbWV0YS5ub25fc2hhcmVkW293bmVyX2tleV1bcHJvcE5hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlZCA9IHBvc19tZXRhLnNoYXJlZDtcbiAgICAgICAgICAgIGlmIChzaGFyZWQgJiYgdHlwZW9mIHNoYXJlZCA9PT0gT0JKKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgc2hhcmVkW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm4gdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyLCBpbiBjYXNlcyB3aGVyZVxuICAgICAgYSBjb21tYW5kIG1heSBiZSBwZW5kaW5nLiBJZiBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgKFwiXCIpIGNvbnRhaW5lciBpcyBpZGxlLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LnN0YXR1c1xuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9IG9mIGFueSBwZW5kaW5nIHN0YXR1cywgb3RoZXJ3aXNlIGVtcHR5IHN0cmluZy5cbiAgICAgICAqL1xuICAgICAgc3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwZW5kaW5nX21zZykge1xuICAgICAgICAgIGlmIChwZW5kaW5nX21zZy5jbWQgPT09IEVYUEFORF9DT01NQU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gU1RBVFVTX0VYUEFORElORztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdfbXNnLmNtZCA9PT0gQ09MTEFQU0VfQ09NTUFORCkge1xuICAgICAgICAgICAgICByZXR1cm4gU1RBVFVTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVFVTX0VYUEFOREVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBTVEFUVVNfQ09MTEFQU0VEO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmVxdWVzdHMgdGhlIGhvc3QgcmVhZCBvciB3cml0ZSBhIGNvb2tpZSB0byB0aGUgaG9zdCBkb21haW4uXG4gICAgICBUaGUgaG9zdCBkb21haW4gbXVzdCBncmFudCBwZXJtaXNzaW9uIGZvciB0aGUgY29va2llIHRvIGJlIHdyaXR0ZW4uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuY29va2llXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbY29va2llTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0byBzZXQgb3IgcmVhZFxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtjb29raWVEYXRhXSBBbiBvYmplY3QgaGFzaCBjb250YWluaW5nIHRoZSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgZXhwaXJlc1xuICAgICAgQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBjb29raWUgPSBmdW5jdGlvbihjb29raWVOYW1lLCBjb29raWVEYXRhKSB7XG4gICAgICAgIHZhciBjbWRfbm0sIGNtZF9zdHIsIGlzUmVhZDtcbiAgICAgICAgaXNSZWFkID0gIShjb29raWVEYXRhICE9IG51bGwpO1xuICAgICAgICBjbWRfbm0gPSAoaXNSZWFkID8gXCJyZWFkLWNvb2tpZVwiIDogXCJ3cml0ZS1jb29raWVcIik7XG4gICAgICAgIGNtZF9zdHIgPSBbXCJjbWQ9XCIsIGNtZF9ubSwgXCImcG9zPVwiLCBwb3NfaWQsIFwiJmNvb2tpZT1cIiwgY29va2llTmFtZV07XG4gICAgICAgIGlmICghaXNSZWFkKSB7XG4gICAgICAgICAgY21kX3N0ci5wdXNoKFwiJnZhbHVlPVwiKTtcbiAgICAgICAgICBjbWRfc3RyLnB1c2goY29va2llRGF0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3NlbmRfbXNnKF9jc3RyKGNtZF9zdHIpLCBjbWRfbm0pO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBob3N0XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQubWVzc2FnZVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIG1lc3NhZ2UgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIF9zZW5kX21zZyhfY3N0cihbXCJjbWQ9XCIsIFwibXNnXCIsIFwiJnBvcz1cIiwgcG9zX2lkLCBcIiZtc2c9XCIsIGNvbnRlbnRdKSwgXCJtc2dcIik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJuIHRoZSBwZXJjZW50YWdlIHRoYXQgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgaXMgdmlld2FibGUgd2l0aGluIHRoZSBicm93c2VyIHdpbmRvd1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LmluVmlld1BlcmNlbnRhZ2VcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBpblZpZXdQZXJjZW50YWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdiwgdHY7XG4gICAgICAgIGl2ID0gX2NudW0oZ2VvbV9pbmZvICYmIGdlb21faW5mby5zZWxmICYmIGdlb21faW5mby5zZWxmLml2LCAtMSwgMCk7XG4gICAgICAgIHR2ID0gdm9pZCAwO1xuICAgICAgICBpZiAoaXYgPj0gMCkge1xuICAgICAgICAgIHR2ID0gTWF0aC5mbG9vcihpdiAqIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR2O1xuICAgICAgfTtcbiAgICAgIHdpbkhhc0ZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5faGFzX2ZvY3VzO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybiB3aGV0aGVyIG9yIG5vdCBhIHBhcnRpY3VsYXIgZmVhdHVyZSBpcyBzdXBwb3J0ZWQsIG9yIGFuIG9iamVjdCBjb250YWluaW5nXG4gICAgICBrZXkvdmFsdWUgcGFpcnMgZGVub3RpbmcgYWxsIGZlYXR1cmVzIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBzdXBwb3J0ZWRcbiAgICAgIFxuICAgICAgQnkgZGVmYXVsdCBTYWZlRnJhbWVzIHZlcnNpb24gMSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIGZlYXR1cmU6XG4gICAgICBcbiAgICAgIFwiZXhwLW92clwiOiBFeHBhbnNpb24gb2YgdGhlIGNvbnRhaW5lciBieSBvdmVybGF5aW5nIG9uIHRvcCBvZiBvdGhlciBjb250ZW50XG4gICAgICBcbiAgICAgIExhdGVyIGluIG90aGVyIHZlcnNpb25zIHRoZXJlIGFyZSBleHBleHRlZCB0byBiZSBtb3JlIGZlYXR1cmUgd2l0aCB0aGVpciBvd25cbiAgICAgIHN0cmluZyBuYW1lLCB0aGF0IGNhbiBiZSBjaGVja2VkIGJ5IHRoZSBjb250ZW50IGluIHRoZSBTYWZlRnJhbWUsIHNvIHRoYXRcbiAgICAgIGl0IGtub3dzIHdoYXQgdGhpbmdzIGNhbiBiZSBkb25lLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LnN1cHBvcnRzXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBba2V5XSBJZiBzcGVjaWZlZCwgY2hlY2tzIHRvIHNlZSBpZiB0aGF0IHNwZWNpZmljIGZlYXR1cmUgaGFzIGJlZW4gZW5hYmxlZFxuICAgICAgQHJldHVybiB7Qm9vbGVhbnxPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHN1cHBvcnRzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBjb25mLCBzdXA7XG4gICAgICAgIGNvbmYgPSByZW5kZXJfcGFyYW1zLmNvbmY7XG4gICAgICAgIHN1cCA9IChjb25mICYmIGNvbmYuc3VwcG9ydHMpIHx8IGZhbHNlO1xuICAgICAgICBpZiAoc3VwKSB7XG4gICAgICAgICAga2V5ID0gX2NzdHIoa2V5KTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBzdXAgPSBzdXBba2V5XSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdXAgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgIHN1cCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXAgPSBsYW5nLm1peCh7fSwgc3VwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cDtcbiAgICAgIH07XG4gICAgICByZW5kZXIgPSBmdW5jdGlvbihzaG93QWQsIGNiKSB7XG4gICAgICAgIHZhciBlcnJfaW5mbztcbiAgICAgICAgZXJyX2luZm8gPSB7fTtcbiAgICAgICAgaWYgKF9jb25zdHJ1Y3Rpb24oZXJyX2luZm8pKSB7XG4gICAgICAgICAgaWYgKHNob3dBZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXIoY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNob3dBZCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmICghaXNBZFNob3duKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZW5kZXIoY2IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYWRTaG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNBZFNob3duO1xuICAgICAgfTtcbiAgICAgIGxhbmcubWl4KHNmLmV4dCwge1xuICAgICAgICByZWdpc3RlcjogcmVnaXN0ZXIsXG4gICAgICAgIGV4cGFuZDogZXhwYW5kLFxuICAgICAgICBjb2xsYXBzZTogY29sbGFwc2UsXG4gICAgICAgIGdlb206IGdlb20sXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIGRlbGV0ZU1ldGE6IGRlbGV0ZU1ldGEsXG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBzdXBwb3J0czogc3VwcG9ydHMsXG4gICAgICAgIGNvb2tpZTogY29va2llLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBpblZpZXdQZXJjZW50YWdlOiBpblZpZXdQZXJjZW50YWdlLFxuICAgICAgICB3aW5IYXNGb2N1czogd2luSGFzRm9jdXMsXG4gICAgICAgIGNsaWNrOiBjbGljayxcbiAgICAgICAgdmlld2VkOiB2aWV3ZWQsXG4gICAgICAgIHVudmlld2VkOiB1bnZpZXdlZCxcbiAgICAgICAgc2hvd0FkOiBzaG93QWQsXG4gICAgICAgIGFkU2hvd246IGFkU2hvd24sXG4gICAgICAgIHJlbG9hZDogcmVsb2FkXG4gICAgICB9KTtcbiAgICAgIGlmICghaXNFeHRlcm5hbCkge1xuICAgICAgICB3aW5kb3cuJHNmID0gc2Y7XG4gICAgICAgIHJlbmRlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LiRzZiA9IHNmO1xuICAgICAgICBzZi5leHQucmVuZGVyID0gcmVuZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNmO1xuICAgIH0pKHdpbmRvdywgc2YpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tLCBlbnYsIGxhbmcsIGxvZ2dlcjtcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG4gIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24obGFuZywgZW52LCBkb20sIGxvZ2dlcikge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXI6IFwiMS0xLTBcIixcbiAgICAgIHNwZWNWZXJzaW9uOiBcIjEuMVwiLFxuICAgICAgbGliOiB7XG4gICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgIGRvbTogZG9tLFxuICAgICAgICBsb2dnZXI6IGxvZ2dlclxuICAgICAgfSxcbiAgICAgIGVudjogZW52LFxuICAgICAgaG9zdDoge30sXG4gICAgICBleHQ6IHt9LFxuICAgICAgaW5mbzoge1xuICAgICAgICBlcnJzOiBbXSxcbiAgICAgICAgbGlzdDogW11cbiAgICAgIH1cbiAgICB9O1xuICB9KShsYW5nLCBlbnYsIGRvbSwgbG9nZ2VyKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGVudiwgbGFuZztcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3csIGxhbmcsIGVudikge1xuICAgIHZhciBCTEFOS19VUkwsIEVWVF9DTkNMX01FVEhPRFMsIEdDLCBJRV9HQ19JTlRFUlZBTCwgSUZSQU1FLCBhcHBlbmQsIGF0dGFjaCwgYXR0ciwgY2xvbmVfaWZyYW1lLCBjc3MsIGRldGFjaCwgZG9jLCBkb20sIGRvbV9pc19yZWFkeSwgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSwgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50LCBkb21fcmVhZHlfY2hrX21heF90cmllcywgZG9tX3JlYWR5X2Noa190aW1lcl9pZCwgZG9tX3JlYWR5X2Noa190cmllcywgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwsIGVsdCwgZXZ0Q25jbCwgZXZ0VGd0LCBldnRfdGd0X3Byb3BfYSwgZXZ0X3RndF9wcm9wX2IsIGdjLCBnY190aW1lcl9pZCwgaWVfYXR0YWNoLCBpZV9kZXRhY2gsIGlmcmFtZV9jYnNfYXR0YWNoZWQsIGlmcmFtZV9tc2dfaG9zdF9saWIsIGlmcmFtZV9uZXh0X2lkLCBpZnJhbWVfdmlldywgaXNJRSwgbWFrZV9lbGVtZW50LCBtYWtlX2lmcmFtZSwgcGFyLCBwdXJnZSwgcmVhZHksIHJlcGxhY2VfaWZyYW1lLCB0YWdOYW1lLCB0YWdzLCB0aGVEb2N1bWVudCwgdXNlT2xkU3R5bGVBdHRyTWV0aG9kcywgdXNlX2F0dGFjaCwgdXNlX2RldGFjaCwgdXNlX2llX29sZF9hdHRhY2gsIHZpZXcsIHczY19hdHRhY2gsIHczY19kZXRhY2gsIHdhaXQsIHdpbiwgX2JpbmRfaWZyYW1lX29ubG9hZCwgX2J5SUQsIF9jYWxsX3htc2dfaG9zdCwgX2NhbGxhYmxlLCBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2ssIF9jbG9uZV9pZnJhbWUsIF9jc3RyLCBfZW52LCBfaGFuZGxlX2RvbV9sb2FkX2V2dCwgX2xhbmcsIF9yZWFkeV9zdGF0ZV9jaGVjaywgX3VuYmluZF9pZnJhbWVfb25sb2FkO1xuICAgIGRvbSA9IHt9O1xuICAgIF9sYW5nID0gbGFuZztcbiAgICBfZW52ID0gZW52O1xuICAgIHdpbiA9IHdpbmRvdztcbiAgICBJRlJBTUUgPSBcImlmcmFtZVwiO1xuICAgIEdDID0gXCJDb2xsZWN0R2FyYmFnZVwiO1xuICAgIGllX2F0dGFjaCA9IFwiYXR0YWNoRXZlbnRcIjtcbiAgICB3M2NfYXR0YWNoID0gXCJhZGRFdmVudExpc3RlbmVyXCI7XG4gICAgaWVfZGV0YWNoID0gXCJkZXRhY2hFdmVudFwiO1xuICAgIHczY19kZXRhY2ggPSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjtcbiAgICB1c2VfYXR0YWNoID0gXCJcIjtcbiAgICB1c2VfZGV0YWNoID0gXCJcIjtcbiAgICB1c2VfaWVfb2xkX2F0dGFjaCA9IGZhbHNlO1xuICAgIElFX0dDX0lOVEVSVkFMID0gMzAwMDtcbiAgICBFVlRfQ05DTF9NRVRIT0RTID0ge1xuICAgICAgXCJwcmV2ZW50RGVmYXVsdFwiOiAwLFxuICAgICAgXCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIjogMCxcbiAgICAgIFwic3RvcFByb3BhZ2F0aW9uXCI6IDAsXG4gICAgICBcInByZXZlbnRCdWJibGVcIjogMFxuICAgIH07XG4gICAgaXNJRSA9IGVudi5pc0lFO1xuICAgIHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMgPSBmYWxzZTtcbiAgICBnY190aW1lcl9pZCA9IDA7XG4gICAgZG9tX2lzX3JlYWR5ID0gbnVsbDtcbiAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgIGRvbV9yZWFkeV9jaGtfbWF4X3RyaWVzID0gMzAwO1xuICAgIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsID0gNTA7XG4gICAgZG9tX3JlYWR5X2Noa190cmllcyA9IDA7XG4gICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IDA7XG4gICAgaWZyYW1lX25leHRfaWQgPSAwO1xuICAgIGlmcmFtZV9jYnNfYXR0YWNoZWQgPSB7fTtcbiAgICBldnRfdGd0X3Byb3BfYSA9IFwiXCI7XG4gICAgZXZ0X3RndF9wcm9wX2IgPSBcIlwiO1xuICAgIGlmcmFtZV9tc2dfaG9zdF9saWIgPSBudWxsO1xuICAgIHRoZURvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuICAgIEJMQU5LX1VSTCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICBfY2FsbGFibGUgPSBsYW5nLmNhbGxhYmxlO1xuXG4gICAgLypcbiAgICBDbGVhciBvdXQgdGhlIHRpbWVyIGZ1bmN0aW9uIHVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIHJlYWR5IHN0YXRlIG9mIHRoZSBET01cbiAgICBjYW5ub3QgYmUgZGlyZWN0bHkgZGV0ZWN0ZWRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fY2xlYXJfcmVhZHlfdGltZXJfY2hlY2tcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb21fcmVhZHlfY2hrX3RpbWVyX2lkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkb21fcmVhZHlfY2hrX3RpbWVyX2lkKTtcbiAgICAgICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBfaGFuZGxlX2RvbV9sb2FkX2V2dCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZGV0YWNoKHdpbiwgXCJsb2FkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIGRldGFjaCh3aW4sIFwiRE9NQ29udGVudExvYWRlZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyB0byBzZWUgaWYgdGhlIERPTSBpcyByZWFkeSB0byBiZSBtYW5pcHVsYXRlZCwgd2l0aG91dCB0aGUgbmVlZCBmb3IgZXZlbnQgaG9va2luZy5cbiAgICBPZnRlbiB0aW1lcyB5b3UnbGwgc2VlIGZvbGtzIHVzZSB0aGUgb25sb2FkIGV2ZW50IG9yIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQuICBIb3dldmVyXG4gICAgdGhlIHByb2JsZW0gd2l0aCB0aG9zZSwgaXMgdGhhdCB5b3VyIEphdmFTY3JpcHQgY29kZSBtYXkgaGF2ZSBiZWVuIGxvYWRlZCBhc3luY2hyb25vdXNseSxcbiAgICBhZnRlciBlaXRoZXIgb25lIG9mIHRob3NlIGV2ZW50cyBoYXZlIGZpcmVkLCBhbmQgaW4gd2hpY2ggY2FzZSB5b3Ugc3RpbGwgZG9uJ3Qga25vdyBpZiB0aGUgRE9NIGlzIHJlYWxseVxuICAgIHJlYWR5LiAgTW9zdCBtb2Rlcm4gYnJvd3NlcnMgKGluY2x1ZGluZyBJRSksIGltcGxlbWVudCBhIGRvY3VtZW50LnJlYWR5U3RhdGUgcHJvcGVydHkgdGhhdCB3ZSBjYW5cbiAgICBjaGVjaywgYnV0IG5vdCBhbGwuICBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIHByb3BlcnR5IGlzIG5vdCBpbXBsZW1lbnRlZCwgd2UgZG8gYSBzZXJpZXMgb2Ygbm9kZVxuICAgIGNoZWNrcyBhbmQgdGFnIGNvdW50cyB2aWEgdGltZXJzLiAgT2YgY291cnNlIHRoaXMgbWVhbnMgdGhhdCBvbiB0aGUgdmVyeSAxc3QgY2FsbCwgd2Ugd2lsbCBhbHdheXNcbiAgICBhcHBlYXIgdG8gYmUgbm90IHJlYWR5IGV2ZW50aG91Z2ggdGhlIERPTSBpdHNlbGYgbWF5IGJlIGluIGEgcmVhZHkgc3RhdGUsIGJ1dCBvdXIgdGltZW91dCBpbnRlcnZhbFxuICAgIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoaXMgaXMgT0suXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX3JlYWR5X3N0YXRlX2NoZWNrXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX3JlYWR5X3N0YXRlX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYiwgZSwga2lkcywgbHN0LCB0YWdfY250O1xuICAgICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrKCk7XG4gICAgICBpZiAoZG9tX3JlYWR5X2Noa190cmllcyA+PSBkb21fcmVhZHlfY2hrX21heF90cmllcykge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb21faXNfcmVhZHkgPT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiID0gdGhlRG9jdW1lbnQgJiYgdGhlRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICBraWRzID0gYiAmJiB0YWdzKFwiKlwiLCBiKTtcbiAgICAgICAgICB0YWdfY250ID0ga2lkcyAmJiBraWRzW0xFTl07XG4gICAgICAgICAgbHN0ID0gYiAmJiBiLmxhc3RDaGlsZDtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21fbGFzdF9rbm93bl90YWdfY291bnQgJiYgdGFnX2NudCA9PT0gZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ICYmIGxzdCA9PT0gZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSkge1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gdGFnX2NudDtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbHN0O1xuICAgICAgICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgKz0gMTtcbiAgICAgICAgICBkb21fcmVhZHlfY2hrX3RpbWVyX2lkID0gc2V0VGltZW91dChfcmVhZHlfc3RhdGVfY2hlY2ssIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRGV0YWNoIG9ubG9hZCBoYW5kbGVycyBvbiBpZnJhbWVzIHRoYXQgd2UgaGF2ZSBjcmVhdGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fdW5iaW5kX2lmcmFtZV9vbmxvYWRcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgaWZyYW1lIGVsZW1lbnQgdG8gdW5iaW5kIGZyb21cbiAgICAgKi9cbiAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGlkLCBvbGRDQjtcbiAgICAgIGlkID0gYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgIG9sZENCID0gdm9pZCAwO1xuICAgICAgb2xkQ0IgPSBpZCAmJiBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXTtcbiAgICAgIGlmIChvbGRDQikge1xuICAgICAgICBkZXRhY2goZWwsIFwibG9hZFwiLCBvbGRDQik7XG4gICAgICAgIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEEgZGVmYXVsdCBvbmxvYWQgZXZlbnQgaGFuZGxlciBmb3IgSUZyYW1lcy4gV2UgZG9uJ3RcbiAgICB3YW50IHRvIGF0dGFjaCB0byBvbmxvYWQgZXZlbnRzIGZvciBJRnJhbWVzIHZpYSBhdHRyaWJ1dGVzXG4gICAgYi9jIHdlIGRvbid0IHdhbnQgb3RoZXJzIHRvIHNlZSB3aGF0IGhhbmRsZXJzIGFyZSB0aGVyZS5cbiAgICBJbiB0dXJuIHdlIGFsc28gbWFrZSBzdXJlIHRoZSBcInRoaXNcIiByZWZlcmVuY2UgZm9yIHRoZSBvdXRzaWRlXG4gICAgaGFuZGxlIGdldHMgc2V0IHByb3Blcmx5LCBhbmQgaXQgYWxsb3dzIHVzIHRvIG1ha2Ugc3VyZVxuICAgIHRoYXQgdW5iaW5kaW5nIG9mIHRoZSBldmVudCBoYW5kbGVyIGFsc28gZ2V0cyBoYW5kbGVkIGFsd2F5c1xuICAgIHNvIGFzIG5vdCB0byBjcmVhdGUgbWVtb3J5IGxlYWsgaXNzdWVzLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX2JpbmRfaWZyYW1lX29ubG9hZFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBpZnJhbWUgZWxlbWVudCB0byBiaW5kIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBvbmxvYWQgaGFuZGxlciBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICovXG4gICAgX2JpbmRfaWZyYW1lX29ubG9hZCA9IGZ1bmN0aW9uKGVsLCBjYikge1xuICAgICAgdmFyIGlkLCBuZXdDQjtcbiAgICAgIG5ld0NCID0gdm9pZCAwO1xuICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICBpZiAoX2NhbGxhYmxlKGNiKSkge1xuXG4gICAgICAgIC8qXG4gICAgICAgIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIG5ld0NCID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIGUsIHRndDtcbiAgICAgICAgICB0Z3QgPSBldnRUZ3QoZXZ0KTtcbiAgICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZCh0Z3QpO1xuICAgICAgICAgIGlmICh0Z3QgJiYgY2IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNiLmNhbGwodGd0LCBldnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgICB0Z3QgPSBlbCA9IGNiID0gbmV3Q0IgPSBpZCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlkID0gYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKGVsKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF0gPSBuZXdDQjtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2goZWwsIFwibG9hZFwiLCBuZXdDQik7XG4gICAgICB9XG4gICAgICBuZXdDQiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBlbGVtZW50IHJlZmVyZW5jZSBwYXNzZWQgaW4sIGFuZCBpZiBpdHMgYSBzdHJpbmcgdmFsdWUgcGFzc2VkXG4gICAgaW4gdXNlIHRoYXQgdG8gbG9va3VwIHRoZSBlbGVtZW50IGJ5IGlkIGF0dHJpYnV0ZS5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fYnlJRFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBlbCAgdGhlIGVsZW1lbnQgaWQgLyBlbGVtZW50IHJlZmVyZW5jZVxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fGVsfVxuICAgICAqL1xuICAgIF9ieUlEID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGVsdChlbCkgfHwgZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBwcm94eSB3cmFwcGVyIGZvciBjYWxsaW5nIGludG8gdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgaG9zdCBsaWJyYXJ5XG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fY2FsbF94bXNnX2hvc3RcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gbWV0aE5hbWUgVGhlIG1ldGhvZCBuYW1lIGluIHRoZSBtc2cgaG9zdCBsaWJyYXJ5IHRvIGNhbGxcbiAgICBAcGFyYW0geyp9IGFyZzEgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDFzdCBhcmdcbiAgICBAcGFyYW0geyp9IGFyZzIgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDJuZCBhcmdcbiAgICBAcGFyYW0geyp9IGFyZzMgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDNyZCBhcmdcbiAgICBAcmV0dXJuIHsqfSB3aGF0ZXZlciBjb21lcyBiYWNrIGZyb20gdGhlIG1ldGhvZFxuICAgICAqL1xuICAgIF9jYWxsX3htc2dfaG9zdCA9IGZ1bmN0aW9uKG1ldGhOYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlmcmFtZV9tc2dfaG9zdF9saWIpIHtcbiAgICAgICAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gZG9tLm1zZ2hvc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW4gIT09IHRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aE5hbWUgJiYgaWZyYW1lX21zZ19ob3N0X2xpYiAmJiBpZnJhbWVfbXNnX2hvc3RfbGliW21ldGhOYW1lXSAmJiBpZnJhbWVfbXNnX2hvc3RfbGliW21ldGhOYW1lXShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSBhIGRvY3VtZW50IGZvciBhIGdpdmVuIEhUTUwgRWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGRvYyBhcyAkc2YubGliLmRvbS5kb2NcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHdoaWNoIHlvdSB3aXNoIHRvIGZpbmQgaXQncyBwYXJlbnQgZG9jdW1lbnRcbiAgICBAcmV0dXJuIHtEb2N1bWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICBkb2MgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGxvY2FsRDtcbiAgICAgIGxvY2FsRCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBlbC5kb2N1bWVudCB8fCBlbC5vd25lckRvY3VtZW50IHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgbG9jYWxEID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NhbEQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgdGhlIGhvc3Qgd2luZG93IG9iamVjdCBmb3IgYSBnaXZlbiBIVE1MIEVsZW1lbnQvZG9jdW1lbnQuIE5vdGUgdGhhdCB0aGlzIGlzIE5PVCB0aGUgc2FtZSBhcyAkc2YubGliLmRvbS5pZnJhbWVzLnZpZXcsIHdoaWNoXG4gICAgcmV0dXJucyB0aGUgd2luZG93IHJlZmVyZW5jZSBJTlNJREUgdGhlIElGUkFNRSBlbGVtZW50LlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHZpZXcgYXMgJHNmLmxpYi5kb20udmlld1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MRG9jdW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQvZG9jdW1lbnQgZm9yIHdoaWNoIHlvdSB3aXNoIHRvIGZpbmQgaXQncyBwYXJlbnQgd2luZG93XG4gICAgQHJldHVybiB7RG9jdW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgdmlldyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZSwgbG9jYWxELCBwcm9wMSwgcHJvcDIsIHc7XG4gICAgICB3ID0gbnVsbDtcbiAgICAgIGxvY2FsRCA9IHZvaWQgMDtcbiAgICAgIHByb3AxID0gXCJwYXJlbnRXaW5kb3dcIjtcbiAgICAgIHByb3AyID0gXCJkZWZhdWx0Vmlld1wiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdyA9IGVsW3Byb3AxXSB8fCBlbFtwcm9wMl0gfHwgbnVsbDtcbiAgICAgICAgICBpZiAoIXcpIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGRvYyhlbCk7XG4gICAgICAgICAgICB3ID0gKGxvY2FsRCAmJiAobG9jYWxEW3Byb3AxXSB8fCBsb2NhbERbcHJvcDJdKSkgfHwgbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB3ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIGFuIGVsZW1lbnQgYnkgaXRzIElELiAuIGJhc2ljYWxseSBhIHNob3J0IGhhbmQgd3JhcHBlciBhcm91bmQgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZWx0IGFzICRzZi5saWIuZG9tLmVsdFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IGlkIChSZXF1aXJlZCkgdGhlIGlkIG9mIHRoZSBIVE1MIGVsZW1lbnQgdG8gZmluZFxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFdpbmRvd3xIVE1MRG9jdW1lbnR9IFtwYXJdIFRoZSBwYXJlbnQgZWxlbWVudCxkb2N1bWVudCx3aW5kb3cgdG8gbG9vayBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICBlbHQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIGFyZ3MsIGRjLCBsZW47XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICBkYyA9IHZvaWQgMDtcbiAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgIGRjID0gZG9jKGFyZ3NbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGMgPSB0aGVEb2N1bWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZGMgJiYgZGMuZ2V0RWxlbWVudEJ5SWQoaWQpKSB8fCBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBhcm91bmQgcmV0cmlldmluZyB0aGUgdGFnTmFtZSBvZiBhbiBIVE1MIGVsZW1lbnQgKG5vcm1hbGl6ZXMgdmFsdWVzIHRvIGxvd2VyIGNhc2Ugc3RyaW5ncykuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdGFnTmFtZSBhcyAkc2YubGliLmRvbS50YWdOYW1lXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTCBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIHRhZyBuYW1lLlxuICAgIEByZXR1cm4ge1N0cmluZ30gVGhlIHRhZyBuYW1lIGluIGFsbCBsb3dlciBjYXNlIG9mIGFuIEhUTUwgZWxlbWVudCwgaWYgaXQgY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQsIGFsd2FzeXMgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgKHdoaWNoIHdpbGwgZXZhbHVhdGUgdG8gZmFsc2UpLlxuICAgICAqL1xuICAgIHRhZ05hbWUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCI7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIGFyb3VuZCByZXRyaWV2aW5nIGEgbGlzdCBvZiB0YWdzIGJ5IG5hbWUuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdGFncyBhcyAkc2YubGliLmRvbS50YWdzXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFncyB0aGF0IHlvdSB3aXNoIHRvIGxvb2sgZm9yLCBub3RlIHRoYXQgeW91IGNhbiBwYXNzIGluIFwiKlwiIHRvIGZpbmQgYWxsLlxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9IFtwYXJOb2RlXSB0aGUgcGFyZW50IG5vZGUgdGhhdCB5b3Ugd2lzaCB0byBsb29rIGluXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnRDb2xsZWN0aW9ufSBMaXN0IG9mIHRhZ3MgZm91bmQuIE5vdGUgdGhhdCBpcyBOT1QgYSByZWFsIEphdmFTY3JpcHQgQXJyYXlcbiAgICAgKi9cbiAgICB0YWdzID0gZnVuY3Rpb24obmFtZSwgcGFyTm9kZSkge1xuICAgICAgdmFyIGUsIHJldDtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJOb2RlICYmIHBhck5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICByZXQgPSBwYXJOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpIHx8IHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSB0aGVEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSB8fCByZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cml2ZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcGFyIGFzICRzZi5saWIuZG9tLnBhclxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBjaGVja1xuICAgIHJldHVybiB7SFRNTEVsZW1lbnR9IHRoZSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBvciBudWxsXG4gICAgICovXG4gICAgcGFyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbCAmJiAoZWwucGFyZW50Tm9kZSB8fCBlbC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZS9TZXQvRGVsZXRlIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUuIE5vdGUgdGhhdCB0aGlzIGhhbmRsZSdzXG4gICAgc2xpZ2h0IGRpZmZlcmVuY2VzIGluIHRoZSB3YXkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBoYW5kbGVkIGFjcm9zcyBicm93c2Vyc1xuICAgIGFzIHdlbGwgYXMgYmVpbmcgc2hvcnRoYW5kXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXR0ciBhcyAkc2YubGliLmRvbS5hdHRyXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgdGhlIGF0dHJpYnV0ZSB0byBzZXQvZ2V0XG4gICAgQHBhcmFtIHtTdHJpbmd9IFthdHRyVmFsXSwgaWYgc3BlY2lmaWVkIHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGZvciB0aGlzIGVsZW1lbnQuICBQYXNzaW5nIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBjb21wbGV0ZWx5XG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBub3JtYWxpemVkIHRvIGEgc3RyaW5nIChtYXkgYmUgZW1wdHkpXG4gICAgICovXG4gICAgYXR0ciA9IGZ1bmN0aW9uKGVsLCBhdHRyTmFtZSwgYXR0clZhbCkge1xuICAgICAgdmFyIGU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgaWYgKGF0dHJWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1c2VPbGRTdHlsZUF0dHJNZXRob2RzKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoYXR0clZhbCk7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJWYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCwgMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSwgMCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgYXR0clZhbCA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0clZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZXQvR2V0IHRoZSBDU1MgdGV4dCBvZiBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBjc3MgYXMgJHNmLmxpYi5kb20uY3NzXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gW3ZhbF0gdGhlIENTUyBzdHJpbmcgdG8gc2V0IGlmIHNwZWNpZmllZCAoZS5nLiBcImJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjBweDtsZWZ0OjBweFwiKS5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG5vcm1hbGl6ZWQgdG8gYSBzdHJpbmcgKG1heSBiZSBlbXB0eSlcbiAgICAgKi9cbiAgICBjc3MgPSBmdW5jdGlvbihlbCwgdmFsKSB7XG4gICAgICB2YXIgZSwgc3Q7XG4gICAgICBzdCA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ID0gZWwuc3R5bGU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN0LmNzc1RleHQgPSBfY3N0cih2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHN0LmNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNYWtlIGEgbmV3IGVsZW1lbnRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5tYWtlXG4gICAgQGV4cG9ydHMgbWFrZV9lbGVtZW50IGFzICRzZi5saWIuZG9tLm1ha2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lXG4gICAgQHBhcmFtIHtEb2N1bWVudHxIVE1MRWxlbWVudHxXaW5kb3d9IFtwYXJlbnRdIGVsZW1lbnQsIGRvY3VtZW50LCBvciB3aW5kb3cgdG8gbWFrZSB0aGUgdGFnIGluLCBvcHRpb25hbC5cbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBtYWtlX2VsZW1lbnQgPSBmdW5jdGlvbih0YWdOYW1lLCBwYXIpIHtcbiAgICAgIHJldHVybiAoKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGRvYyhwYXIpKSB8fCB0aGVEb2N1bWVudCkuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBcHBlbmQgYW5kIEhUTUxFbGVtZW50IHRvIGFub3RoZXIgSFRNTEVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBhcHBlbmQgYXMgJHNmLmxpYi5kb20uYXBwZW5kXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJOb2RlIHRoZSBIVE1MIGVsZW1lbnQgdG8gbWFuaXB1bGF0ZVxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNoaWxkIChSZXF1aXJlZCkgdGhlIG5ldyBIVE1MIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBwYXJlbnRcbiAgICByZXR1cm4ge0hUTUxFbGVtZW50fEJvb2xlYW59IHRoZSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBlbGVtZW50IHRoYXQgd2FzIGFwcGVuZGVkLCBvciBmYWxzZSBpZiBmYWlsdXJlXG4gICAgICovXG4gICAgYXBwZW5kID0gZnVuY3Rpb24ocGFyTm9kZSwgY2hpbGQpIHtcbiAgICAgIHZhciBlLCBzdWNjZXNzO1xuICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJOb2RlKSB7XG4gICAgICAgICAgc3VjY2VzcyA9IHBhck5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIG1ldGhvZCBmb3IgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSBhIGRvY3VtZW50IHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCByYXcuXG4gICAgSGFzIHNwZWNpYWwgcHJvY2Vzc2luZyB0byBlbnN1cmUgdGhhdCBjb250ZW50cyBvZiBJRlJBTUUgdGFncyBnZXRzIHJlbGVhc2VkIGZyb20gbWVtb3J5IGFzIHdlbGxcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBwdXJnZSBhcyAkc2YubGliLmRvbS5wdXJnZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgSFRNTCBlbGVtZW50IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkXG4gICAgICovXG4gICAgcHVyZ2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZSwgaXNJRnJhbWUsIHBhck5vZGUsIHN1Y2Nlc3M7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICBwYXJOb2RlID0gdm9pZCAwO1xuICAgICAgaXNJRnJhbWUgPSB0YWdOYW1lKG5vZGUpID09PSBJRlJBTUU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgaWYgKGlzSUZyYW1lKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdChcImRldGFjaFwiLCBub2RlKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKG5vZGUpO1xuICAgICAgICBpZiAoIWlzSUUpIHtcbiAgICAgICAgICBhdHRyKG5vZGUsIFwic3JjXCIsIEJMQU5LX1VSTCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHBhck5vZGUgPSBwYXIobm9kZSk7XG4gICAgICAgIGlmIChwYXJOb2RlKSB7XG4gICAgICAgICAgcGFyTm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNJRSAmJiBpc0lGcmFtZSkge1xuICAgICAgICAgICAgZ2MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIG5vZGUgPSBwYXJOb2RlID0gbnVsbDtcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEF0dGFjaCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIEhUTUxFbGVtZW50LiAgTm90ZSBub3JtYWxpemUgZXZlbnQgbmFtZXMgdG8gbG93ZXIgY2FzZSAvIHczYyBzdGFuZGFyZHMuXG4gICAgU2VlIGV4YW1wbGUuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXR0YWNoIGFzICRzZi5saWIuZG9tLmF0dGFjaFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBhdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0b29cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGhhbmRsZSB0aGUgcGFydGljdWxhciBldmVudFxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIGVsID0gJHNmLmxpYi5kb20uZWx0KFwibXlfZWxlbWVudFwiKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVfY2xpY2soZXZ0KVxuICAgIHtcbiAgICBhbGVydCgnaSB3YXMgY2xpY2tlZCcpO1xuICAgIH1cbiAgICBcbiAgICAkc2YubGliLmRvbS5hdHRhY2goZWwsXCJjbGlja1wiLGhhbmRsZV9jbGljayk7XG4gICAgICovXG4gICAgYXR0YWNoID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVzZV9pZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgb2JqW3VzZV9hdHRhY2hdKFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpbdXNlX2F0dGFjaF0obmFtZSwgY2IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgb2JqID0gY2IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERldGFjaCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZGV0YWNoIGFzICRzZi5saWIuZG9tLmRldGFjaFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBhdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0b29cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZXRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9vXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoZSBwYXJ0aWN1bGFyIGV2ZW50XG4gICAgICovXG4gICAgZGV0YWNoID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVzZV9pZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgb2JqLmRldGFjaEV2ZW50KFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBvYmogPSBjYiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgRE9NIGlzIHJlYWR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcmVhZHkgYXMgJHNmLmxpYi5kb20ucmVhZHlcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgcmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBycztcbiAgICAgIHJzID0gdm9pZCAwO1xuICAgICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrKCk7XG4gICAgICBpZiAoZG9tX2lzX3JlYWR5KSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJzID0gdGhlRG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgIGlmIChycykge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHJzID09PSBcImxvYWRlZFwiIHx8IHJzID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgPSBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgICAgX3JlYWR5X3N0YXRlX2NoZWNrKCk7XG4gICAgICByZXR1cm4gISFkb21faXNfcmVhZHk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRmlyZSBvZmYgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIHdoZW4gaXQgaXMgZGV0ZWN0ZWQgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG4gICAgVXNlZnVsIHdoZW4geW91IGRvbid0IGtub3cgZm9yIHN1cmUgaWYgdGhlIERPTSBvZiB0aGUgYnJvd3NlciBpcyByZWFkeSBvciBub3QsIHNvIHRoaXMgd2lsbCBkZXRlY3QgYW5kIGZpcmVcbiAgICB5b3VyIGZ1bmN0aW9uIGZvciB5b3UuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgd2FpdCBhcyAkc2YubGliLmRvbS53YWl0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBBIGZ1bmN0aW9uIHJlZmVyZW5jZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICovXG4gICAgd2FpdCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgZSwgcmR5O1xuICAgICAgcmR5ID0gcmVhZHkoKTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBpZiAocmR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGxhbmcuY2FsbGFibGUoY2IpKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgd2FpdChjYik7XG4gICAgICAgIGNiID0gbnVsbDtcbiAgICAgIH0pLCBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCArIDEpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENhbmNlbCB0aGUgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIGEgcGFydGljdWxhciBET00gZXZlbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBldnRDbmNsIGFzICRzZi5saWIuZG9tLmV2dENuY2xcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgIFRoZSByYXcgSFRNTCBldmVudFxuICAgICAqL1xuICAgIGV2dENuY2wgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlLCBwcm9wO1xuICAgICAgcHJvcCA9IFwiXCI7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgZXZ0ID0gZXZ0IHx8IHdpbi5ldmVudDtcbiAgICAgIGlmIChldnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZ0LnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIGZvciAocHJvcCBpbiBFVlRfQ05DTF9NRVRIT0RTKSB7XG4gICAgICAgICAgaWYgKEVWVF9DTkNMX01FVEhPRFNbcHJvcF0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGV2dFtwcm9wXSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgdGFyZ2V0L3NyY0VsZW1lbnQgb2YgYW4gZXZlbnQgZnJvbSBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBldnRUZ3QgYXMgJHNmLmxpYi5kb20uZXZ0VGd0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgSFRNTCBldmVudFxuICAgICAqL1xuICAgIGV2dFRndCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGUsIHRndDtcbiAgICAgIHRndCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBldnQgPSBldnQgfHwgd2luLmV2ZW50O1xuICAgICAgICB0Z3QgPSAoZXZ0ID8gZXZ0W2V2dF90Z3RfcHJvcF9hXSB8fCBldnRbZXZ0X3RndF9wcm9wX2JdIDogbnVsbCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGd0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0Z3Q7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQG5hbWVzcGFjZSAkc2YubGliLmRvbS5pZnJhbWVzIERlZmluZXMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZGVhbGluZyBzcGVjaWZpY2FsbHkgd2l0aCBJRlJBTUUgdGFncywgd2hpY2ggaXMga2V5IHRvIFNhZmVGcmFtZXMgdGVjaCBpbiBhIGJyb3dzZXIuXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lc1xuICAgIEByZXF1aXJlcyAkc2YubGliLmxhbmdcbiAgICAgKi9cblxuICAgIC8qXG4gICAgQ2xvbmVzIGFuIGlmcmFtZS4gLiAuXG4gICAgVGhpcyBjb2RlIGNyZWF0ZXMgLyBjbG9uZXMgaWZyYW1lIHRhZ3MgaW4gYSB2ZXJ5IHNwZWNpZmljIHdheSB0byBlbnN1cmUgYm90aCBvcHRpbWFsIHBlcmZvcm1hbmNlIGFuZCBzdGFiaWxpdHkuXG4gICAgV2UgdXNlIHN0cmluZyBidWZmZXJzIHRvIGJ1aWxkIG1hcmt1cCBpbnRlcm5hbGx5LCB3aGljaCBpcyB0eXBpY2FsbHkgZmFzdGVyIHRoYW4gdXNpbmcgYWxsIERPTSBBUElzLiAgQWxzb1xuICAgIHdlIGFsbG93IHRoZSB1c2FnZSBvZiB0aGUgXCJuYW1lXCIgYXR0cmlidXRlIGFzIGEgZGF0YSBwaXBlbGluZSwgd2hpY2ggaW4gdHVybiBhbGxvd3MgZm9yIHN5bmNocm9ub3VzIGRvd253YXJkXG4gICAgeC1kb21haW4gbWVzc2FnaW5nLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMuY2xvbmVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnQvU3RyaW5nfSBlbCAgQW4gaWZyYW1lIGVsZW1lbnQgb3IgaWQgb2YgYW4gaWZyYW1lIGVsZW1lbnQgdG8gY2xvbmVcbiAgICBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSAgQSBoYXNoIG1hcCBvZiBvdGhlciBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgaWZyYW1lLiAgRG8gbm90IHNldCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZnJhbWUgaGVyZSwgc2VlIHRoZSBuZXh0IGFyZ3VtZW50IGZvciB0aGF0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbY3NzVGV4dF0gIFRoZSBzdHlsZSBzdHJpbmcgKGFzIGluIHdoYXQgeW91IHdvdWxkIHVzZSBpbiBIVE1MIG1hcmt1cCwgZS5nLiBcImJhY2tncm91bmQtY29sb3I6cmVkO2JvcmRlcjpzb2xpZCAzcHggYmx1ZTtcIiksIHRvIHVzZSBmb3IgdGhpcyBpZnJhbWVcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gb3B0aW9uYWwgY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9ICB0aGUgaWZyYW1lIG5vZGUgaWYgc3VjY2VzZnVsbHkgY3JlYXRlZCBvciBudWxsLiAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgaW5zZXJ0IHRoZSBpZnJhbWUgaW50byB0aGUgZG9jdW1lbnQgZm9yIHlvdS4gLiAuXG4gICAgICovXG4gICAgY2xvbmVfaWZyYW1lID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKSB7XG4gICAgICByZXR1cm4gX2Nsb25lX2lmcmFtZShlbCwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBfY2xvbmVfaWZyYW1lID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCLCBpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgdmFyIGF0dHJTdHIsIGJ1ZmZlckhUTUwsIGNsLCBodG1sLCBuZXdDbCwgcHJvcCwgdGVtcCwgeG1zZ1BpcGU7XG4gICAgICBidWZmZXJIVE1MID0gW1wiPFwiLCBJRlJBTUUsIFwiIFwiXTtcbiAgICAgIHhtc2dQaXBlID0gXCJcIjtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICB0ZW1wID0gdm9pZCAwO1xuICAgICAgY2wgPSB2b2lkIDA7XG4gICAgICBuZXdDbCA9IHZvaWQgMDtcbiAgICAgIGh0bWwgPSB2b2lkIDA7XG4gICAgICBhdHRyU3RyID0gdm9pZCAwO1xuICAgICAgaWYgKCFpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgICBlbCA9IF9ieUlEKGVsKTtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBJRlJBTUUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjbCA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbCA9IGVsO1xuICAgICAgfVxuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIGlmIChcInNyY1wiIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIoY2wsIFwic3JjXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuc3JjID0gYXR0cihlbCwgXCJzcmNcIikgfHwgQkxBTktfVVJMO1xuICAgICAgfVxuICAgICAgaWYgKFwibmFtZVwiIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIoY2wsIFwibmFtZVwiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLm5hbWUgPSBhdHRyKGVsLCBcIm5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzLnNyYykge1xuICAgICAgICBhdHRycy5zcmMgPSBCTEFOS19VUkw7XG4gICAgICB9XG4gICAgICB4bXNnUGlwZSA9IHhtc2dDQiAmJiBfY2FsbF94bXNnX2hvc3QoXCJwcmVwXCIsIGF0dHJzKTtcbiAgICAgIGlmICghaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgICAgYXR0cihjbCwgXCJ3aWR0aFwiLCBudWxsKTtcbiAgICAgICAgYXR0cihjbCwgXCJoZWlnaHRcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICB0ZW1wID0gY3NzKGNsKTtcbiAgICAgICAgaWYgKHRlbXAgJiYgdGVtcC5jaGFyQXQodGVtcC5sZW5ndGggLSAxKSAhPT0gXCI7XCIpIHtcbiAgICAgICAgICB0ZW1wICs9IFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIGNzcyhjbCwgW3RlbXAsIF9jc3RyKGNzc1RleHQpXSk7XG4gICAgICB9XG4gICAgICB0ZW1wID0gbWFrZV9lbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYXBwZW5kKHRlbXAsIGNsKTtcbiAgICAgIGh0bWwgPSB0ZW1wLmlubmVySFRNTDtcbiAgICAgIGF0dHJTdHIgPSBodG1sLnJlcGxhY2UoLzxpZnJhbWUoLio/KT4oLio/KTxcXC9pZnJhbWU+L2csIFwiJDFcIik7XG4gICAgICBidWZmZXJIVE1MLnB1c2goXCJuYW1lPVxcXCJcIiwgYXR0cnMubmFtZSwgXCJcXFwiIFwiLCBhdHRyU3RyLCBcIj48L1wiLCBJRlJBTUUsIFwiPlwiKTtcbiAgICAgIGRlbGV0ZSBhdHRycy5uYW1lO1xuICAgICAgdGVtcC5pbm5lckhUTUwgPSBfY3N0cihidWZmZXJIVE1MKTtcbiAgICAgIG5ld0NsID0gdGVtcC5maXJzdENoaWxkO1xuICAgICAgZm9yIChwcm9wIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIobmV3Q2wsIHByb3AsIGF0dHJzW3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cihuZXdDbCwgXCJpZFwiKSkge1xuICAgICAgICBhdHRyKG5ld0NsLCBcImlkXCIsIFwic2ZfXCIgKyBJRlJBTUUgKyBcIl9cIiArIGlmcmFtZV9uZXh0X2lkKTtcbiAgICAgICAgaWZyYW1lX25leHRfaWQrKztcbiAgICAgIH1cbiAgICAgIGF0dHIobmV3Q2wsIFwiRlJBTUVCT1JERVJcIiwgXCJub1wiKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiU0NST0xMSU5HXCIsIFwibm9cIik7XG4gICAgICBhdHRyKG5ld0NsLCBcIkFMTE9XVFJBTlNQQVJFTkNZXCIsIHRydWUpO1xuICAgICAgYXR0cihuZXdDbCwgXCJISURFRk9DVVNcIiwgdHJ1ZSk7XG4gICAgICBhdHRyKG5ld0NsLCBcIlRBQklOREVYXCIsIC0xKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiTUFSR0lOV0lEVEhcIiwgMCk7XG4gICAgICBhdHRyKG5ld0NsLCBcIk1BUkdJTkhFSUdIVFwiLCAwKTtcbiAgICAgIF9iaW5kX2lmcmFtZV9vbmxvYWQobmV3Q2wsIGNiKTtcbiAgICAgIGlmICh4bXNnUGlwZSkge1xuICAgICAgICBfY2FsbF94bXNnX2hvc3QoXCJhdHRhY2hcIiwgbmV3Q2wsIHhtc2dQaXBlLCB4bXNnQ0IpO1xuICAgICAgfVxuICAgICAgeG1zZ1BpcGUgPSB4bXNnQ0IgPSBjbCA9IGNiID0gZWwgPSB0ZW1wID0gbnVsbDtcbiAgICAgIHJldHVybiBuZXdDbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNYWtlIGEgbmV3IGlmcmFtZVxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMubWFrZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBIGhhc2ggbWFwIG9mIG90aGVyIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBpZnJhbWUuICBEbyBub3Qgc2V0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSBmcmFtZSBoZXJlLCBzZWUgdGhlIG5leHQgYXJndW1lbnQgZm9yIHRoYXQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjc3NUZXh0XSAgVGhlIHN0eWxlIHN0cmluZyAoYXMgaW4gd2hhdCB5b3Ugd291bGQgdXNlIGluIEhUTUwgbWFya3VwLCBlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7Ym9yZGVyOnNvbGlkIDNweCBibHVlO1wiKSwgdG8gdXNlIGZvciB0aGlzIGlmcmFtZVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gIHRoZSBpZnJhbWUgbm9kZSBpZiBzdWNjZXNmdWxseSBjcmVhdGVkIG9yIG51bGwuICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBpbnNlcnQgdGhlIGlmcmFtZSBpbnRvIHRoZSBkb2N1bWVudCBmb3IgeW91LiAuIC5cbiAgICAgKi9cbiAgICBtYWtlX2lmcmFtZSA9IGZ1bmN0aW9uKGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKSB7XG4gICAgICByZXR1cm4gX2Nsb25lX2lmcmFtZShtYWtlX2VsZW1lbnQoSUZSQU1FKSwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgbWV0aG9kIHRvIGluc2VydCBvciByZXBsYWNlIGFuIEhUTUwgdGFnIHdpdGggYW4gSUZSQU1FIHRhZywgd2l0aCBhIG5ldyBVUkwgYW5kIGF0dHJpYnV0ZXMuXG4gICAgXG4gICAgVXNlZCBmb3IgMyByZWFzb25zOlxuICAgIDxvbD5cbiAgICA8bGk+SXQgYXZvaWRzIGNsaWNrIHNvdW5kcyBvbiBJRS48L2xpPlxuICAgIDxsaT5JdCBhbGxvd3MgYWx3YXlzIHJlc2V0dGluZyB0aGUgd2luZG93Lm5hbWUgcHJvcGVydHkgb2YgdGhlIGlmcmFtZXMgdW5kZXJseWluZyBIVE1MV2luZG93IG9iamVjdCwgdW5mb3J1bmF0ZWx5IElFIHdpbGwgbm90IGxldCB5b3Ugc2V0IHRoaXMgYXR0cmlidXRlIG9uIGEgY2xvbmUuPC9saT5cbiAgICA8bGk+SXQgZW5zdXJlcyB0aGF0IGV2ZW50IGhhbmRsZXJzIGluIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50IGZvciB1bmxvYWRpbmcgYXJlIGV4ZWN1dGVkLjwvbGk+XG4gICAgPGxpPkNoYW5naW5nIHRoZSBzcmMgYXR0cmlidXRlIGRpcmVjdGx5IHdpbGwgcmVzdWx0IGluIGEgYnJvd3NlciBoaXN0b3J5IHVwZGF0ZSwgd2hpY2ggd2UgZG8gbm90IHdhbnQuPC9saT5cbiAgICA8L29sPlxuICAgIFxuICAgIFdlIGNvdWxkIGp1c3QgY2hhbmdlIGxvY2F0aW9uLmhyZWYgcHJvcGVydHkgb3IgY2FsbCBsb2NhdGlvbi5yZXBsYWNlLCBob3dldmVyIHRoYXQgaXMgbm90IGFsd2F5cyAgcG9zc2libGUgc2luY2VcbiAgICB0aGUgZnJhbWUgY291bGQgYmUgeC1kb21haW4uXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy5yZXBsYWNlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAcGFyYW0ge09iamVjdH0gYXR0cnMgIEEgaGFzaCBtYXAgb2Ygb3RoZXIgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIGlmcmFtZS4gIERvIG5vdCBzZXQgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGZyYW1lIGhlcmUsIHNlZSB0aGUgbmV4dCBhcmd1bWVudCBmb3IgdGhhdC5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2Nzc1RleHRdICBUaGUgc3R5bGUgc3RyaW5nIChhcyBpbiB3aGF0IHlvdSB3b3VsZCB1c2UgaW4gSFRNTCBtYXJrdXAsIGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtib3JkZXI6c29saWQgM3B4IGJsdWU7XCIpLCB0byB1c2UgZm9yIHRoaXMgaWZyYW1lXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IFtwYXJSZWZdICBBbiBwYXJlbnQgZWxlbWVudCBvciBwYXJlbnQgZWxlbWVudCBpZCwgdG8gYmUgdXNlZCBvbmx5IGlmIGEgbmV3IGlmcmFtZSBpcyBjcmVhdGVkLCB0aGUgaWZyYW1lIHdpbGwgYmUgYXBwZW5kIHRvIHRoYXQgcGFyZW50LCBpZiBub3Qgc3BlY2lmaWVkIGRvY3VtZW50IGJvZHkgaXMgdXNlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gYSByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgaWZyYW1lIGVsZW1lbnQgaWYgc3VjY2Vzc2Z1bGx5IGluc2VydGVkLCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKi9cbiAgICByZXBsYWNlX2lmcmFtZSA9IGZ1bmN0aW9uKGF0dHJzLCBjc3NUZXh0LCBwYXJSZWYsIGNiLCB4bXNnQ0IpIHtcbiAgICAgIHZhciBjbCwgZSwgZWwsIGVsSUQsIGZyYW1lRWwsIHBhck5vZGUsIHRnbjtcbiAgICAgIGNsID0gdm9pZCAwO1xuICAgICAgZWwgPSB2b2lkIDA7XG4gICAgICBmcmFtZUVsID0gdm9pZCAwO1xuICAgICAgZWxJRCA9IHZvaWQgMDtcbiAgICAgIHRnbiA9IHZvaWQgMDtcbiAgICAgIHBhck5vZGUgPSB2b2lkIDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIGVsSUQgPSBhdHRycy5pZDtcbiAgICAgIGVsID0gZWxJRCAmJiBfYnlJRChlbElEKTtcbiAgICAgIHRnbiA9IHRhZ05hbWUoZWwpO1xuICAgICAgZWwgPSAodGduID8gZWwgOiBudWxsKTtcbiAgICAgIGZyYW1lRWwgPSAodGduID09PSBJRlJBTUUgPyBlbCA6IG51bGwpO1xuICAgICAgaWYgKGZyYW1lRWwpIHtcbiAgICAgICAgX2NhbGxfeG1zZ19ob3N0KFwiZGV0YWNoXCIsIGZyYW1lRWwpO1xuICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQoZnJhbWVFbCk7XG4gICAgICAgIHBhck5vZGUgPSBwYXIoZnJhbWVFbCk7XG4gICAgICAgIGNsID0gY2xvbmVfaWZyYW1lKGZyYW1lRWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKTtcbiAgICAgICAgYXR0cihjbCwgXCJvbmxvYWRcIiwgbnVsbCk7XG4gICAgICAgIGF0dHIoY2wsIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhclJlZikge1xuICAgICAgICAgIHBhclJlZiA9IF9ieUlEKHBhclJlZik7XG4gICAgICAgICAgaWYgKHRhZ05hbWUocGFyUmVmKSkge1xuICAgICAgICAgICAgcGFyTm9kZSA9IHBhclJlZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJOb2RlICYmIGVsKSB7XG4gICAgICAgICAgcGFyTm9kZSA9IHBhcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IF9jc3RyKGNzc1RleHQpIHx8IGNzcyhlbCkgfHwgXCJcIjtcbiAgICAgICAgY2wgPSBtYWtlX2lmcmFtZShhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXBhck5vZGUpIHtcbiAgICAgICAgICBhcHBlbmQodGhlRG9jdW1lbnQuYm9keSwgY2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmcmFtZUVsKSB7XG4gICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChjbCwgZnJhbWVFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChjbCwgZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwZW5kKHBhck5vZGUsIGNsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIGNsID0gZWwgPSBhdHRycyA9IGZyYW1lRWwgPSBwYXJOb2RlID0gY2IgPSBudWxsO1xuICAgICAgcmV0dXJuIGVsdChlbElEKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSB0aGUgd2luZG93IHJlZmVyZW5jZSBpbnNpZGUgb2YgYW4gSUZSQU1FLiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCAkc2YubGliLmRvbS52aWV3IHdoaWNoXG4gICAgcmV0dXJucyB0aGUgcGFyZW50IHdpbmRvdyByZWZlcmVuY2Ugb2YgYW4gZWxlbWVudC5cbiAgICBcbiAgICBOb3RlIHRoYXQgZXZlbiBpbiBjcm9zcy1kb21haW4gc2NlbmFyaW9zLCB5b3UgYXJlIHN1cHBvc2VkIHRvIGFibGUgdG8gZ2V0IGFjY2VzcyB0byB0aGUgd2luZG93IHJlZmVyZW5jZS5cbiAgICBJbiBhIGNyb3NzLWRvbWFpbiBzY2VuYXJpbywgeW91IHdvdWxkIG5vdCBiZSBhYmxlIHRvIHRoZW4gYWNlc3NzIG1vc3QgcHJvcGVydGllcyAvIG1ldGhvZHMgLyBvYmplY3RzIG9mIHRoYXRcbiAgICB3aW5kb3csIGJ1dCB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBhbGxvd2VkLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMudmlld1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGlmcmFtZSBlbGVtZW50IHRvIHNhZmVseSBnZXQgYmFjayB0aGUgd2luZG93XG4gICAgQHJldHVybiB7SFRNTFdpbmRvd30gdGhlIHdpbmRvdyByZWZlcmVuY2UgaW5zaWRlIHRoZSBpZnJhbWUuXG4gICAgICovXG4gICAgaWZyYW1lX3ZpZXcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGVsRG9jLCBlbFdpbiwgZXJyLCBmZSwgZnJhbWUsIGZyYW1lX2xpc3QsIGlkeCwgbG9jYWxXaW47XG4gICAgICBsb2NhbFdpbiA9IHZvaWQgMDtcbiAgICAgIGVsV2luID0gdm9pZCAwO1xuICAgICAgZWxEb2MgPSB2b2lkIDA7XG4gICAgICBmcmFtZV9saXN0ID0gdm9pZCAwO1xuICAgICAgZnJhbWUgPSB2b2lkIDA7XG4gICAgICBmZSA9IHZvaWQgMDtcbiAgICAgIGlkeCA9IDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgZXJyID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxXaW4gPSBlbC5jb250ZW50V2luZG93IHx8IG51bGw7XG4gICAgICAgIGlmICghd2luKSB7XG4gICAgICAgICAgZWxEb2MgPSBkb2MoZWwpO1xuICAgICAgICAgIGVsV2luID0gZWxEb2MgJiYgdmlldyhlbERvYyk7XG4gICAgICAgICAgZnJhbWVfbGlzdCA9IChlbFdpbiAmJiBlbFdpbi5mcmFtZXMpIHx8IFtdO1xuICAgICAgICAgIHdoaWxlIChmcmFtZSA9IGZyYW1lX2xpc3RbaWR4KytdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZSA9IGZyYW1lLmZyYW1lRWxlbWVudDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIGZlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZSAmJiBmZSA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgbG9jYWxXaW4gPSBmcmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgbG9jYWxXaW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsV2luO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBnYyA9IF9sYW5nLm5vb3A7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEFUVFJfTkFNRSwgQ1JFQVRFX0VWRU5ULCBFVlRfVFlQRSwgZXJyLCBvYmosIHByb3A7XG4gICAgICBvYmogPSB2b2lkIDA7XG4gICAgICBBVFRSX05BTUUgPSBcIlNDUk9MTElOR1wiO1xuICAgICAgQ1JFQVRFX0VWRU5UID0gXCJjcmVhdGVFdmVudFwiO1xuICAgICAgRVZUX1RZUEUgPSBcIlVJRXZlbnRcIjtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICBlcnIgPSB2b2lkIDA7XG4gICAgICBpZiAoaXNJRSkge1xuICAgICAgICBldnRfdGd0X3Byb3BfYSA9IFwic3JjRWxlbWVudFwiO1xuICAgICAgICBldnRfdGd0X3Byb3BfYiA9IFwidGFyZ2V0XCI7XG4gICAgICAgIG9iaiA9IG1ha2VfZWxlbWVudChJRlJBTUUpO1xuICAgICAgICBhdHRyKG9iaiwgQVRUUl9OQU1FLCBcIm5vXCIpO1xuICAgICAgICB1c2VPbGRTdHlsZUF0dHJNZXRob2RzID0gYXR0cihvYmosIEFUVFJfTkFNRSkgIT09IFwibm9cIjtcbiAgICAgICAgaWYgKEdDIGluIHdpbikge1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICBAaWdub3JlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZ2MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChnY190aW1lcl9pZCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2NfdGltZXJfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2NfdGltZXJfaWcoc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5bR0NdKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICAgIH0sIElFX0dDX0lOVEVSVkFMKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYyA9IF9sYW5nLm5vb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9hID0gXCJ0YXJnZXRcIjtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2IgPSBcImN1cnJlbnRUYXJnZXRcIjtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5bdzNjX2F0dGFjaF0gJiYgIWlzSUUpIHtcbiAgICAgICAgdXNlX2F0dGFjaCA9IHczY19hdHRhY2g7XG4gICAgICAgIHVzZV9kZXRhY2ggPSB3M2NfZGV0YWNoO1xuICAgICAgfSBlbHNlIGlmIChpc0lFKSB7XG4gICAgICAgIHVzZV9pZV9vbGRfYXR0YWNoID0gdHJ1ZTtcbiAgICAgICAgdXNlX2F0dGFjaCA9IGllX2F0dGFjaDtcbiAgICAgICAgdXNlX2RldGFjaCA9IGllX2RldGFjaDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBvYmogPSB0aGVEb2N1bWVudFtDUkVBVEVfRVZFTlRdKEVWVF9UWVBFKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgIG9iaiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9iaiA9IHRoZURvY3VtZW50W0NSRUFURV9FVkVOVF0oRVZUX1RZUEUgKyBcInNcIik7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBFVlRfQ05DTF9NRVRIT0RTKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSkge1xuICAgICAgICAgICAgRVZUX0NOQ0xfTUVUSE9EU1twcm9wXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmogPSBudWxsO1xuICAgICAgYXR0YWNoKHdpbiwgXCJsb2FkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIHJldHVybiBhdHRhY2god2luLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGRvbSA9IHtcbiAgICAgIGRvYzogZG9jLFxuICAgICAgdmlldzogdmlldyxcbiAgICAgIGVsdDogZWx0LFxuICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICBwYXI6IHBhcixcbiAgICAgIG1ha2U6IG1ha2VfZWxlbWVudCxcbiAgICAgIGNzczogY3NzLFxuICAgICAgYXR0cjogYXR0cixcbiAgICAgIGdjOiBnYyxcbiAgICAgIGFwcGVuZDogYXBwZW5kLFxuICAgICAgcHVyZ2U6IHB1cmdlLFxuICAgICAgYXR0YWNoOiBhdHRhY2gsXG4gICAgICBkZXRhY2g6IGRldGFjaCxcbiAgICAgIHJlYWR5OiByZWFkeSxcbiAgICAgIHdhaXQ6IHdhaXQsXG4gICAgICBldnRDbmNsOiBldnRDbmNsLFxuICAgICAgZXZ0VGd0OiBldnRUZ3QsXG4gICAgICBpZnJhbWVzOiB7XG4gICAgICAgIG1ha2U6IG1ha2VfaWZyYW1lLFxuICAgICAgICBjbG9uZTogY2xvbmVfaWZyYW1lLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlX2lmcmFtZSxcbiAgICAgICAgdmlldzogaWZyYW1lX3ZpZXdcbiAgICAgIH1cbiAgICB9O1xuICB9KSh3aW5kb3csIGxhbmcsIGVudik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgbGFuZyxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGNhY2hlZF91YSwgaXNJRSwgaXNJRTExLCBuYXZpZ2F0b3IsIHRoZURvY3VtZW50LCB1YSwgdXNlckFnZW50LCB3aW47XG4gICAgd2luID0gd2luZG93O1xuICAgIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgdGhlRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdXNlckFnZW50ID0gKG5hdmlnYXRvciAhPSBudWxsID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6IHZvaWQgMCkgfHwgXCJcIjtcbiAgICBpc0lFMTEgPSAhd2luZG93LkFjdGl2ZVhPYmplY3QgJiYgX19pbmRleE9mLmNhbGwod2luZG93LCBcIkFjdGl2ZVhPYmplY3RcIikgPj0gMDtcbiAgICBpc0lFID0gIWlzSUUxMSAmJiAod2luICYmIChfX2luZGV4T2YuY2FsbCh3aW4sIFwiQWN0aXZlWE9iamVjdFwiKSA+PSAwKSk7XG4gICAgY2FjaGVkX3VhID0gbnVsbDtcbiAgICB1YSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIENvbnZlcnQgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGEgbnVtZXJpYyB2YWx1ZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLV9udW1iZXJpZnlcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzIFRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdmVyc2lvbiBudW1iZXIgKGUuZy4gJ21ham9yLm1pbm9yLnJldmlzaW9uJylcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBwYXJzZV91YSwgX21hdGNoSXQsIF9udW1iZXJpZnksIF90ZXN0SXQ7XG4gICAgICBfbnVtYmVyaWZ5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgYyA9IDA7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHMucmVwbGFjZSgvXFwuL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjKysgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgV3JhcHBlciBtZXRob2QgZm9yIHJldHVybmluZyB2YWx1ZXMgZnJvbSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBzYWZlbHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEtX21hdGNoSXRcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICBAcGFyYW0ge1JlZ0V4cH0gcmVnRXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgZm9yIG1hdGNoaW5nXG4gICAgICBAcGFyYW0ge051bWJlcn0gW2lkeF0gVGhlIGluZGV4IG51bWJlciBvZiBhIG1hdGNoIHRvIHB1bGwgZnJvbVxuICAgICAgQHJldHVybnMge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgX21hdGNoSXQgPSBmdW5jdGlvbihzdHIsIHJlZ0V4LCBpZHgpIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIG0gPSBzdHIgJiYgc3RyLm1hdGNoKHJlZ0V4KTtcbiAgICAgICAgaWYgKCEoaWR4ICE9IG51bGwpKSB7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChtICYmIG1baWR4XSkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFdyYXBwZXIgbWV0aG9kIGZvciB0ZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS1fdGVzdEl0XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1JlZ0V4cH0gcmVnRXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IHdpdGhcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3Rlc3RJdCA9IGZ1bmN0aW9uKHJlZ0V4LCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ0V4LnRlc3Qoc3RyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBQYXJzZSBhIHVzZXItYWdlbnQgc3RyaW5nIGZyb20gdGhlIGJyb3dzZXIgYW5kIGdhdGhlciBwZXJ0aW5lbnQgYnJvd3NlciwgYW5kIE9TIGluZm9ybWF0aW9uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEucGFyc2VcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtzdWJVQV0gQW4gYWx0ZXJuYXRlIHVzZXItYWdlbnQgc3RyaW5nIHRvIHBhcnNlLiBJZiBubyB2YWxpZCBzdHJpbmcgaXMgcGFzc2VkIGluLCBmdW5jdGlvbiB3aWxsIHJldHVybiBhbiBvYmplY3QgYmFzZWQgb24gdGhlIGtub3duIHVzZXItYWdlbnRcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IDxiPnBhcnNlZDwvYj4gQnJvd3NlciBhbmQgT1MgaW5mb3JtYXRpb248YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaWUgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ub3BlcmEgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBPcGVyYSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5nZWNrbyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEdlY2tvIChGaXJlZm94KSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi53ZWJraXQgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJLaXQgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uc2FmYXJpIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2FmYXJpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmNocm9tZSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENocm9tZSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5haXIgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBSVIgU0RLIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pcG9kIFdoZXRoZXIgb3Igbm90IGFuIGlQb2QgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmlwYWQgV2hldGhlciBvciBub3QgYW4gaVBhZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaXBob25lIFdoZXRoZXIgb3Igbm90IGFuIGlQaG9uZSBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uYW5kcm9pZCBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFuZHJvaWQgT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LndlYm9zIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnNpbGsgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBTaWxrIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+Lm5vZGVqcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE5vZGVKUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ucGhhbnRvbWpzIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgUGhhbnRvbUpTIGVudmlyb25tZW50IGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge1N0cmluZ30gPGI+cGFyc2VkPC9iPi5tb2JpbGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gb3MgaXMgYSBtb2JpbGUgZGV2aWNlICBhbmQgaXQncyB0eXBlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd3aW5kb3dzJywgJ2FuZHJvaWQnLCAnc3ltYm9zJywgJ2xpbnV4JywgJ21hY2ludG9zaCcsICdyaGlubycsICdnZWNrbycsICdBcHBsZScsICdjaHJvbWUnLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pb3MgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBpT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7Qm9vbGVhbn0gPGI+cGFyc2VkPC9iPi5hY2NlbCBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIGVudmlyb25tZW50IGluIHF1ZXN0aW9uIGlzIGhhcmR3YXJlIGFjY2VsZXJhdGVkLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5jYWphVmVyc2lvbiBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENBSkEgZW52aXJvbm1lbnQgb3IgMCBpZiBub3QuXG4gICAgICAgKi9cbiAgICAgIHBhcnNlX3VhID0gZnVuY3Rpb24oc3ViVUEpIHtcbiAgICAgICAgdmFyIGRhdGUsIGUsIG1hdGNoLCByZXQ7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKCFzdWJVQSAmJiBjYWNoZWRfdWEpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkX3VhO1xuICAgICAgICB9XG4gICAgICAgIHJldC5pZSA9IHJldC5vcGVyYSA9IHJldC5nZWNrbyA9IHJldC53ZWJraXQgPSByZXQuc2FmYXJpID0gcmV0LmNocm9tZSA9IHJldC5haXIgPSByZXQuaXBvZCA9IHJldC5pcGFkID0gcmV0LmlwaG9uZSA9IHJldC5hbmRyb2lkID0gcmV0LndlYm9zID0gcmV0LnNpbGsgPSByZXQubm9kZWpzID0gcmV0LnBoYW50b21qcyA9IDA7XG4gICAgICAgIHJldC5tb2JpbGUgPSByZXQuaW9zID0gcmV0Lm9zID0gbnVsbDtcbiAgICAgICAgcmV0LmFjY2VsID0gZmFsc2U7XG4gICAgICAgIHJldC5jYWphID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5jYWphVmVyc2lvbjtcbiAgICAgICAgcmV0LmNrcyA9IGZhbHNlO1xuICAgICAgICBzdWJVQSA9IHN1YlVBIHx8IHVzZXJBZ2VudCB8fCBcIlwiO1xuICAgICAgICBpZiAoc3ViVUEpIHtcbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvd2luZG93c3x3aW4zMi9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwid2luZG93c1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvbWFjaW50b3NofG1hY19wb3dlcnBjL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJtYWNpbnRvc2hcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL2FuZHJvaWQvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcImFuZHJvaWRcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL3N5bWJvcy9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwic3ltYm9zXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9saW51eC9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwibGludXhcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF90ZXN0SXQoL3JoaW5vL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgICByZXQub3MgPSBcInJoaW5vXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9LSFRNTC8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0LndlYmtpdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9JRU1vYmlsZXxYQkxXUDcvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIndpbmRvd3NcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL0Zlbm5lYy8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiZ2Vja29cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL0FwcGxlV2ViS2l0XFwvKFteXFxzXSopLywgMSk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXQud2Via2l0ID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICByZXQuc2FmYXJpID0gcmV0LndlYmtpdDtcbiAgICAgICAgICAgIGlmIChfdGVzdEl0KC9QaGFudG9tSlMvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL1BoYW50b21KU1xcLyhbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQucGhhbnRvbWpzID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGVzdEl0KFJlZ0V4cChcIiBNb2JpbGVcXFxcL1wiKSwgc3ViVUEpIHx8IF90ZXN0SXQoL2lQYWR8aVBvZHxpUGhvbmUvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiQXBwbGVcIjtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09TIChbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoICYmIF9udW1iZXJpZnkobWF0Y2gucmVwbGFjZShcIl9cIiwgXCIuXCIpKTtcbiAgICAgICAgICAgICAgcmV0LmlvcyA9IG1hdGNoO1xuICAgICAgICAgICAgICByZXQuaXBhZCA9IHJldC5pcG9kID0gcmV0LmlwaG9uZSA9IDA7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9pUGFkfGlQb2R8aVBob25lLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldFttYXRjaC50b0xvd2VyQ2FzZSgpXSA9IHJldC5pb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9Ob2tpYU5bXlxcL10qfEFuZHJvaWQgXFxkXFwuXFxkfHdlYk9TXFwvXFxkXFwuXFxkLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvd2ViT1MvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gXCJXZWJPU1wiO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC93ZWJPU1xcLyhbXlxcc10qKTsvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC53ZWJvcyA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdChSZWdFeHAoXCIgQW5kcm9pZFwiKSwgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiQW5kcm9pZFwiO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BbmRyb2lkIChbXlxcc10qKTsvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hbmRyb2lkID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGVzdEl0KC9TaWxrLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL1NpbGtcXC8oW15cXHNdKilcXCkvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5zaWxrID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmV0LmFuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hbmRyb2lkID0gMi4zNDtcbiAgICAgICAgICAgICAgICAgIHJldC5vcyA9IFwiQW5kcm9pZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvQWNjZWxlcmF0ZWQ9dHJ1ZS8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgICAgcmV0LmFjY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoID0gc3ViVUEubWF0Y2goLyhDaHJvbWV8Q3JNbylcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICByZXQuY2hyb21lID0gX251bWJlcmlmeShtYXRjaFsyXSk7XG4gICAgICAgICAgICAgIHJldC5zYWZhcmkgPSAwO1xuICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwiQ3JNb1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiY2hyb21lXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BZG9iZUFJUlxcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQuYWlyID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXQud2Via2l0KSB7XG4gICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT3BlcmFbXFxzXFwvXShbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHJldC5vcGVyYSA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT3BlcmEgTWluaVteO10qLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL01TSUVcXHMoW147XSopLywgMSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5pZSA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9HZWNrb1xcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgcmV0LmdlY2tvID0gMTtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9ydjooW15cXHNcXCldKikvLCAxKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXQuZ2Vja28gPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgICAgICB0aGVEb2N1bWVudC5jb29raWUgPSBsYW5nLmNzdHIoW1wic2ZfY2tfdHN0PXRlc3Q7IGV4cGlyZXM9XCIsIGRhdGUudG9HTVRTdHJpbmcoKSwgXCI7IHBhdGg9L1wiXSk7XG4gICAgICAgICAgaWYgKHRoZURvY3VtZW50LmNvb2tpZS5pbmRleE9mKFwic2ZfY2tfdHN0XCIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0LmNrcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJldC5ja3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgICAgICAgICAgIHJldC5vcyA9IHByb2Nlc3MucGxhdGZvcm07XG4gICAgICAgICAgICAgIHJldC5ub2RlanMgPSBudW1iZXJpZnkocHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgcmV0Lm5vZGVqcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaWVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgT3BlcmEgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEBuYW1lICRzZi5lbnYudWEub3BlcmFcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgR2Vja28gKEZpcmVmb3gpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmdlY2tvXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYktpdCBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS53ZWJraXRcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2FmYXJpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnNhZmFyaVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDaHJvbWUgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuY2hyb21lXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFJUiBTREsgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmFpclxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgYW4gaVBvZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCwgMCBmb3IgZmFsc2UsICZndDsgMCA9PSB0cnVlXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlwb2RcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IGFuIGlQYWQgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcGFkXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCBhbiBpUGhvbmUgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcGhvbmVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQW5kcm9pZCBPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuYW5kcm9pZFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEud2Vib3NcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2lsayBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5zaWxrXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE5vZGVKUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEubm9kZWpzXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFBoYW50b21KUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEucGhhbnRvbWpzXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBvcyBpcyBhIG1vYmlsZSBkZXZpY2UgIGFuZCBpdCdzIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3dpbmRvd3MnLCAnYW5kcm9pZCcsICdzeW1ib3MnLCAnbGludXgnLCAnbWFjaW50b3NoJywgJ3JoaW5vJywgJ2dlY2tvJywgJ0FwcGxlJywgJ2Nocm9tZScuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEubW9iaWxlXG4gICAgICBAdHlwZSB7U3RyaW5nfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIGlPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaW9zXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIGVudmlyb25tZW50IGluIHF1ZXN0aW9uIGlzIGhhcmR3YXJlIGFjY2VsZXJhdGVkLlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5hY2NlbFxuICAgICAgQHR5cGUge0Jvb2xlYW59XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ0FKQSBlbnZpcm9ubWVudCBvciAwIGlmIG5vdFxuICAgICAgQG5hbWUgJHNmLmVudi51YS5jYWphVmVyc2lvblxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuICAgICAgY2FjaGVkX3VhID0gcGFyc2VfdWEoKTtcbiAgICAgIGNhY2hlZF91YS5wYXJzZSA9IHBhcnNlX3VhO1xuICAgICAgcmV0dXJuIGNhY2hlZF91YTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICB1YTogdWEsXG4gICAgICBpc0lFOiBpc0lFXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgUGFyYW1IYXNoLCBiYWNrU2xhc2gsIGNhbGxhYmxlLCBjYm9vbCwgY251bSwgY3N0ciwgZGVmLCBlbnRpdHlNYXAsIGVudGl0eVJlZ2V4ZXMsIGd1aWQsIGlzQXJyYXksIGpzc2FmZV9odG1sLCBsYW5nLCBtaXgsIG5leHRfaWQsIG5vb3AsIG5zLCBwcm90bywgcmFuZCwgc2NyaXBfc3RyLCB0aW1lLCB0b1N0cmluZywgdHJpbSwgd2luLCB3cmFwLCBfZXMsIF9rZXlzLCBfdWU7XG4gICAgbmV4dF9pZCA9IDA7XG4gICAgd2luID0gd2luZG93O1xuICAgIGJhY2tTbGFzaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTIpO1xuICAgIHNjcmlwX3N0ciA9ICdzY3JcIitcImlwdCc7XG4gICAgX2VzID0gd2luLmVzY2FwZTtcbiAgICBfdWUgPSB3aW4udW5lc2NhcGU7XG5cbiAgICAvKlxuICAgIEEgZnVuY3Rpb24gcmVmZXJlbmNlIHRoYXQgZG9lcyBub3RoaW5nLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBub29wIGFzICRzZi5saWIubGFuZy5ub29wXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwdWJsaWNcbiAgICBAcmV0dXJuIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIG5vb3AgPSBmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBOb3RlIHRoYXQgXCJmYWxzeVwiIHZhbHVlcyBvciB2YWx1ZXMgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgIGFzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikuXG4gICAgICBcbiAgICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICAgIEBleHBvcnRzIGNzdHIgYXMgJHNmLmxpYi5sYW5nLmNzdHJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHsqfSBzdHIgIEFueSBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9ICBUaGUgbm9ybWFsaXplZCBzdHJpbmcgdmFsdWUuXG4gICAgICAgKi9cbiAgICB9O1xuICAgIGNzdHIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciB0eXA7XG4gICAgICB0eXAgPSB0eXBlb2Ygc3RyO1xuICAgICAgaWYgKHR5cCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJudW1iZXJcIiAmJiAhc3RyKSB7XG4gICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwib2JqZWN0XCIgJiYgc3RyICYmIHN0ci5qb2luKSB7XG4gICAgICAgIHJldHVybiBzdHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIGJvb2xlYW4uXG4gICAgXCJGYWxzeVwiIHZhbHVlcyBzdWNoIGFzIFwiXCIsIDAsIG51bGwsIGFuZCB1bmRlZmluZWQgYWxsIHJldHVybiBmYWxzZVxuICAgIFN0cmluZyB2YWx1ZXMgb2YgIFwiMFwiLCBcImZhbHNlXCIsIFwibm9cIiwgXCJ1bmRlZmluZWRcIiwgXCJudWxsXCIgYWxzbyByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY2Jvb2wgYXMgJHNmLmxpYi5sYW5nLmNib29sXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyp9IHZhbCBBbnkgSmF2YVNjcmlwdCByZWZlcmVuY2UgLyB2YWx1ZVxuICAgIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub3JtYWxpemVkIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBjYm9vbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKCF2YWwgfHwgdmFsID09PSBcIjBcIiB8fCB2YWwgPT09IFwiZmFsc2VcIiB8fCB2YWwgPT09IFwibm9cIiB8fCB2YWwgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgaywgX3Y7XG4gICAgICByZXR1cm4gKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmtleXMob2JqKSA6IHZvaWQgMCkgfHwgKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgX3YgPSBvYmpba107XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBGb3JjZXMgdHlwZSBjb252ZXJzaW9uIG9mIGFueSBKYXZhU2NyaXB0IHZhcmlhYmxlIHRvIGEgbnVtYmVyLlxuICAgIFZhbHVlcyAvIG9iamVjdHMgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkLCB3aWxsIGJlIHJldHVybmVkIGFzIE5hTiwgdW5sZXNzXG4gICAgYSBkZWZhdWx0IHZhbHVlIGlzIHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyB1c2VkLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjbnVtIGFzICRzZi5saWIubGFuZy5jbnVtXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyp9IHZhbCBBbnkgSmF2YVNjcmlwdCByZWZlcmVuY2UgLyB2YWx1ZVxuICAgIEBwYXJhbSB7Kn0gW2RlZlZhbF0gdXNlIHRoaXMgdmFsdWUgaWYgb3JpZ2luYWwgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgb3IgaWYgdmFsdWUgaXMgbGVzcyB0aGFuIG1pbiB2YWx1ZSwgb3IgaWYgdmFsdWUgaXMgbGVzcyB0aGFuIG1heCB2YWx1ZS5cbiAgICBAcGFyYW0ge051bWJlcn0gW21pblZhbF0gc3BlY2lmaWVzIHRoZSBsb3dlc3QgbnVtZXJpY2FsIHZhbHVlLCBpZiBvcmlnaW5hbCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGRlZlZhbCB3aWxsIGJlIHJldHVybmVkLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbbWF4VmFsXSBzcGVjaWZpZXMgdGhlIGdyZWF0ZXN0IG51bWVyaWNhbCB2YWx1ZSwgaWYgb3JpZ2luYWwgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBkZWZWYWwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICBAcmV0dXJuIHtOdW1iZXJ8TmFOfCp9IHRoZSBjb252ZXJ0ZWQgdmFsdWUsIG90aGVyd2lzZSBOYU4gb3IgZGVmYXVsdCB2YWx1ZVxuICAgICAqL1xuICAgIGNudW0gPSBmdW5jdGlvbih2YWwsIGRlZlZhbCwgbWluVmFsLCBtYXhWYWwpIHtcbiAgICAgIHZhciBlO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgdmFsID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICB2YWwgPSBOdW1iZXIuTmFOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF4VmFsID09IG51bGwpIHtcbiAgICAgICAgbWF4VmFsID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5WYWwgPT0gbnVsbCkge1xuICAgICAgICBtaW5WYWwgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIGlmICgoaXNOYU4odmFsKSB8fCB2YWwgPCBtaW5WYWwgfHwgdmFsID4gbWF4VmFsKSAmJiAoZGVmVmFsICE9IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBkZWZWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyB0aGF0IGEgZnVuY3Rpb24gcmVmZXJlbmNlIGNhbiBiZSBjYWxsZWQgc2FmZWx5LiAgU29tZXRpbWVzIGZ1bmN0aW9uIHJlZmVyZW5jZXMgYXJlIHBhcnRcbiAgICBvZiBvYmplY3RzIHRoYXQgbWF5IGhhdmUgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZCAoc3VjaCBhcyBhIGZ1bmN0aW9uIHJlZmVyZW5jZSBmcm9tIGFub3RoZXIgd2luZG93IG9yIGRvbSBlbGVtZW50KS5cbiAgICBUaGlzIG1ldGhvZCBjaGVja3MgdGhlIHJlZmVyZW5jZSBieSBtYWtpbmcgc3VyZSBpdCBoYXMgYSBjb25zdHJ1Y3RvciBhbmQgdG9TdHJpbmcgcHJvcGVydGllcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgZnVuY3Rpb24gaXRzZWxmIHdoZW4gY2FsbGVkIChvciBpdHMgc3Vic3F1ZW50IGNhbGwgc3RhY2spLCBjYW4ndCB0aHJvdyBhbiBlcnJvci4gLiAuXG4gICAgc2ltcGx5IHRoYXQgeW91IGFyZSBhYmxlIHRvIGNhbGwgaXQuIC4gLlxuICAgIFxuICAgIHRoaXMgY2FuIHByb2JsZW0gYmUgcmVtb3ZlZCBpbiBsaWV1IG9mIGZ1bmM/KCkgaW4gY3NcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY2FsbGFibGUgYXMgJHNmLmxpYi5sYW5nLmNhbGxhYmxlXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBBIHJlZmVyZW5jZSB0byBhIEphdmFTY3JpcHQgZnVuY3Rpb25cbiAgICBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgc2FmZWx5LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgY2FsbGFibGUgPSBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGYgPSAoZiAmJiB0eXBlb2YgZiA9PT0gXCJmdW5jdGlvblwiICYmIGYudG9TdHJpbmcoKSAmJiAobmV3IGYuY29uc3RydWN0b3IoKSkgPyBmIDogbnVsbCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgZiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFmO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdlbmVyYXRlIGEgdW5pcXVlIGlkIHN0cmluZ1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBndWlkIGFzICRzZi5saWIubGFuZy5ndWlkXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeF0gYSBzdWJzdHJpbmcgdG8gdXNlIGEgcHJlZml4XG4gICAgQHJldHVybiB7U3RyaW5nfSB1bmlxdWUgaWQgc3RyaW5nXG4gICAgICovXG4gICAgZ3VpZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgICAgcmV0dXJuIGNzdHIoW3ByZWZpeCB8fCBcIlwiLCBcIl9cIiwgdGltZSgpLCBcIl9cIiwgcmFuZCgpLCBcIl9cIiwgbmV4dF9pZCsrXSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWl4ZWQgdGhlIHByb3BlcnRpZXMgb2Ygb25lIG9iamVjdCBpbnRvIGFub3RoZXIgb2JqZWN0LlxuICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHJlY3Vyc2l2ZVxuICAgIFxuICAgIFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBtaXggYXMgJHNmLmxpYi5sYW5nLm1peFxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtPYmplY3R9ICByICBUaGUgb2JqZWN0IHRoYXQgd2lsbCByZWNlaXZlIHByb3BlcnRpZXNcbiAgICBAcGFyYW0ge09iamVjdH0gIHMgIFRoZSBvYmplY3QgdGhhdCB3aWxsIGRlbGlldmVyIHByb3BlcnRpZXNcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtvd25lZF0gV2hldGhlciBvciBub3QgdG8gc2tpcCBvdmVyIHByb3BlcnRpZXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgb2JqZWN0IHByb3RvdHlwZVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBGdW5jc10gV2hldGhlciBvciBub3QgdG8gc2tpcCBvdmVyIGZ1bmN0aW9uIHJlZmVyZW5jZXNcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtub19vdnJdIFdoZXRoZXIgb3Igbm90IHRvIG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIHRoYXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGZpbGxlZCBvdXRcbiAgICBAcmV0dXJuIHtPYmplY3R9IFRoZSByZWNlaXZlciBvYmplY3QgcGFzc2VkIGluIHdpdGggcG90ZW50aWFsbHkgbmV3IHByb3BlcnRpZXMgYWRkZWRcbiAgICAgKi9cbiAgICBtaXggPSBmdW5jdGlvbihyLCBzLCBvd25lZCwgc2tpcEZ1bmNzLCBub19vdnIpIHtcbiAgICAgIHZhciBpdGVtLCBwLCB0eXA7XG4gICAgICBpZiAoIXMgfHwgIXIpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgICBmb3IgKHAgaW4gcykge1xuICAgICAgICBpdGVtID0gc1twXTtcbiAgICAgICAgdHlwID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmIChvd25lZCAmJiAhcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub19vdnIgJiYgKHAgaW4gcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcEZ1bmNzICYmIHR5cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cCA9PT0gXCJvYmplY3RcIiAmJiBpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uc2xpY2UpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtaXgoW10sIGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gbWl4KHt9LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcltwXSA9IGl0ZW07XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMsIGZyb20gdGhlIGVwb2NoXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIHRpbWUgYXMgJHNmLmxpYi5sYW5nLnRpbWVcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEByZXR1cm4ge051bWJlcn0gY3VycmVudCB0aW1lXG4gICAgICovXG4gICAgdGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYW55d2hlcmUgZnJvbSAwIHRvIDk5XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIHJhbmQgYXMgJHNmLmxpYi5sYW5nLnJhbmRcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEByZXR1cm4ge051bWJlcn0gcmFuZG9tIG51bWJlclxuICAgICAqL1xuICAgIHJhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFRyaW0gdGhlIGJlZ2luaW5nIGFuZCBlbmRpbmcgd2hpdGVzcGFjZSBmcm9tIGEgc3RyaW5nLlxuICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhbiBhcmd1bWVudCB0byBhIHN0cmluZyBmaXJzdFxuICAgIGZvciB0eXBlIHNhZmV0eSBwdXJwb3Nlcy4gSWYgc3RyaW5nIGNhbm5vdCBiZSBjb252ZXJ0ZWQsIGFuZCBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgdHJpbSBhcyAkc2YubGliLmxhbmcudHJpbVxuICAgIEByZXR1cm4ge1N0cmluZ30gdHJpbW1lZCBzdHJpbmdcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgICAqL1xuICAgIHRyaW0gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICByZXQgPSBjc3RyKHN0cik7XG4gICAgICByZXR1cm4gcmV0ICYmIHJldC5yZXBsYWNlKC9eXFxzXFxzKi8sIFwiXCIpLnJlcGxhY2UoL1xcc1xccyokLywgXCJcIik7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRGVmaW5lIGEgSmF2YVNjcmlwdCBOYW1lc3BhY2Ugd2l0aGluIGEgZ2l2ZW4gY29udGV4dFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBkZWYgYXMgJHNmLmxpYi5sYW5nLmRlZlxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJfbnMgIFRoZSBuYW1lIG9mIHRoZSBuYW1lc3BhY2UgaW4gZG90IG5vdGF0aW9uIGFzIGEgc3RyaW5nIChlLmcuIFwiRm9vLmJhclwiKVxuICAgIEBwYXJhbSB7T2JqZWN0fSBbYXVnXSBkZWZpbmVzIHRoZSBvYmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZXNwYWNlLiAgSWYgbmFtZXNwYWNlIGlzIGFscmVhZHkgc3BlY2lmaWVkLCBhbmQgdGhpcyBvYmplY3QgaXMgcHJvdmlkZWQsIHRoZSBuYW1lc3BhY2Ugd2lsbCBiZSBhdWdtZW50ZWQgd2l0aCBwcm9wZXJ0aWVzIGZyb20gdGhpcyBvYmplY3QuIElmIG5vdGhpbmcgaXMgcGFzc2VkIGluLCBkZWZhdWx0cyB0byB1c2luZyBhbiBlbXB0eSBvYmplY3QuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtyb290XSB0aGUgcm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgbmFtZXNwYWNlIGlzIGRlZmluZWQuICBJZiBub3QgcGFzc2VkIGluIGRlZmF1bHRzIHRvIHRoZSBnbG9iYWwvd2luZG93IG9iamVjdFxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW25vX292cl0gaWYgdHJ1ZSwgcHJvcGVydGllcyBhbHJlYWR5IGRlZmluZWQgb24gcm9vdCB3aXRoIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBpZ25vcmVkXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZXNwYWNlXG4gICAgICovXG4gICAgZGVmID0gZnVuY3Rpb24oc3RyX25zLCBhdWcsIHJvb3QsIG5vX292cikge1xuICAgICAgdmFyIGFyLCBpZHgsIGl0ZW0sIG9iaiwgcGVyLCByZXQ7XG4gICAgICBvYmogPSAocm9vdCAmJiB0eXBlb2Ygcm9vdCA9PT0gXCJvYmplY3RcIiA/IHJvb3QgOiB3aW4pO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHBlciA9IFwiLlwiO1xuICAgICAgcmV0ID0gbnVsbDtcbiAgICAgIGlmIChzdHJfbnMpIHtcbiAgICAgICAgc3RyX25zID0gY3N0cihzdHJfbnMpO1xuICAgICAgICBhdWcgPSAoYXVnICYmIHR5cGVvZiBhdWcgPT09IFwib2JqZWN0XCIgPyBhdWcgOiBudWxsKTtcbiAgICAgICAgaWYgKHN0cl9ucy5pbmRleE9mKHBlcikpIHtcbiAgICAgICAgICBhciA9IHN0cl9ucy5zcGxpdChwZXIpO1xuICAgICAgICAgIHdoaWxlIChpdGVtID0gYXJbaWR4KytdKSB7XG4gICAgICAgICAgICBpdGVtID0gdHJpbShpdGVtKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAob2JqW2l0ZW1dICYmIGF1Zykge1xuICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXSA9IG1peChvYmpbaXRlbV0sIGF1ZywgZmFsc2UsIG51bGwsIG5vX292cik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vX292ciAmJiAoaXRlbSBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXSA9IG9ialtpdGVtXSB8fCBhdWcgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobm9fb3ZyICYmIChpdGVtIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gb2JqW2l0ZW1dIHx8IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvYmpbc3RyX25zXSAmJiBhdWcpIHtcbiAgICAgICAgICAgIHJldCA9IG9ialtzdHJfbnNdID0gbWl4KG9ialtzdHJfbnNdLCBhdWcsIGZhbHNlLCBudWxsLCBub19vdnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBvYmpbc3RyX25zXSA9IG9ialtzdHJfbnNdIHx8IGF1ZyB8fCB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgSmF2YVNjcmlwdCBuYW1lc3BhY2VcbiAgICBhcyBvcHBvc2VkIHRvIGRlZiwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRlZmluZSB0aGUgbmFtZXNwYWNlXG4gICAgd2l0aCBhIGdpdmVuIGNvbnRleHQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG5zIGFzICRzZi5saWIubGFuZy5uc1xuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJfbnMgIEEgc3RyaW5nIHdpdGggLiBvciBbXSBub3RhdGlvbiBvZiBhIEphdmFTY3JpcHQgbmFtZXNhY2UgKGUuZy4gXCJmb28uYmFyLnNob3dcIiwgb3IgXCJmb29bJ2JhciddWydzaG93J11cIikuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtyb290XSB0aGUgcm9vdCBvYmplY3QgdG8gY2hlY2sgd2l0aGluLiAuZGVmYXVsdHMgdG8gZ2xvYmFsIC8gd2luZG93XG4gICAgQHJldHVybiB7Kn0gVGhlIGVuZHBvaW50IHJlZmVyZW5jZSBvZiB0aGUgbmFtZXNwYWNlIG9yIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgbnMgPSBmdW5jdGlvbihzdHJfbnMsIHJvb3QpIHtcbiAgICAgIHZhciBleGlzdHMsIGV4cCwgZXhwMiwgZXhwMywgZXhwNCwgaWR4LCBtYXRjaGVzLCBvYmosIHByb3AsIHJvb3RTdHI7XG4gICAgICBleHAgPSAvKFxcWyguezEsfSlcXF0pfChcXC5cXHcrKS9nO1xuICAgICAgZXhwMiA9IC9cXFsoKCd8XCIpPykoKFxcc3wuKSo/KSgoJ3xcIik/KVxcXS9nO1xuICAgICAgZXhwMyA9IC8oXFxbLiopfChcXC4uKikvZztcbiAgICAgIGV4cDQgPSAvXFwuL2c7XG4gICAgICBpZHggPSAwO1xuICAgICAgcm9vdFN0ciA9IFwiXCI7XG4gICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgb2JqID0gcm9vdCA9IHJvb3QgfHwgd2luO1xuICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICBzdHJfbnMgPSBjc3RyKHN0cl9ucyk7XG4gICAgICAgIGlmIChzdHJfbnMpIHtcbiAgICAgICAgICBzdHJfbnMgPSB0cmltKHN0cl9ucyk7XG4gICAgICAgICAgbWF0Y2hlcyA9IHN0cl9ucy5tYXRjaChleHApO1xuICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByb290U3RyID0gc3RyX25zLnJlcGxhY2UoZXhwMywgXCJcIik7XG4gICAgICAgICAgICBtYXRjaGVzLnVuc2hpZnQocm9vdFN0cik7XG4gICAgICAgICAgICB3aGlsZSAocHJvcCA9IG1hdGNoZXNbaWR4KytdKSB7XG4gICAgICAgICAgICAgIHByb3AgPSBwcm9wLnJlcGxhY2UoZXhwMiwgXCIkM1wiKS5yZXBsYWNlKGV4cDQsIFwiXCIpO1xuICAgICAgICAgICAgICBpZiAoIW9ialtwcm9wXSkge1xuICAgICAgICAgICAgICAgIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcCA9IHN0cl9ucztcbiAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChleGlzdHMgJiYgb2JqKSB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAZnVuY3Rpb25cbiAgICBUZXN0cyB0byBzZWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaXMgYW4gYXJyYXlcbiAgICAgKi9cbiAgICBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChvYmoubGVuZ3RoICE9IG51bGwpICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgSmF2YVNjcmlwdCBuYW1lc3BhY2VcbiAgICBhcyBvcHBvc2VkIHRvIGRlZiwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRlZmluZSB0aGUgbmFtZXNwYWNlXG4gICAgd2l0aCBhIGdpdmVuIGNvbnRleHQuICAgICAgICAgdmlhIHVuZGVyc2NvcmUuanNcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgbnMgYXMgJHNmLmxpYi5sYW5nLndyYXBcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgd3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgIGFyZ3MgPSBbZnVuY107XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBHaXZlbiBhIHN0cmluZyBvZiBIVE1MIGVzY2FwZSBxdW90ZSBtYXJrcyBhbmQgc2VwZXJhdGUgc2NyaXB0IHRhZ3Mgc28gdGhhdCBicm93c2VycyBkb24ndCBnZXQgdHJpcHBlZCB1cFxuICAgIGR1cmluZyBwcm9jZXNzaW5nLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBqc3NhZmVfaHRtbCBhcyAkc2YubGliLmxhbmcuanNzYWZlX2h0bWxcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyIEEgc3RyaW5nIG9mIEhUTUwgbWFya3VwIHRvIGJlIHByb2Nlc3NlZFxuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgICAqL1xuICAgIGVudGl0eU1hcCA9IHtcbiAgICAgIGVzY2FwZToge1xuICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgIFwiJ1wiOiAnJiN4Mjc7J1xuICAgICAgfVxuICAgIH07XG4gICAgZW50aXR5UmVnZXhlcyA9IHtcbiAgICAgIGVzY2FwZTogbmV3IFJlZ0V4cCgnWycgKyBfa2V5cyhlbnRpdHlNYXAuZXNjYXBlKS5qb2luKCcnKSArICddJywgJ2cnKVxuICAgIH07XG4gICAganNzYWZlX2h0bWwgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXMuZXNjYXBlLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW50aXR5TWFwLmVzY2FwZVttYXRjaF07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAY2xhc3MgSW50YW50aWFibGUgY2xhc3MgdXNlZCB0byBjb252ZXJ0IGEgZGVsaW1pdGVkIHN0cmluZyBpbnRvIGFuIG9iamVjdC48YnIgLz5cbiAgICBGb3IgZXhhbXBsZSBxdWVyeXN0cmluZ3M6IFwibmFtZV8xPXZhbHVlXzEmbmFtZV8yPXZhbHVlXzJcIiA9PT4ge25hbWVfMTp2YWx1ZV8xLG5hbWVfMjp2YWx1ZV8yfTs8YnIvPjxiciAvPlxuICAgIFxuICAgIE5vdGUgdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgY291bGQgYWxzbyBjb250YWluIHRoZSBzYW1lIHNQcm9wRGVsaW0gYW5kIHNWYWx1ZURlbGltIHN0cmluZ3MuICBQcm9wZXIgc3RyaW5nIGVuY29kaW5nIHNob3VsZCBvY2N1clxuICAgIHRvIG5vdCB0cmlwIHVwIHRoZSBwYXJzaW5nIG9mIHRoZSBzdHJpbmcuICBTYWlkIHZhbHVlcyBtYXkgYmUgYXNjaWkgZXNjYXBlZCwgYW5kIGluIHR1cm4sIGFsb25nIHdpdGggdGhlIDxpPjxiPmJSZWN1cnNlPC9iPjwvaT4gY29uc3RydWN0b3IgcGFyYW1ldGVyIHNldCB0byB0cnVlLCB3aWxsIGNhdXNlIG5lc3RlZCBQYXJhbUhhc2ggb2JqZWN0cyB0byBiZSBjcmVhdGVkLlxuICAgIFxuICAgIEBjb25zdHJ1Y3RvclxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBQYXJhbUhhc2ggYXMgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1N0cmluZ10gIFRoZSBkZWxpbWl0ZWQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1Byb3BEZWxpbT1cIiZcIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVyIHVzZWQgdG8gc2VwZXJhdGUgcHJvcGVydGllcy4gRGVmYXVsdCBpcyBcIiZcIi5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NWYWx1ZURlbGltPVwiPVwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZWQgdXNlZCB0byBzZXBlcmF0ZSB2YWx1ZXMuICBEZWZhdWx0IGlzIFwiPVwiLlxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2JOb092ZXJ3cml0ZT1mYWxzZV0gIElmIHRydWUsIHdoZW4gYSBuYW1lIGlzIGVuY291bnRlcmVkIG1vcmUgdGhhbiAxIHRpbWUgaW4gdGhlIHN0cmluZyBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgQHBhcmFtIHtCb29sZWFufSBbYlJlY3Vyc2U9ZmFsc2VdICBJZiB0cnVlLCB3aGVuIGEgdmFsdWUgb2YgYSBwcm9wZXJ0eSB0aGF0IGlzIHBhcnNlZCBhbHNvIGhhcyBib3RoIHRoZSBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSBpbnNpZGUsIGNvbnZlcnQgdGhhdCB2YWx1ZSB0byBhbm90aGVyIFBhcmFtSGFzaCBvYmplY3QgYXV0b21hdGljYWxseVxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4PTEmeT0xJno9MVwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueik7IC8vID09IDFcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieDoxO3k6Mjt6OjNcIiwgXCI7XCIsIFwiOlwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyA9PSAyXG4gICAgYWxlcnQocGgueik7IC8vID09IDNcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieD0xJnk9MSZ6PTEmej0yXCIpO1xuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vIDFcbiAgICBhbGVydChwaC56KTsgLy9Ob3RlIHRoYXQgeiA9PSAyIGIvYyBvZiAyIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng9MSZ5PTEmej0xJno9MlwiLG51bGwsbnVsbCx0cnVlKTsgLy9udWxsIGZvciBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSA9PSB1c2UgZGVmYXVsdCB2YWx1ZXMgb2YgXCImXCIgYW5kIFwiPVwiIHJlc3BlY3RpdmVseVxuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vIDFcbiAgICBhbGVydChwaC56KTsgLy9Ob3RlIHRoYXQgeiA9PSAxIGIvYyBiTm9PdmVyd3JpdGUgd2FzIHNldCB0byB0cnVlXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICAvL1lvdSBjYW4gYWxzbyBkbyByZWN1cnNpdmUgcHJvY2Vzc2luZyBpZiBuZWVkIGJlXG4gICAgdmFyIHBvaW50c1x0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpLFxuICAgIHBvaW50XzFcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKSxcbiAgICBwb2ludF8yXHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKCk7XG4gICAgXG4gICAgcG9pbnRfMS54ID0gMTAwO1xuICAgIHBvaW50XzEueSA9IDc1O1xuICAgIFxuICAgIHBvaW50XzIueCA9IDIwMDtcbiAgICBwb2ludF8yLnkgPSAxNTA7XG4gICAgXG4gICAgcG9pbnRzLnBvaW50XzFcdD0gcG9pbnRfMTtcbiAgICBwb2ludHMucG9pbnRfMlx0PSBwb2ludF8yO1xuICAgIFxuICAgIHZhciBwb2ludF9zdHJcdD0gcG9pbnRzLnRvU3RyaW5nKCk7ICAvLyA9PSBcInBvaW50XzE9eCUzRDEwMCUyNnklM0Q3NSUyNiZwb2ludF8yPXglM0QyMDAlMjZ5JTNEMTUwJTI2JlwiO1xuICAgIHZhciBwb2ludHNfY29weVx0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChwb2ludF9zdHIsIG51bGwsIG51bGwsIHRydWUsIHRydWUpOyAvL25vdGUgcGFzc2luZyB0cnVlLCBiL2Mgd2Ugd2FudCB0byByZWN1cnNlXG4gICAgXG4gICAgYWxlcnQocG9pbnRzX2NvcHkucG9pbnRfMS54KSAvLyA9PSBcIjEwMFwiO1xuICAgICAqL1xuICAgIFBhcmFtSGFzaCA9IGZ1bmN0aW9uKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKSB7XG4gICAgICB2YXIgYWRkZWQsIGNudCwgZG9BZGQsIGlkeCwgaWR4MiwgaWR4MywgaW8sIGxlbiwgbGVuMiwgbWUsIG5tLCBudiwgb2JqLCBwYWlycywgc1RlbXAsIHNUZW1wMiwgc1RlbXAzLCBzcztcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIGlvID0gXCJpbmRleE9mXCI7XG4gICAgICBzcyA9IFwic3Vic3RyaW5nXCI7XG4gICAgICBkb0FkZCA9IGZhbHNlO1xuICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQYXJhbUhhc2gpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1IYXNoKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWU7XG4gICAgICB9XG4gICAgICBpZiAoc1N0cmluZyAmJiB0eXBlb2Ygc1N0cmluZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gbWl4KG5ldyBQYXJhbUhhc2goXCJcIiwgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpLCBzU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHNTdHJpbmcgPSBjc3RyKHNTdHJpbmcpO1xuICAgICAgc1Byb3BEZWxpbSA9IGNzdHIoc1Byb3BEZWxpbSkgfHwgXCImXCI7XG4gICAgICBzVmFsdWVEZWxpbSA9IGNzdHIoc1ZhbHVlRGVsaW0pIHx8IFwiPVwiO1xuICAgICAgaWYgKCFzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtZTtcbiAgICAgIH1cbiAgICAgIGlmIChzUHJvcERlbGltICE9PSBcIj9cIiAmJiBzVmFsdWVEZWxpbSAhPT0gXCI/XCIgJiYgc1N0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXSgxKTtcbiAgICAgIH1cbiAgICAgIGlkeCA9IHNTdHJpbmdbaW9dKFwiP1wiKTtcbiAgICAgIGlkeDIgPSBzU3RyaW5nW2lvXShzVmFsdWVEZWxpbSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSAmJiBpZHgyICE9PSAtMSAmJiBpZHggPiBpZHgyKSB7XG4gICAgICAgIHNUZW1wID0gX2VzKHNTdHJpbmdbc3NdKGlkeDIgKyAxKSk7XG4gICAgICAgIHNUZW1wMiA9IHNTdHJpbmcuc3Vic3RyKDAsIGlkeDIgKyAxKTtcbiAgICAgICAgc1N0cmluZyA9IHNUZW1wMiArIHNUZW1wO1xuICAgICAgfSBlbHNlIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXShpZHggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbUhhc2goc1N0cmluZywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc1N0cmluZy5jaGFyQXQoMCkgPT09IHNQcm9wRGVsaW0pIHtcbiAgICAgICAgc1N0cmluZyA9IHNTdHJpbmdbc3NdKDEpO1xuICAgICAgfVxuICAgICAgcGFpcnMgPSBzU3RyaW5nLnNwbGl0KHNQcm9wRGVsaW0pO1xuICAgICAgY250ID0gcGFpcnMubGVuZ3RoO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHdoaWxlIChjbnQtLSkge1xuICAgICAgICBzVGVtcCA9IHBhaXJzW2lkeCsrXTtcbiAgICAgICAgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgZG9BZGQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNUZW1wKSB7XG4gICAgICAgICAgbnYgPSBzVGVtcC5zcGxpdChzVmFsdWVEZWxpbSk7XG4gICAgICAgICAgbGVuID0gbnYubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgICBubSA9IF91ZShudlswXSk7XG4gICAgICAgICAgICBudi5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGJSZWN1cnNlKSB7XG4gICAgICAgICAgICAgIHNUZW1wMiA9IG5tICsgc1ZhbHVlRGVsaW07XG4gICAgICAgICAgICAgIGlkeDIgPSBzU3RyaW5nW2lvXShzVGVtcDIpO1xuICAgICAgICAgICAgICBsZW4gPSBzVGVtcDJbTEVOXTtcbiAgICAgICAgICAgICAgc1RlbXAzID0gc1N0cmluZ1tzc10oaWR4MiArIGxlbik7XG4gICAgICAgICAgICAgIHNUZW1wMiA9IHNQcm9wRGVsaW0gKyBzUHJvcERlbGltO1xuICAgICAgICAgICAgICBsZW4yID0gc1RlbXAyW0xFTl07XG4gICAgICAgICAgICAgIGlkeDMgPSBzVGVtcDNbaW9dKHNUZW1wMik7XG4gICAgICAgICAgICAgIGlmIChpZHgzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNUZW1wMyA9IHNTdHJpbmcuc3Vic3RyKGlkeDIgKyBsZW4sIGlkeDMgKyBsZW4yKTtcbiAgICAgICAgICAgICAgICBvYmogPSBuZXcgUGFyYW1IYXNoKHNUZW1wMywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgIHNUZW1wMyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHNUZW1wMyBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWR4ICs9IGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNUZW1wID0gb2JqO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNUZW1wID0gX3VlKG52LmpvaW4oc1ZhbHVlRGVsaW0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc1RlbXAgPSBfdWUobnYuam9pbihzVmFsdWVEZWxpbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9BZGQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICBubSA9IF91ZShudlswXSk7XG4gICAgICAgICAgICBzVGVtcCA9IF91ZShudlsxXSk7XG4gICAgICAgICAgICBkb0FkZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb0FkZCkge1xuICAgICAgICAgICAgaWYgKGJOb092ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICBpZiAoIShubSBpbiBtZSkpIHtcbiAgICAgICAgICAgICAgICBtZVtubV0gPSBzVGVtcDtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lW25tXSA9IHNUZW1wO1xuICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYlJlY3Vyc2UgJiYgYWRkZWQgJiYgbm0gJiYgc1RlbXAgJiYgdHlwZW9mIHNUZW1wICE9PSBcIm9iamVjdFwiICYmIChzVGVtcFtpb10oc1Byb3BEZWxpbSkgPj0gMCB8fCBzVGVtcFtpb10oc1ZhbHVlRGVsaW0pID49IDApKSB7XG4gICAgICAgICAgICAgIG1lW25tXSA9IG5ldyBQYXJhbUhhc2goc1RlbXAsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBDb252ZXJ0cyBhIFBhcmFtSGFzaCBvYmplY3QgYmFjayBpbnRvIGEgc3RyaW5nIHVzaW5nIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVsaW1pdGVycyBzcGVjaWZlZCAoZGVmYXVsdHMgdG8gXCImXCIgYW5kIFwiPVwiKS5cbiAgICBBZ2FpbiB0aGlzIG1ldGhvZCB3b3JrcyByZWN1cnNpdmVseS4gIElmIGFuIG9iamVjdCBpcyBmb3VuZCBhcyBhIHByb3BlcnR5LCBpdCB3aWxsIGNvbnZlcnQgdGhhdCBvYmplY3QgaW50byBhIFBhcmFtSGFzaCBzdHJpbmdcbiAgICBhbmQgdGhlbiBlc2NhcGUgaXQuIE5vdGUgYWxzbyB0aGF0IHRoaXMgY2xhc3MncyB2YWx1ZU9mIG1ldGhvZCBpcyBlcXVhbCB0byB0aGlzIG1ldGhvZC5cbiAgICBcbiAgICBAbWV0aG9kT2YgUGFyYW1IYXNoI1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NQcm9wRGVsaW09XCImXCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlciB1c2VkIHRvIHNlcGVyYXRlIHByb3BlcnRpZXMuIERlZmF1bHQgaXMgXCImXCIuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzVmFsdWVEZWxpbT1cIj1cIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVkIHVzZWQgdG8gc2VwZXJhdGUgdmFsdWVzLiAgRGVmYXVsdCBpcyBcIj1cIi5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtlc2NhcGVQcm9wPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBhc2NpaSBlc2NhcGUgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2RvbnRFc2NhcGVWYWx1ZT1mYWxzZV0gRG8gbm90IGVzY2FwZSB2YWx1ZXMgb3IgcHJvcGVydGllcyBhdXRvbWF0aWNhbGx5XG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA9IGZ1bmN0aW9uKHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBlc2NhcGVQcm9wLCBkb250RXNjYXBlVmFsdWUpIHtcbiAgICAgIHZhciBidWZmZXIsIGl0ZW0sIGl0ZW1UeXBlLCBtZSwgcHJvcDtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICBidWZmZXIgPSBbXTtcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIGl0ZW1UeXBlID0gdm9pZCAwO1xuICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgIHNQcm9wRGVsaW0gPSBzUHJvcERlbGltIHx8IFwiJlwiO1xuICAgICAgc1ZhbHVlRGVsaW0gPSBzVmFsdWVEZWxpbSB8fCBcIj1cIjtcbiAgICAgIGZvciAocHJvcCBpbiBtZSkge1xuICAgICAgICBpdGVtID0gbWVbcHJvcF07XG4gICAgICAgIGl0ZW1UeXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW1UeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGl0ZW0gPSB0b1N0cmluZy5hcHBseShpdGVtLCBbc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGVzY2FwZVByb3AsIGRvbnRFc2NhcGVWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlc2NhcGVQcm9wKSB7XG4gICAgICAgICAgcHJvcCA9IF9lcyhwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRFc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGl0ZW0gPSBfZXMoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2gocHJvcCwgc1ZhbHVlRGVsaW0sIGl0ZW0sIHNQcm9wRGVsaW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzdHIoYnVmZmVyKTtcbiAgICB9O1xuICAgIHByb3RvID0gUGFyYW1IYXNoLnByb3RvdHlwZTtcbiAgICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gdHJpbTtcbiAgICB9XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBwcm90by50b1N0cmluZyA9IHByb3RvLnZhbHVlT2YgPSB0b1N0cmluZztcbiAgICBsYW5nID0ge1xuICAgICAgUGFyYW1IYXNoOiBQYXJhbUhhc2gsXG4gICAgICBjc3RyOiBjc3RyLFxuICAgICAgY251bTogY251bSxcbiAgICAgIGNib29sOiBjYm9vbCxcbiAgICAgIG5vb3A6IG5vb3AsXG4gICAgICB0cmltOiB0cmltLFxuICAgICAgY2FsbGFibGU6IGNhbGxhYmxlLFxuICAgICAgZ3VpZDogZ3VpZCxcbiAgICAgIG1peDogbWl4LFxuICAgICAgdGltZTogdGltZSxcbiAgICAgIHJhbmQ6IHJhbmQsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIG5zOiBucyxcbiAgICAgIGpzc2FmZV9odG1sOiBqc3NhZmVfaHRtbCxcbiAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICB3cmFwOiB3cmFwXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgZXhwb3J0cyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMubGFuZyA9IGxhbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGxvZ0Vycm9yLCBsb2dJbmZvLCB3aW47XG4gICAgd2luID0gd2luZG93O1xuXG4gICAgLypcbiAgICBXcml0ZSBhbiBlbnRyeSB0byB0aGUgY29uc29sZSBsb2cgYW5kIGZpcmUgYW55IGxvZyBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbWVzc2FnZSAgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nSW5mbyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh3aW4uY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBXcml0ZSBhbiBlbnRyeSB0byB0aGUgY29uc29sZSBlcnJvciBsb2cgYW5kIGZpcmUgYW55IGxvZyBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbWVzc2FnZSAgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBpZiAod2luLmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdpbi5jb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBpbmZvOiBsb2dJbmZvLFxuICAgICAgZXJyb3I6IGxvZ0Vycm9yXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIl19
