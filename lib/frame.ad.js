(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Request, currentName, events, sf, stream, utils;

  currentName = window.name;

  sf = require('../node_modules/safeframe/lib/js/ext/ext')(true);

  events = require('./shared/event')(["request", "load", "view", "click", "expanded", "collapsed", "engage", "unview", "unload"]);

  utils = require('./shared/utils');

  Request = require('./request');

  stream = require('./shared/stream');

  (function(sf, window) {
    var AdJS, VIEWED_STRIKE, attributes, didShow, forceNuke, height, host, isViewedInterval, location, onUpdate, referrerLevel, registerAdJSendpoints, registerForEvents, registered, request, requested, setSessionInfo, sfDom, showAd, showAdTimer, showPage, unviewedTicks, updateIsViewed, updateReferrer, viewedTicks, width;
    request = new Request();
    request.change(function() {
      return stream.event(request);
    });
    sfDom = sf.lib.dom;
    AdJS = {};
    VIEWED_STRIKE = 9;
    viewedTicks = 0;
    unviewedTicks = 0;
    width = window.innerWidth;
    height = window.innerHeight;
    registered = false;
    didShow = false;
    requested = false;
    attributes = {};
    AdJS.setDimensions = function(w, h) {
      width = w;
      return height = h;
    };
    registerForEvents = function() {
      registered = true;
      return $sf.ext.register(width, height, onUpdate);
    };
    registerAdJSendpoints = function() {
      return true;
    };
    setSessionInfo = function(cookieData) {
      return request.set(utils.fromQuery(cookieData));
    };
    updateReferrer = function(level) {
      if (level == null) {
        level = "all";
      }
      switch (level) {
        case "all":
          return true;
        case "host":
          utils.defineProperty(document, "referrer", {
            get: function() {
              return "" + document.location.protocol + "//" + host;
            }
          });
          return true;
        case "none":
          return false;
        default:
          return true;
      }
    };
    onUpdate = function(status, data) {
      switch (status) {
        case "expanded":
          return function() {
            return AdJS.expanded();
          };
        case "collapsed":
          return function() {
            return AdJS.collapsed();
          };
        case "geom-update":
          return showAd();
        case "cookie-update":
          return setSessionInfo(unescape(data.value));
        case "engaged":
          return AdJS.engage();
        case "requested":
          if (!requested) {
            return AdJS.request();
          }
      }
    };
    isViewedInterval = null;
    updateIsViewed = function() {
      var _base, _base1;
      if (!AdJS.isViewed && (typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 50 && $sf.ext.winHasFocus()) {
        viewedTicks++;
      } else if (AdJS.isViewed && ((typeof (_base1 = $sf.ext).inViewPercentage === "function" ? _base1.inViewPercentage() : void 0) < 50 || !$sf.ext.winHasFocus())) {
        unviewedTicks++;
      } else {
        unviewedTicks = viewedTicks = 0;
      }
      if (viewedTicks === VIEWED_STRIKE) {
        if (!AdJS.isViewed) {
          AdJS.view();
        }
        AdJS.isViewed = true;
      }
      if (unviewedTicks === VIEWED_STRIKE) {
        if (!AdJS.isunViewed) {
          AdJS.unview();
        }
        AdJS.isunViewed = true;
        return clearInterval(isViewedInterval);
      }
    };
    showAdTimer = null;
    showAd = function(show) {
      var startTime, _base;
      if (((typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 5 && !didShow) || show) {
        if (showAdTimer) {
          clearInterval(showAdTimer);
        }
        startTime = utils.now();
        AdJS.request();
        $sf.ext.showAd(function() {
          return AdJS.load();
        });
        return didShow = true;
      } else if (!(showAdTimer || didShow)) {
        return showAdTimer = setInterval(forceNuke, 50);
      }
    };
    forceNuke = function() {
      var _base;
      if ((typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 5 && showAdTimer) {
        clearInterval(showAdTimer);
        showAdTimer = null;
        return $sf.ext.reload();
      }
    };
    sf.lib.lang.mix(AdJS, events);
    AdJS.on = function(event, cb) {
      return events.on.apply(this, [event, cb]);
    };
    AdJS.expand = function(deltaXorDesc, deltaY, p) {
      return $sf.ext.expand(deltaXorDesc, deltaY, p);
    };
    AdJS.collapse = function() {
      return $sf.ext.collapse();
    };
    AdJS.cookie = function(cookieName, cookieData) {
      return $sf.ext.cookie(coookieName, cookieData);
    };
    AdJS.supports = function(key) {
      return $sf.ext.supports(key);
    };
    AdJS.sendMessage = function(content) {
      return setTimeout(function() {
        return $sf.ext.message(encodeURIComponent(content));
      }, 1);
    };
    sfDom.attach(document.body, "mouseup", function() {
      AdJS.click();
      return true;
    });
    window.$ad = AdJS;
    registerAdJSendpoints();
    AdJS.click(function() {
      return sf.ext.click();
    });
    AdJS.view(function() {
      return sf.ext.viewed();
    });
    AdJS.unview(function() {
      return sf.ext.unviewed();
    });
    AdJS.load(function() {
      return registerForEvents();
    });
    AdJS.load(function() {
      return isViewedInterval = setInterval(updateIsViewed, 100);
    });
    AdJS.load(function() {
      AdJS.frameCount = utils.countFrames(window);
      return request.set({
        frame_count: AdJS.frameCount
      });
    });
    AdJS.request(function() {
      AdJS.requestTime = utils.now();
      return request.set({
        requested: true,
        requestedAt: utils.now()
      });
    });
    AdJS.load(function() {
      AdJS.loadTime = utils.now();
      sfDom.attach(window, "unload", function() {
        return $ad.unload();
      });
      return request.set({
        loaded: true,
        loadedAt: utils.now()
      });
    });
    AdJS.view(function() {
      AdJS.viewTime = utils.now();
      return request.set({
        viewed: true,
        viewedAt: utils.now()
      });
    });
    AdJS.engage(function() {
      AdJS.engageTime = utils.now();
      return request.set({
        engaged: true,
        engagedAt: utils.now()
      });
    });
    AdJS.click(function() {
      AdJS.clickTime = utils.now();
      return request.set({
        clicked: true,
        clickedAt: utils.now()
      });
    });
    AdJS.unview(function() {
      AdJS.unviewTime = utils.now();
      return request.set({
        unviewed: true,
        unviewedAt: utils.now()
      });
    });
    AdJS.unload(function() {
      AdJS.unloadTime = utils.now();
      return request.set({
        unloaded: true,
        unloadedAt: utils.now()
      });
    });
    sf.ext.render(false);
    didShow = !sf.lib.lang.cbool(sf.ext.meta("inview", "extended"));
    referrerLevel = sf.ext.meta("referrer", "extended") || "all";
    host = sf.ext.meta("host", "extended");
    sf.ext.deleteMeta("host", "extended");
    location = sf.ext.meta("location", "extended");
    sf.ext.deleteMeta("location", "extended");
    setSessionInfo(sf.ext.meta("session", "extended"), {
      silent: true
    });
    sf.ext.deleteMeta("session", "extended");
    $ad.slotId = sf.ext.meta("slot_id", "extended");
    $ad.count = sf.ext.meta("slot_count", "extended");
    request.set({
      slot_id: sf.ext.meta("slot_id", "extended"),
      slot_count: sf.ext.meta("slot_count", "extended"),
      page_url: location,
      page_host: host
    }, {
      silent: true
    });
    showPage = document.location.href === document.referrer || updateReferrer(referrerLevel);
    if (showPage) {
      showAd(didShow);
    } else {
      window.name = currentName;
      document.location = document.location;
    }
    return AdJS;
  })(sf, window);

}).call(this);

},{"../node_modules/safeframe/lib/js/ext/ext":10,"./request":2,"./shared/event":5,"./shared/stream":6,"./shared/utils":7}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.JSON || (window.JSON = require('json'));

  utils = require('./shared/utils');

  Base = require('./shared/base');

  module.exports = (function(window) {
    var Request;
    Request = (function(_super) {
      var REQ_INTERVAL;

      __extends(Request, _super);

      REQ_INTERVAL = 50;

      function Request(clientId, sessionId) {
        Request.__super__.constructor.apply(this, arguments);
      }

      Request.prototype.sendRequest = function() {
        if (!this.requestInProcess) {
          this.requestInProcess = true;
          clearTimeout(this.timeoutId);
          this.timeoutId = null;
          return utils.sendRequest("http://127.0.0.1/test", {
            data: this.attributes,
            success: function(data) {
              this.requestInProcess = false;
              return this.set(data, {
                silent: true
              });
            }
          });
        } else {
          if (!this.timeoutId) {
            this.waiting = true;
            return this.timeoutId = setTimeout((function(_this) {
              return function() {
                clearTimeout(_this.timeoutId);
                _this.timeoutId = null;
                return _this.sendRequest();
              };
            })(this));
          }
        }
      };

      return Request;

    })(Base);
    return Request;
  })(window);

}).call(this);

},{"./shared/base":3,"./shared/utils":7,"json":8}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.attributes || (this.attributes = {});
        this._events = [];
      }

      Base.prototype.set = function(attrs, options) {
        var changed, changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        changed = false;
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
          }
          this.attributes[k] = v;
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      return Base;

    })();
  })();

}).call(this);

},{}],4:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html',
        visit_expiry: 1
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//endpoint.adjs.io/1",
        cdn_url: process.env.CDN_URL,
        visit_expiry: 30
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html',
        visit_expiry: 3
      };
    }
  })();

}).call(this);

}).call(this,require("8DwohR"))
},{"8DwohR":16}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(eventNames) {
    return (function() {
      var event, events, utils, _i, _len;
      utils = require('./utils');
      events = {
        on: function(event, cb) {
          var eventList;
          this.events || (this.events = {});
          eventList = this.events[event] || [];
          eventList.push(cb);
          this.events[event] = eventList;
          return this;
        },

        /*
          optionalData needs to be fixed
         */
        trigger: function(event, data, optionalData) {
          var e, ex, _i, _len, _ref;
          this.events || (this.events = {});
          _ref = this.events[event] || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            try {
              e.call(this, data, optionalData);
            } catch (_error) {
              ex = _error;
            }
          }
          this.notify(event, data || this);
          return this;
        },
        notify: function(event, data) {
          var endpoint, params, _i, _len, _ref, _ref1, _results;
          _ref1 = ((_ref = this.eventEndpoints) != null ? _ref[event] : void 0) || [];
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            endpoint = _ref1[_i];
            params = (data != null ? typeof data.getParams === "function" ? data.getParams() : void 0 : void 0) || {};
            params.event = event;
            _results.push(utils.sendRequest(endpoint, {
              data: params
            }));
          }
          return _results;
        }
      };
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        event = eventNames[_i];
        events[event] = (function(event) {
          var f;
          return f = function(data) {
            if (typeof data === "function") {
              return this.on(event, data);
            } else {
              return this.trigger(event, data);
            }
          };
        })(event);
        events["" + event + "RegisterEndpoint"] = (function(event) {
          var f;
          return f = function(endpoint) {
            var _base;
            this.eventEndpoints || (this.eventEndpoints = {});
            (_base = this.eventEndpoints)[event] || (_base[event] = []);
            return this.eventEndpoints[event].push(endpoint);
          };
        })(event);
      }
      return events;
    })();
  };

}).call(this);

},{"./utils":7}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var config, reqwest;

  reqwest = require('reqwest');

  config = require('./config');

  module.exports = (function() {
    var pendingRequests, prefix, send, sendingRequests;
    prefix = config.api;
    pendingRequests = {};
    sendingRequests = {};
    send = function(url, data, success, error) {
      return reqwest({
        url: url,
        type: 'jsonp',
        data: data,
        success: success,
        error: error
      });
    };
    return {
      page: function(session) {
        var error, k, obj, subst, success, v, _ref;
        success = function(resp) {
          return session.set(resp, {
            silent: true
          });
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        subst = {
          id: 'page_id',
          vid: 'vis_id',
          p: 'site_page_vw'
        };
        obj = {};
        _ref = session.attributes;
        for (k in _ref) {
          v = _ref[k];
          if (subst[k]) {
            obj[subst[k]] = v;
          }
        }
        console.log(JSON.stringify(obj, null, '\t'));
        console.log(JSON.stringify(session.attributes, null, '\t'));
        return send(prefix + '/page', session.attributes, success, error);
      },
      event: function(request, cb, isAttempt) {
        var error, success;
        success = function(resp) {
          request.set(resp, {
            silent: true
          });
          if (typeof cb === "function") {
            cb(resp);
          }
          return delete sendingRequests[request.id];
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        if (!sendingRequests[request.id]) {
          delete pendingRequests[request.id];
          sendingRequests[request.id] = true;
          return send(prefix + '/event', request.attributes, success, error);
        } else if (!pendingRequests[request.id] || isAttempt) {
          pendingRequests[request.id];
          return setTimeout((function(_this) {
            return function() {
              return _this.event(request, cb, true);
            };
          })(this), 500);
        }
      }
    };
  })();

}).call(this);

},{"./config":4,"reqwest":9}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var capitalizeString;

  window.reqwest || (window.reqwest = require('reqwest'));

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf, window) {
    var countFrames, defineProperty, e, e2, fromQuery, getReferrer, now, referrer, reqwest, sendRequest, toNumber, toQuery;
    reqwest = window.reqwest;
    sendRequest = function(url, options) {
      return reqwest({
        url: url,
        type: 'jsonp',
        success: options.success,
        error: options.error,
        data: options.data
      });
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        }
      } catch (_error) {
        e = _error;
        return console.log(e);
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    getReferrer = function(win) {
      var qs, referrer;
      referrer = '';
      qs = object.fromQuerystring("referrer", window.location.href) || object.fromQuerystring("referer", window.location.href);
      if (qs) {
        return qs;
      }
    };
    try {
      referrer = window.top.document.referrer;
    } catch (_error) {
      e = _error;
      if (window.parent) {
        try {
          referrer = window.parent.document.referrer;
        } catch (_error) {
          e2 = _error;
          referrer = "";
        }
      }
    }
    if (referrer === "") {
      referrer = document.referrer;
    }
    return referrer;
  })($sf, window);

  object.addEventListener = function(element, eventType, eventHandler, useCapture) {
    if (element.addEventListener) {
      element.addEventListener(eventType, eventHandler, useCapture);
      return true;
    }
    if (element.attachEvent) {
      return element.attachEvent("on" + eventType, eventHandler);
    }
    element["on" + eventType] = eventHandler;
  };

  object.fromQuerystring = function(field, url) {
    var match;
    match = RegExp("^[^#]*[?&]" + field + "=([^&#]*)").exec(url);
    if (!match) {
      return null;
    }
    return decodeURIComponent(match[1].replace(/\+/g, " "));
  };

  capitalizeString = function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  };

  ({
    sendRequest: sendRequest,
    toQuery: toQuery,
    fromQuery: fromQuery,
    toNumber: toNumber,
    now: now,
    defineProperty: defineProperty,
    countFrames: countFrames,
    capitalizeString: capitalizeString
  });

}).call(this);

},{"json":8,"reqwest":9}],8:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],9:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@fileOverview This file contains JavaScript code that handles the HTML document where HTML is rendered for a SafeFrame, as well as defining the External Vendor/Client API.
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.3
 */


/*
@namespace $sf.ext The external vendor / client API for functionality inside a SafeFrame
@name $sf.ext
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require("../shared/base");

  module.exports = function(isExternal) {
    return (function(window, sf) {
      var COLLAPSE_COMMAND, DG, DOM_WATCH_INTERVAL, DP, DS, ERROR_COMMAND, EXPAND_COMMAND, GUID_VALID_TIME, IE_ATTACH, IE_DETACH, LOAD, MAX_MSG_WAIT_TIME, MSG, NOTIFY_CLICKED, NOTIFY_COLLAPSE, NOTIFY_COLLAPSED, NOTIFY_EXPAND, NOTIFY_FAILURE, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, NOTIFY_LOADED, NOTIFY_READ_COOKIE, NOTIFY_RELOAD, NOTIFY_REQUESTED, NOTIFY_UNVIEWED, NOTIFY_VIEWED, NOTIFY_WRITE_COOKIE, OBJ, ONLOAD, ONMSG, ONUNLOAD, ON_STR, OUR_TAG_CLS_NAME, ParamHash, STATUS_COLLAPSED, STATUS_COLLAPSING, STATUS_EXPANDED, STATUS_EXPANDING, TOLOWERCASE, UNLOAD, W3C_ATTACH, W3C_DETACH, adShown, can_use_html5, click, cmdRetries, collapse, cookie, d, deleteMeta, dom, env, err_msg_timer_id, err_msgs, expand, force_collapse, frame_id, geom, geom_info, guid, hasLoaded, host_cname, ie_old_attach, ie_old_detach, iframes, inViewPercentage, init_height, init_width, inline_handler_timer_id, isAdShown, isIE, is_expanded, is_registered, lang, lib, loaded, message, meta, msgclient_fb, originalWrite, orphan_timer_id, par, pending_msg, pos_id, pos_meta, register, reload, render, render_conf, render_params, sandbox_cb, showAd, status, supports, unload_handlers, unviewed, viewed, w3c_old_attach, w3c_old_detach, win, winHasFocus, win_has_focus, _append, _attach, _attach_override, _attr, _call_client_fb, _call_raw_evt_func, _check_orphaned, _cnum, _collapse, _construction, _create_stylesheet, _cstr, _destruction, _detach, _detach_override, _detect_bad_iframe, _elt, _fire_sandbox_callback, _handle_err, _handle_load, _handle_msg, _handle_unload, _nuke_doc, _purge, _reattach_messaging, _receive_msg, _render, _report_errs, _requested, _reset_inline_handlers, _send_cmd, _send_msg, _set_alignment, _set_hyperlink_targets, _setup_win_evt_props, _tags, _ue, _wrapiFrame;
      win = window;
      LOAD = "load";
      ON_STR = "on";
      MSG = "message";
      UNLOAD = "un" + LOAD;
      ONUNLOAD = ON_STR + UNLOAD;
      ONMSG = ON_STR + MSG;
      ONLOAD = ON_STR + LOAD;
      DG = "__defineGetter__";
      DS = "__defineSetter__";
      DP = "__defineProperty__";
      W3C_ATTACH = "addEventListener";
      W3C_DETACH = "removeEventListener";
      IE_ATTACH = "attachEvent";
      IE_DETACH = "detachEvent";
      TOLOWERCASE = "toLowerCase";
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_EXPAND = "expand";
      NOTIFY_FOCUS_CHANGE = "focus-change";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_COLLAPSED = NOTIFY_COLLAPSE + "d";
      NOTIFY_FAILURE = "failed";
      NOTIFY_READ_COOKIE = "read-cookie";
      NOTIFY_WRITE_COOKIE = "write-cookie";
      NOTIFY_CLICKED = "clicked";
      NOTIFY_VIEWED = "viewed";
      NOTIFY_UNVIEWED = "unviewed";
      NOTIFY_LOADED = "loaded";
      NOTIFY_REQUESTED = "requested";
      NOTIFY_RELOAD = "reload";
      STATUS_COLLAPSED = NOTIFY_COLLAPSED;
      STATUS_EXPANDED = NOTIFY_EXPAND + "ed";
      STATUS_COLLAPSING = "collapsing";
      STATUS_EXPANDING = NOTIFY_EXPAND + "ing";
      OUR_TAG_CLS_NAME = "sf";
      MAX_MSG_WAIT_TIME = 4000;
      DOM_WATCH_INTERVAL = 3000;
      GUID_VALID_TIME = 30000;
      OBJ = "object";
      d = win && win.document;
      par = win && win.parent;
      lib = sf.lib;
      env = sf.env;
      lang = lib.lang;
      ParamHash = lang.ParamHash;
      dom = lib.dom;
      iframes = dom.iframes;
      msgclient_fb = dom.msgclient_fb;
      isIE = env.isIE;
      _ue = win.unescape;
      _cstr = lang.cstr;
      _cnum = lang.cnum;
      _append = dom.append;
      _tags = dom.tags;
      _elt = dom && dom.elt;
      _purge = dom && dom.purge;
      _attach = dom && dom.attach;
      _detach = dom && dom.detach;
      _attr = dom && dom.attr;
      hasLoaded = false;
      is_expanded = false;
      force_collapse = false;
      is_registered = false;
      init_width = 0;
      init_height = 0;
      sandbox_cb = null;
      pending_msg = null;
      geom_info = null;
      pos_meta = null;
      win_has_focus = false;
      guid = "";
      host_cname = "";
      can_use_html5 = false;
      frame_id = "";
      pos_id = "";
      err_msg_timer_id = 0;
      orphan_timer_id = 0;
      inline_handler_timer_id = 0;
      err_msgs = [];
      unload_handlers = [];
      render_params = void 0;
      render_conf = void 0;
      ie_old_attach = void 0;
      w3c_old_attach = void 0;
      ie_old_detach = void 0;
      w3c_old_detach = void 0;
      isAdShown = false;

      /*
      Creates and appends a style sheet for any custom CSS passed
      
      @name $sf.ext-_create_stylesheet
      @function
      @static
      @private
      @param {String} cssText A string of CSS rules, or a URL string
      @param {String} [id] The id attribute of the tag created and appended
       */
      _create_stylesheet = function(cssText, id) {
        var e, oHead, oSS, oTxt;
        oHead = void 0;
        oSS = void 0;
        oTxt = void 0;
        e = void 0;
        try {
          oHead = _tags("head")[0];
          if (cssText.search(/\{[^\}]*}/g) === -1) {
            oSS = dom.make("link");
            oSS.type = "text/css";
            oSS.rel = "stylesheet";
            oSS.href = cssText;
          } else {
            oSS = dom.make("style");
            oSS.type = "text/css";
            if (isIE) {
              oSS.styleSheet.cssText = cssText;
            } else {
              oTxt = d.createTextNode(cssText);
              _append(oSS, oTxt);
            }
          }
          if (id) {
            oSS.id = id;
          }
          _append(oHead, oSS);
        } catch (_error) {}
      };

      /*
      Fires of unload event handlers and performs the necessary clean up when a SafeFrame is destroyed
      
      @name $sf.ext-_destruction
      @function
      @static
      @private
      @param {HTMLEvent} [evt] The raw dom event object if it exists
       */
      _destruction = function(evt) {
        var e, grand_par, handler, success, w;
        handler = void 0;
        w = window;
        success = 1;
        e = void 0;
        try {
          evt = evt || w.event || {};
        } catch (_error) {
          e = _error;
          evt = {
            type: UNLOAD
          };
        }
        while (handler = unload_handlers.shift()) {
          try {
            handler(evt);
          } catch (_error) {}
        }
        try {
          if (ie_old_attach) {
            w[IE_ATTACH] = ie_old_attach;
            w[IE_DETACH] = ie_old_detach;
          }
        } catch (_error) {}
        try {
          if (w3c_old_attach) {
            w[W3C_ATTACH] = w3c_old_attach;
            w[W3C_DETACH] = w3c_old_detach;
          }
        } catch (_error) {}
        if (!hasLoaded) {
          _detach(w, LOAD, _handle_load);
        }
        _detach(w, UNLOAD, _handle_unload);
        try {
          w.onerror = null;
        } catch (_error) {}
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (orphan_timer_id) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        w = ie_old_attach = w3c_old_attach = ie_old_detach = w3c_old_detach = d = _ue = par = handler = grand_par = null;
        return success;
      };

      /*
      Maintains that the window.onmessage property remains unset.
      We don't want content in our document listening to HTML5 messages.
      We override attaching to listeners below to maintain that functionality,
      however IE won't let you override properties directly hangning off of the
      window object, so we have a timer as a fallback for that purpose
      
      @name $sf.ext-_reset_inline_handlers
      @function
      @static
      @private
       */
      _reset_inline_handlers = function() {
        var e;
        e = void 0;
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (isIE && win.onmessage) {
            win.onmessage = null;
          }
        } catch (_error) {}
        try {
          win.onerror = _handle_err;
        } catch (_error) {}
        inline_handler_timer_id = setTimeout(_reset_inline_handlers, DOM_WATCH_INTERVAL);
      };

      /*
      Clears out the HTML document (which will force an unload event as well).
      
      @name $sf.ext-_nuke_doc
      @function
      @static
      @private
       */
      _nuke_doc = function() {
        var e;
        e = void 0;
        try {
          document.open("text/html", "replace");
          document.write("");
          document.close();
        } catch (_error) {}
      };

      /*
      Iteratively checks to see if the IFRAME HTML document is no longer
      attached to the main dom, doing this by checking that our internal
      window reference is still valid. . .as well as running the checks to make
      sure invalid iframes (iframes from origin) are not created.
      
      If we detect that the IFRAME has been removed from the main dom of the
      publisher, then we call to destroy the HTML document, forcing onunload
      event and subsquent cleanup
      
      @name $sf.ext-_check_orphaned
      @function
      @static
      @private
       */
      _check_orphaned = function() {
        var e, is_orphaned;
        is_orphaned = false;
        e = void 0;
        _detect_bad_iframe();
        if (!isIE) {
          return;
        }
        try {
          if (orphan_timer_id && orphan_timer_id !== -1) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          is_orphaned = win === top && orphan_timer_id !== -1;
        } catch (_error) {
          e = _error;
          is_orphaned = false;
        }
        if (is_orphaned) {
          orphan_timer_id = -1;
          _destruction();
          _nuke_doc();
          return;
        }
        try {
          if (!orphan_timer_id) {
            orphan_timer_id = setTimeout(_check_orphaned, DOM_WATCH_INTERVAL);
          }
        } catch (_error) {}
      };

      /*
      Detect whether or not an IFRAME tag has been inserted into the DOM that has the same
      origin / cname as the publisher, which should not be allowed as it's a security issue
      If said IFRAME tag(s) are found, remove them.
      
      @name $sf.ext-_detect_bad_iframe
      @function
      @static
      @private
       */
      _detect_bad_iframe = function() {
        var idx, srcHost, tag, written;
        iframes = _tags("iframe");
        idx = 0;
        srcHost = "";
        written = false;
        tag = void 0;
        if (host_cname) {
          while (tag = iframes[idx++]) {
            srcHost = _attr(tag, "src");
            srcHost = (srcHost && srcHost.length >= 9 ? srcHost.substring(0, srcHost.indexOf("/", 9))[TOLOWERCASE]() : "");
            if (srcHost && srcHost === host_cname && tag.className !== OUR_TAG_CLS_NAME) {
              try {
                _purge(tag);
              } catch (_error) {}
            }
          }
        }
      };

      /*
      Make sure that all hyperlinks in the document are set with the property "target" attribute
      such that links will navigate to the right window properly.
      
      @name $sf.ext-_set_hyperlink_targets
      @function
      @static
      @private
       */
      _set_hyperlink_targets = function() {
        var atgt, idx, ln, lns, ttgt;
        idx = 0;
        ttgt = (render_conf && render_conf.tgt) || "_top";
        ln = void 0;
        atgt = void 0;
        lns = void 0;
        lns = _tags("a");
        if (ttgt === "_self") {
          ttgt = "_top";
        }
        while (ln = lns[idx++]) {
          atgt = _attr(ln, "target");
          if (atgt !== ttgt) {
            _attr(ln, "target", ttgt);
          }
          if (idx > 10) {
            break;
          }
        }
      };

      /*
      Handle the onunload event from the HTML document of the IFRAME, which in turn will trigger clean up
      
      @name $sf.ext-_handle_unload
      @function
      @static
      @private
      @param {HTMLEvent} evt The raw DOM event object
       */
      _handle_unload = function(evt) {
        _destruction(evt);
        _nuke_doc();
      };

      /*
      Handle the load event from the HTML document of the IFRAME, which will also setup
      to make sure link targets are set properly
      
      @name $sf.ext-_handle_load
      @function
      @static
      @private
       */
      _handle_load = function() {
        if (loaded) {
          return;
        }
        hasLoaded = true;
        _detach(win, LOAD, _handle_load);
        _set_hyperlink_targets();
      };

      /*
      Handle onmessage HTML5 x-domain events. We always cancel the event
      never allowing it to go to other listeners besides our own, as we don't allow HTML5 messaging
      beyond us and the publisher / host.
      
      @name $sf.ext-_handle_msg
      @function
      @static
      @private
       */
      _handle_msg = function(evt) {
        var e, msg_guid, msg_obj, msg_params, org, src, str;
        str = void 0;
        src = void 0;
        org = void 0;
        e = void 0;
        msg_params = void 0;
        msg_guid = void 0;
        msg_obj = void 0;

        /*
        TODO, also validate origin
         */
        try {
          str = evt.data;
          src = evt.source;
          org = evt.origin;
        } catch (_error) {}
        dom.evtCncl(evt);
        if (str && src && src === top) {
          msg_params = ParamHash(str, null, null, true, true);
          msg_guid = msg_params.guid;
          msg_obj = msg_params.msg;
          if (guid === msg_guid && msg_obj && typeof msg_obj === OBJ) {
            try {
              setTimeout((function() {
                _receive_msg(msg_obj, evt);
                msg_params = evt = msg_guid = msg_obj = null;
              }), 1);
            } catch (_error) {}
          }
        }
      };

      /*
      This SafeFrames implementation internally handles all event attachment to maintain that the listener order
      for events that it cares about (onload, onunload, onbeforeunload, onmessage).
      This is done to make sure that proper clean up and intialization happens, as well as to enforce
      security.
      
      For events that it SafeFrames does not care about we allow the attachment listeners
      to proceed as normal, so we call the raw attachEvent / addEventListener functions.
      
      @name $sf.ext-_call_raw_evt_func
      @function
      @static
      @private
      @param {String} type The name of the event for which to attach/detach a listener
      @param {Function} f The callback function to use as a listener for said event
      @param {Boolean} [remove] If set to true, remove/detach this function as a listener, otherwise add
       */
      _call_raw_evt_func = function(type, f, remove) {
        var bOK, e, ie_f, w3c_f;
        bOK = false;
        ie_f = void 0;
        w3c_f = void 0;
        e = void 0;
        if (remove) {
          ie_f = ie_old_detach || w3c_old_detach;
          w3c_f = w3c_old_detach;
        } else {
          ie_f = ie_old_attach || w3c_old_attach;
          w3c_f = w3c_old_attach;
        }
        if (ie_f) {
          try {
            ie_f(type, f);
            bOK = true;
          } catch (_error) {
            e = _error;
            bOK = false;
          }
          if (!bOK) {
            try {
              ie_f.call(win, type, f);
              bOK = true;
            } catch (_error) {
              e = _error;
              bOK = false;
            }
          }
        }
        if (w3c_f && !bOK) {
          try {
            w3c_f.call(win, type, f, false);
          } catch (_error) {}
        }
      };

      /*
      Override default event attachment, and send load, beforeunload, and unload handlers into our
      own ques, so that we can enforce the proper firing order.  if message event is passed in,
      we do not allow attachment, since we do not want n-party code listening to HTML5 messages
      
      @name $sf.ext-_attach_override
      @function
      @static
      @private
      @param {String} type the event name to listen too
      @param {Function} f The function to be called whenever the event fires
       */
      _attach_override = function(type, f) {
        var bDoDefault;
        bDoDefault = false;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            unload_handlers.push(f);
            break;
          case MSG:
          case ONMSG:
            true;
            break;
          default:
            bDoDefault = true;
        }
        if (bDoDefault) {
          _call_raw_evt_func(type, f);
        }
      };

      /*
      Override default event detachment, and remove load, beforeunload, and unload handlers
      from our own que.  if message event is passed in, we do nothing (since we don't alllow
      attachment either).  If not one of those event types, then we call the default event detachment
      
      @name $sf.ext-_detach_override
      @function
      @static
      @private
      @param {String} type the event name to unlisten too
      @param {Function} f The function to no longer be called for the specific event
       */
      _detach_override = function(type, f) {
        var handler, handlers, idx;
        idx = 0;
        handler = void 0;
        handlers = void 0;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            handlers = unload_handlers;
            break;
          case MSG:
          case ONMSG:
            true;
        }
        if (handlers != null ? handlers.length : void 0) {
          while (handler = handlers[idx]) {
            if (handler === f) {
              handlers.splice(idx, 1);
              break;
            }
            idx++;
          }
        } else {

        }
        _call_raw_evt_func(type, f, true);
      };

      /*
      Report any internal uncaught JavaScript errors up to the publisher / host
      
      @name $sf.ext-_report_errs
      @static
      @function
      @private
       */
      _report_errs = function() {
        var cmd_str, e, errs;
        e = void 0;
        errs = void 0;
        try {
          if (err_msgs.length > 0) {
            errs = err_msgs[0];
            cmd_str = ["cmd=", ERROR_COMMAND, "&pos=", pos_id, "&errors=", errs];
            _send_msg(_cstr(cmd_str), ERROR_COMMAND);
          }
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        err_msgs = [];
      };

      /*
      Handle any uncaught JavaScript errors
      
      @name $sf.ext-_handle_err
      @static
      @function
      @private
      @param {String} a The the error message / description string
      @param {String} b The URL / file that the JavaScript error occured within
      @param {Number} c The line number that the error occured on. . .
       */
      _handle_err = function(a, b, c) {
        var e;
        e = void 0;
        err_msgs.push(_cstr(["Error occurred inside SafeFrame:\nMessage: ", a, "\nURL:", b, "\nLine:", c]));
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
          err_msg_timer_id = setTimeout(_report_errs, DOM_WATCH_INTERVAL);
        } catch (_error) {}
        return true;
      };

      /*
      Override native window methods and properties so that we can control
      how the events that we need to manage
      
      @name $sf.ext-_setup_win_evt_props
      @static
      @function
      @private
      @param {Object} obj The window object / prototype
       */
      _setup_win_evt_props = function(obj) {
        var O, e, n, nobj, ret;
        n = lang.noop;
        O = Object;
        nobj = {
          get: n,
          set: n
        };
        ret = false;
        if (obj) {
          if (ie_old_attach) {
            obj[IE_ATTACH] = _attach_override;
            obj[IE_DETACH] = _detach_override;
          }
          if (w3c_old_attach) {
            obj[W3C_ATTACH] = _attach_override;
            obj[W3C_DETACH] = _detach_override;
          }
          if (obj[DG]) {
            try {
              obj[DG](ONLOAD, n);
              obj[DS](ONLOAD, n);
              obj[DG](ONUNLOAD, n);
              obj[DS](ONUNLOAD, n);
              obj[DG](ONMSG, n);
              obj[DS](ONMSG, n);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
          if (!ret && O[DP]) {
            try {
              O[DP](obj, ONLOAD, nobj);
              O[DP](obj, ONUNLOAD, nobj);
              O[DP](obj, ONMSG, nobg);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Intialize / setup the safeframe, the environment according to the configuration found within the serialized
      window.name property.
      
      @name $sf.ext-_construction
      @param {Object} [details] An optional object to pass in status / error information into
      @static
      @private
      @function
       */
      _construction = function(details) {
        var cont, cur_time, e, el, guid_time, nm, ret, temp, time_delta;
        cont = false;
        ret = true;
        el = void 0;
        nm = void 0;
        temp = void 0;
        cur_time = void 0;
        guid_time = void 0;
        time_delta = void 0;
        e = void 0;
        details = (details && (details instanceof Object) ? details : {});
        try {
          nm = win.name;
        } catch (_error) {}
        try {
          win.name = "";
        } catch (_error) {}
        if (!nm) {
          details.status = 500.101;
          return cont;
        }
        try {
          if (top === par) {
            render_params = ParamHash(nm, null, null, true, true);
            cur_time = lang.time();
            guid = render_params.guid;
            guid_time = _cnum(guid.replace(/[^_]*_(\d+)_\d+_\d+/g, "$1"), 0);
            time_delta = cur_time - guid_time;
            cont = guid && guid_time && time_delta > 0 && time_delta < GUID_VALID_TIME;
            if (render_params.loc) {
              render_params.loc = unescape(render_params.loc);
            }
            if (!cont) {
              details.status = 500.104;
            }
          } else {
            details.status = 500.102;
          }
        } catch (_error) {
          e = _error;
          render_params = guid = null;
          cont = false;
          details.status = 500.103;
        }
        if (cont) {
          try {
            render_conf = render_params.conf;
            frame_id = win.name = render_conf.dest;
            pos_id = render_conf.id;
            pos_meta = render_params.meta;
            host_cname = render_params.host;
            geom_info = render_params.geom;
            can_use_html5 = lang.cbool(render_params.html5);
            win_has_focus = lang.cbool(render_params.has_focus);
            temp = render_conf.bg;
            if (geom_info) {
              geom_info = ParamHash(_ue(geom_info), null, null, true, true);
              if (!geom_info.self || !geom_info.exp) {
                geom_info = null;
              }
            }
            if (!host_cname) {
              host_cname = d.referrer;
              host_cname = host_cname.substring(0, host_cname.indexOf("/", 9));
            }
            if (temp) {
              _create_stylesheet(_cstr(["#sf_body { background-color: ", temp, "; }"]), "sf_bg_css");
            }
            temp = render_conf.tgt;
            if (temp === "_self") {
              render_conf.tgt = "_top";
            }
            if (!temp) {
              render_conf.tgt = "_top";
            }
            if (temp !== "_top") {
              while (_purge(_tags("base")[0])) {
                true;
              }
            }
            el = dom.make("base");
            _attr(el, "target", temp);
            _append(_tags("head")[0], el);
            if (isIE) {
              ie_old_attach = win[IE_ATTACH];
              ie_old_detach = win[IE_DETACH];
            }
            w3c_old_attach = win[W3C_ATTACH];
            w3c_old_detach = win[W3C_DETACH];
            _attach(win, UNLOAD, _handle_unload);
            _attach(win, LOAD, _handle_load);
            _attach(win, MSG, _handle_msg);
            _setup_win_evt_props(win);
            _setup_win_evt_props(win.__proto__);
            _setup_win_evt_props(win.Window && win.Window.prototype);
          } catch (_error) {
            e = _error;
            details.status = 500.105;
            render_params = render_conf = guid = null;
            ret = false;
          }
        } else {
          render_params = guid = null;
          ret = false;
        }
        return ret;
      };
      _wrapiFrame = function(html, cbName) {
        return "<iframe style=\"width:100%;height:100%;\" allowtransparency=\"true\"\nscrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" onload='" + cbName + "()'>\n<html><head><base target=\"_top\"></head><body style=\"margin: 0; padding: 0\">\n<script>\n  $ad = window.parent.$ad\n  $sf = window.parent.$sf\n</script>\n  " + html + "\n</html>\n</iframe>";
      };
      originalWrite = document.write;

      /*
      Render the HTML and CSS content passed in through the window.name message via a document.write
      
      @name $sf.ext-_render
      @function
      @static
      @private
       */
      _render = function(callback) {
        var cbName, css, e, html, otherCallbackApplied;
        if (callback == null) {
          callback = function() {};
        }
        cbName = lib.lang.guid("load_cb");
        otherCallbackApplied = false;
        window[cbName] = function(fromFrame) {
          return (sf.lib.lang.wrap(callback, function() {
            if (fromFrame || !otherCallbackApplied) {
              callback.apply(sf, arguments);
              if (pending_msg) {
                setTimeout((function(_this) {
                  return function() {
                    _handle_load();
                    return loaded();
                  };
                })(this), 300);
              } else {
                _handle_load();
                loaded();
              }
              document.write = originalWrite;
              return delete window[cbName];
            }
          }))();
        };
        document.write = function(str) {
          var domElem, iframe, oldOnload, _i, _len, _ref;
          if (!(hasLoaded || otherCallbackApplied)) {
            domElem = document.createElement("div");
            domElem.innerHTML = "_" + str;
            _ref = domElem.getElementsByTagName("iframe");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              iframe = _ref[_i];
              if (_cnum(_attr(iframe, "width"), 0) > 1) {
                otherCallbackApplied = true;
                if (oldOnload = _attr(iframe, "onload")) {
                  _attr(iframe, "onload", "" + cbName + "(true);" + oldOnload + ";");
                } else {
                  _attr(iframe, "onload", "" + cbName + "(true);");
                }
                break;
              }
            }
            if (otherCallbackApplied) {
              str = domElem.innerHTML.substring(1);
            }
          }
          return originalWrite.call(this, str);
        };
        html = void 0;
        css = void 0;
        isAdShown = true;
        css = _cstr(render_conf && render_conf.css);
        html = _cstr(render_params && render_params.html);
        if (css) {
          css = _ue(css);
          _create_stylesheet(css, "sf_custom_css");
        }
        if (html) {
          html = _ue(html);
          try {
            _reattach_messaging();
            _requested();
            document.write(html + "<scr" + ("ipt> " + cbName + "() ;</scr") + "ipt>");
            _check_orphaned();
            _reset_inline_handlers();
          } catch (_error) {
            e = _error;
            _handle_err("Error while rendering content: " + e[MSG]);
          }
        }
      };

      /*
      Call into the fallback x-msging library client if possible when no HTML5 style messaging
      exists
      
      @name $sf.ext-_call_client_fb
      @function
      @private
      @static
      @param {String} methName The name of the message in the library to call
      @param {*} [arg1] An arbitrary argument to hand into the library
      @param {*} [arg2] An arbitrary argument to hand into the library
       */
      _call_client_fb = function(methName, arg1, arg2) {
        var msg_clientfb;
        if (msgclient_fb) {
          msg_clientfb = dom.msgclient_fb;
        }
        return methName && msgclient_fb && msgclient_fb[methName] && msgclient_fb[methName](arg1, arg2);
      };

      /*
      Process a validated message to notify the contents of the SafeFrame of state updates
      
      @name $sf.ext-_receive_msg
      @function
      @private
      @static
      @param {$sf.lib.lang.ParamHash} params The message parameter hash object containing information about what has occured
      @param {HTMLEvent} [evt] The raw DOM event from the x-domain message
      @return {Boolean} Whether or not the message received could be handled
       */
      _receive_msg = function(params, evt) {
        var cmd, data, e, g, msg, ret;
        ret = false;
        msg = void 0;
        cmd = void 0;
        g = void 0;
        e = void 0;
        data = {};
        if (params) {
          g = params.geom || "";
          cmd = params.cmd;
          if (g) {
            geom_info = ParamHash(_ue(g), null, null, true, true);
          }
        }
        data.cmd = cmd;
        data.value = data.info = params && params.value;
        data.reason = params && params.reason;
        if (cmd === NOTIFY_COLLAPSED) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            force_collapse = true;
            _collapse();
            force_collapse = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
          }
        } else if (cmd === NOTIFY_COLLAPSE) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
          }
        } else if (cmd === NOTIFY_EXPAND) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            is_expanded = true;
            _fire_sandbox_callback(NOTIFY_EXPAND + "ed");
          }
        } else if (cmd === NOTIFY_GEOM_UPDATE) {
          _fire_sandbox_callback(NOTIFY_GEOM_UPDATE);
        } else if (cmd === NOTIFY_FOCUS_CHANGE) {
          data.info = data.value = lang.cbool(data.value);
          win_has_focus = data.value;
          _fire_sandbox_callback(NOTIFY_FOCUS_CHANGE, data);
        } else if (cmd === NOTIFY_READ_COOKIE) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            data = params && params.value;
            _fire_sandbox_callback(NOTIFY_READ_COOKIE, data);
          }
        } else if ([NOTIFY_WRITE_COOKIE, NOTIFY_FAILURE, NOTIFY_CLICKED, NOTIFY_VIEWED, NOTIFY_UNVIEWED, NOTIFY_LOADED, NOTIFY_REQUESTED, NOTIFY_RELOAD].indexOf(cmd) > -1) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
        } else {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
        }
        params = null;
        return ret;
      };
      cmdRetries = {};

      /*
      Send a command message up to the SafeFrames publisher / host code
      
      @name $sf.ext-_send_msg
      @private
      @function
      @static
      @param {String} str An encoded string (query-string/$sf.lib.lang.ParamHash format) that contains the command message to send
      @param {String} cmd The command to be sent itself (note that this string should also be present in the 1st argument)
       */
      _send_msg = function(str, cmd) {
        var e, id, params, sent, sent_time;
        id = lang.guid("sf_pnd_cmd");
        frame_id = render_params.dest;
        sent = false;
        sent_time = lang.time();
        params = void 0;
        if (!str || !cmd || pending_msg) {
          return;
        }
        params = ParamHash({
          msg: str,
          id: frame_id,
          guid: guid,
          cmd: cmd
        });
        pending_msg = {
          id: id,
          sent: sent_time,
          cmd: cmd
        };
        setTimeout((function() {
          if (pending_msg && pending_msg.id === id) {
            if (cmd === EXPAND_COMMAND || cmd === "exp-push") {
              force_collapse = true;
              _collapse();
              force_collapse = false;
            }
            _fire_sandbox_callback(NOTIFY_FAILURE + ":" + cmd + ":timeout");
          }
          id = sent = sent_time = cmd = str = pending_msg = params = null;
        }), MAX_MSG_WAIT_TIME);
        if (can_use_html5) {
          try {
            top.postMessage(params.toString(), (host_cname === "file" || host_cname === "" ? "*" : host_cname));
            sent = true;
          } catch (_error) {
            e = _error;
            sent = false;
          }
        }
        if (!sent) {
          _call_client_fb("send", params);
        }
      };

      /*
      Fire a notification off to the SafeFrame contents if a callback function was specified
      
      @name $sf.ext-_fire_sandbox_callback
      @private
      @function
      @static
      @param {String} msg The status update / message to send
      @param {Object} data The data from the response
       */
      _fire_sandbox_callback = function(msg, data) {
        var e;
        e = void 0;
        try {
          if (typeof sandbox_cb === "function") {
            sandbox_cb(msg, data);
          }
        } catch (_error) {}
      };

      /*
      Set the alignment of our internal DIV whenever expansion occurs uni-directionaly
      
      @name $sf.ext-_set_alignment
      @private
      @function
      @static
      @param {Boolean} xn Whether or not horizontal axis is growing to the left or right (xn == true == left)
      @param {Boolean} yn Whether or not vertical axis is growing to the top or bottom (yn == true == top)
       */
      _set_alignment = function(xn, yn) {
        var fcDiv, fcDivStyle, preTxt, xTxt, yTxt;
        fcDiv = _elt("sf_align");
        fcDivStyle = fcDiv.style;
        xTxt = void 0;
        yTxt = void 0;
        preTxt = "position:absolute;";
        if (xn) {
          xTxt = "right:0px;";
        } else {
          xTxt = "left:0px;";
        }
        if (yn) {
          yTxt = "bottom:0px;";
        } else {
          yTxt = "top:0px;";
        }
        fcDivStyle.cssText = preTxt + xTxt + yTxt;
        fcDiv = fcDivStyle = null;
      };

      /*
      Internal function for collapsing the SafeFrame, which checks that there is
      not some other pending state which may get in the way
      
      @name $sf.ext._collapse
      @private
      @function
      @static
       */
      _collapse = function() {
        if (!force_collapse && (!is_registered || !is_expanded || pending_msg)) {
          return false;
        }
        _set_alignment(0, 0);
        return true;
      };
      _reattach_messaging = function() {
        if (ie_old_attach) {
          ie_old_detach(ONMSG, _handle_msg);
          return ie_old_attach(ONMSG, _handle_msg);
        } else if (w3c_old_attach) {
          w3c_old_detach(MSG, _handle_msg);
          return w3c_old_attach(MSG, _handle_msg);
        }
      };

      /*
      Intialize the SafeFrame external vendor/client API, so that other features may be used
      This method MUST be called prior to using any other rich-media functionality (like expansion).
      
      @name $sf.ext.register
      @public
      @function
      @static
      @param {Number} initWidth The initial width (in pixels) expected of the content within the SafeFrame container
      @param {Number} initHeight The initial height (in pixels) expected of the content within the SafeFrame container
      @param {Function} [notify] A callback function that content can specify to be notified of status updates
       */
      register = function(initWidth, initHeight, notify) {
        if (is_registered || !guid) {
          return;
        }
        initWidth = _cnum(initWidth, 0, 0);
        initHeight = _cnum(initHeight, 0, 0);
        init_width = initWidth;
        init_height = initHeight;
        is_registered = true;
        if (lang.callable(notify)) {
          sandbox_cb = notify;
        } else {
          sandbox_cb = null;
        }
      };

      /*
      Make a request to expand the SafeFrame container to a certain size. Note that you may only call $sf.ext.expand
      to expand to the largest size needed, followed by calling collapse (and then repeat the same process if needed).
      Tweening or animation done, should be reserved for your own content, and you cannot make multiple calls to expand
      without a corresponding collapse.
      
      Note that when setting t, l, b, and r offset values, expansion will not cause the content inside the SafeFrame
      to hold it's current alignment, whereas using dx/dy or only setting partial offfsets (e.g {t:100,l:100} ==  dx:-100,dy:-100) will cause expansion to
      hold it's current alignment.
      
      @name $sf.ext.expand
      @public
      @static
      @function
      @param {Number|Object} deltaXorDesc If a number is specifed, SafeFrame will grow in size by this amount in pixels along the horizontal axis. Specifiy a negative value to grow to the left, and a postive value to grow to the right. <br />
      If an object is specified, it should contain "t","l","r","b" properties (top,left,bottom,right) for the amount in pixels to grow the container in each dimension
      @param {Number} deltaXorDesc.t Specifies to shift the top position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.l Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.b Specifies to shift the bottom position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Number} deltaXorDesc.r Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Boolean}deltaXorDesc.push  When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      @param {Number} deltaY If a number is specifed, SafeFrame will grow in size by this amount in pixels along the vertical axis. Specifiy a negative value to grow to the top, and a postive value to grow to the bottom. <br />
      Note that this value is ignored if deltaXorDesc is passed in as an object.
      
      @param {Boolean} push When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      
      @return {Boolean} true/false if the request to expand the container was sent. This does not mean that expansion is complete as expansion is an asynchronous process. Pass in a callback function to $sf.ext.register to get status updates.
       */
      expand = function(deltaXorDesc, deltaY, p) {
        var align_buffer, align_el, align_el_st, b, cmd_nm, cmd_str, doAlign, dx, dy, l, r, t, xn, yn;
        xn = false;
        yn = false;
        doAlign = false;
        cmd_nm = (p ? "exp-push" : EXPAND_COMMAND);
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id];
        dx = 0;
        dy = 0;
        r = void 0;
        b = void 0;
        t = void 0;
        l = void 0;
        align_el = void 0;
        align_el_st = void 0;
        align_buffer = void 0;
        if (!is_registered || pending_msg) {
          return;
        }
        if (p && !supports("exp-push")) {
          return;
        }
        if (deltaXorDesc && typeof deltaXorDesc === OBJ) {
          r = _cnum(deltaXorDesc.r, 0, 0);
          b = _cnum(deltaXorDesc.b, 0, 0);
          t = _cnum(deltaXorDesc.t, 0, 0);
          l = _cnum(deltaXorDesc.l, 0, 0);
          if (deltaXorDesc.push) {
            if (!supports("exp-push")) {
              return;
            }
            cmd_nm = "exp-push";
            cmd_str[1] = cmd_nm;
          }
          if (!r && l) {
            xn = true;
            dx = -1 * l;
          }
          if (r && !l) {
            dx = r;
          }
          if (!b && t) {
            yn = true;
            dy = -1 * t;
          }
          if (b && !t) {
            dy = b;
          }
          if ((t && b) || (l && r)) {
            doAlign = false;
          } else {
            doAlign = true;
          }
          if (doAlign) {
            _set_alignment(xn, yn);
            cmd_str.push("&dx=", dx, "&dy=", dy);
            _send_msg(_cstr(cmd_str), cmd_nm);
          } else {
            align_el = _elt("sf_align");
            align_el_st = align_el && align_el.style;
            align_buffer = ["position:absolute;"];
            if (t && b) {
              align_buffer.push("top:", t, "px;");
            } else if (t) {
              align_buffer.push("bottom:0px;");
            } else {
              if (b) {
                align_buffer.push("top:0px;");
              }
            }
            if (l && r) {
              align_buffer.push("left:", l, "px;");
            } else if (l) {
              align_buffer.push("right:0px;");
            } else {
              if (b) {
                align_buffer.push("left:0px;");
              }
            }
            if (align_el_st) {
              align_el_st.cssText = _cstr(align_buffer);
            }
            cmd_str.push("&exp_obj=", escape(ParamHash(deltaXorDesc)));
            _send_msg(_cstr(cmd_str), cmd_nm);
          }
        } else {
          deltaXorDesc = _cnum(deltaXorDesc, 0);
          deltaY = _cnum(deltaY, 0);
          if (deltaXorDesc <= 0 && deltaY <= 0) {
            return;
          }
          xn = deltaXorDesc <= 0;
          yn = deltaY <= 0;
          _set_alignment(xn, yn);
          cmd_str.push("&dx=", deltaXorDesc, "&dy=", deltaY);
          _send_msg(_cstr(cmd_str), cmd_nm);
        }
        return true;
      };

      /*
      Collapse the SafeFrame container after having called to expand. If no previous call to expand has been made, this call will do nothing.
      
      @name $sf.ext.collapse
      @public
      @static
      @function
       */
      collapse = function() {
        if (_collapse()) {
          _send_msg(_cstr(["cmd=", COLLAPSE_COMMAND, "&pos=", pos_id]), COLLAPSE_COMMAND);
        }
      };
      click = function() {
        return _send_cmd(NOTIFY_CLICKED);
      };
      viewed = function() {
        return _send_cmd(NOTIFY_VIEWED);
      };
      loaded = function() {
        return _send_cmd(NOTIFY_LOADED);
      };
      unviewed = function() {
        return _send_cmd(NOTIFY_UNVIEWED);
      };
      reload = function() {
        return _send_cmd(NOTIFY_RELOAD);
      };
      _requested = function() {
        _fire_sandbox_callback(NOTIFY_REQUESTED);
        return _send_cmd(NOTIFY_REQUESTED);
      };
      _send_cmd = function(cmd) {
        return _send_msg(_cstr(["cmd=", cmd, "&pos=", pos_id]), cmd);
      };

      /*
      Return geometric information about the SafeFrame container and it's status within a page
      
      @name $sf.ext.geom
      @public
      @static
      @function
      @return {Object} geom_info
       */
      geom = function() {
        return geom_info;
      };

      /*
      Return meta-data information that may have been specified by the publisher / host.
      
      @name $sf.ext.meta
      @public
      @static
      @function
      @param {String} propName the key name of the meta-data value to be retrieved
      @param {String} [owner_key] the super key name of the data to be retrieved
      @return {String} The value of some meta-data that may have been specified by the publisher / host or "".
       */
      meta = function(propName, owner_key) {
        var ret, shared;
        ret = "";
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              ret = _cstr(pos_meta[owner_key][propName]);
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                ret = _cstr(pos_meta.non_shared[owner_key][propName]);
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              ret = _cstr(shared[propName]);
            }
          }
        }
        return ret;
      };
      deleteMeta = function(propName, owner_key) {
        var shared;
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              return delete pos_meta[owner_key][propName];
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                return delete pos_meta.non_shared[owner_key][propName];
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              return delete shared[propName];
            }
          }
        }
      };

      /*
      Return the current status of the SafeFrame container, in cases where
      a command may be pending. If an empty string is returned ("") container is idle.
      
      @name $sf.ext.status
      @public
      @static
      @function
      @return {String} of any pending status, otherwise empty string.
       */
      status = function() {
        if (pending_msg) {
          if (pending_msg.cmd === EXPAND_COMMAND) {
            return STATUS_EXPANDING;
          } else {
            if (pending_msg.cmd === COLLAPSE_COMMAND) {
              return STATUS;
            }
          }
        }
        if (is_expanded) {
          return STATUS_EXPANDED;
        } else {
          return STATUS_COLLAPSED;
        }
      };

      /*
      Requests the host read or write a cookie to the host domain.
      The host domain must grant permission for the cookie to be written.
      
      @name $sf.ext.cookie
      @public
      @static
      @function
      @param {String} [cookieName] The name of the cookie to set or read
      @param {Object} [cookieData] An object hash containing the value and an optional expires
      @return {Number}
       */
      cookie = function(cookieName, cookieData) {
        var cmd_nm, cmd_str, isRead;
        isRead = !(cookieData != null);
        cmd_nm = (isRead ? "read-cookie" : "write-cookie");
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id, "&cookie=", cookieName];
        if (!isRead) {
          cmd_str.push("&value=");
          cmd_str.push(cookieData.value);
        }
        _send_msg(_cstr(cmd_str), cmd_nm);
      };

      /*
      Send a message to the host
      
      @name $sf.ext.message
      @public
      @static
      @function
       */
      message = function(content) {
        _send_msg(_cstr(["cmd=", "msg", "&pos=", pos_id, "&msg=", content]), "msg");
      };

      /*
      Return the percentage that the SafeFrame container is viewable within the browser window
      
      @name $sf.ext.inViewPercentage
      @public
      @static
      @function
      @return {Number}
       */
      inViewPercentage = function() {
        var iv, tv;
        iv = _cnum(geom_info && geom_info.self && geom_info.self.iv, -1, 0);
        tv = void 0;
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      winHasFocus = function() {
        return win_has_focus;
      };

      /*
      Return whether or not a particular feature is supported, or an object containing
      key/value pairs denoting all features and whether or not they are supported
      
      By default SafeFrames version 1 supports the following feature:
      
      "exp-ovr": Expansion of the container by overlaying on top of other content
      
      Later in other versions there are expexted to be more feature with their own
      string name, that can be checked by the content in the SafeFrame, so that
      it knows what things can be done.
      
      @name $sf.ext.supports
      @public
      @static
      @function
      @param {String} [key] If specifed, checks to see if that specific feature has been enabled
      @return {Boolean|Object}
       */
      supports = function(key) {
        var conf, sup;
        conf = render_params.conf;
        sup = (conf && conf.supports) || false;
        if (sup) {
          key = _cstr(key);
          if (key) {
            sup = sup[key] || false;
            if (sup === "0") {
              sup = false;
            }
          } else {
            sup = lang.mix({}, sup);
          }
        }
        return sup;
      };
      render = function(showAd, cb) {
        var err_info;
        err_info = {};
        if (_construction(err_info)) {
          if (showAd) {
            return _render(cb);
          }
        }
      };
      showAd = function(cb) {
        if (!isAdShown) {
          return _render(cb);
        }
      };
      adShown = function() {
        return isAdShown;
      };
      lang.mix(sf.ext, {
        register: register,
        expand: expand,
        collapse: collapse,
        geom: geom,
        meta: meta,
        deleteMeta: deleteMeta,
        status: status,
        supports: supports,
        cookie: cookie,
        message: message,
        inViewPercentage: inViewPercentage,
        winHasFocus: winHasFocus,
        click: click,
        viewed: viewed,
        unviewed: unviewed,
        showAd: showAd,
        adShown: adShown,
        reload: reload
      });
      if (!isExternal) {
        window.$sf = sf;
        render();
      } else {
        window.$sf = sf;
        sf.ext.render = render;
      }
      return sf;
    })(window, sf);
  };

}).call(this);

},{"../shared/base":11}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":12,"./env":13,"./lang":14,"./logger":15}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":13,"./lang":14}],13:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./lang":14,"8DwohR":16}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, wrap, _es, _keys, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    _keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + _keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray,
      wrap: wrap
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],16:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL2ZyYW1lLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvcmVxdWVzdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9iYXNlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL2NvbmZpZy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9ldmVudC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9zdHJlYW0uanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvdXRpbHMuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9qc29uL2pzb24yLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvcmVxd2VzdC9yZXF3ZXN0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9leHQvZXh0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvYmFzZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2RvbS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2Vudi5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2xhbmcuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9sb2dnZXIuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4aURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1akNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBSZXF1ZXN0LCBjdXJyZW50TmFtZSwgZXZlbnRzLCBzZiwgc3RyZWFtLCB1dGlscztcblxuICBjdXJyZW50TmFtZSA9IHdpbmRvdy5uYW1lO1xuXG4gIHNmID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvZXh0L2V4dCcpKHRydWUpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4vc2hhcmVkL2V2ZW50JykoW1wicmVxdWVzdFwiLCBcImxvYWRcIiwgXCJ2aWV3XCIsIFwiY2xpY2tcIiwgXCJleHBhbmRlZFwiLCBcImNvbGxhcHNlZFwiLCBcImVuZ2FnZVwiLCBcInVudmlld1wiLCBcInVubG9hZFwiXSk7XG5cbiAgdXRpbHMgPSByZXF1aXJlKCcuL3NoYXJlZC91dGlscycpO1xuXG4gIFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcblxuICBzdHJlYW0gPSByZXF1aXJlKCcuL3NoYXJlZC9zdHJlYW0nKTtcblxuICAoZnVuY3Rpb24oc2YsIHdpbmRvdykge1xuICAgIHZhciBBZEpTLCBWSUVXRURfU1RSSUtFLCBhdHRyaWJ1dGVzLCBkaWRTaG93LCBmb3JjZU51a2UsIGhlaWdodCwgaG9zdCwgaXNWaWV3ZWRJbnRlcnZhbCwgbG9jYXRpb24sIG9uVXBkYXRlLCByZWZlcnJlckxldmVsLCByZWdpc3RlckFkSlNlbmRwb2ludHMsIHJlZ2lzdGVyRm9yRXZlbnRzLCByZWdpc3RlcmVkLCByZXF1ZXN0LCByZXF1ZXN0ZWQsIHNldFNlc3Npb25JbmZvLCBzZkRvbSwgc2hvd0FkLCBzaG93QWRUaW1lciwgc2hvd1BhZ2UsIHVudmlld2VkVGlja3MsIHVwZGF0ZUlzVmlld2VkLCB1cGRhdGVSZWZlcnJlciwgdmlld2VkVGlja3MsIHdpZHRoO1xuICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuICAgIHJlcXVlc3QuY2hhbmdlKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmVhbS5ldmVudChyZXF1ZXN0KTtcbiAgICB9KTtcbiAgICBzZkRvbSA9IHNmLmxpYi5kb207XG4gICAgQWRKUyA9IHt9O1xuICAgIFZJRVdFRF9TVFJJS0UgPSA5O1xuICAgIHZpZXdlZFRpY2tzID0gMDtcbiAgICB1bnZpZXdlZFRpY2tzID0gMDtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgZGlkU2hvdyA9IGZhbHNlO1xuICAgIHJlcXVlc3RlZCA9IGZhbHNlO1xuICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBBZEpTLnNldERpbWVuc2lvbnMgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgICByZXR1cm4gaGVpZ2h0ID0gaDtcbiAgICB9O1xuICAgIHJlZ2lzdGVyRm9yRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiAkc2YuZXh0LnJlZ2lzdGVyKHdpZHRoLCBoZWlnaHQsIG9uVXBkYXRlKTtcbiAgICB9O1xuICAgIHJlZ2lzdGVyQWRKU2VuZHBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBzZXRTZXNzaW9uSW5mbyA9IGZ1bmN0aW9uKGNvb2tpZURhdGEpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh1dGlscy5mcm9tUXVlcnkoY29va2llRGF0YSkpO1xuICAgIH07XG4gICAgdXBkYXRlUmVmZXJyZXIgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgbGV2ZWwgPSBcImFsbFwiO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlIFwiYWxsXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgXCJob3N0XCI6XG4gICAgICAgICAgdXRpbHMuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsIFwicmVmZXJyZXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgb25VcGRhdGUgPSBmdW5jdGlvbihzdGF0dXMsIGRhdGEpIHtcbiAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJleHBhbmRlZFwiOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBBZEpTLmV4cGFuZGVkKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImNvbGxhcHNlZFwiOlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBBZEpTLmNvbGxhcHNlZCgpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJnZW9tLXVwZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiBzaG93QWQoKTtcbiAgICAgICAgY2FzZSBcImNvb2tpZS11cGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gc2V0U2Vzc2lvbkluZm8odW5lc2NhcGUoZGF0YS52YWx1ZSkpO1xuICAgICAgICBjYXNlIFwiZW5nYWdlZFwiOlxuICAgICAgICAgIHJldHVybiBBZEpTLmVuZ2FnZSgpO1xuICAgICAgICBjYXNlIFwicmVxdWVzdGVkXCI6XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBBZEpTLnJlcXVlc3QoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpc1ZpZXdlZEludGVydmFsID0gbnVsbDtcbiAgICB1cGRhdGVJc1ZpZXdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9iYXNlLCBfYmFzZTE7XG4gICAgICBpZiAoIUFkSlMuaXNWaWV3ZWQgJiYgKHR5cGVvZiAoX2Jhc2UgPSAkc2YuZXh0KS5pblZpZXdQZXJjZW50YWdlID09PSBcImZ1bmN0aW9uXCIgPyBfYmFzZS5pblZpZXdQZXJjZW50YWdlKCkgOiB2b2lkIDApID4gNTAgJiYgJHNmLmV4dC53aW5IYXNGb2N1cygpKSB7XG4gICAgICAgIHZpZXdlZFRpY2tzKys7XG4gICAgICB9IGVsc2UgaWYgKEFkSlMuaXNWaWV3ZWQgJiYgKCh0eXBlb2YgKF9iYXNlMSA9ICRzZi5leHQpLmluVmlld1BlcmNlbnRhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IF9iYXNlMS5pblZpZXdQZXJjZW50YWdlKCkgOiB2b2lkIDApIDwgNTAgfHwgISRzZi5leHQud2luSGFzRm9jdXMoKSkpIHtcbiAgICAgICAgdW52aWV3ZWRUaWNrcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW52aWV3ZWRUaWNrcyA9IHZpZXdlZFRpY2tzID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3ZWRUaWNrcyA9PT0gVklFV0VEX1NUUklLRSkge1xuICAgICAgICBpZiAoIUFkSlMuaXNWaWV3ZWQpIHtcbiAgICAgICAgICBBZEpTLnZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBBZEpTLmlzVmlld2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnZpZXdlZFRpY2tzID09PSBWSUVXRURfU1RSSUtFKSB7XG4gICAgICAgIGlmICghQWRKUy5pc3VuVmlld2VkKSB7XG4gICAgICAgICAgQWRKUy51bnZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBBZEpTLmlzdW5WaWV3ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChpc1ZpZXdlZEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNob3dBZFRpbWVyID0gbnVsbDtcbiAgICBzaG93QWQgPSBmdW5jdGlvbihzaG93KSB7XG4gICAgICB2YXIgc3RhcnRUaW1lLCBfYmFzZTtcbiAgICAgIGlmICgoKHR5cGVvZiAoX2Jhc2UgPSAkc2YuZXh0KS5pblZpZXdQZXJjZW50YWdlID09PSBcImZ1bmN0aW9uXCIgPyBfYmFzZS5pblZpZXdQZXJjZW50YWdlKCkgOiB2b2lkIDApID4gNSAmJiAhZGlkU2hvdykgfHwgc2hvdykge1xuICAgICAgICBpZiAoc2hvd0FkVGltZXIpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHNob3dBZFRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgQWRKUy5yZXF1ZXN0KCk7XG4gICAgICAgICRzZi5leHQuc2hvd0FkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBBZEpTLmxvYWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWRTaG93ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIShzaG93QWRUaW1lciB8fCBkaWRTaG93KSkge1xuICAgICAgICByZXR1cm4gc2hvd0FkVGltZXIgPSBzZXRJbnRlcnZhbChmb3JjZU51a2UsIDUwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvcmNlTnVrZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9iYXNlO1xuICAgICAgaWYgKCh0eXBlb2YgKF9iYXNlID0gJHNmLmV4dCkuaW5WaWV3UGVyY2VudGFnZSA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2UuaW5WaWV3UGVyY2VudGFnZSgpIDogdm9pZCAwKSA+IDUgJiYgc2hvd0FkVGltZXIpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChzaG93QWRUaW1lcik7XG4gICAgICAgIHNob3dBZFRpbWVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuICRzZi5leHQucmVsb2FkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzZi5saWIubGFuZy5taXgoQWRKUywgZXZlbnRzKTtcbiAgICBBZEpTLm9uID0gZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgICByZXR1cm4gZXZlbnRzLm9uLmFwcGx5KHRoaXMsIFtldmVudCwgY2JdKTtcbiAgICB9O1xuICAgIEFkSlMuZXhwYW5kID0gZnVuY3Rpb24oZGVsdGFYb3JEZXNjLCBkZWx0YVksIHApIHtcbiAgICAgIHJldHVybiAkc2YuZXh0LmV4cGFuZChkZWx0YVhvckRlc2MsIGRlbHRhWSwgcCk7XG4gICAgfTtcbiAgICBBZEpTLmNvbGxhcHNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNmLmV4dC5jb2xsYXBzZSgpO1xuICAgIH07XG4gICAgQWRKUy5jb29raWUgPSBmdW5jdGlvbihjb29raWVOYW1lLCBjb29raWVEYXRhKSB7XG4gICAgICByZXR1cm4gJHNmLmV4dC5jb29raWUoY29vb2tpZU5hbWUsIGNvb2tpZURhdGEpO1xuICAgIH07XG4gICAgQWRKUy5zdXBwb3J0cyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuICRzZi5leHQuc3VwcG9ydHMoa2V5KTtcbiAgICB9O1xuICAgIEFkSlMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRzZi5leHQubWVzc2FnZShlbmNvZGVVUklDb21wb25lbnQoY29udGVudCkpO1xuICAgICAgfSwgMSk7XG4gICAgfTtcbiAgICBzZkRvbS5hdHRhY2goZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgQWRKUy5jbGljaygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgd2luZG93LiRhZCA9IEFkSlM7XG4gICAgcmVnaXN0ZXJBZEpTZW5kcG9pbnRzKCk7XG4gICAgQWRKUy5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZi5leHQuY2xpY2soKTtcbiAgICB9KTtcbiAgICBBZEpTLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2YuZXh0LnZpZXdlZCgpO1xuICAgIH0pO1xuICAgIEFkSlMudW52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNmLmV4dC51bnZpZXdlZCgpO1xuICAgIH0pO1xuICAgIEFkSlMubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWdpc3RlckZvckV2ZW50cygpO1xuICAgIH0pO1xuICAgIEFkSlMubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc1ZpZXdlZEludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlSXNWaWV3ZWQsIDEwMCk7XG4gICAgfSk7XG4gICAgQWRKUy5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgQWRKUy5mcmFtZUNvdW50ID0gdXRpbHMuY291bnRGcmFtZXMod2luZG93KTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIGZyYW1lX2NvdW50OiBBZEpTLmZyYW1lQ291bnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEFkSlMucmVxdWVzdChmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMucmVxdWVzdFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIHJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgcmVxdWVzdGVkQXQ6IHV0aWxzLm5vdygpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLmxvYWRUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICBzZkRvbS5hdHRhY2god2luZG93LCBcInVubG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRhZC51bmxvYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICBsb2FkZWRBdDogdXRpbHMubm93KClcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEFkSlMudmlldyhmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMudmlld1RpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNldCh7XG4gICAgICAgIHZpZXdlZDogdHJ1ZSxcbiAgICAgICAgdmlld2VkQXQ6IHV0aWxzLm5vdygpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLmVuZ2FnZShmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMuZW5nYWdlVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgZW5nYWdlZDogdHJ1ZSxcbiAgICAgICAgZW5nYWdlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMuY2xpY2tUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICBjbGlja2VkOiB0cnVlLFxuICAgICAgICBjbGlja2VkQXQ6IHV0aWxzLm5vdygpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnVudmlldyhmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMudW52aWV3VGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgdW52aWV3ZWQ6IHRydWUsXG4gICAgICAgIHVudmlld2VkQXQ6IHV0aWxzLm5vdygpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnVubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMudW5sb2FkVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgdW5sb2FkZWQ6IHRydWUsXG4gICAgICAgIHVubG9hZGVkQXQ6IHV0aWxzLm5vdygpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzZi5leHQucmVuZGVyKGZhbHNlKTtcbiAgICBkaWRTaG93ID0gIXNmLmxpYi5sYW5nLmNib29sKHNmLmV4dC5tZXRhKFwiaW52aWV3XCIsIFwiZXh0ZW5kZWRcIikpO1xuICAgIHJlZmVycmVyTGV2ZWwgPSBzZi5leHQubWV0YShcInJlZmVycmVyXCIsIFwiZXh0ZW5kZWRcIikgfHwgXCJhbGxcIjtcbiAgICBob3N0ID0gc2YuZXh0Lm1ldGEoXCJob3N0XCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgc2YuZXh0LmRlbGV0ZU1ldGEoXCJob3N0XCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgbG9jYXRpb24gPSBzZi5leHQubWV0YShcImxvY2F0aW9uXCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgc2YuZXh0LmRlbGV0ZU1ldGEoXCJsb2NhdGlvblwiLCBcImV4dGVuZGVkXCIpO1xuICAgIHNldFNlc3Npb25JbmZvKHNmLmV4dC5tZXRhKFwic2Vzc2lvblwiLCBcImV4dGVuZGVkXCIpLCB7XG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgICBzZi5leHQuZGVsZXRlTWV0YShcInNlc3Npb25cIiwgXCJleHRlbmRlZFwiKTtcbiAgICAkYWQuc2xvdElkID0gc2YuZXh0Lm1ldGEoXCJzbG90X2lkXCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgJGFkLmNvdW50ID0gc2YuZXh0Lm1ldGEoXCJzbG90X2NvdW50XCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgcmVxdWVzdC5zZXQoe1xuICAgICAgc2xvdF9pZDogc2YuZXh0Lm1ldGEoXCJzbG90X2lkXCIsIFwiZXh0ZW5kZWRcIiksXG4gICAgICBzbG90X2NvdW50OiBzZi5leHQubWV0YShcInNsb3RfY291bnRcIiwgXCJleHRlbmRlZFwiKSxcbiAgICAgIHBhZ2VfdXJsOiBsb2NhdGlvbixcbiAgICAgIHBhZ2VfaG9zdDogaG9zdFxuICAgIH0sIHtcbiAgICAgIHNpbGVudDogdHJ1ZVxuICAgIH0pO1xuICAgIHNob3dQYWdlID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9PT0gZG9jdW1lbnQucmVmZXJyZXIgfHwgdXBkYXRlUmVmZXJyZXIocmVmZXJyZXJMZXZlbCk7XG4gICAgaWYgKHNob3dQYWdlKSB7XG4gICAgICBzaG93QWQoZGlkU2hvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5uYW1lID0gY3VycmVudE5hbWU7XG4gICAgICBkb2N1bWVudC5sb2NhdGlvbiA9IGRvY3VtZW50LmxvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gQWRKUztcbiAgfSkoc2YsIHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBCYXNlLCB1dGlscyxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB3aW5kb3cuSlNPTiB8fCAod2luZG93LkpTT04gPSByZXF1aXJlKCdqc29uJykpO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi9zaGFyZWQvdXRpbHMnKTtcblxuICBCYXNlID0gcmVxdWlyZSgnLi9zaGFyZWQvYmFzZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBSZXF1ZXN0O1xuICAgIFJlcXVlc3QgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICB2YXIgUkVRX0lOVEVSVkFMO1xuXG4gICAgICBfX2V4dGVuZHMoUmVxdWVzdCwgX3N1cGVyKTtcblxuICAgICAgUkVRX0lOVEVSVkFMID0gNTA7XG5cbiAgICAgIGZ1bmN0aW9uIFJlcXVlc3QoY2xpZW50SWQsIHNlc3Npb25JZCkge1xuICAgICAgICBSZXF1ZXN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdEluUHJvY2Vzcykge1xuICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzLnNlbmRSZXF1ZXN0KFwiaHR0cDovLzEyNy4wLjAuMS90ZXN0XCIsIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9jZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChkYXRhLCB7XG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBSZXF1ZXN0O1xuXG4gICAgfSkoQmFzZSk7XG4gICAgcmV0dXJuIFJlcXVlc3Q7XG4gIH0pKHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBCYXNlO1xuICAgIHJldHVybiBCYXNlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQmFzZSgpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzIHx8ICh0aGlzLmF0dHJpYnV0ZXMgPSB7fSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIGYsIGssIHYsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvciAoayBpbiBhdHRycykge1xuICAgICAgICAgIHYgPSBhdHRyc1trXTtcbiAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW2tdICE9PSB2KSB7XG4gICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlcy5wdXNoKGspO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba10gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQgJiYgY2hhbmdlZEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF9yZWYgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGYgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZi5hcHBseSh0aGlzLCBbdGhpcywgY2hhbmdlZEF0dHJpYnV0ZXNdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuY2hhbmdlID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBpZiAoZiAmJiB0eXBlb2YgZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5wdXNoKGYpO1xuICAgICAgICB9IGVsc2UgaWYgKCFmKSB7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBCYXNlO1xuXG4gICAgfSkoKTtcbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcGk6ICcvL2VuZHBvaW50LmFkanMuZGV2OjgwODAvMScsXG4gICAgICAgIGNkbl91cmw6ICdiYXNlL2xpYi9odG1sL2FkanNmcmFtZS5odG1sJyxcbiAgICAgICAgdmlzaXRfZXhwaXJ5OiAxXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBpOiBcIi8vZW5kcG9pbnQuYWRqcy5pby8xXCIsXG4gICAgICAgIGNkbl91cmw6IHByb2Nlc3MuZW52LkNETl9VUkwsXG4gICAgICAgIHZpc2l0X2V4cGlyeTogMzBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJy4uL2xpYi9odG1sL2FkanNmcmFtZS5odG1sJyxcbiAgICAgICAgdmlzaXRfZXhwaXJ5OiAzXG4gICAgICB9O1xuICAgIH1cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCBldmVudHMsIHV0aWxzLCBfaSwgX2xlbjtcbiAgICAgIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgICAgZXZlbnRzID0ge1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdDtcbiAgICAgICAgICB0aGlzLmV2ZW50cyB8fCAodGhpcy5ldmVudHMgPSB7fSk7XG4gICAgICAgICAgZXZlbnRMaXN0ID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKGNiKTtcbiAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBldmVudExpc3Q7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICBvcHRpb25hbERhdGEgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhLCBvcHRpb25hbERhdGEpIHtcbiAgICAgICAgICB2YXIgZSwgZXgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICAgIHRoaXMuZXZlbnRzIHx8ICh0aGlzLmV2ZW50cyA9IHt9KTtcbiAgICAgICAgICBfcmVmID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZSA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZS5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbmFsRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXggPSBfZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubm90aWZ5KGV2ZW50LCBkYXRhIHx8IHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBub3RpZnk6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZHBvaW50LCBwYXJhbXMsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjEgPSAoKF9yZWYgPSB0aGlzLmV2ZW50RW5kcG9pbnRzKSAhPSBudWxsID8gX3JlZltldmVudF0gOiB2b2lkIDApIHx8IFtdO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICBwYXJhbXMgPSAoZGF0YSAhPSBudWxsID8gdHlwZW9mIGRhdGEuZ2V0UGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBkYXRhLmdldFBhcmFtcygpIDogdm9pZCAwIDogdm9pZCAwKSB8fCB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh1dGlscy5zZW5kUmVxdWVzdChlbmRwb2ludCwge1xuICAgICAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBldmVudE5hbWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnROYW1lc1tfaV07XG4gICAgICAgIGV2ZW50c1tldmVudF0gPSAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICByZXR1cm4gZiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgZXZlbnRzW1wiXCIgKyBldmVudCArIFwiUmVnaXN0ZXJFbmRwb2ludFwiXSA9IChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIHJldHVybiBmID0gZnVuY3Rpb24oZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBfYmFzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbmRwb2ludHMgfHwgKHRoaXMuZXZlbnRFbmRwb2ludHMgPSB7fSk7XG4gICAgICAgICAgICAoX2Jhc2UgPSB0aGlzLmV2ZW50RW5kcG9pbnRzKVtldmVudF0gfHwgKF9iYXNlW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50RW5kcG9pbnRzW2V2ZW50XS5wdXNoKGVuZHBvaW50KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KShldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH0pKCk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBjb25maWcsIHJlcXdlc3Q7XG5cbiAgcmVxd2VzdCA9IHJlcXVpcmUoJ3JlcXdlc3QnKTtcblxuICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nUmVxdWVzdHMsIHByZWZpeCwgc2VuZCwgc2VuZGluZ1JlcXVlc3RzO1xuICAgIHByZWZpeCA9IGNvbmZpZy5hcGk7XG4gICAgcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgIHJldHVybiByZXF3ZXN0KHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHR5cGU6ICdqc29ucCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZTogZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB2YXIgZXJyb3IsIGssIG9iaiwgc3Vic3QsIHN1Y2Nlc3MsIHYsIF9yZWY7XG4gICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgcmV0dXJuIHNlc3Npb24uc2V0KHJlc3AsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVSUk9SOlwiICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3Vic3QgPSB7XG4gICAgICAgICAgaWQ6ICdwYWdlX2lkJyxcbiAgICAgICAgICB2aWQ6ICd2aXNfaWQnLFxuICAgICAgICAgIHA6ICdzaXRlX3BhZ2VfdncnXG4gICAgICAgIH07XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBfcmVmID0gc2Vzc2lvbi5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICAgIGlmIChzdWJzdFtrXSkge1xuICAgICAgICAgICAgb2JqW3N1YnN0W2tdXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgJ1xcdCcpKTtcbiAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbi5hdHRyaWJ1dGVzLCBudWxsLCAnXFx0JykpO1xuICAgICAgICByZXR1cm4gc2VuZChwcmVmaXggKyAnL3BhZ2UnLCBzZXNzaW9uLmF0dHJpYnV0ZXMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgIH0sXG4gICAgICBldmVudDogZnVuY3Rpb24ocmVxdWVzdCwgY2IsIGlzQXR0ZW1wdCkge1xuICAgICAgICB2YXIgZXJyb3IsIHN1Y2Nlc3M7XG4gICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgcmVxdWVzdC5zZXQocmVzcCwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjYihyZXNwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSBzZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF07XG4gICAgICAgIH07XG4gICAgICAgIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiRVJST1I6XCIgKyBlcnIpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXNlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSkge1xuICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF07XG4gICAgICAgICAgc2VuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gc2VuZChwcmVmaXggKyAnL2V2ZW50JywgcmVxdWVzdC5hdHRyaWJ1dGVzLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSB8fCBpc0F0dGVtcHQpIHtcbiAgICAgICAgICBwZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF07XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ldmVudChyZXF1ZXN0LCBjYiwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKHRoaXMpLCA1MDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGNhcGl0YWxpemVTdHJpbmc7XG5cbiAgd2luZG93LnJlcXdlc3QgfHwgKHdpbmRvdy5yZXF3ZXN0ID0gcmVxdWlyZSgncmVxd2VzdCcpKTtcblxuICB3aW5kb3cuSlNPTiB8fCAod2luZG93LkpTT04gPSByZXF1aXJlKCdqc29uJykpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCRzZiwgd2luZG93KSB7XG4gICAgdmFyIGNvdW50RnJhbWVzLCBkZWZpbmVQcm9wZXJ0eSwgZSwgZTIsIGZyb21RdWVyeSwgZ2V0UmVmZXJyZXIsIG5vdywgcmVmZXJyZXIsIHJlcXdlc3QsIHNlbmRSZXF1ZXN0LCB0b051bWJlciwgdG9RdWVyeTtcbiAgICByZXF3ZXN0ID0gd2luZG93LnJlcXdlc3Q7XG4gICAgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF3ZXN0KHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHR5cGU6ICdqc29ucCcsXG4gICAgICAgIHN1Y2Nlc3M6IG9wdGlvbnMuc3VjY2VzcyxcbiAgICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3IsXG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmcm9tUXVlcnkgPSBmdW5jdGlvbihxdWVyeSwgZGVsaW0pIHtcbiAgICAgIHZhciBpdGVtLCBrZXksIHBhcmFtcywgdmFsdWUsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMTtcbiAgICAgIGlmIChxdWVyeSA9PSBudWxsKSB7XG4gICAgICAgIHF1ZXJ5ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxpbSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGltID0gXCImXCI7XG4gICAgICB9XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICAgIF9yZWYgPSBxdWVyeS5zcGxpdChkZWxpbSk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaXRlbSA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVmMSA9IGl0ZW0uc3BsaXQoXCI9XCIpLCBrZXkgPSBfcmVmMVswXSwgdmFsdWUgPSBfcmVmMVsxXTtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICAgIHRvUXVlcnkgPSBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKGF0dHJpYnV0ZXMpO1xuICAgIH07XG4gICAgdG9OdW1iZXIgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAkc2YgIT0gbnVsbCA/ICRzZi5saWIubGFuZy5jbnVtKHZhbCwgMCkgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHByb3AsIGRlc2NyaXB0b3IpIHtcbiAgICAgIHZhciBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFwiZGVmaW5lUHJvcGVydHlcIiBpbiBPYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJfX2RlZmluZUdldHRlcl9fXCIgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUpIHtcbiAgICAgICAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKHByb3AsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iud3JpdGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmouX19kZWZpbmVTZXR0ZXJfXyhwcm9wLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18ocHJvcCwgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai5fX2RlZmluZVNldHRlcl9fKHByb3AsIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb3VudEZyYW1lcyA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgdmFyIGNvdW50LCBmcmFtZSwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBjb3VudCA9IHdpbi5mcmFtZXMubGVuZ3RoO1xuICAgICAgX3JlZiA9IHdpbi5mcmFtZXM7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZnJhbWUgPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGZyYW1lICE9PSB3aW4pIHtcbiAgICAgICAgICBjb3VudCArPSBjb3VudEZyYW1lcyhmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIGdldFJlZmVycmVyID0gZnVuY3Rpb24od2luKSB7XG4gICAgICB2YXIgcXMsIHJlZmVycmVyO1xuICAgICAgcmVmZXJyZXIgPSAnJztcbiAgICAgIHFzID0gb2JqZWN0LmZyb21RdWVyeXN0cmluZyhcInJlZmVycmVyXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB8fCBvYmplY3QuZnJvbVF1ZXJ5c3RyaW5nKFwicmVmZXJlclwiLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICBpZiAocXMpIHtcbiAgICAgICAgcmV0dXJuIHFzO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIHJlZmVycmVyID0gd2luZG93LnRvcC5kb2N1bWVudC5yZWZlcnJlcjtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGUgPSBfZXJyb3I7XG4gICAgICBpZiAod2luZG93LnBhcmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlZmVycmVyID0gd2luZG93LnBhcmVudC5kb2N1bWVudC5yZWZlcnJlcjtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZTIgPSBfZXJyb3I7XG4gICAgICAgICAgcmVmZXJyZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWZlcnJlciA9PT0gXCJcIikge1xuICAgICAgcmVmZXJyZXIgPSBkb2N1bWVudC5yZWZlcnJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlZmVycmVyO1xuICB9KSgkc2YsIHdpbmRvdyk7XG5cbiAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudFR5cGUsIGV2ZW50SGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50SGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50VHlwZSwgZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxlbWVudFtcIm9uXCIgKyBldmVudFR5cGVdID0gZXZlbnRIYW5kbGVyO1xuICB9O1xuXG4gIG9iamVjdC5mcm9tUXVlcnlzdHJpbmcgPSBmdW5jdGlvbihmaWVsZCwgdXJsKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIG1hdGNoID0gUmVnRXhwKFwiXlteI10qWz8mXVwiICsgZmllbGQgKyBcIj0oW14mI10qKVwiKS5leGVjKHVybCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG4gIH07XG5cbiAgY2FwaXRhbGl6ZVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gIH07XG5cbiAgKHtcbiAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3QsXG4gICAgdG9RdWVyeTogdG9RdWVyeSxcbiAgICBmcm9tUXVlcnk6IGZyb21RdWVyeSxcbiAgICB0b051bWJlcjogdG9OdW1iZXIsXG4gICAgbm93OiBub3csXG4gICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5LFxuICAgIGNvdW50RnJhbWVzOiBjb3VudEZyYW1lcyxcbiAgICBjYXBpdGFsaXplU3RyaW5nOiBjYXBpdGFsaXplU3RyaW5nXG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLypcbiAgICBodHRwOi8vd3d3LkpTT04ub3JnL2pzb24yLmpzXG4gICAgMjAxMS0wMi0yM1xuXG4gICAgUHVibGljIERvbWFpbi5cblxuICAgIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cblxuICAgIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcblxuXG4gICAgVGhpcyBjb2RlIHNob3VsZCBiZSBtaW5pZmllZCBiZWZvcmUgZGVwbG95bWVudC5cbiAgICBTZWUgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9qc21pbi5odG1sXG5cbiAgICBVU0UgWU9VUiBPV04gQ09QWS4gSVQgSVMgRVhUUkVNRUxZIFVOV0lTRSBUTyBMT0FEIENPREUgRlJPTSBTRVJWRVJTIFlPVSBET1xuICAgIE5PVCBDT05UUk9MLlxuXG5cbiAgICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbiAgICBhbmQgcGFyc2UuXG5cbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSlcbiAgICAgICAgICAgIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cblxuICAgICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cblxuICAgICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgJ1xcdCcgb3IgJyZuYnNwOycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cblxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG5cbiAgICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4gICAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuICAgICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuICAgICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4gICAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbiAgICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZVxuXG4gICAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBzZXJpYWxpemUgRGF0ZXMgYXMgSVNPIHN0cmluZ3MuXG5cbiAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbiAgICAgICAgICAgIGtleSBhbmQgdmFsdWUgb2YgZWFjaCBtZW1iZXIsIHdpdGggdGhpcyBib3VuZCB0byB0aGUgY29udGFpbmluZ1xuICAgICAgICAgICAgb2JqZWN0LiBUaGUgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHlvdXIgbWV0aG9kIHdpbGwgYmVcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuICAgICAgICAgICAgYmUgZXhjbHVkZWQgZnJvbSB0aGUgc2VyaWFsaXphdGlvbi5cblxuICAgICAgICAgICAgSWYgdGhlIHJlcGxhY2VyIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgICAgICAgIHVzZWQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHNlcmlhbGl6ZWQuIEl0IGZpbHRlcnMgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIHN1Y2ggdGhhdCBvbmx5IG1lbWJlcnMgd2l0aCBrZXlzIGxpc3RlZCBpbiB0aGUgcmVwbGFjZXIgYXJyYXkgYXJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgVmFsdWVzIHRoYXQgZG8gbm90IGhhdmUgSlNPTiByZXByZXNlbnRhdGlvbnMsIHN1Y2ggYXMgdW5kZWZpbmVkIG9yXG4gICAgICAgICAgICBmdW5jdGlvbnMsIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuIFN1Y2ggdmFsdWVzIGluIG9iamVjdHMgd2lsbCBiZVxuICAgICAgICAgICAgZHJvcHBlZDsgaW4gYXJyYXlzIHRoZXkgd2lsbCBiZSByZXBsYWNlZCB3aXRoIG51bGwuIFlvdSBjYW4gdXNlXG4gICAgICAgICAgICBhIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhvc2Ugd2l0aCBKU09OIHZhbHVlcy5cbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4gICAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4gICAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuICAgICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuICAgICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbiAgICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcImVcIix7XCJwbHVyaWJ1c1wiOlwidW51bVwifV0nXG5cblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFsnZScsIHtwbHVyaWJ1czogJ3VudW0nfV0sIG51bGwsICdcXHQnKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgICAgICAgICAgICAgJ0RhdGUoJyArIHRoaXNba2V5XSArICcpJyA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cblxuICAgICAgICBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpXG4gICAgICAgICAgICBUaGlzIG1ldGhvZCBwYXJzZXMgYSBKU09OIHRleHQgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICAgICAgICBJdCBjYW4gdGhyb3cgYSBTeW50YXhFcnJvciBleGNlcHRpb24uXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbiAgICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuICAgICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuICAgICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuICAgICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPVxuL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gJ0RhdGUoJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTEpID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgVGhpcyBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi4gWW91IGFyZSBmcmVlIHRvIGNvcHksIG1vZGlmeSwgb3JcbiAgICByZWRpc3RyaWJ1dGUuXG4qL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCByZWdleHA6IGZhbHNlICovXG5cbi8qbWVtYmVycyBcIlwiLCBcIlxcYlwiLCBcIlxcdFwiLCBcIlxcblwiLCBcIlxcZlwiLCBcIlxcclwiLCBcIlxcXCJcIiwgSlNPTiwgXCJcXFxcXCIsIGFwcGx5LFxuICAgIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgICBnZXRVVENNaW51dGVzLCBnZXRVVENNb250aCwgZ2V0VVRDU2Vjb25kcywgaGFzT3duUHJvcGVydHksIGpvaW4sXG4gICAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG4gICAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuKi9cblxuXG4vLyBDcmVhdGUgYSBKU09OIG9iamVjdCBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBXZSBjcmVhdGUgdGhlXG4vLyBtZXRob2RzIGluIGEgY2xvc3VyZSB0byBhdm9pZCBjcmVhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxuXG52YXIgSlNPTjtcbmlmICghSlNPTikge1xuICAgIEpTT04gPSB7fTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBnbG9iYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpXG4gICAgICAsIEpTT04gPSBnbG9iYWwuSlNPTlxuICAgICAgO1xuXG4gICAgaWYgKCFKU09OKSB7XG4gICAgICBKU09OID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRVVENGdWxsWWVhcigpICAgICArICctJyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJyA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gICAgICA9XG4gICAgICAgICAgICBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiAgPVxuICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGdhcCxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICB9LFxuICAgICAgICByZXA7XG5cblxuICAgIGZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXG4vLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4vLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4vLyBzZXF1ZW5jZXMuXG5cbiAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblxuLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXG4gICAgICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgICAgIHBhcnRpYWwsXG4gICAgICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4vLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbi8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuXG4vLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4vLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4vLyBudWxsLlxuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG5cbi8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0Jyxcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4vLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXG4vLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4vLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4vLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBzdHJpbmdpZnkgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuXG4vLyBUaGUgc3RyaW5naWZ5IG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCByZXBsYWNlciwgYW5kIGFuIG9wdGlvbmFsXG4vLyBzcGFjZSBwYXJhbWV0ZXIsIGFuZCByZXR1cm5zIGEgSlNPTiB0ZXh0LiBUaGUgcmVwbGFjZXIgY2FuIGJlIGEgZnVuY3Rpb25cbi8vIHRoYXQgY2FuIHJlcGxhY2UgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGtleXMuXG4vLyBBIGRlZmF1bHQgcmVwbGFjZXIgbWV0aG9kIGNhbiBiZSBwcm92aWRlZC4gVXNlIG9mIHRoZSBzcGFjZSBwYXJhbWV0ZXIgY2FuXG4vLyBwcm9kdWNlIHRleHQgdGhhdCBpcyBtb3JlIGVhc2lseSByZWFkYWJsZS5cblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBnYXAgPSAnJztcbiAgICAgICAgICAgIGluZGVudCA9ICcnO1xuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4vLyBtYW55IHNwYWNlcy5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICAgICAgICAgICAgcmVwID0gcmVwbGFjZXI7XG4gICAgICAgICAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5wYXJzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cblxuLy8gUGFyc2luZyBoYXBwZW5zIGluIGZvdXIgc3RhZ2VzLiBJbiB0aGUgZmlyc3Qgc3RhZ2UsIHdlIHJlcGxhY2UgY2VydGFpblxuLy8gVW5pY29kZSBjaGFyYWN0ZXJzIHdpdGggZXNjYXBlIHNlcXVlbmNlcy4gSmF2YVNjcmlwdCBoYW5kbGVzIG1hbnkgY2hhcmFjdGVyc1xuLy8gaW5jb3JyZWN0bHksIGVpdGhlciBzaWxlbnRseSBkZWxldGluZyB0aGVtLCBvciB0cmVhdGluZyB0aGVtIGFzIGxpbmUgZW5kaW5ncy5cblxuICAgICAgICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0KTtcbiAgICAgICAgICAgIGN4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoY3gudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoY3gsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbi8vIEluIHRoZSBzZWNvbmQgc3RhZ2UsIHdlIHJ1biB0aGUgdGV4dCBhZ2FpbnN0IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBsb29rXG4vLyBmb3Igbm9uLUpTT04gcGF0dGVybnMuIFdlIGFyZSBlc3BlY2lhbGx5IGNvbmNlcm5lZCB3aXRoICcoKScgYW5kICduZXcnXG4vLyBiZWNhdXNlIHRoZXkgY2FuIGNhdXNlIGludm9jYXRpb24sIGFuZCAnPScgYmVjYXVzZSBpdCBjYW4gY2F1c2UgbXV0YXRpb24uXG4vLyBCdXQganVzdCB0byBiZSBzYWZlLCB3ZSB3YW50IHRvIHJlamVjdCBhbGwgdW5leHBlY3RlZCBmb3Jtcy5cblxuLy8gV2Ugc3BsaXQgdGhlIHNlY29uZCBzdGFnZSBpbnRvIDQgcmVnZXhwIG9wZXJhdGlvbnMgaW4gb3JkZXIgdG8gd29yayBhcm91bmRcbi8vIGNyaXBwbGluZyBpbmVmZmljaWVuY2llcyBpbiBJRSdzIGFuZCBTYWZhcmkncyByZWdleHAgZW5naW5lcy4gRmlyc3Qgd2Vcbi8vIHJlcGxhY2UgdGhlIEpTT04gYmFja3NsYXNoIHBhaXJzIHdpdGggJ0AnIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCAnXScgY2hhcmFjdGVycy4gVGhpcmQsIHdlIGRlbGV0ZSBhbGxcbi8vIG9wZW4gYnJhY2tldHMgdGhhdCBmb2xsb3cgYSBjb2xvbiBvciBjb21tYSBvciB0aGF0IGJlZ2luIHRoZSB0ZXh0LiBGaW5hbGx5LFxuLy8gd2UgbG9vayB0byBzZWUgdGhhdCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYXJlIG9ubHkgd2hpdGVzcGFjZSBvciAnXScgb3Jcbi8vICcsJyBvciAnOicgb3IgJ3snIG9yICd9Jy4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoL15bXFxdLDp7fVxcc10qJC9cbiAgICAgICAgICAgICAgICAgICAgLnRlc3QodGV4dC5yZXBsYWNlKC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2csICdAJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZywgJ10nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLCAnJykpKSB7XG5cbi8vIEluIHRoZSB0aGlyZCBzdGFnZSB3ZSB1c2UgdGhlIGV2YWwgZnVuY3Rpb24gdG8gY29tcGlsZSB0aGUgdGV4dCBpbnRvIGFcbi8vIEphdmFTY3JpcHQgc3RydWN0dXJlLiBUaGUgJ3snIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9IGV2YWwoJygnICsgdGV4dCArICcpJyk7XG5cbi8vIEluIHRoZSBvcHRpb25hbCBmb3VydGggc3RhZ2UsIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsIHBhc3Npbmdcbi8vIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIGEgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGUgdHJhbnNmb3JtYXRpb24uXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICB3YWxrKHsnJzogan0sICcnKSA6IGo7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSB0ZXh0IGlzIG5vdCBKU09OIHBhcnNlYWJsZSwgdGhlbiBhIFN5bnRheEVycm9yIGlzIHRocm93bi5cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdKU09OLnBhcnNlJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2xvYmFsLkpTT04gPSBKU09OO1xuICAgIG1vZHVsZS5leHBvcnRzID0gSlNPTjtcbn0oKSk7XG4iLCIvKiFcbiAgKiBSZXF3ZXN0ISBBIGdlbmVyYWwgcHVycG9zZSBYSFIgY29ubmVjdGlvbiBtYW5hZ2VyXG4gICogbGljZW5zZSBNSVQgKGMpIER1c3RpbiBEaWF6IDIwMTRcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL3JlcXdlc3RcbiAgKi9cblxuIWZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgY29udGV4dFtuYW1lXSA9IGRlZmluaXRpb24oKVxufSgncmVxd2VzdCcsIHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgd2luID0gd2luZG93XG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgdHdvSHVuZG8gPSAvXigyMFxcZHwxMjIzKSQvXG4gICAgLCBieVRhZyA9ICdnZXRFbGVtZW50c0J5VGFnTmFtZSdcbiAgICAsIHJlYWR5U3RhdGUgPSAncmVhZHlTdGF0ZSdcbiAgICAsIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZSdcbiAgICAsIHJlcXVlc3RlZFdpdGggPSAnWC1SZXF1ZXN0ZWQtV2l0aCdcbiAgICAsIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF1cbiAgICAsIHVuaXFpZCA9IDBcbiAgICAsIGNhbGxiYWNrUHJlZml4ID0gJ3JlcXdlc3RfJyArICgrbmV3IERhdGUoKSlcbiAgICAsIGxhc3RWYWx1ZSAvLyBkYXRhIHN0b3JlZCBieSB0aGUgbW9zdCByZWNlbnQgSlNPTlAgY2FsbGJhY2tcbiAgICAsIHhtbEh0dHBSZXF1ZXN0ID0gJ1hNTEh0dHBSZXF1ZXN0J1xuICAgICwgeERvbWFpblJlcXVlc3QgPSAnWERvbWFpblJlcXVlc3QnXG4gICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cblxuICAgICwgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBBcnJheS5pc0FycmF5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICB9XG5cbiAgICAsIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgICAgICdjb250ZW50VHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICwgJ3JlcXVlc3RlZFdpdGgnOiB4bWxIdHRwUmVxdWVzdFxuICAgICAgICAsICdhY2NlcHQnOiB7XG4gICAgICAgICAgICAgICcqJzogICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJ1xuICAgICAgICAgICAgLCAneG1sJzogICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJ1xuICAgICAgICAgICAgLCAnaHRtbCc6ICd0ZXh0L2h0bWwnXG4gICAgICAgICAgICAsICd0ZXh0JzogJ3RleHQvcGxhaW4nXG4gICAgICAgICAgICAsICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICAgICwgJ2pzJzogICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCwgdGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICwgeGhyID0gZnVuY3Rpb24obykge1xuICAgICAgICAvLyBpcyBpdCB4LWRvbWFpblxuICAgICAgICBpZiAob1snY3Jvc3NPcmlnaW4nXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB4aHIgPSB3aW5beG1sSHR0cFJlcXVlc3RdID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBudWxsXG4gICAgICAgICAgaWYgKHhociAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpblt4RG9tYWluUmVxdWVzdF0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3aW5beG1sSHR0cFJlcXVlc3RdKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsIGdsb2JhbFNldHVwT3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVhZHlTdGF0ZShyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB1c2UgX2Fib3J0ZWQgdG8gbWl0aWdhdGUgYWdhaW5zdCBJRSBlcnIgYzAwYzAyM2ZcbiAgICAgIC8vIChjYW4ndCByZWFkIHByb3BzIG9uIGFib3J0ZWQgcmVxdWVzdCBvYmplY3RzKVxuICAgICAgaWYgKHIuX2Fib3J0ZWQpIHJldHVybiBlcnJvcihyLnJlcXVlc3QpXG4gICAgICBpZiAoci5yZXF1ZXN0ICYmIHIucmVxdWVzdFtyZWFkeVN0YXRlXSA9PSA0KSB7XG4gICAgICAgIHIucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBub29wXG4gICAgICAgIGlmICh0d29IdW5kby50ZXN0KHIucmVxdWVzdC5zdGF0dXMpKSBzdWNjZXNzKHIucmVxdWVzdClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVycm9yKHIucmVxdWVzdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRIZWFkZXJzKGh0dHAsIG8pIHtcbiAgICB2YXIgaGVhZGVycyA9IG9bJ2hlYWRlcnMnXSB8fCB7fVxuICAgICAgLCBoXG5cbiAgICBoZWFkZXJzWydBY2NlcHQnXSA9IGhlYWRlcnNbJ0FjY2VwdCddXG4gICAgICB8fCBkZWZhdWx0SGVhZGVyc1snYWNjZXB0J11bb1sndHlwZSddXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddWycqJ11cblxuICAgIC8vIGJyZWFrcyBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgd2l0aCBsZWdhY3kgYnJvd3NlcnNcbiAgICBpZiAoIW9bJ2Nyb3NzT3JpZ2luJ10gJiYgIWhlYWRlcnNbcmVxdWVzdGVkV2l0aF0pIGhlYWRlcnNbcmVxdWVzdGVkV2l0aF0gPSBkZWZhdWx0SGVhZGVyc1sncmVxdWVzdGVkV2l0aCddXG4gICAgaWYgKCFoZWFkZXJzW2NvbnRlbnRUeXBlXSkgaGVhZGVyc1tjb250ZW50VHlwZV0gPSBvWydjb250ZW50VHlwZSddIHx8IGRlZmF1bHRIZWFkZXJzWydjb250ZW50VHlwZSddXG4gICAgZm9yIChoIGluIGhlYWRlcnMpXG4gICAgICBoZWFkZXJzLmhhc093blByb3BlcnR5KGgpICYmICdzZXRSZXF1ZXN0SGVhZGVyJyBpbiBodHRwICYmIGh0dHAuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q3JlZGVudGlhbHMoaHR0cCwgbykge1xuICAgIGlmICh0eXBlb2Ygb1snd2l0aENyZWRlbnRpYWxzJ10gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBodHRwLndpdGhDcmVkZW50aWFscyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGh0dHAud2l0aENyZWRlbnRpYWxzID0gISFvWyd3aXRoQ3JlZGVudGlhbHMnXVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYWxDYWxsYmFjayhkYXRhKSB7XG4gICAgbGFzdFZhbHVlID0gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gdXJsYXBwZW5kICh1cmwsIHMpIHtcbiAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBzXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpIHtcbiAgICB2YXIgcmVxSWQgPSB1bmlxaWQrK1xuICAgICAgLCBjYmtleSA9IG9bJ2pzb25wQ2FsbGJhY2snXSB8fCAnY2FsbGJhY2snIC8vIHRoZSAnY2FsbGJhY2snIGtleVxuICAgICAgLCBjYnZhbCA9IG9bJ2pzb25wQ2FsbGJhY2tOYW1lJ10gfHwgcmVxd2VzdC5nZXRjYWxsYmFja1ByZWZpeChyZXFJZClcbiAgICAgICwgY2JyZWcgPSBuZXcgUmVnRXhwKCcoKF58XFxcXD98JiknICsgY2JrZXkgKyAnKT0oW14mXSspJylcbiAgICAgICwgbWF0Y2ggPSB1cmwubWF0Y2goY2JyZWcpXG4gICAgICAsIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgICAgLCBsb2FkZWQgPSAwXG4gICAgICAsIGlzSUUxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSAxMC4wJykgIT09IC0xXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGlmIChtYXRjaFszXSA9PT0gJz8nKSB7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKGNicmVnLCAnJDE9JyArIGNidmFsKSAvLyB3aWxkY2FyZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNidmFsID0gbWF0Y2hbM10gLy8gcHJvdmlkZWQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGNia2V5ICsgJz0nICsgY2J2YWwpIC8vIG5vIGNhbGxiYWNrIGRldGFpbHMsIGFkZCAnZW1cbiAgICB9XG5cbiAgICB3aW5bY2J2YWxdID0gZ2VuZXJhbENhbGxiYWNrXG5cbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgc2NyaXB0LnNyYyA9IHVybFxuICAgIHNjcmlwdC5hc3luYyA9IHRydWVcbiAgICBpZiAodHlwZW9mIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgIT09ICd1bmRlZmluZWQnICYmICFpc0lFMTApIHtcbiAgICAgIC8vIG5lZWQgdGhpcyBmb3IgSUUgZHVlIHRvIG91dC1vZi1vcmRlciBvbnJlYWR5c3RhdGVjaGFuZ2UoKSwgYmluZGluZyBzY3JpcHRcbiAgICAgIC8vIGV4ZWN1dGlvbiB0byBhbiBldmVudCBsaXN0ZW5lciBnaXZlcyB1cyBjb250cm9sIG92ZXIgd2hlbiB0aGUgc2NyaXB0XG4gICAgICAvLyBpcyBleGVjdXRlZC4gU2VlIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQgPSAnX3JlcXdlc3RfJyArIHJlcUlkXG4gICAgfVxuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKHNjcmlwdFtyZWFkeVN0YXRlXSAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdjb21wbGV0ZScgJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnbG9hZGVkJykgfHwgbG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICBzY3JpcHQub25jbGljayAmJiBzY3JpcHQub25jbGljaygpXG4gICAgICAvLyBDYWxsIHRoZSB1c2VyIGNhbGxiYWNrIHdpdGggdGhlIGxhc3QgdmFsdWUgc3RvcmVkIGFuZCBjbGVhbiB1cCB2YWx1ZXMgYW5kIHNjcmlwdHMuXG4gICAgICBmbihsYXN0VmFsdWUpXG4gICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgbG9hZGVkID0gMVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgc2NyaXB0IHRvIHRoZSBET00gaGVhZFxuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXG4gICAgLy8gRW5hYmxlIEpTT05QIHRpbWVvdXRcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIGVycih7fSwgJ1JlcXVlc3QgaXMgYWJvcnRlZDogdGltZW91dCcsIHt9KVxuICAgICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgICAgIGxvYWRlZCA9IDFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXF1ZXN0KGZuLCBlcnIpIHtcbiAgICB2YXIgbyA9IHRoaXMub1xuICAgICAgLCBtZXRob2QgPSAob1snbWV0aG9kJ10gfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKClcbiAgICAgICwgdXJsID0gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG9bJ3VybCddXG4gICAgICAvLyBjb252ZXJ0IG5vbi1zdHJpbmcgb2JqZWN0cyB0byBxdWVyeS1zdHJpbmcgZm9ybSB1bmxlc3Mgb1sncHJvY2Vzc0RhdGEnXSBpcyBmYWxzZVxuICAgICAgLCBkYXRhID0gKG9bJ3Byb2Nlc3NEYXRhJ10gIT09IGZhbHNlICYmIG9bJ2RhdGEnXSAmJiB0eXBlb2Ygb1snZGF0YSddICE9PSAnc3RyaW5nJylcbiAgICAgICAgPyByZXF3ZXN0LnRvUXVlcnlTdHJpbmcob1snZGF0YSddKVxuICAgICAgICA6IChvWydkYXRhJ10gfHwgbnVsbClcbiAgICAgICwgaHR0cFxuICAgICAgLCBzZW5kV2FpdCA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSdyZSB3b3JraW5nIG9uIGEgR0VUIHJlcXVlc3QgYW5kIHdlIGhhdmUgZGF0YSB0aGVuIHdlIHNob3VsZCBhcHBlbmRcbiAgICAvLyBxdWVyeSBzdHJpbmcgdG8gZW5kIG9mIFVSTCBhbmQgbm90IHBvc3QgZGF0YVxuICAgIGlmICgob1sndHlwZSddID09ICdqc29ucCcgfHwgbWV0aG9kID09ICdHRVQnKSAmJiBkYXRhKSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBkYXRhKVxuICAgICAgZGF0YSA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAob1sndHlwZSddID09ICdqc29ucCcpIHJldHVybiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpXG5cbiAgICAvLyBnZXQgdGhlIHhociBmcm9tIHRoZSBmYWN0b3J5IGlmIHBhc3NlZFxuICAgIC8vIGlmIHRoZSBmYWN0b3J5IHJldHVybnMgbnVsbCwgZmFsbC1iYWNrIHRvIG91cnNcbiAgICBodHRwID0gKG8ueGhyICYmIG8ueGhyKG8pKSB8fCB4aHIobylcblxuICAgIGh0dHAub3BlbihtZXRob2QsIHVybCwgb1snYXN5bmMnXSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpXG4gICAgc2V0SGVhZGVycyhodHRwLCBvKVxuICAgIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pXG4gICAgaWYgKHdpblt4RG9tYWluUmVxdWVzdF0gJiYgaHR0cCBpbnN0YW5jZW9mIHdpblt4RG9tYWluUmVxdWVzdF0pIHtcbiAgICAgICAgaHR0cC5vbmxvYWQgPSBmblxuICAgICAgICBodHRwLm9uZXJyb3IgPSBlcnJcbiAgICAgICAgLy8gTk9URTogc2VlXG4gICAgICAgIC8vIGh0dHA6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9pZXdlYmRldmVsb3BtZW50L3RocmVhZC8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmVcbiAgICAgICAgaHR0cC5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7fVxuICAgICAgICBzZW5kV2FpdCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVSZWFkeVN0YXRlKHRoaXMsIGZuLCBlcnIpXG4gICAgfVxuICAgIG9bJ2JlZm9yZSddICYmIG9bJ2JlZm9yZSddKGh0dHApXG4gICAgaWYgKHNlbmRXYWl0KSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHR0cC5zZW5kKGRhdGEpXG4gICAgICB9LCAyMDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHAuc2VuZChkYXRhKVxuICAgIH1cbiAgICByZXR1cm4gaHR0cFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxd2VzdChvLCBmbikge1xuICAgIHRoaXMubyA9IG9cbiAgICB0aGlzLmZuID0gZm5cblxuICAgIGluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VHlwZShoZWFkZXIpIHtcbiAgICAvLyBqc29uLCBqYXZhc2NyaXB0LCB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIHhtbFxuICAgIGlmIChoZWFkZXIubWF0Y2goJ2pzb24nKSkgcmV0dXJuICdqc29uJ1xuICAgIGlmIChoZWFkZXIubWF0Y2goJ2phdmFzY3JpcHQnKSkgcmV0dXJuICdqcydcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCd0ZXh0JykpIHJldHVybiAnaHRtbCdcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCd4bWwnKSkgcmV0dXJuICd4bWwnXG4gIH1cblxuICBmdW5jdGlvbiBpbml0KG8sIGZuKSB7XG5cbiAgICB0aGlzLnVybCA9IHR5cGVvZiBvID09ICdzdHJpbmcnID8gbyA6IG9bJ3VybCddXG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuXG4gICAgLy8gd2hldGhlciByZXF1ZXN0IGhhcyBiZWVuIGZ1bGZpbGxlZCBmb3IgcHVycG9zZVxuICAgIC8vIG9mIHRyYWNraW5nIHRoZSBQcm9taXNlc1xuICAgIHRoaXMuX2Z1bGZpbGxlZCA9IGZhbHNlXG4gICAgLy8gc3VjY2VzcyBoYW5kbGVyc1xuICAgIHRoaXMuX3N1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24oKXt9XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVycyA9IFtdXG4gICAgLy8gZXJyb3IgaGFuZGxlcnNcbiAgICB0aGlzLl9lcnJvckhhbmRsZXJzID0gW11cbiAgICAvLyBjb21wbGV0ZSAoYm90aCBzdWNjZXNzIGFuZCBmYWlsKSBoYW5kbGVyc1xuICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMgPSBbXVxuICAgIHRoaXMuX2VycmVkID0gZmFsc2VcbiAgICB0aGlzLl9yZXNwb25zZUFyZ3MgPSB7fVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHt9XG5cbiAgICBpZiAob1sndGltZW91dCddKSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hYm9ydCgpXG4gICAgICB9LCBvWyd0aW1lb3V0J10pXG4gICAgfVxuXG4gICAgaWYgKG9bJ3N1Y2Nlc3MnXSkge1xuICAgICAgdGhpcy5fc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ3N1Y2Nlc3MnXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9bJ2Vycm9yJ10pIHtcbiAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ2Vycm9yJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAob1snY29tcGxldGUnXSkge1xuICAgICAgdGhpcy5fY29tcGxldGVIYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snY29tcGxldGUnXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlIChyZXNwKSB7XG4gICAgICBvWyd0aW1lb3V0J10gJiYgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcbiAgICAgIHNlbGYudGltZW91dCA9IG51bGxcbiAgICAgIHdoaWxlIChzZWxmLl9jb21wbGV0ZUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fY29tcGxldGVIYW5kbGVycy5zaGlmdCgpKHJlc3ApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyAocmVzcCkge1xuICAgICAgdmFyIHR5cGUgPSBvWyd0eXBlJ10gfHwgc2V0VHlwZShyZXNwLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSlcbiAgICAgIHJlc3AgPSAodHlwZSAhPT0gJ2pzb25wJykgPyBzZWxmLnJlcXVlc3QgOiByZXNwXG4gICAgICAvLyB1c2UgZ2xvYmFsIGRhdGEgZmlsdGVyIG9uIHJlc3BvbnNlIHRleHRcbiAgICAgIHZhciBmaWx0ZXJlZFJlc3BvbnNlID0gZ2xvYmFsU2V0dXBPcHRpb25zLmRhdGFGaWx0ZXIocmVzcC5yZXNwb25zZVRleHQsIHR5cGUpXG4gICAgICAgICwgciA9IGZpbHRlcmVkUmVzcG9uc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3AucmVzcG9uc2VUZXh0ID0gclxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBjYW4ndCBhc3NpZ24gdGhpcyBpbiBJRTw9OCwganVzdCBpZ25vcmVcbiAgICAgIH1cbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcCA9IHdpbi5KU09OID8gd2luLkpTT04ucGFyc2UocikgOiBldmFsKCcoJyArIHIgKyAnKScpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IocmVzcCwgJ0NvdWxkIG5vdCBwYXJzZSBKU09OIGluIHJlc3BvbnNlJywgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdqcyc6XG4gICAgICAgICAgcmVzcCA9IGV2YWwocilcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICByZXNwID0gclxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgcmVzcCA9IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yIC8vIElFIHRyb2xvbG9cbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLmVycm9yQ29kZVxuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IucmVhc29uXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogcmVzcC5yZXNwb25zZVhNTFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwXG4gICAgICBzZWxmLl9mdWxmaWxsZWQgPSB0cnVlXG4gICAgICBmbihyZXNwKVxuICAgICAgc2VsZi5fc3VjY2Vzc0hhbmRsZXIocmVzcClcbiAgICAgIHdoaWxlIChzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzcCA9IHNlbGYuX2Z1bGZpbGxtZW50SGFuZGxlcnMuc2hpZnQoKShyZXNwKVxuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZShyZXNwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKHJlc3AsIG1zZywgdCkge1xuICAgICAgcmVzcCA9IHNlbGYucmVxdWVzdFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MubXNnID0gbXNnXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MudCA9IHRcbiAgICAgIHNlbGYuX2VycmVkID0gdHJ1ZVxuICAgICAgd2hpbGUgKHNlbGYuX2Vycm9ySGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9lcnJvckhhbmRsZXJzLnNoaWZ0KCkocmVzcCwgbXNnLCB0KVxuICAgICAgfVxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QgPSBnZXRSZXF1ZXN0LmNhbGwodGhpcywgc3VjY2VzcywgZXJyb3IpXG4gIH1cblxuICBSZXF3ZXN0LnByb3RvdHlwZSA9IHtcbiAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWVcbiAgICAgIHRoaXMucmVxdWVzdC5hYm9ydCgpXG4gICAgfVxuXG4gICwgcmV0cnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGluaXQuY2FsbCh0aGlzLCB0aGlzLm8sIHRoaXMuZm4pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU21hbGwgZGV2aWF0aW9uIGZyb20gdGhlIFByb21pc2VzIEEgQ29tbW9uSnMgc3BlY2lmaWNhdGlvblxuICAgICAqIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1Byb21pc2VzL0FcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGB0aGVuYCB3aWxsIGV4ZWN1dGUgdXBvbiBzdWNjZXNzZnVsIHJlcXVlc3RzXG4gICAgICovXG4gICwgdGhlbjogZnVuY3Rpb24gKHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgICBmYWlsID0gZmFpbCB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCA9IHN1Y2Nlc3ModGhpcy5fcmVzcG9uc2VBcmdzLnJlc3ApXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZhaWwodGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVycy5wdXNoKHN1Y2Nlc3MpXG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmYWlsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgYWx3YXlzYCB3aWxsIGV4ZWN1dGUgd2hldGhlciB0aGUgcmVxdWVzdCBzdWNjZWVkcyBvciBmYWlsc1xuICAgICAqL1xuICAsIGFsd2F5czogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZnVsZmlsbGVkIHx8IHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZuKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgZmFpbGAgd2lsbCBleGVjdXRlIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHNcbiAgICAgKi9cbiAgLCBmYWlsOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCwgdGhpcy5fcmVzcG9uc2VBcmdzLm1zZywgdGhpcy5fcmVzcG9uc2VBcmdzLnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZm4pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXdlc3QobywgZm4pIHtcbiAgICByZXR1cm4gbmV3IFJlcXdlc3QobywgZm4pXG4gIH1cblxuICAvLyBub3JtYWxpemUgbmV3bGluZSB2YXJpYW50cyBhY2NvcmRpbmcgdG8gc3BlYyAtPiBDUkxGXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShzKSB7XG4gICAgcmV0dXJuIHMgPyBzLnJlcGxhY2UoL1xccj9cXG4vZywgJ1xcclxcbicpIDogJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcmlhbChlbCwgY2IpIHtcbiAgICB2YXIgbiA9IGVsLm5hbWVcbiAgICAgICwgdCA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgLCBvcHRDYiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgLy8gSUUgZ2l2ZXMgdmFsdWU9XCJcIiBldmVuIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlIGF0dHJpYnV0ZVxuICAgICAgICAgIC8vICdzcGVjaWZpZWQnIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9jb3JlLmh0bWwjSUQtODYyNTI5MjczXG4gICAgICAgICAgaWYgKG8gJiYgIW9bJ2Rpc2FibGVkJ10pXG4gICAgICAgICAgICBjYihuLCBub3JtYWxpemUob1snYXR0cmlidXRlcyddWyd2YWx1ZSddICYmIG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXVsnc3BlY2lmaWVkJ10gPyBvWyd2YWx1ZSddIDogb1sndGV4dCddKSlcbiAgICAgICAgfVxuICAgICAgLCBjaCwgcmEsIHZhbCwgaVxuXG4gICAgLy8gZG9uJ3Qgc2VyaWFsaXplIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FibGVkIG9yIHdpdGhvdXQgYSBuYW1lXG4gICAgaWYgKGVsLmRpc2FibGVkIHx8ICFuKSByZXR1cm5cblxuICAgIHN3aXRjaCAodCkge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGlmICghL3Jlc2V0fGJ1dHRvbnxpbWFnZXxmaWxlL2kudGVzdChlbC50eXBlKSkge1xuICAgICAgICBjaCA9IC9jaGVja2JveC9pLnRlc3QoZWwudHlwZSlcbiAgICAgICAgcmEgPSAvcmFkaW8vaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHZhbCA9IGVsLnZhbHVlXG4gICAgICAgIC8vIFdlYktpdCBnaXZlcyB1cyBcIlwiIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgY2hlY2tib3ggaGFzIG5vIHZhbHVlLCBzbyBjb3JyZWN0IGl0IGhlcmVcbiAgICAgICAgOyghKGNoIHx8IHJhKSB8fCBlbC5jaGVja2VkKSAmJiBjYihuLCBub3JtYWxpemUoY2ggJiYgdmFsID09PSAnJyA/ICdvbicgOiB2YWwpKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBjYihuLCBub3JtYWxpemUoZWwudmFsdWUpKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaWYgKGVsLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdC1vbmUnKSB7XG4gICAgICAgIG9wdENiKGVsLnNlbGVjdGVkSW5kZXggPj0gMCA/IGVsLm9wdGlvbnNbZWwuc2VsZWN0ZWRJbmRleF0gOiBudWxsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgZWwubGVuZ3RoICYmIGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLm9wdGlvbnNbaV0uc2VsZWN0ZWQgJiYgb3B0Q2IoZWwub3B0aW9uc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBjb2xsZWN0IHVwIGFsbCBmb3JtIGVsZW1lbnRzIGZvdW5kIGZyb20gdGhlIHBhc3NlZCBhcmd1bWVudCBlbGVtZW50cyBhbGxcbiAgLy8gdGhlIHdheSBkb3duIHRvIGNoaWxkIGVsZW1lbnRzOyBwYXNzIGEgJzxmb3JtPicgb3IgZm9ybSBmaWVsZHMuXG4gIC8vIGNhbGxlZCB3aXRoICd0aGlzJz1jYWxsYmFjayB0byB1c2UgZm9yIHNlcmlhbCgpIG9uIGVhY2ggZWxlbWVudFxuICBmdW5jdGlvbiBlYWNoRm9ybUVsZW1lbnQoKSB7XG4gICAgdmFyIGNiID0gdGhpc1xuICAgICAgLCBlLCBpXG4gICAgICAsIHNlcmlhbGl6ZVN1YnRhZ3MgPSBmdW5jdGlvbiAoZSwgdGFncykge1xuICAgICAgICAgIHZhciBpLCBqLCBmYVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmYSA9IGVbYnlUYWddKHRhZ3NbaV0pXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZmEubGVuZ3RoOyBqKyspIHNlcmlhbChmYVtqXSwgY2IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlID0gYXJndW1lbnRzW2ldXG4gICAgICBpZiAoL2lucHV0fHNlbGVjdHx0ZXh0YXJlYS9pLnRlc3QoZS50YWdOYW1lKSkgc2VyaWFsKGUsIGNiKVxuICAgICAgc2VyaWFsaXplU3VidGFncyhlLCBbICdpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnIF0pXG4gICAgfVxuICB9XG5cbiAgLy8gc3RhbmRhcmQgcXVlcnkgc3RyaW5nIHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplUXVlcnlTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHJlcXdlc3QudG9RdWVyeVN0cmluZyhyZXF3ZXN0LnNlcmlhbGl6ZUFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpXG4gIH1cblxuICAvLyB7ICduYW1lJzogJ3ZhbHVlJywgLi4uIH0gc3R5bGUgc2VyaWFsaXphdGlvblxuICBmdW5jdGlvbiBzZXJpYWxpemVIYXNoKCkge1xuICAgIHZhciBoYXNoID0ge31cbiAgICBlYWNoRm9ybUVsZW1lbnQuYXBwbHkoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSBpbiBoYXNoKSB7XG4gICAgICAgIGhhc2hbbmFtZV0gJiYgIWlzQXJyYXkoaGFzaFtuYW1lXSkgJiYgKGhhc2hbbmFtZV0gPSBbaGFzaFtuYW1lXV0pXG4gICAgICAgIGhhc2hbbmFtZV0ucHVzaCh2YWx1ZSlcbiAgICAgIH0gZWxzZSBoYXNoW25hbWVdID0gdmFsdWVcbiAgICB9LCBhcmd1bWVudHMpXG4gICAgcmV0dXJuIGhhc2hcbiAgfVxuXG4gIC8vIFsgeyBuYW1lOiAnbmFtZScsIHZhbHVlOiAndmFsdWUnIH0sIC4uLiBdIHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgcmVxd2VzdC5zZXJpYWxpemVBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gW11cbiAgICBlYWNoRm9ybUVsZW1lbnQuYXBwbHkoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBhcnIucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSlcbiAgICB9LCBhcmd1bWVudHMpXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgcmVxd2VzdC5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuICAgIHZhciBvcHQsIGZuXG4gICAgICAsIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cbiAgICBvcHQgPSBhcmdzLnBvcCgpXG4gICAgb3B0ICYmIG9wdC5ub2RlVHlwZSAmJiBhcmdzLnB1c2gob3B0KSAmJiAob3B0ID0gbnVsbClcbiAgICBvcHQgJiYgKG9wdCA9IG9wdC50eXBlKVxuXG4gICAgaWYgKG9wdCA9PSAnbWFwJykgZm4gPSBzZXJpYWxpemVIYXNoXG4gICAgZWxzZSBpZiAob3B0ID09ICdhcnJheScpIGZuID0gcmVxd2VzdC5zZXJpYWxpemVBcnJheVxuICAgIGVsc2UgZm4gPSBzZXJpYWxpemVRdWVyeVN0cmluZ1xuXG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH1cblxuICByZXF3ZXN0LnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAobywgdHJhZCkge1xuICAgIHZhciBwcmVmaXgsIGlcbiAgICAgICwgdHJhZGl0aW9uYWwgPSB0cmFkIHx8IGZhbHNlXG4gICAgICAsIHMgPSBbXVxuICAgICAgLCBlbmMgPSBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgICwgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICB2YWx1ZSA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUpID8gdmFsdWUoKSA6ICh2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSlcbiAgICAgICAgICBzW3MubGVuZ3RoXSA9IGVuYyhrZXkpICsgJz0nICsgZW5jKHZhbHVlKVxuICAgICAgICB9XG4gICAgLy8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cbiAgICBpZiAoaXNBcnJheShvKSkge1xuICAgICAgZm9yIChpID0gMDsgbyAmJiBpIDwgby5sZW5ndGg7IGkrKykgYWRkKG9baV1bJ25hbWUnXSwgb1tpXVsndmFsdWUnXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgZm9yIChwcmVmaXggaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpKSBidWlsZFBhcmFtcyhwcmVmaXgsIG9bcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzcGFjZXMgc2hvdWxkIGJlICsgYWNjb3JkaW5nIHRvIHNwZWNcbiAgICByZXR1cm4gcy5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XG4gICAgdmFyIG5hbWUsIGksIHZcbiAgICAgICwgcmJyYWNrZXQgPSAvXFxbXFxdJC9cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgZm9yIChpID0gMDsgb2JqICYmIGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdiA9IG9ialtpXVxuICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgIGFkZChwcmVmaXgsIHYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyA/IGkgOiAnJykgKyAnXScsIHYsIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiBvYmoudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgbmFtZSArICddJywgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgIGFkZChwcmVmaXgsIG9iailcbiAgICB9XG4gIH1cblxuICByZXF3ZXN0LmdldGNhbGxiYWNrUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFja1ByZWZpeFxuICB9XG5cbiAgLy8galF1ZXJ5IGFuZCBaZXB0byBjb21wYXRpYmlsaXR5LCBkaWZmZXJlbmNlcyBjYW4gYmUgcmVtYXBwZWQgaGVyZSBzbyB5b3UgY2FuIGNhbGxcbiAgLy8gLmFqYXguY29tcGF0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICByZXF3ZXN0LmNvbXBhdCA9IGZ1bmN0aW9uIChvLCBmbikge1xuICAgIGlmIChvKSB7XG4gICAgICBvWyd0eXBlJ10gJiYgKG9bJ21ldGhvZCddID0gb1sndHlwZSddKSAmJiBkZWxldGUgb1sndHlwZSddXG4gICAgICBvWydkYXRhVHlwZSddICYmIChvWyd0eXBlJ10gPSBvWydkYXRhVHlwZSddKVxuICAgICAgb1snanNvbnBDYWxsYmFjayddICYmIChvWydqc29ucENhbGxiYWNrTmFtZSddID0gb1snanNvbnBDYWxsYmFjayddKSAmJiBkZWxldGUgb1snanNvbnBDYWxsYmFjayddXG4gICAgICBvWydqc29ucCddICYmIChvWydqc29ucENhbGxiYWNrJ10gPSBvWydqc29ucCddKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlcXdlc3QobywgZm4pXG4gIH1cblxuICByZXF3ZXN0LmFqYXhTZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgIGdsb2JhbFNldHVwT3B0aW9uc1trXSA9IG9wdGlvbnNba11cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxd2VzdFxufSk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG5cbi8qXG5AZmlsZU92ZXJ2aWV3IFRoaXMgZmlsZSBjb250YWlucyBKYXZhU2NyaXB0IGNvZGUgdGhhdCBoYW5kbGVzIHRoZSBIVE1MIGRvY3VtZW50IHdoZXJlIEhUTUwgaXMgcmVuZGVyZWQgZm9yIGEgU2FmZUZyYW1lLCBhcyB3ZWxsIGFzIGRlZmluaW5nIHRoZSBFeHRlcm5hbCBWZW5kb3IvQ2xpZW50IEFQSS5cbkBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpzc25pZGVyQHlhaG9vLWluYy5jb21cIj5TZWFuIFNuaWRlcjwvYT5cbkBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpjY29sZVtBVF1lbWluYXRpb24uY29tXCI+Q2hyaXMgQ29sZTwvYT5cbkB2ZXJzaW9uIDEuMC4zXG4gKi9cblxuXG4vKlxuQG5hbWVzcGFjZSAkc2YuZXh0IFRoZSBleHRlcm5hbCB2ZW5kb3IgLyBjbGllbnQgQVBJIGZvciBmdW5jdGlvbmFsaXR5IGluc2lkZSBhIFNhZmVGcmFtZVxuQG5hbWUgJHNmLmV4dFxuICovXG5cblxuLypcbkBpZ25vcmVcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBzZjtcblxuICBzZiA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvYmFzZVwiKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzRXh0ZXJuYWwpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKHdpbmRvdywgc2YpIHtcbiAgICAgIHZhciBDT0xMQVBTRV9DT01NQU5ELCBERywgRE9NX1dBVENIX0lOVEVSVkFMLCBEUCwgRFMsIEVSUk9SX0NPTU1BTkQsIEVYUEFORF9DT01NQU5ELCBHVUlEX1ZBTElEX1RJTUUsIElFX0FUVEFDSCwgSUVfREVUQUNILCBMT0FELCBNQVhfTVNHX1dBSVRfVElNRSwgTVNHLCBOT1RJRllfQ0xJQ0tFRCwgTk9USUZZX0NPTExBUFNFLCBOT1RJRllfQ09MTEFQU0VELCBOT1RJRllfRVhQQU5ELCBOT1RJRllfRkFJTFVSRSwgTk9USUZZX0ZPQ1VTX0NIQU5HRSwgTk9USUZZX0dFT01fVVBEQVRFLCBOT1RJRllfTE9BREVELCBOT1RJRllfUkVBRF9DT09LSUUsIE5PVElGWV9SRUxPQUQsIE5PVElGWV9SRVFVRVNURUQsIE5PVElGWV9VTlZJRVdFRCwgTk9USUZZX1ZJRVdFRCwgTk9USUZZX1dSSVRFX0NPT0tJRSwgT0JKLCBPTkxPQUQsIE9OTVNHLCBPTlVOTE9BRCwgT05fU1RSLCBPVVJfVEFHX0NMU19OQU1FLCBQYXJhbUhhc2gsIFNUQVRVU19DT0xMQVBTRUQsIFNUQVRVU19DT0xMQVBTSU5HLCBTVEFUVVNfRVhQQU5ERUQsIFNUQVRVU19FWFBBTkRJTkcsIFRPTE9XRVJDQVNFLCBVTkxPQUQsIFczQ19BVFRBQ0gsIFczQ19ERVRBQ0gsIGFkU2hvd24sIGNhbl91c2VfaHRtbDUsIGNsaWNrLCBjbWRSZXRyaWVzLCBjb2xsYXBzZSwgY29va2llLCBkLCBkZWxldGVNZXRhLCBkb20sIGVudiwgZXJyX21zZ190aW1lcl9pZCwgZXJyX21zZ3MsIGV4cGFuZCwgZm9yY2VfY29sbGFwc2UsIGZyYW1lX2lkLCBnZW9tLCBnZW9tX2luZm8sIGd1aWQsIGhhc0xvYWRlZCwgaG9zdF9jbmFtZSwgaWVfb2xkX2F0dGFjaCwgaWVfb2xkX2RldGFjaCwgaWZyYW1lcywgaW5WaWV3UGVyY2VudGFnZSwgaW5pdF9oZWlnaHQsIGluaXRfd2lkdGgsIGlubGluZV9oYW5kbGVyX3RpbWVyX2lkLCBpc0FkU2hvd24sIGlzSUUsIGlzX2V4cGFuZGVkLCBpc19yZWdpc3RlcmVkLCBsYW5nLCBsaWIsIGxvYWRlZCwgbWVzc2FnZSwgbWV0YSwgbXNnY2xpZW50X2ZiLCBvcmlnaW5hbFdyaXRlLCBvcnBoYW5fdGltZXJfaWQsIHBhciwgcGVuZGluZ19tc2csIHBvc19pZCwgcG9zX21ldGEsIHJlZ2lzdGVyLCByZWxvYWQsIHJlbmRlciwgcmVuZGVyX2NvbmYsIHJlbmRlcl9wYXJhbXMsIHNhbmRib3hfY2IsIHNob3dBZCwgc3RhdHVzLCBzdXBwb3J0cywgdW5sb2FkX2hhbmRsZXJzLCB1bnZpZXdlZCwgdmlld2VkLCB3M2Nfb2xkX2F0dGFjaCwgdzNjX29sZF9kZXRhY2gsIHdpbiwgd2luSGFzRm9jdXMsIHdpbl9oYXNfZm9jdXMsIF9hcHBlbmQsIF9hdHRhY2gsIF9hdHRhY2hfb3ZlcnJpZGUsIF9hdHRyLCBfY2FsbF9jbGllbnRfZmIsIF9jYWxsX3Jhd19ldnRfZnVuYywgX2NoZWNrX29ycGhhbmVkLCBfY251bSwgX2NvbGxhcHNlLCBfY29uc3RydWN0aW9uLCBfY3JlYXRlX3N0eWxlc2hlZXQsIF9jc3RyLCBfZGVzdHJ1Y3Rpb24sIF9kZXRhY2gsIF9kZXRhY2hfb3ZlcnJpZGUsIF9kZXRlY3RfYmFkX2lmcmFtZSwgX2VsdCwgX2ZpcmVfc2FuZGJveF9jYWxsYmFjaywgX2hhbmRsZV9lcnIsIF9oYW5kbGVfbG9hZCwgX2hhbmRsZV9tc2csIF9oYW5kbGVfdW5sb2FkLCBfbnVrZV9kb2MsIF9wdXJnZSwgX3JlYXR0YWNoX21lc3NhZ2luZywgX3JlY2VpdmVfbXNnLCBfcmVuZGVyLCBfcmVwb3J0X2VycnMsIF9yZXF1ZXN0ZWQsIF9yZXNldF9pbmxpbmVfaGFuZGxlcnMsIF9zZW5kX2NtZCwgX3NlbmRfbXNnLCBfc2V0X2FsaWdubWVudCwgX3NldF9oeXBlcmxpbmtfdGFyZ2V0cywgX3NldHVwX3dpbl9ldnRfcHJvcHMsIF90YWdzLCBfdWUsIF93cmFwaUZyYW1lO1xuICAgICAgd2luID0gd2luZG93O1xuICAgICAgTE9BRCA9IFwibG9hZFwiO1xuICAgICAgT05fU1RSID0gXCJvblwiO1xuICAgICAgTVNHID0gXCJtZXNzYWdlXCI7XG4gICAgICBVTkxPQUQgPSBcInVuXCIgKyBMT0FEO1xuICAgICAgT05VTkxPQUQgPSBPTl9TVFIgKyBVTkxPQUQ7XG4gICAgICBPTk1TRyA9IE9OX1NUUiArIE1TRztcbiAgICAgIE9OTE9BRCA9IE9OX1NUUiArIExPQUQ7XG4gICAgICBERyA9IFwiX19kZWZpbmVHZXR0ZXJfX1wiO1xuICAgICAgRFMgPSBcIl9fZGVmaW5lU2V0dGVyX19cIjtcbiAgICAgIERQID0gXCJfX2RlZmluZVByb3BlcnR5X19cIjtcbiAgICAgIFczQ19BVFRBQ0ggPSBcImFkZEV2ZW50TGlzdGVuZXJcIjtcbiAgICAgIFczQ19ERVRBQ0ggPSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjtcbiAgICAgIElFX0FUVEFDSCA9IFwiYXR0YWNoRXZlbnRcIjtcbiAgICAgIElFX0RFVEFDSCA9IFwiZGV0YWNoRXZlbnRcIjtcbiAgICAgIFRPTE9XRVJDQVNFID0gXCJ0b0xvd2VyQ2FzZVwiO1xuICAgICAgRVhQQU5EX0NPTU1BTkQgPSBcImV4cC1vdnJcIjtcbiAgICAgIENPTExBUFNFX0NPTU1BTkQgPSBcImNvbGxhcHNlXCI7XG4gICAgICBFUlJPUl9DT01NQU5EID0gXCJlcnJvclwiO1xuICAgICAgTk9USUZZX0dFT01fVVBEQVRFID0gXCJnZW9tLXVwZGF0ZVwiO1xuICAgICAgTk9USUZZX0VYUEFORCA9IFwiZXhwYW5kXCI7XG4gICAgICBOT1RJRllfRk9DVVNfQ0hBTkdFID0gXCJmb2N1cy1jaGFuZ2VcIjtcbiAgICAgIE5PVElGWV9DT0xMQVBTRSA9IENPTExBUFNFX0NPTU1BTkQ7XG4gICAgICBOT1RJRllfQ09MTEFQU0VEID0gTk9USUZZX0NPTExBUFNFICsgXCJkXCI7XG4gICAgICBOT1RJRllfRkFJTFVSRSA9IFwiZmFpbGVkXCI7XG4gICAgICBOT1RJRllfUkVBRF9DT09LSUUgPSBcInJlYWQtY29va2llXCI7XG4gICAgICBOT1RJRllfV1JJVEVfQ09PS0lFID0gXCJ3cml0ZS1jb29raWVcIjtcbiAgICAgIE5PVElGWV9DTElDS0VEID0gXCJjbGlja2VkXCI7XG4gICAgICBOT1RJRllfVklFV0VEID0gXCJ2aWV3ZWRcIjtcbiAgICAgIE5PVElGWV9VTlZJRVdFRCA9IFwidW52aWV3ZWRcIjtcbiAgICAgIE5PVElGWV9MT0FERUQgPSBcImxvYWRlZFwiO1xuICAgICAgTk9USUZZX1JFUVVFU1RFRCA9IFwicmVxdWVzdGVkXCI7XG4gICAgICBOT1RJRllfUkVMT0FEID0gXCJyZWxvYWRcIjtcbiAgICAgIFNUQVRVU19DT0xMQVBTRUQgPSBOT1RJRllfQ09MTEFQU0VEO1xuICAgICAgU1RBVFVTX0VYUEFOREVEID0gTk9USUZZX0VYUEFORCArIFwiZWRcIjtcbiAgICAgIFNUQVRVU19DT0xMQVBTSU5HID0gXCJjb2xsYXBzaW5nXCI7XG4gICAgICBTVEFUVVNfRVhQQU5ESU5HID0gTk9USUZZX0VYUEFORCArIFwiaW5nXCI7XG4gICAgICBPVVJfVEFHX0NMU19OQU1FID0gXCJzZlwiO1xuICAgICAgTUFYX01TR19XQUlUX1RJTUUgPSA0MDAwO1xuICAgICAgRE9NX1dBVENIX0lOVEVSVkFMID0gMzAwMDtcbiAgICAgIEdVSURfVkFMSURfVElNRSA9IDMwMDAwO1xuICAgICAgT0JKID0gXCJvYmplY3RcIjtcbiAgICAgIGQgPSB3aW4gJiYgd2luLmRvY3VtZW50O1xuICAgICAgcGFyID0gd2luICYmIHdpbi5wYXJlbnQ7XG4gICAgICBsaWIgPSBzZi5saWI7XG4gICAgICBlbnYgPSBzZi5lbnY7XG4gICAgICBsYW5nID0gbGliLmxhbmc7XG4gICAgICBQYXJhbUhhc2ggPSBsYW5nLlBhcmFtSGFzaDtcbiAgICAgIGRvbSA9IGxpYi5kb207XG4gICAgICBpZnJhbWVzID0gZG9tLmlmcmFtZXM7XG4gICAgICBtc2djbGllbnRfZmIgPSBkb20ubXNnY2xpZW50X2ZiO1xuICAgICAgaXNJRSA9IGVudi5pc0lFO1xuICAgICAgX3VlID0gd2luLnVuZXNjYXBlO1xuICAgICAgX2NzdHIgPSBsYW5nLmNzdHI7XG4gICAgICBfY251bSA9IGxhbmcuY251bTtcbiAgICAgIF9hcHBlbmQgPSBkb20uYXBwZW5kO1xuICAgICAgX3RhZ3MgPSBkb20udGFncztcbiAgICAgIF9lbHQgPSBkb20gJiYgZG9tLmVsdDtcbiAgICAgIF9wdXJnZSA9IGRvbSAmJiBkb20ucHVyZ2U7XG4gICAgICBfYXR0YWNoID0gZG9tICYmIGRvbS5hdHRhY2g7XG4gICAgICBfZGV0YWNoID0gZG9tICYmIGRvbS5kZXRhY2g7XG4gICAgICBfYXR0ciA9IGRvbSAmJiBkb20uYXR0cjtcbiAgICAgIGhhc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgaXNfZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgIGZvcmNlX2NvbGxhcHNlID0gZmFsc2U7XG4gICAgICBpc19yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICBpbml0X3dpZHRoID0gMDtcbiAgICAgIGluaXRfaGVpZ2h0ID0gMDtcbiAgICAgIHNhbmRib3hfY2IgPSBudWxsO1xuICAgICAgcGVuZGluZ19tc2cgPSBudWxsO1xuICAgICAgZ2VvbV9pbmZvID0gbnVsbDtcbiAgICAgIHBvc19tZXRhID0gbnVsbDtcbiAgICAgIHdpbl9oYXNfZm9jdXMgPSBmYWxzZTtcbiAgICAgIGd1aWQgPSBcIlwiO1xuICAgICAgaG9zdF9jbmFtZSA9IFwiXCI7XG4gICAgICBjYW5fdXNlX2h0bWw1ID0gZmFsc2U7XG4gICAgICBmcmFtZV9pZCA9IFwiXCI7XG4gICAgICBwb3NfaWQgPSBcIlwiO1xuICAgICAgZXJyX21zZ190aW1lcl9pZCA9IDA7XG4gICAgICBvcnBoYW5fdGltZXJfaWQgPSAwO1xuICAgICAgaW5saW5lX2hhbmRsZXJfdGltZXJfaWQgPSAwO1xuICAgICAgZXJyX21zZ3MgPSBbXTtcbiAgICAgIHVubG9hZF9oYW5kbGVycyA9IFtdO1xuICAgICAgcmVuZGVyX3BhcmFtcyA9IHZvaWQgMDtcbiAgICAgIHJlbmRlcl9jb25mID0gdm9pZCAwO1xuICAgICAgaWVfb2xkX2F0dGFjaCA9IHZvaWQgMDtcbiAgICAgIHczY19vbGRfYXR0YWNoID0gdm9pZCAwO1xuICAgICAgaWVfb2xkX2RldGFjaCA9IHZvaWQgMDtcbiAgICAgIHczY19vbGRfZGV0YWNoID0gdm9pZCAwO1xuICAgICAgaXNBZFNob3duID0gZmFsc2U7XG5cbiAgICAgIC8qXG4gICAgICBDcmVhdGVzIGFuZCBhcHBlbmRzIGEgc3R5bGUgc2hlZXQgZm9yIGFueSBjdXN0b20gQ1NTIHBhc3NlZFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9jcmVhdGVfc3R5bGVzaGVldFxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGNzc1RleHQgQSBzdHJpbmcgb2YgQ1NTIHJ1bGVzLCBvciBhIFVSTCBzdHJpbmdcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbaWRdIFRoZSBpZCBhdHRyaWJ1dGUgb2YgdGhlIHRhZyBjcmVhdGVkIGFuZCBhcHBlbmRlZFxuICAgICAgICovXG4gICAgICBfY3JlYXRlX3N0eWxlc2hlZXQgPSBmdW5jdGlvbihjc3NUZXh0LCBpZCkge1xuICAgICAgICB2YXIgZSwgb0hlYWQsIG9TUywgb1R4dDtcbiAgICAgICAgb0hlYWQgPSB2b2lkIDA7XG4gICAgICAgIG9TUyA9IHZvaWQgMDtcbiAgICAgICAgb1R4dCA9IHZvaWQgMDtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvSGVhZCA9IF90YWdzKFwiaGVhZFwiKVswXTtcbiAgICAgICAgICBpZiAoY3NzVGV4dC5zZWFyY2goL1xce1teXFx9XSp9L2cpID09PSAtMSkge1xuICAgICAgICAgICAgb1NTID0gZG9tLm1ha2UoXCJsaW5rXCIpO1xuICAgICAgICAgICAgb1NTLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgICAgICBvU1MucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gICAgICAgICAgICBvU1MuaHJlZiA9IGNzc1RleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9TUyA9IGRvbS5tYWtlKFwic3R5bGVcIik7XG4gICAgICAgICAgICBvU1MudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICAgICAgICAgIGlmIChpc0lFKSB7XG4gICAgICAgICAgICAgIG9TUy5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb1R4dCA9IGQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dCk7XG4gICAgICAgICAgICAgIF9hcHBlbmQob1NTLCBvVHh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBvU1MuaWQgPSBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2FwcGVuZChvSGVhZCwgb1NTKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEZpcmVzIG9mIHVubG9hZCBldmVudCBoYW5kbGVycyBhbmQgcGVyZm9ybXMgdGhlIG5lY2Vzc2FyeSBjbGVhbiB1cCB3aGVuIGEgU2FmZUZyYW1lIGlzIGRlc3Ryb3llZFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9kZXN0cnVjdGlvblxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IFtldnRdIFRoZSByYXcgZG9tIGV2ZW50IG9iamVjdCBpZiBpdCBleGlzdHNcbiAgICAgICAqL1xuICAgICAgX2Rlc3RydWN0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBlLCBncmFuZF9wYXIsIGhhbmRsZXIsIHN1Y2Nlc3MsIHc7XG4gICAgICAgIGhhbmRsZXIgPSB2b2lkIDA7XG4gICAgICAgIHcgPSB3aW5kb3c7XG4gICAgICAgIHN1Y2Nlc3MgPSAxO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dCA9IGV2dCB8fCB3LmV2ZW50IHx8IHt9O1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGV2dCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFVOTE9BRFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGhhbmRsZXIgPSB1bmxvYWRfaGFuZGxlcnMuc2hpZnQoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyKGV2dCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGllX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICAgIHdbSUVfQVRUQUNIXSA9IGllX29sZF9hdHRhY2g7XG4gICAgICAgICAgICB3W0lFX0RFVEFDSF0gPSBpZV9vbGRfZGV0YWNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh3M2Nfb2xkX2F0dGFjaCkge1xuICAgICAgICAgICAgd1tXM0NfQVRUQUNIXSA9IHczY19vbGRfYXR0YWNoO1xuICAgICAgICAgICAgd1tXM0NfREVUQUNIXSA9IHczY19vbGRfZGV0YWNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBpZiAoIWhhc0xvYWRlZCkge1xuICAgICAgICAgIF9kZXRhY2godywgTE9BRCwgX2hhbmRsZV9sb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBfZGV0YWNoKHcsIFVOTE9BRCwgX2hhbmRsZV91bmxvYWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHcub25lcnJvciA9IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZXJyX21zZ190aW1lcl9pZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVycl9tc2dfdGltZXJfaWQpO1xuICAgICAgICAgICAgZXJyX21zZ190aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG9ycGhhbl90aW1lcl9pZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ycGhhbl90aW1lcl9pZCk7XG4gICAgICAgICAgICBvcnBoYW5fdGltZXJfaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlubGluZV9oYW5kbGVyX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIGlubGluZV9oYW5kbGVyX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdyA9IGllX29sZF9hdHRhY2ggPSB3M2Nfb2xkX2F0dGFjaCA9IGllX29sZF9kZXRhY2ggPSB3M2Nfb2xkX2RldGFjaCA9IGQgPSBfdWUgPSBwYXIgPSBoYW5kbGVyID0gZ3JhbmRfcGFyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTWFpbnRhaW5zIHRoYXQgdGhlIHdpbmRvdy5vbm1lc3NhZ2UgcHJvcGVydHkgcmVtYWlucyB1bnNldC5cbiAgICAgIFdlIGRvbid0IHdhbnQgY29udGVudCBpbiBvdXIgZG9jdW1lbnQgbGlzdGVuaW5nIHRvIEhUTUw1IG1lc3NhZ2VzLlxuICAgICAgV2Ugb3ZlcnJpZGUgYXR0YWNoaW5nIHRvIGxpc3RlbmVycyBiZWxvdyB0byBtYWludGFpbiB0aGF0IGZ1bmN0aW9uYWxpdHksXG4gICAgICBob3dldmVyIElFIHdvbid0IGxldCB5b3Ugb3ZlcnJpZGUgcHJvcGVydGllcyBkaXJlY3RseSBoYW5nbmluZyBvZmYgb2YgdGhlXG4gICAgICB3aW5kb3cgb2JqZWN0LCBzbyB3ZSBoYXZlIGEgdGltZXIgYXMgYSBmYWxsYmFjayBmb3IgdGhhdCBwdXJwb3NlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3Jlc2V0X2lubGluZV9oYW5kbGVyc1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfcmVzZXRfaW5saW5lX2hhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlubGluZV9oYW5kbGVyX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIGlubGluZV9oYW5kbGVyX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaXNJRSAmJiB3aW4ub25tZXNzYWdlKSB7XG4gICAgICAgICAgICB3aW4ub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW4ub25lcnJvciA9IF9oYW5kbGVfZXJyO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIGlubGluZV9oYW5kbGVyX3RpbWVyX2lkID0gc2V0VGltZW91dChfcmVzZXRfaW5saW5lX2hhbmRsZXJzLCBET01fV0FUQ0hfSU5URVJWQUwpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENsZWFycyBvdXQgdGhlIEhUTUwgZG9jdW1lbnQgKHdoaWNoIHdpbGwgZm9yY2UgYW4gdW5sb2FkIGV2ZW50IGFzIHdlbGwpLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9udWtlX2RvY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfbnVrZV9kb2MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jdW1lbnQub3BlbihcInRleHQvaHRtbFwiLCBcInJlcGxhY2VcIik7XG4gICAgICAgICAgZG9jdW1lbnQud3JpdGUoXCJcIik7XG4gICAgICAgICAgZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEl0ZXJhdGl2ZWx5IGNoZWNrcyB0byBzZWUgaWYgdGhlIElGUkFNRSBIVE1MIGRvY3VtZW50IGlzIG5vIGxvbmdlclxuICAgICAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9tLCBkb2luZyB0aGlzIGJ5IGNoZWNraW5nIHRoYXQgb3VyIGludGVybmFsXG4gICAgICB3aW5kb3cgcmVmZXJlbmNlIGlzIHN0aWxsIHZhbGlkLiAuIC5hcyB3ZWxsIGFzIHJ1bm5pbmcgdGhlIGNoZWNrcyB0byBtYWtlXG4gICAgICBzdXJlIGludmFsaWQgaWZyYW1lcyAoaWZyYW1lcyBmcm9tIG9yaWdpbikgYXJlIG5vdCBjcmVhdGVkLlxuICAgICAgXG4gICAgICBJZiB3ZSBkZXRlY3QgdGhhdCB0aGUgSUZSQU1FIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFpbiBkb20gb2YgdGhlXG4gICAgICBwdWJsaXNoZXIsIHRoZW4gd2UgY2FsbCB0byBkZXN0cm95IHRoZSBIVE1MIGRvY3VtZW50LCBmb3JjaW5nIG9udW5sb2FkXG4gICAgICBldmVudCBhbmQgc3Vic3F1ZW50IGNsZWFudXBcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fY2hlY2tfb3JwaGFuZWRcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX2NoZWNrX29ycGhhbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlLCBpc19vcnBoYW5lZDtcbiAgICAgICAgaXNfb3JwaGFuZWQgPSBmYWxzZTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgX2RldGVjdF9iYWRfaWZyYW1lKCk7XG4gICAgICAgIGlmICghaXNJRSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChvcnBoYW5fdGltZXJfaWQgJiYgb3JwaGFuX3RpbWVyX2lkICE9PSAtMSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ycGhhbl90aW1lcl9pZCk7XG4gICAgICAgICAgICBvcnBoYW5fdGltZXJfaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlzX29ycGhhbmVkID0gd2luID09PSB0b3AgJiYgb3JwaGFuX3RpbWVyX2lkICE9PSAtMTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBpc19vcnBoYW5lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19vcnBoYW5lZCkge1xuICAgICAgICAgIG9ycGhhbl90aW1lcl9pZCA9IC0xO1xuICAgICAgICAgIF9kZXN0cnVjdGlvbigpO1xuICAgICAgICAgIF9udWtlX2RvYygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghb3JwaGFuX3RpbWVyX2lkKSB7XG4gICAgICAgICAgICBvcnBoYW5fdGltZXJfaWQgPSBzZXRUaW1lb3V0KF9jaGVja19vcnBoYW5lZCwgRE9NX1dBVENIX0lOVEVSVkFMKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBEZXRlY3Qgd2hldGhlciBvciBub3QgYW4gSUZSQU1FIHRhZyBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00gdGhhdCBoYXMgdGhlIHNhbWVcbiAgICAgIG9yaWdpbiAvIGNuYW1lIGFzIHRoZSBwdWJsaXNoZXIsIHdoaWNoIHNob3VsZCBub3QgYmUgYWxsb3dlZCBhcyBpdCdzIGEgc2VjdXJpdHkgaXNzdWVcbiAgICAgIElmIHNhaWQgSUZSQU1FIHRhZyhzKSBhcmUgZm91bmQsIHJlbW92ZSB0aGVtLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9kZXRlY3RfYmFkX2lmcmFtZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfZGV0ZWN0X2JhZF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkeCwgc3JjSG9zdCwgdGFnLCB3cml0dGVuO1xuICAgICAgICBpZnJhbWVzID0gX3RhZ3MoXCJpZnJhbWVcIik7XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIHNyY0hvc3QgPSBcIlwiO1xuICAgICAgICB3cml0dGVuID0gZmFsc2U7XG4gICAgICAgIHRhZyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGhvc3RfY25hbWUpIHtcbiAgICAgICAgICB3aGlsZSAodGFnID0gaWZyYW1lc1tpZHgrK10pIHtcbiAgICAgICAgICAgIHNyY0hvc3QgPSBfYXR0cih0YWcsIFwic3JjXCIpO1xuICAgICAgICAgICAgc3JjSG9zdCA9IChzcmNIb3N0ICYmIHNyY0hvc3QubGVuZ3RoID49IDkgPyBzcmNIb3N0LnN1YnN0cmluZygwLCBzcmNIb3N0LmluZGV4T2YoXCIvXCIsIDkpKVtUT0xPV0VSQ0FTRV0oKSA6IFwiXCIpO1xuICAgICAgICAgICAgaWYgKHNyY0hvc3QgJiYgc3JjSG9zdCA9PT0gaG9zdF9jbmFtZSAmJiB0YWcuY2xhc3NOYW1lICE9PSBPVVJfVEFHX0NMU19OQU1FKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3B1cmdlKHRhZyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBNYWtlIHN1cmUgdGhhdCBhbGwgaHlwZXJsaW5rcyBpbiB0aGUgZG9jdW1lbnQgYXJlIHNldCB3aXRoIHRoZSBwcm9wZXJ0eSBcInRhcmdldFwiIGF0dHJpYnV0ZVxuICAgICAgc3VjaCB0aGF0IGxpbmtzIHdpbGwgbmF2aWdhdGUgdG8gdGhlIHJpZ2h0IHdpbmRvdyBwcm9wZXJseS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fc2V0X2h5cGVybGlua190YXJnZXRzXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9zZXRfaHlwZXJsaW5rX3RhcmdldHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF0Z3QsIGlkeCwgbG4sIGxucywgdHRndDtcbiAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgdHRndCA9IChyZW5kZXJfY29uZiAmJiByZW5kZXJfY29uZi50Z3QpIHx8IFwiX3RvcFwiO1xuICAgICAgICBsbiA9IHZvaWQgMDtcbiAgICAgICAgYXRndCA9IHZvaWQgMDtcbiAgICAgICAgbG5zID0gdm9pZCAwO1xuICAgICAgICBsbnMgPSBfdGFncyhcImFcIik7XG4gICAgICAgIGlmICh0dGd0ID09PSBcIl9zZWxmXCIpIHtcbiAgICAgICAgICB0dGd0ID0gXCJfdG9wXCI7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxuID0gbG5zW2lkeCsrXSkge1xuICAgICAgICAgIGF0Z3QgPSBfYXR0cihsbiwgXCJ0YXJnZXRcIik7XG4gICAgICAgICAgaWYgKGF0Z3QgIT09IHR0Z3QpIHtcbiAgICAgICAgICAgIF9hdHRyKGxuLCBcInRhcmdldFwiLCB0dGd0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkeCA+IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIG9udW5sb2FkIGV2ZW50IGZyb20gdGhlIEhUTUwgZG9jdW1lbnQgb2YgdGhlIElGUkFNRSwgd2hpY2ggaW4gdHVybiB3aWxsIHRyaWdnZXIgY2xlYW4gdXBcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1faGFuZGxlX3VubG9hZFxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IERPTSBldmVudCBvYmplY3RcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV91bmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX2Rlc3RydWN0aW9uKGV2dCk7XG4gICAgICAgIF9udWtlX2RvYygpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSB0aGUgbG9hZCBldmVudCBmcm9tIHRoZSBIVE1MIGRvY3VtZW50IG9mIHRoZSBJRlJBTUUsIHdoaWNoIHdpbGwgYWxzbyBzZXR1cFxuICAgICAgdG8gbWFrZSBzdXJlIGxpbmsgdGFyZ2V0cyBhcmUgc2V0IHByb3Blcmx5XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2hhbmRsZV9sb2FkXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIF9kZXRhY2god2luLCBMT0FELCBfaGFuZGxlX2xvYWQpO1xuICAgICAgICBfc2V0X2h5cGVybGlua190YXJnZXRzKCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIG9ubWVzc2FnZSBIVE1MNSB4LWRvbWFpbiBldmVudHMuIFdlIGFsd2F5cyBjYW5jZWwgdGhlIGV2ZW50XG4gICAgICBuZXZlciBhbGxvd2luZyBpdCB0byBnbyB0byBvdGhlciBsaXN0ZW5lcnMgYmVzaWRlcyBvdXIgb3duLCBhcyB3ZSBkb24ndCBhbGxvdyBIVE1MNSBtZXNzYWdpbmdcbiAgICAgIGJleW9uZCB1cyBhbmQgdGhlIHB1Ymxpc2hlciAvIGhvc3QuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2hhbmRsZV9tc2dcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV9tc2cgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIGUsIG1zZ19ndWlkLCBtc2dfb2JqLCBtc2dfcGFyYW1zLCBvcmcsIHNyYywgc3RyO1xuICAgICAgICBzdHIgPSB2b2lkIDA7XG4gICAgICAgIHNyYyA9IHZvaWQgMDtcbiAgICAgICAgb3JnID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBtc2dfcGFyYW1zID0gdm9pZCAwO1xuICAgICAgICBtc2dfZ3VpZCA9IHZvaWQgMDtcbiAgICAgICAgbXNnX29iaiA9IHZvaWQgMDtcblxuICAgICAgICAvKlxuICAgICAgICBUT0RPLCBhbHNvIHZhbGlkYXRlIG9yaWdpblxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHIgPSBldnQuZGF0YTtcbiAgICAgICAgICBzcmMgPSBldnQuc291cmNlO1xuICAgICAgICAgIG9yZyA9IGV2dC5vcmlnaW47XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgZG9tLmV2dENuY2woZXZ0KTtcbiAgICAgICAgaWYgKHN0ciAmJiBzcmMgJiYgc3JjID09PSB0b3ApIHtcbiAgICAgICAgICBtc2dfcGFyYW1zID0gUGFyYW1IYXNoKHN0ciwgbnVsbCwgbnVsbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXNnX2d1aWQgPSBtc2dfcGFyYW1zLmd1aWQ7XG4gICAgICAgICAgbXNnX29iaiA9IG1zZ19wYXJhbXMubXNnO1xuICAgICAgICAgIGlmIChndWlkID09PSBtc2dfZ3VpZCAmJiBtc2dfb2JqICYmIHR5cGVvZiBtc2dfb2JqID09PSBPQkopIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9yZWNlaXZlX21zZyhtc2dfb2JqLCBldnQpO1xuICAgICAgICAgICAgICAgIG1zZ19wYXJhbXMgPSBldnQgPSBtc2dfZ3VpZCA9IG1zZ19vYmogPSBudWxsO1xuICAgICAgICAgICAgICB9KSwgMSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVGhpcyBTYWZlRnJhbWVzIGltcGxlbWVudGF0aW9uIGludGVybmFsbHkgaGFuZGxlcyBhbGwgZXZlbnQgYXR0YWNobWVudCB0byBtYWludGFpbiB0aGF0IHRoZSBsaXN0ZW5lciBvcmRlclxuICAgICAgZm9yIGV2ZW50cyB0aGF0IGl0IGNhcmVzIGFib3V0IChvbmxvYWQsIG9udW5sb2FkLCBvbmJlZm9yZXVubG9hZCwgb25tZXNzYWdlKS5cbiAgICAgIFRoaXMgaXMgZG9uZSB0byBtYWtlIHN1cmUgdGhhdCBwcm9wZXIgY2xlYW4gdXAgYW5kIGludGlhbGl6YXRpb24gaGFwcGVucywgYXMgd2VsbCBhcyB0byBlbmZvcmNlXG4gICAgICBzZWN1cml0eS5cbiAgICAgIFxuICAgICAgRm9yIGV2ZW50cyB0aGF0IGl0IFNhZmVGcmFtZXMgZG9lcyBub3QgY2FyZSBhYm91dCB3ZSBhbGxvdyB0aGUgYXR0YWNobWVudCBsaXN0ZW5lcnNcbiAgICAgIHRvIHByb2NlZWQgYXMgbm9ybWFsLCBzbyB3ZSBjYWxsIHRoZSByYXcgYXR0YWNoRXZlbnQgLyBhZGRFdmVudExpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fY2FsbF9yYXdfZXZ0X2Z1bmNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gYXR0YWNoL2RldGFjaCBhIGxpc3RlbmVyXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byB1c2UgYXMgYSBsaXN0ZW5lciBmb3Igc2FpZCBldmVudFxuICAgICAgQHBhcmFtIHtCb29sZWFufSBbcmVtb3ZlXSBJZiBzZXQgdG8gdHJ1ZSwgcmVtb3ZlL2RldGFjaCB0aGlzIGZ1bmN0aW9uIGFzIGEgbGlzdGVuZXIsIG90aGVyd2lzZSBhZGRcbiAgICAgICAqL1xuICAgICAgX2NhbGxfcmF3X2V2dF9mdW5jID0gZnVuY3Rpb24odHlwZSwgZiwgcmVtb3ZlKSB7XG4gICAgICAgIHZhciBiT0ssIGUsIGllX2YsIHczY19mO1xuICAgICAgICBiT0sgPSBmYWxzZTtcbiAgICAgICAgaWVfZiA9IHZvaWQgMDtcbiAgICAgICAgdzNjX2YgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICBpZV9mID0gaWVfb2xkX2RldGFjaCB8fCB3M2Nfb2xkX2RldGFjaDtcbiAgICAgICAgICB3M2NfZiA9IHczY19vbGRfZGV0YWNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGllX2YgPSBpZV9vbGRfYXR0YWNoIHx8IHczY19vbGRfYXR0YWNoO1xuICAgICAgICAgIHczY19mID0gdzNjX29sZF9hdHRhY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGllX2YpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWVfZih0eXBlLCBmKTtcbiAgICAgICAgICAgIGJPSyA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgYk9LID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYk9LKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZV9mLmNhbGwod2luLCB0eXBlLCBmKTtcbiAgICAgICAgICAgICAgYk9LID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICBiT0sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHczY19mICYmICFiT0spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdzNjX2YuY2FsbCh3aW4sIHR5cGUsIGYsIGZhbHNlKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBPdmVycmlkZSBkZWZhdWx0IGV2ZW50IGF0dGFjaG1lbnQsIGFuZCBzZW5kIGxvYWQsIGJlZm9yZXVubG9hZCwgYW5kIHVubG9hZCBoYW5kbGVycyBpbnRvIG91clxuICAgICAgb3duIHF1ZXMsIHNvIHRoYXQgd2UgY2FuIGVuZm9yY2UgdGhlIHByb3BlciBmaXJpbmcgb3JkZXIuICBpZiBtZXNzYWdlIGV2ZW50IGlzIHBhc3NlZCBpbixcbiAgICAgIHdlIGRvIG5vdCBhbGxvdyBhdHRhY2htZW50LCBzaW5jZSB3ZSBkbyBub3Qgd2FudCBuLXBhcnR5IGNvZGUgbGlzdGVuaW5nIHRvIEhUTUw1IG1lc3NhZ2VzXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2F0dGFjaF9vdmVycmlkZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWUgdG8gbGlzdGVuIHRvb1xuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBldmVudCBmaXJlc1xuICAgICAgICovXG4gICAgICBfYXR0YWNoX292ZXJyaWRlID0gZnVuY3Rpb24odHlwZSwgZikge1xuICAgICAgICB2YXIgYkRvRGVmYXVsdDtcbiAgICAgICAgYkRvRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0eXBlID0gX2NzdHIodHlwZSlbVE9MT1dFUkNBU0VdKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgVU5MT0FEOlxuICAgICAgICAgIGNhc2UgT05VTkxPQUQ6XG4gICAgICAgICAgICB1bmxvYWRfaGFuZGxlcnMucHVzaChmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTVNHOlxuICAgICAgICAgIGNhc2UgT05NU0c6XG4gICAgICAgICAgICB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJEb0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiRG9EZWZhdWx0KSB7XG4gICAgICAgICAgX2NhbGxfcmF3X2V2dF9mdW5jKHR5cGUsIGYpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgT3ZlcnJpZGUgZGVmYXVsdCBldmVudCBkZXRhY2htZW50LCBhbmQgcmVtb3ZlIGxvYWQsIGJlZm9yZXVubG9hZCwgYW5kIHVubG9hZCBoYW5kbGVyc1xuICAgICAgZnJvbSBvdXIgb3duIHF1ZS4gIGlmIG1lc3NhZ2UgZXZlbnQgaXMgcGFzc2VkIGluLCB3ZSBkbyBub3RoaW5nIChzaW5jZSB3ZSBkb24ndCBhbGxsb3dcbiAgICAgIGF0dGFjaG1lbnQgZWl0aGVyKS4gIElmIG5vdCBvbmUgb2YgdGhvc2UgZXZlbnQgdHlwZXMsIHRoZW4gd2UgY2FsbCB0aGUgZGVmYXVsdCBldmVudCBkZXRhY2htZW50XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2RldGFjaF9vdmVycmlkZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWUgdG8gdW5saXN0ZW4gdG9vXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0byBubyBsb25nZXIgYmUgY2FsbGVkIGZvciB0aGUgc3BlY2lmaWMgZXZlbnRcbiAgICAgICAqL1xuICAgICAgX2RldGFjaF9vdmVycmlkZSA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIGhhbmRsZXJzLCBpZHg7XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIGhhbmRsZXIgPSB2b2lkIDA7XG4gICAgICAgIGhhbmRsZXJzID0gdm9pZCAwO1xuICAgICAgICB0eXBlID0gX2NzdHIodHlwZSlbVE9MT1dFUkNBU0VdKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgVU5MT0FEOlxuICAgICAgICAgIGNhc2UgT05VTkxPQUQ6XG4gICAgICAgICAgICBoYW5kbGVycyA9IHVubG9hZF9oYW5kbGVycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTVNHOlxuICAgICAgICAgIGNhc2UgT05NU0c6XG4gICAgICAgICAgICB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVycyAhPSBudWxsID8gaGFuZGxlcnMubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICAgICAgd2hpbGUgKGhhbmRsZXIgPSBoYW5kbGVyc1tpZHhdKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gZikge1xuICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgfVxuICAgICAgICBfY2FsbF9yYXdfZXZ0X2Z1bmModHlwZSwgZiwgdHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmVwb3J0IGFueSBpbnRlcm5hbCB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9ycyB1cCB0byB0aGUgcHVibGlzaGVyIC8gaG9zdFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9yZXBvcnRfZXJyc1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfcmVwb3J0X2VycnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNtZF9zdHIsIGUsIGVycnM7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGVycnMgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGVycl9tc2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycnMgPSBlcnJfbXNnc1swXTtcbiAgICAgICAgICAgIGNtZF9zdHIgPSBbXCJjbWQ9XCIsIEVSUk9SX0NPTU1BTkQsIFwiJnBvcz1cIiwgcG9zX2lkLCBcIiZlcnJvcnM9XCIsIGVycnNdO1xuICAgICAgICAgICAgX3NlbmRfbXNnKF9jc3RyKGNtZF9zdHIpLCBFUlJPUl9DT01NQU5EKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycl9tc2dfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlcnJfbXNnX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIGVycl9tc2dfdGltZXJfaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBlcnJfbXNncyA9IFtdO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSBhbnkgdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvcnNcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1faGFuZGxlX2VyclxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGEgVGhlIHRoZSBlcnJvciBtZXNzYWdlIC8gZGVzY3JpcHRpb24gc3RyaW5nXG4gICAgICBAcGFyYW0ge1N0cmluZ30gYiBUaGUgVVJMIC8gZmlsZSB0aGF0IHRoZSBKYXZhU2NyaXB0IGVycm9yIG9jY3VyZWQgd2l0aGluXG4gICAgICBAcGFyYW0ge051bWJlcn0gYyBUaGUgbGluZSBudW1iZXIgdGhhdCB0aGUgZXJyb3Igb2NjdXJlZCBvbi4gLiAuXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfZXJyID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgZXJyX21zZ3MucHVzaChfY3N0cihbXCJFcnJvciBvY2N1cnJlZCBpbnNpZGUgU2FmZUZyYW1lOlxcbk1lc3NhZ2U6IFwiLCBhLCBcIlxcblVSTDpcIiwgYiwgXCJcXG5MaW5lOlwiLCBjXSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChlcnJfbXNnX3RpbWVyX2lkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZXJyX21zZ190aW1lcl9pZCk7XG4gICAgICAgICAgICBlcnJfbXNnX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyX21zZ190aW1lcl9pZCA9IHNldFRpbWVvdXQoX3JlcG9ydF9lcnJzLCBET01fV0FUQ0hfSU5URVJWQUwpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE92ZXJyaWRlIG5hdGl2ZSB3aW5kb3cgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBzbyB0aGF0IHdlIGNhbiBjb250cm9sXG4gICAgICBob3cgdGhlIGV2ZW50cyB0aGF0IHdlIG5lZWQgdG8gbWFuYWdlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3NldHVwX3dpbl9ldnRfcHJvcHNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIHdpbmRvdyBvYmplY3QgLyBwcm90b3R5cGVcbiAgICAgICAqL1xuICAgICAgX3NldHVwX3dpbl9ldnRfcHJvcHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIE8sIGUsIG4sIG5vYmosIHJldDtcbiAgICAgICAgbiA9IGxhbmcubm9vcDtcbiAgICAgICAgTyA9IE9iamVjdDtcbiAgICAgICAgbm9iaiA9IHtcbiAgICAgICAgICBnZXQ6IG4sXG4gICAgICAgICAgc2V0OiBuXG4gICAgICAgIH07XG4gICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgaWYgKGllX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICAgIG9ialtJRV9BVFRBQ0hdID0gX2F0dGFjaF9vdmVycmlkZTtcbiAgICAgICAgICAgIG9ialtJRV9ERVRBQ0hdID0gX2RldGFjaF9vdmVycmlkZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHczY19vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgICBvYmpbVzNDX0FUVEFDSF0gPSBfYXR0YWNoX292ZXJyaWRlO1xuICAgICAgICAgICAgb2JqW1czQ19ERVRBQ0hdID0gX2RldGFjaF9vdmVycmlkZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9ialtER10pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG9ialtER10oT05MT0FELCBuKTtcbiAgICAgICAgICAgICAgb2JqW0RTXShPTkxPQUQsIG4pO1xuICAgICAgICAgICAgICBvYmpbREddKE9OVU5MT0FELCBuKTtcbiAgICAgICAgICAgICAgb2JqW0RTXShPTlVOTE9BRCwgbik7XG4gICAgICAgICAgICAgIG9ialtER10oT05NU0csIG4pO1xuICAgICAgICAgICAgICBvYmpbRFNdKE9OTVNHLCBuKTtcbiAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXQgJiYgT1tEUF0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIE9bRFBdKG9iaiwgT05MT0FELCBub2JqKTtcbiAgICAgICAgICAgICAgT1tEUF0ob2JqLCBPTlVOTE9BRCwgbm9iaik7XG4gICAgICAgICAgICAgIE9bRFBdKG9iaiwgT05NU0csIG5vYmcpO1xuICAgICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEludGlhbGl6ZSAvIHNldHVwIHRoZSBzYWZlZnJhbWUsIHRoZSBlbnZpcm9ubWVudCBhY2NvcmRpbmcgdG8gdGhlIGNvbmZpZ3VyYXRpb24gZm91bmQgd2l0aGluIHRoZSBzZXJpYWxpemVkXG4gICAgICB3aW5kb3cubmFtZSBwcm9wZXJ0eS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fY29uc3RydWN0aW9uXG4gICAgICBAcGFyYW0ge09iamVjdH0gW2RldGFpbHNdIEFuIG9wdGlvbmFsIG9iamVjdCB0byBwYXNzIGluIHN0YXR1cyAvIGVycm9yIGluZm9ybWF0aW9uIGludG9cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2NvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKGRldGFpbHMpIHtcbiAgICAgICAgdmFyIGNvbnQsIGN1cl90aW1lLCBlLCBlbCwgZ3VpZF90aW1lLCBubSwgcmV0LCB0ZW1wLCB0aW1lX2RlbHRhO1xuICAgICAgICBjb250ID0gZmFsc2U7XG4gICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgIGVsID0gdm9pZCAwO1xuICAgICAgICBubSA9IHZvaWQgMDtcbiAgICAgICAgdGVtcCA9IHZvaWQgMDtcbiAgICAgICAgY3VyX3RpbWUgPSB2b2lkIDA7XG4gICAgICAgIGd1aWRfdGltZSA9IHZvaWQgMDtcbiAgICAgICAgdGltZV9kZWx0YSA9IHZvaWQgMDtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgZGV0YWlscyA9IChkZXRhaWxzICYmIChkZXRhaWxzIGluc3RhbmNlb2YgT2JqZWN0KSA/IGRldGFpbHMgOiB7fSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm0gPSB3aW4ubmFtZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbi5uYW1lID0gXCJcIjtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBpZiAoIW5tKSB7XG4gICAgICAgICAgZGV0YWlscy5zdGF0dXMgPSA1MDAuMTAxO1xuICAgICAgICAgIHJldHVybiBjb250O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRvcCA9PT0gcGFyKSB7XG4gICAgICAgICAgICByZW5kZXJfcGFyYW1zID0gUGFyYW1IYXNoKG5tLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGN1cl90aW1lID0gbGFuZy50aW1lKCk7XG4gICAgICAgICAgICBndWlkID0gcmVuZGVyX3BhcmFtcy5ndWlkO1xuICAgICAgICAgICAgZ3VpZF90aW1lID0gX2NudW0oZ3VpZC5yZXBsYWNlKC9bXl9dKl8oXFxkKylfXFxkK19cXGQrL2csIFwiJDFcIiksIDApO1xuICAgICAgICAgICAgdGltZV9kZWx0YSA9IGN1cl90aW1lIC0gZ3VpZF90aW1lO1xuICAgICAgICAgICAgY29udCA9IGd1aWQgJiYgZ3VpZF90aW1lICYmIHRpbWVfZGVsdGEgPiAwICYmIHRpbWVfZGVsdGEgPCBHVUlEX1ZBTElEX1RJTUU7XG4gICAgICAgICAgICBpZiAocmVuZGVyX3BhcmFtcy5sb2MpIHtcbiAgICAgICAgICAgICAgcmVuZGVyX3BhcmFtcy5sb2MgPSB1bmVzY2FwZShyZW5kZXJfcGFyYW1zLmxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbnQpIHtcbiAgICAgICAgICAgICAgZGV0YWlscy5zdGF0dXMgPSA1MDAuMTA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXRhaWxzLnN0YXR1cyA9IDUwMC4xMDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJlbmRlcl9wYXJhbXMgPSBndWlkID0gbnVsbDtcbiAgICAgICAgICBjb250ID0gZmFsc2U7XG4gICAgICAgICAgZGV0YWlscy5zdGF0dXMgPSA1MDAuMTAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlbmRlcl9jb25mID0gcmVuZGVyX3BhcmFtcy5jb25mO1xuICAgICAgICAgICAgZnJhbWVfaWQgPSB3aW4ubmFtZSA9IHJlbmRlcl9jb25mLmRlc3Q7XG4gICAgICAgICAgICBwb3NfaWQgPSByZW5kZXJfY29uZi5pZDtcbiAgICAgICAgICAgIHBvc19tZXRhID0gcmVuZGVyX3BhcmFtcy5tZXRhO1xuICAgICAgICAgICAgaG9zdF9jbmFtZSA9IHJlbmRlcl9wYXJhbXMuaG9zdDtcbiAgICAgICAgICAgIGdlb21faW5mbyA9IHJlbmRlcl9wYXJhbXMuZ2VvbTtcbiAgICAgICAgICAgIGNhbl91c2VfaHRtbDUgPSBsYW5nLmNib29sKHJlbmRlcl9wYXJhbXMuaHRtbDUpO1xuICAgICAgICAgICAgd2luX2hhc19mb2N1cyA9IGxhbmcuY2Jvb2wocmVuZGVyX3BhcmFtcy5oYXNfZm9jdXMpO1xuICAgICAgICAgICAgdGVtcCA9IHJlbmRlcl9jb25mLmJnO1xuICAgICAgICAgICAgaWYgKGdlb21faW5mbykge1xuICAgICAgICAgICAgICBnZW9tX2luZm8gPSBQYXJhbUhhc2goX3VlKGdlb21faW5mbyksIG51bGwsIG51bGwsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAoIWdlb21faW5mby5zZWxmIHx8ICFnZW9tX2luZm8uZXhwKSB7XG4gICAgICAgICAgICAgICAgZ2VvbV9pbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFob3N0X2NuYW1lKSB7XG4gICAgICAgICAgICAgIGhvc3RfY25hbWUgPSBkLnJlZmVycmVyO1xuICAgICAgICAgICAgICBob3N0X2NuYW1lID0gaG9zdF9jbmFtZS5zdWJzdHJpbmcoMCwgaG9zdF9jbmFtZS5pbmRleE9mKFwiL1wiLCA5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcCkge1xuICAgICAgICAgICAgICBfY3JlYXRlX3N0eWxlc2hlZXQoX2NzdHIoW1wiI3NmX2JvZHkgeyBiYWNrZ3JvdW5kLWNvbG9yOiBcIiwgdGVtcCwgXCI7IH1cIl0pLCBcInNmX2JnX2Nzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXAgPSByZW5kZXJfY29uZi50Z3Q7XG4gICAgICAgICAgICBpZiAodGVtcCA9PT0gXCJfc2VsZlwiKSB7XG4gICAgICAgICAgICAgIHJlbmRlcl9jb25mLnRndCA9IFwiX3RvcFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZW1wKSB7XG4gICAgICAgICAgICAgIHJlbmRlcl9jb25mLnRndCA9IFwiX3RvcFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXAgIT09IFwiX3RvcFwiKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChfcHVyZ2UoX3RhZ3MoXCJiYXNlXCIpWzBdKSkge1xuICAgICAgICAgICAgICAgIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsID0gZG9tLm1ha2UoXCJiYXNlXCIpO1xuICAgICAgICAgICAgX2F0dHIoZWwsIFwidGFyZ2V0XCIsIHRlbXApO1xuICAgICAgICAgICAgX2FwcGVuZChfdGFncyhcImhlYWRcIilbMF0sIGVsKTtcbiAgICAgICAgICAgIGlmIChpc0lFKSB7XG4gICAgICAgICAgICAgIGllX29sZF9hdHRhY2ggPSB3aW5bSUVfQVRUQUNIXTtcbiAgICAgICAgICAgICAgaWVfb2xkX2RldGFjaCA9IHdpbltJRV9ERVRBQ0hdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdzNjX29sZF9hdHRhY2ggPSB3aW5bVzNDX0FUVEFDSF07XG4gICAgICAgICAgICB3M2Nfb2xkX2RldGFjaCA9IHdpbltXM0NfREVUQUNIXTtcbiAgICAgICAgICAgIF9hdHRhY2god2luLCBVTkxPQUQsIF9oYW5kbGVfdW5sb2FkKTtcbiAgICAgICAgICAgIF9hdHRhY2god2luLCBMT0FELCBfaGFuZGxlX2xvYWQpO1xuICAgICAgICAgICAgX2F0dGFjaCh3aW4sIE1TRywgX2hhbmRsZV9tc2cpO1xuICAgICAgICAgICAgX3NldHVwX3dpbl9ldnRfcHJvcHMod2luKTtcbiAgICAgICAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzKHdpbi5fX3Byb3RvX18pO1xuICAgICAgICAgICAgX3NldHVwX3dpbl9ldnRfcHJvcHMod2luLldpbmRvdyAmJiB3aW4uV2luZG93LnByb3RvdHlwZSk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgZGV0YWlscy5zdGF0dXMgPSA1MDAuMTA1O1xuICAgICAgICAgICAgcmVuZGVyX3BhcmFtcyA9IHJlbmRlcl9jb25mID0gZ3VpZCA9IG51bGw7XG4gICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyX3BhcmFtcyA9IGd1aWQgPSBudWxsO1xuICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgICAgX3dyYXBpRnJhbWUgPSBmdW5jdGlvbihodG1sLCBjYk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiPGlmcmFtZSBzdHlsZT1cXFwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtcXFwiIGFsbG93dHJhbnNwYXJlbmN5PVxcXCJ0cnVlXFxcIlxcbnNjcm9sbGluZz1cXFwibm9cXFwiIG1hcmdpbndpZHRoPVxcXCIwXFxcIiBtYXJnaW5oZWlnaHQ9XFxcIjBcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiBvbmxvYWQ9J1wiICsgY2JOYW1lICsgXCIoKSc+XFxuPGh0bWw+PGhlYWQ+PGJhc2UgdGFyZ2V0PVxcXCJfdG9wXFxcIj48L2hlYWQ+PGJvZHkgc3R5bGU9XFxcIm1hcmdpbjogMDsgcGFkZGluZzogMFxcXCI+XFxuPHNjcmlwdD5cXG4gICRhZCA9IHdpbmRvdy5wYXJlbnQuJGFkXFxuICAkc2YgPSB3aW5kb3cucGFyZW50LiRzZlxcbjwvc2NyaXB0PlxcbiAgXCIgKyBodG1sICsgXCJcXG48L2h0bWw+XFxuPC9pZnJhbWU+XCI7XG4gICAgICB9O1xuICAgICAgb3JpZ2luYWxXcml0ZSA9IGRvY3VtZW50LndyaXRlO1xuXG4gICAgICAvKlxuICAgICAgUmVuZGVyIHRoZSBIVE1MIGFuZCBDU1MgY29udGVudCBwYXNzZWQgaW4gdGhyb3VnaCB0aGUgd2luZG93Lm5hbWUgbWVzc2FnZSB2aWEgYSBkb2N1bWVudC53cml0ZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9yZW5kZXJcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3JlbmRlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYk5hbWUsIGNzcywgZSwgaHRtbCwgb3RoZXJDYWxsYmFja0FwcGxpZWQ7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIGNiTmFtZSA9IGxpYi5sYW5nLmd1aWQoXCJsb2FkX2NiXCIpO1xuICAgICAgICBvdGhlckNhbGxiYWNrQXBwbGllZCA9IGZhbHNlO1xuICAgICAgICB3aW5kb3dbY2JOYW1lXSA9IGZ1bmN0aW9uKGZyb21GcmFtZSkge1xuICAgICAgICAgIHJldHVybiAoc2YubGliLmxhbmcud3JhcChjYWxsYmFjaywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUZyYW1lIHx8ICFvdGhlckNhbGxiYWNrQXBwbGllZCkge1xuICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShzZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX2hhbmRsZV9sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZWQoKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkodGhpcyksIDMwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2hhbmRsZV9sb2FkKCk7XG4gICAgICAgICAgICAgICAgbG9hZGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUgPSBvcmlnaW5hbFdyaXRlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHdpbmRvd1tjYk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSgpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHZhciBkb21FbGVtLCBpZnJhbWUsIG9sZE9ubG9hZCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICAgICAgaWYgKCEoaGFzTG9hZGVkIHx8IG90aGVyQ2FsbGJhY2tBcHBsaWVkKSkge1xuICAgICAgICAgICAgZG9tRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBkb21FbGVtLmlubmVySFRNTCA9IFwiX1wiICsgc3RyO1xuICAgICAgICAgICAgX3JlZiA9IGRvbUVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIik7XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgaWZyYW1lID0gX3JlZltfaV07XG4gICAgICAgICAgICAgIGlmIChfY251bShfYXR0cihpZnJhbWUsIFwid2lkdGhcIiksIDApID4gMSkge1xuICAgICAgICAgICAgICAgIG90aGVyQ2FsbGJhY2tBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAob2xkT25sb2FkID0gX2F0dHIoaWZyYW1lLCBcIm9ubG9hZFwiKSkge1xuICAgICAgICAgICAgICAgICAgX2F0dHIoaWZyYW1lLCBcIm9ubG9hZFwiLCBcIlwiICsgY2JOYW1lICsgXCIodHJ1ZSk7XCIgKyBvbGRPbmxvYWQgKyBcIjtcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF9hdHRyKGlmcmFtZSwgXCJvbmxvYWRcIiwgXCJcIiArIGNiTmFtZSArIFwiKHRydWUpO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlckNhbGxiYWNrQXBwbGllZCkge1xuICAgICAgICAgICAgICBzdHIgPSBkb21FbGVtLmlubmVySFRNTC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbFdyaXRlLmNhbGwodGhpcywgc3RyKTtcbiAgICAgICAgfTtcbiAgICAgICAgaHRtbCA9IHZvaWQgMDtcbiAgICAgICAgY3NzID0gdm9pZCAwO1xuICAgICAgICBpc0FkU2hvd24gPSB0cnVlO1xuICAgICAgICBjc3MgPSBfY3N0cihyZW5kZXJfY29uZiAmJiByZW5kZXJfY29uZi5jc3MpO1xuICAgICAgICBodG1sID0gX2NzdHIocmVuZGVyX3BhcmFtcyAmJiByZW5kZXJfcGFyYW1zLmh0bWwpO1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgY3NzID0gX3VlKGNzcyk7XG4gICAgICAgICAgX2NyZWF0ZV9zdHlsZXNoZWV0KGNzcywgXCJzZl9jdXN0b21fY3NzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaHRtbCA9IF91ZShodG1sKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3JlYXR0YWNoX21lc3NhZ2luZygpO1xuICAgICAgICAgICAgX3JlcXVlc3RlZCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoaHRtbCArIFwiPHNjclwiICsgKFwiaXB0PiBcIiArIGNiTmFtZSArIFwiKCkgOzwvc2NyXCIpICsgXCJpcHQ+XCIpO1xuICAgICAgICAgICAgX2NoZWNrX29ycGhhbmVkKCk7XG4gICAgICAgICAgICBfcmVzZXRfaW5saW5lX2hhbmRsZXJzKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgX2hhbmRsZV9lcnIoXCJFcnJvciB3aGlsZSByZW5kZXJpbmcgY29udGVudDogXCIgKyBlW01TR10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENhbGwgaW50byB0aGUgZmFsbGJhY2sgeC1tc2dpbmcgbGlicmFyeSBjbGllbnQgaWYgcG9zc2libGUgd2hlbiBubyBIVE1MNSBzdHlsZSBtZXNzYWdpbmdcbiAgICAgIGV4aXN0c1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9jYWxsX2NsaWVudF9mYlxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IG1ldGhOYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIGluIHRoZSBsaWJyYXJ5IHRvIGNhbGxcbiAgICAgIEBwYXJhbSB7Kn0gW2FyZzFdIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBoYW5kIGludG8gdGhlIGxpYnJhcnlcbiAgICAgIEBwYXJhbSB7Kn0gW2FyZzJdIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBoYW5kIGludG8gdGhlIGxpYnJhcnlcbiAgICAgICAqL1xuICAgICAgX2NhbGxfY2xpZW50X2ZiID0gZnVuY3Rpb24obWV0aE5hbWUsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgdmFyIG1zZ19jbGllbnRmYjtcbiAgICAgICAgaWYgKG1zZ2NsaWVudF9mYikge1xuICAgICAgICAgIG1zZ19jbGllbnRmYiA9IGRvbS5tc2djbGllbnRfZmI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhOYW1lICYmIG1zZ2NsaWVudF9mYiAmJiBtc2djbGllbnRfZmJbbWV0aE5hbWVdICYmIG1zZ2NsaWVudF9mYlttZXRoTmFtZV0oYXJnMSwgYXJnMik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUHJvY2VzcyBhIHZhbGlkYXRlZCBtZXNzYWdlIHRvIG5vdGlmeSB0aGUgY29udGVudHMgb2YgdGhlIFNhZmVGcmFtZSBvZiBzdGF0ZSB1cGRhdGVzXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3JlY2VpdmVfbXNnXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IHBhcmFtcyBUaGUgbWVzc2FnZSBwYXJhbWV0ZXIgaGFzaCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhcyBvY2N1cmVkXG4gICAgICBAcGFyYW0ge0hUTUxFdmVudH0gW2V2dF0gVGhlIHJhdyBET00gZXZlbnQgZnJvbSB0aGUgeC1kb21haW4gbWVzc2FnZVxuICAgICAgQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG1lc3NhZ2UgcmVjZWl2ZWQgY291bGQgYmUgaGFuZGxlZFxuICAgICAgICovXG4gICAgICBfcmVjZWl2ZV9tc2cgPSBmdW5jdGlvbihwYXJhbXMsIGV2dCkge1xuICAgICAgICB2YXIgY21kLCBkYXRhLCBlLCBnLCBtc2csIHJldDtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIG1zZyA9IHZvaWQgMDtcbiAgICAgICAgY21kID0gdm9pZCAwO1xuICAgICAgICBnID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICBnID0gcGFyYW1zLmdlb20gfHwgXCJcIjtcbiAgICAgICAgICBjbWQgPSBwYXJhbXMuY21kO1xuICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICBnZW9tX2luZm8gPSBQYXJhbUhhc2goX3VlKGcpLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5jbWQgPSBjbWQ7XG4gICAgICAgIGRhdGEudmFsdWUgPSBkYXRhLmluZm8gPSBwYXJhbXMgJiYgcGFyYW1zLnZhbHVlO1xuICAgICAgICBkYXRhLnJlYXNvbiA9IHBhcmFtcyAmJiBwYXJhbXMucmVhc29uO1xuICAgICAgICBpZiAoY21kID09PSBOT1RJRllfQ09MTEFQU0VEKSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNfZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICAgIGlzX2V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JjZV9jb2xsYXBzZSA9IHRydWU7XG4gICAgICAgICAgICBfY29sbGFwc2UoKTtcbiAgICAgICAgICAgIGZvcmNlX2NvbGxhcHNlID0gZmFsc2U7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9DT0xMQVBTRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IE5PVElGWV9DT0xMQVBTRSkge1xuICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzX2V4cGFuZGVkKSB7XG4gICAgICAgICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICAgICAgICBpc19leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfQ09MTEFQU0VEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSBOT1RJRllfRVhQQU5EKSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocGVuZGluZ19tc2cpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICAgIGlzX2V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX0VYUEFORCArIFwiZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0dFT01fVVBEQVRFKSB7XG4gICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfR0VPTV9VUERBVEUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0ZPQ1VTX0NIQU5HRSkge1xuICAgICAgICAgIGRhdGEuaW5mbyA9IGRhdGEudmFsdWUgPSBsYW5nLmNib29sKGRhdGEudmFsdWUpO1xuICAgICAgICAgIHdpbl9oYXNfZm9jdXMgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX0ZPQ1VTX0NIQU5HRSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSBOT1RJRllfUkVBRF9DT09LSUUpIHtcbiAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwZW5kaW5nX21zZykge1xuICAgICAgICAgICAgcGVuZGluZ19tc2cgPSBudWxsO1xuICAgICAgICAgICAgZGF0YSA9IHBhcmFtcyAmJiBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9SRUFEX0NPT0tJRSwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFtOT1RJRllfV1JJVEVfQ09PS0lFLCBOT1RJRllfRkFJTFVSRSwgTk9USUZZX0NMSUNLRUQsIE5PVElGWV9WSUVXRUQsIE5PVElGWV9VTlZJRVdFRCwgTk9USUZZX0xPQURFRCwgTk9USUZZX1JFUVVFU1RFRCwgTk9USUZZX1JFTE9BRF0uaW5kZXhPZihjbWQpID4gLTEpIHtcbiAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwZW5kaW5nX21zZykge1xuICAgICAgICAgICAgcGVuZGluZ19tc2cgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKGNtZCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocGVuZGluZ19tc2cpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhjbWQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgICAgY21kUmV0cmllcyA9IHt9O1xuXG4gICAgICAvKlxuICAgICAgU2VuZCBhIGNvbW1hbmQgbWVzc2FnZSB1cCB0byB0aGUgU2FmZUZyYW1lcyBwdWJsaXNoZXIgLyBob3N0IGNvZGVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fc2VuZF9tc2dcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgQW4gZW5jb2RlZCBzdHJpbmcgKHF1ZXJ5LXN0cmluZy8kc2YubGliLmxhbmcuUGFyYW1IYXNoIGZvcm1hdCkgdGhhdCBjb250YWlucyB0aGUgY29tbWFuZCBtZXNzYWdlIHRvIHNlbmRcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBjbWQgVGhlIGNvbW1hbmQgdG8gYmUgc2VudCBpdHNlbGYgKG5vdGUgdGhhdCB0aGlzIHN0cmluZyBzaG91bGQgYWxzbyBiZSBwcmVzZW50IGluIHRoZSAxc3QgYXJndW1lbnQpXG4gICAgICAgKi9cbiAgICAgIF9zZW5kX21zZyA9IGZ1bmN0aW9uKHN0ciwgY21kKSB7XG4gICAgICAgIHZhciBlLCBpZCwgcGFyYW1zLCBzZW50LCBzZW50X3RpbWU7XG4gICAgICAgIGlkID0gbGFuZy5ndWlkKFwic2ZfcG5kX2NtZFwiKTtcbiAgICAgICAgZnJhbWVfaWQgPSByZW5kZXJfcGFyYW1zLmRlc3Q7XG4gICAgICAgIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgc2VudF90aW1lID0gbGFuZy50aW1lKCk7XG4gICAgICAgIHBhcmFtcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFzdHIgfHwgIWNtZCB8fCBwZW5kaW5nX21zZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBQYXJhbUhhc2goe1xuICAgICAgICAgIG1zZzogc3RyLFxuICAgICAgICAgIGlkOiBmcmFtZV9pZCxcbiAgICAgICAgICBndWlkOiBndWlkLFxuICAgICAgICAgIGNtZDogY21kXG4gICAgICAgIH0pO1xuICAgICAgICBwZW5kaW5nX21zZyA9IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgc2VudDogc2VudF90aW1lLFxuICAgICAgICAgIGNtZDogY21kXG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChwZW5kaW5nX21zZyAmJiBwZW5kaW5nX21zZy5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGlmIChjbWQgPT09IEVYUEFORF9DT01NQU5EIHx8IGNtZCA9PT0gXCJleHAtcHVzaFwiKSB7XG4gICAgICAgICAgICAgIGZvcmNlX2NvbGxhcHNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2NvbGxhcHNlKCk7XG4gICAgICAgICAgICAgIGZvcmNlX2NvbGxhcHNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9GQUlMVVJFICsgXCI6XCIgKyBjbWQgKyBcIjp0aW1lb3V0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZCA9IHNlbnQgPSBzZW50X3RpbWUgPSBjbWQgPSBzdHIgPSBwZW5kaW5nX21zZyA9IHBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0pLCBNQVhfTVNHX1dBSVRfVElNRSk7XG4gICAgICAgIGlmIChjYW5fdXNlX2h0bWw1KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRvcC5wb3N0TWVzc2FnZShwYXJhbXMudG9TdHJpbmcoKSwgKGhvc3RfY25hbWUgPT09IFwiZmlsZVwiIHx8IGhvc3RfY25hbWUgPT09IFwiXCIgPyBcIipcIiA6IGhvc3RfY25hbWUpKTtcbiAgICAgICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZW50KSB7XG4gICAgICAgICAgX2NhbGxfY2xpZW50X2ZiKFwic2VuZFwiLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgRmlyZSBhIG5vdGlmaWNhdGlvbiBvZmYgdG8gdGhlIFNhZmVGcmFtZSBjb250ZW50cyBpZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdhcyBzcGVjaWZpZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fZmlyZV9zYW5kYm94X2NhbGxiYWNrXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0ge1N0cmluZ30gbXNnIFRoZSBzdGF0dXMgdXBkYXRlIC8gbWVzc2FnZSB0byBzZW5kXG4gICAgICBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBmcm9tIHRoZSByZXNwb25zZVxuICAgICAgICovXG4gICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrID0gZnVuY3Rpb24obXNnLCBkYXRhKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2FuZGJveF9jYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBzYW5kYm94X2NiKG1zZywgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgU2V0IHRoZSBhbGlnbm1lbnQgb2Ygb3VyIGludGVybmFsIERJViB3aGVuZXZlciBleHBhbnNpb24gb2NjdXJzIHVuaS1kaXJlY3Rpb25hbHlcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fc2V0X2FsaWdubWVudFxuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHtCb29sZWFufSB4biBXaGV0aGVyIG9yIG5vdCBob3Jpem9udGFsIGF4aXMgaXMgZ3Jvd2luZyB0byB0aGUgbGVmdCBvciByaWdodCAoeG4gPT0gdHJ1ZSA9PSBsZWZ0KVxuICAgICAgQHBhcmFtIHtCb29sZWFufSB5biBXaGV0aGVyIG9yIG5vdCB2ZXJ0aWNhbCBheGlzIGlzIGdyb3dpbmcgdG8gdGhlIHRvcCBvciBib3R0b20gKHluID09IHRydWUgPT0gdG9wKVxuICAgICAgICovXG4gICAgICBfc2V0X2FsaWdubWVudCA9IGZ1bmN0aW9uKHhuLCB5bikge1xuICAgICAgICB2YXIgZmNEaXYsIGZjRGl2U3R5bGUsIHByZVR4dCwgeFR4dCwgeVR4dDtcbiAgICAgICAgZmNEaXYgPSBfZWx0KFwic2ZfYWxpZ25cIik7XG4gICAgICAgIGZjRGl2U3R5bGUgPSBmY0Rpdi5zdHlsZTtcbiAgICAgICAgeFR4dCA9IHZvaWQgMDtcbiAgICAgICAgeVR4dCA9IHZvaWQgMDtcbiAgICAgICAgcHJlVHh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtcIjtcbiAgICAgICAgaWYgKHhuKSB7XG4gICAgICAgICAgeFR4dCA9IFwicmlnaHQ6MHB4O1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhUeHQgPSBcImxlZnQ6MHB4O1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5bikge1xuICAgICAgICAgIHlUeHQgPSBcImJvdHRvbTowcHg7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeVR4dCA9IFwidG9wOjBweDtcIjtcbiAgICAgICAgfVxuICAgICAgICBmY0RpdlN0eWxlLmNzc1RleHQgPSBwcmVUeHQgKyB4VHh0ICsgeVR4dDtcbiAgICAgICAgZmNEaXYgPSBmY0RpdlN0eWxlID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBJbnRlcm5hbCBmdW5jdGlvbiBmb3IgY29sbGFwc2luZyB0aGUgU2FmZUZyYW1lLCB3aGljaCBjaGVja3MgdGhhdCB0aGVyZSBpc1xuICAgICAgbm90IHNvbWUgb3RoZXIgcGVuZGluZyBzdGF0ZSB3aGljaCBtYXkgZ2V0IGluIHRoZSB3YXlcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5fY29sbGFwc2VcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuICAgICAgX2NvbGxhcHNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghZm9yY2VfY29sbGFwc2UgJiYgKCFpc19yZWdpc3RlcmVkIHx8ICFpc19leHBhbmRlZCB8fCBwZW5kaW5nX21zZykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3NldF9hbGlnbm1lbnQoMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIF9yZWF0dGFjaF9tZXNzYWdpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGllX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICBpZV9vbGRfZGV0YWNoKE9OTVNHLCBfaGFuZGxlX21zZyk7XG4gICAgICAgICAgcmV0dXJuIGllX29sZF9hdHRhY2goT05NU0csIF9oYW5kbGVfbXNnKTtcbiAgICAgICAgfSBlbHNlIGlmICh3M2Nfb2xkX2F0dGFjaCkge1xuICAgICAgICAgIHczY19vbGRfZGV0YWNoKE1TRywgX2hhbmRsZV9tc2cpO1xuICAgICAgICAgIHJldHVybiB3M2Nfb2xkX2F0dGFjaChNU0csIF9oYW5kbGVfbXNnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEludGlhbGl6ZSB0aGUgU2FmZUZyYW1lIGV4dGVybmFsIHZlbmRvci9jbGllbnQgQVBJLCBzbyB0aGF0IG90aGVyIGZlYXR1cmVzIG1heSBiZSB1c2VkXG4gICAgICBUaGlzIG1ldGhvZCBNVVNUIGJlIGNhbGxlZCBwcmlvciB0byB1c2luZyBhbnkgb3RoZXIgcmljaC1tZWRpYSBmdW5jdGlvbmFsaXR5IChsaWtlIGV4cGFuc2lvbikuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQucmVnaXN0ZXJcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGluaXRXaWR0aCBUaGUgaW5pdGlhbCB3aWR0aCAoaW4gcGl4ZWxzKSBleHBlY3RlZCBvZiB0aGUgY29udGVudCB3aXRoaW4gdGhlIFNhZmVGcmFtZSBjb250YWluZXJcbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBpbml0SGVpZ2h0IFRoZSBpbml0aWFsIGhlaWdodCAoaW4gcGl4ZWxzKSBleHBlY3RlZCBvZiB0aGUgY29udGVudCB3aXRoaW4gdGhlIFNhZmVGcmFtZSBjb250YWluZXJcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtub3RpZnldIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjb250ZW50IGNhbiBzcGVjaWZ5IHRvIGJlIG5vdGlmaWVkIG9mIHN0YXR1cyB1cGRhdGVzXG4gICAgICAgKi9cbiAgICAgIHJlZ2lzdGVyID0gZnVuY3Rpb24oaW5pdFdpZHRoLCBpbml0SGVpZ2h0LCBub3RpZnkpIHtcbiAgICAgICAgaWYgKGlzX3JlZ2lzdGVyZWQgfHwgIWd1aWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5pdFdpZHRoID0gX2NudW0oaW5pdFdpZHRoLCAwLCAwKTtcbiAgICAgICAgaW5pdEhlaWdodCA9IF9jbnVtKGluaXRIZWlnaHQsIDAsIDApO1xuICAgICAgICBpbml0X3dpZHRoID0gaW5pdFdpZHRoO1xuICAgICAgICBpbml0X2hlaWdodCA9IGluaXRIZWlnaHQ7XG4gICAgICAgIGlzX3JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICBpZiAobGFuZy5jYWxsYWJsZShub3RpZnkpKSB7XG4gICAgICAgICAgc2FuZGJveF9jYiA9IG5vdGlmeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW5kYm94X2NiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE1ha2UgYSByZXF1ZXN0IHRvIGV4cGFuZCB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciB0byBhIGNlcnRhaW4gc2l6ZS4gTm90ZSB0aGF0IHlvdSBtYXkgb25seSBjYWxsICRzZi5leHQuZXhwYW5kXG4gICAgICB0byBleHBhbmQgdG8gdGhlIGxhcmdlc3Qgc2l6ZSBuZWVkZWQsIGZvbGxvd2VkIGJ5IGNhbGxpbmcgY29sbGFwc2UgKGFuZCB0aGVuIHJlcGVhdCB0aGUgc2FtZSBwcm9jZXNzIGlmIG5lZWRlZCkuXG4gICAgICBUd2VlbmluZyBvciBhbmltYXRpb24gZG9uZSwgc2hvdWxkIGJlIHJlc2VydmVkIGZvciB5b3VyIG93biBjb250ZW50LCBhbmQgeW91IGNhbm5vdCBtYWtlIG11bHRpcGxlIGNhbGxzIHRvIGV4cGFuZFxuICAgICAgd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgY29sbGFwc2UuXG4gICAgICBcbiAgICAgIE5vdGUgdGhhdCB3aGVuIHNldHRpbmcgdCwgbCwgYiwgYW5kIHIgb2Zmc2V0IHZhbHVlcywgZXhwYW5zaW9uIHdpbGwgbm90IGNhdXNlIHRoZSBjb250ZW50IGluc2lkZSB0aGUgU2FmZUZyYW1lXG4gICAgICB0byBob2xkIGl0J3MgY3VycmVudCBhbGlnbm1lbnQsIHdoZXJlYXMgdXNpbmcgZHgvZHkgb3Igb25seSBzZXR0aW5nIHBhcnRpYWwgb2ZmZnNldHMgKGUuZyB7dDoxMDAsbDoxMDB9ID09ICBkeDotMTAwLGR5Oi0xMDApIHdpbGwgY2F1c2UgZXhwYW5zaW9uIHRvXG4gICAgICBob2xkIGl0J3MgY3VycmVudCBhbGlnbm1lbnQuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuZXhwYW5kXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZGVsdGFYb3JEZXNjIElmIGEgbnVtYmVyIGlzIHNwZWNpZmVkLCBTYWZlRnJhbWUgd2lsbCBncm93IGluIHNpemUgYnkgdGhpcyBhbW91bnQgaW4gcGl4ZWxzIGFsb25nIHRoZSBob3Jpem9udGFsIGF4aXMuIFNwZWNpZml5IGEgbmVnYXRpdmUgdmFsdWUgdG8gZ3JvdyB0byB0aGUgbGVmdCwgYW5kIGEgcG9zdGl2ZSB2YWx1ZSB0byBncm93IHRvIHRoZSByaWdodC4gPGJyIC8+XG4gICAgICBJZiBhbiBvYmplY3QgaXMgc3BlY2lmaWVkLCBpdCBzaG91bGQgY29udGFpbiBcInRcIixcImxcIixcInJcIixcImJcIiBwcm9wZXJ0aWVzICh0b3AsbGVmdCxib3R0b20scmlnaHQpIGZvciB0aGUgYW1vdW50IGluIHBpeGVscyB0byBncm93IHRoZSBjb250YWluZXIgaW4gZWFjaCBkaW1lbnNpb25cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhvckRlc2MudCBTcGVjaWZpZXMgdG8gc2hpZnQgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBieSB0aGUgbnVtYmVyIG9mIHBpeGVscyBzcGVjaWZpZWQsIHJlbGF0aXZlIHRvIG9yaWdpbmFsIGxvY2F0aW9uIChuZWdhdGl2ZSB2YWx1ZXMgbm90IGFsbG93ZWQpLlxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWG9yRGVzYy5sIFNwZWNpZmllcyB0byBzaGlmdCB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBieSB0aGUgbnVtYmVyIG9mIHBpeGVscyBzcGVjaWZpZWQsIHJlbGF0aXZlIHRvIG9yaWdpbmFsIGxvY2F0aW9uIChuZWdhdGl2ZSB2YWx1ZXMgbm90IGFsbG93ZWQpLlxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWG9yRGVzYy5iIFNwZWNpZmllcyB0byBzaGlmdCB0aGUgYm90dG9tIHBvc2l0aW9uIG9mIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGJ5IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHNwZWNpZmllZCwgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIChuZWdhdGl2ZSB2YWx1ZXMgbm90IGFsbG93ZWQpLlxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWG9yRGVzYy5yIFNwZWNpZmllcyB0byBzaGlmdCB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBieSB0aGUgbnVtYmVyIG9mIHBpeGVscyBzcGVjaWZpZWQsIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiAobmVnYXRpdmUgdmFsdWVzIG5vdCBhbGxvd2VkKS5cbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn1kZWx0YVhvckRlc2MucHVzaCAgV2hlbiBleHBhbmRpbmcsIHB1c2ggb3RoZXIgcGFnZSBjb250ZW50IHJhdGhlciB0aGFuIGRvaW5nIGFuIG92ZXJsYXkuICBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIHZhbHVlIHRvIHRydWUgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIHB1Ymxpc2hlciAvIGhvc3QgZXhwbGljaXRseSBhbGxvd3MgcHVzaCBleHBhbnNpb25cbiAgICAgIENoZWNrICRzZi5leHQuc3VwcG9ydHMoXCJleHAtcHVzaFwiKSwgYWhlYWQgb2YgdGltZSB0byB2ZXJpZnlcbiAgICAgIFxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWSBJZiBhIG51bWJlciBpcyBzcGVjaWZlZCwgU2FmZUZyYW1lIHdpbGwgZ3JvdyBpbiBzaXplIGJ5IHRoaXMgYW1vdW50IGluIHBpeGVscyBhbG9uZyB0aGUgdmVydGljYWwgYXhpcy4gU3BlY2lmaXkgYSBuZWdhdGl2ZSB2YWx1ZSB0byBncm93IHRvIHRoZSB0b3AsIGFuZCBhIHBvc3RpdmUgdmFsdWUgdG8gZ3JvdyB0byB0aGUgYm90dG9tLiA8YnIgLz5cbiAgICAgIE5vdGUgdGhhdCB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgaWYgZGVsdGFYb3JEZXNjIGlzIHBhc3NlZCBpbiBhcyBhbiBvYmplY3QuXG4gICAgICBcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gcHVzaCBXaGVuIGV4cGFuZGluZywgcHVzaCBvdGhlciBwYWdlIGNvbnRlbnQgcmF0aGVyIHRoYW4gZG9pbmcgYW4gb3ZlcmxheS4gIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gdHJ1ZSB3aWxsIG9ubHkgd29yayBpZiB0aGUgcHVibGlzaGVyIC8gaG9zdCBleHBsaWNpdGx5IGFsbG93cyBwdXNoIGV4cGFuc2lvblxuICAgICAgQ2hlY2sgJHNmLmV4dC5zdXBwb3J0cyhcImV4cC1wdXNoXCIpLCBhaGVhZCBvZiB0aW1lIHRvIHZlcmlmeVxuICAgICAgXG4gICAgICBcbiAgICAgIEByZXR1cm4ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgdGhlIHJlcXVlc3QgdG8gZXhwYW5kIHRoZSBjb250YWluZXIgd2FzIHNlbnQuIFRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IGV4cGFuc2lvbiBpcyBjb21wbGV0ZSBhcyBleHBhbnNpb24gaXMgYW4gYXN5bmNocm9ub3VzIHByb2Nlc3MuIFBhc3MgaW4gYSBjYWxsYmFjayBmdW5jdGlvbiB0byAkc2YuZXh0LnJlZ2lzdGVyIHRvIGdldCBzdGF0dXMgdXBkYXRlcy5cbiAgICAgICAqL1xuICAgICAgZXhwYW5kID0gZnVuY3Rpb24oZGVsdGFYb3JEZXNjLCBkZWx0YVksIHApIHtcbiAgICAgICAgdmFyIGFsaWduX2J1ZmZlciwgYWxpZ25fZWwsIGFsaWduX2VsX3N0LCBiLCBjbWRfbm0sIGNtZF9zdHIsIGRvQWxpZ24sIGR4LCBkeSwgbCwgciwgdCwgeG4sIHluO1xuICAgICAgICB4biA9IGZhbHNlO1xuICAgICAgICB5biA9IGZhbHNlO1xuICAgICAgICBkb0FsaWduID0gZmFsc2U7XG4gICAgICAgIGNtZF9ubSA9IChwID8gXCJleHAtcHVzaFwiIDogRVhQQU5EX0NPTU1BTkQpO1xuICAgICAgICBjbWRfc3RyID0gW1wiY21kPVwiLCBjbWRfbm0sIFwiJnBvcz1cIiwgcG9zX2lkXTtcbiAgICAgICAgZHggPSAwO1xuICAgICAgICBkeSA9IDA7XG4gICAgICAgIHIgPSB2b2lkIDA7XG4gICAgICAgIGIgPSB2b2lkIDA7XG4gICAgICAgIHQgPSB2b2lkIDA7XG4gICAgICAgIGwgPSB2b2lkIDA7XG4gICAgICAgIGFsaWduX2VsID0gdm9pZCAwO1xuICAgICAgICBhbGlnbl9lbF9zdCA9IHZvaWQgMDtcbiAgICAgICAgYWxpZ25fYnVmZmVyID0gdm9pZCAwO1xuICAgICAgICBpZiAoIWlzX3JlZ2lzdGVyZWQgfHwgcGVuZGluZ19tc2cpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAgJiYgIXN1cHBvcnRzKFwiZXhwLXB1c2hcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhWG9yRGVzYyAmJiB0eXBlb2YgZGVsdGFYb3JEZXNjID09PSBPQkopIHtcbiAgICAgICAgICByID0gX2NudW0oZGVsdGFYb3JEZXNjLnIsIDAsIDApO1xuICAgICAgICAgIGIgPSBfY251bShkZWx0YVhvckRlc2MuYiwgMCwgMCk7XG4gICAgICAgICAgdCA9IF9jbnVtKGRlbHRhWG9yRGVzYy50LCAwLCAwKTtcbiAgICAgICAgICBsID0gX2NudW0oZGVsdGFYb3JEZXNjLmwsIDAsIDApO1xuICAgICAgICAgIGlmIChkZWx0YVhvckRlc2MucHVzaCkge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0cyhcImV4cC1wdXNoXCIpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtZF9ubSA9IFwiZXhwLXB1c2hcIjtcbiAgICAgICAgICAgIGNtZF9zdHJbMV0gPSBjbWRfbm07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghciAmJiBsKSB7XG4gICAgICAgICAgICB4biA9IHRydWU7XG4gICAgICAgICAgICBkeCA9IC0xICogbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIgJiYgIWwpIHtcbiAgICAgICAgICAgIGR4ID0gcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFiICYmIHQpIHtcbiAgICAgICAgICAgIHluID0gdHJ1ZTtcbiAgICAgICAgICAgIGR5ID0gLTEgKiB0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYiAmJiAhdCkge1xuICAgICAgICAgICAgZHkgPSBiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHQgJiYgYikgfHwgKGwgJiYgcikpIHtcbiAgICAgICAgICAgIGRvQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9BbGlnbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb0FsaWduKSB7XG4gICAgICAgICAgICBfc2V0X2FsaWdubWVudCh4biwgeW4pO1xuICAgICAgICAgICAgY21kX3N0ci5wdXNoKFwiJmR4PVwiLCBkeCwgXCImZHk9XCIsIGR5KTtcbiAgICAgICAgICAgIF9zZW5kX21zZyhfY3N0cihjbWRfc3RyKSwgY21kX25tKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxpZ25fZWwgPSBfZWx0KFwic2ZfYWxpZ25cIik7XG4gICAgICAgICAgICBhbGlnbl9lbF9zdCA9IGFsaWduX2VsICYmIGFsaWduX2VsLnN0eWxlO1xuICAgICAgICAgICAgYWxpZ25fYnVmZmVyID0gW1wicG9zaXRpb246YWJzb2x1dGU7XCJdO1xuICAgICAgICAgICAgaWYgKHQgJiYgYikge1xuICAgICAgICAgICAgICBhbGlnbl9idWZmZXIucHVzaChcInRvcDpcIiwgdCwgXCJweDtcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQpIHtcbiAgICAgICAgICAgICAgYWxpZ25fYnVmZmVyLnB1c2goXCJib3R0b206MHB4O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25fYnVmZmVyLnB1c2goXCJ0b3A6MHB4O1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGwgJiYgcikge1xuICAgICAgICAgICAgICBhbGlnbl9idWZmZXIucHVzaChcImxlZnQ6XCIsIGwsIFwicHg7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsKSB7XG4gICAgICAgICAgICAgIGFsaWduX2J1ZmZlci5wdXNoKFwicmlnaHQ6MHB4O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25fYnVmZmVyLnB1c2goXCJsZWZ0OjBweDtcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGlnbl9lbF9zdCkge1xuICAgICAgICAgICAgICBhbGlnbl9lbF9zdC5jc3NUZXh0ID0gX2NzdHIoYWxpZ25fYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtZF9zdHIucHVzaChcIiZleHBfb2JqPVwiLCBlc2NhcGUoUGFyYW1IYXNoKGRlbHRhWG9yRGVzYykpKTtcbiAgICAgICAgICAgIF9zZW5kX21zZyhfY3N0cihjbWRfc3RyKSwgY21kX25tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFYb3JEZXNjID0gX2NudW0oZGVsdGFYb3JEZXNjLCAwKTtcbiAgICAgICAgICBkZWx0YVkgPSBfY251bShkZWx0YVksIDApO1xuICAgICAgICAgIGlmIChkZWx0YVhvckRlc2MgPD0gMCAmJiBkZWx0YVkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4biA9IGRlbHRhWG9yRGVzYyA8PSAwO1xuICAgICAgICAgIHluID0gZGVsdGFZIDw9IDA7XG4gICAgICAgICAgX3NldF9hbGlnbm1lbnQoeG4sIHluKTtcbiAgICAgICAgICBjbWRfc3RyLnB1c2goXCImZHg9XCIsIGRlbHRhWG9yRGVzYywgXCImZHk9XCIsIGRlbHRhWSk7XG4gICAgICAgICAgX3NlbmRfbXNnKF9jc3RyKGNtZF9zdHIpLCBjbWRfbm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENvbGxhcHNlIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGFmdGVyIGhhdmluZyBjYWxsZWQgdG8gZXhwYW5kLiBJZiBubyBwcmV2aW91cyBjYWxsIHRvIGV4cGFuZCBoYXMgYmVlbiBtYWRlLCB0aGlzIGNhbGwgd2lsbCBkbyBub3RoaW5nLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LmNvbGxhcHNlXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgY29sbGFwc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9jb2xsYXBzZSgpKSB7XG4gICAgICAgICAgX3NlbmRfbXNnKF9jc3RyKFtcImNtZD1cIiwgQ09MTEFQU0VfQ09NTUFORCwgXCImcG9zPVwiLCBwb3NfaWRdKSwgQ09MTEFQU0VfQ09NTUFORCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlbmRfY21kKE5PVElGWV9DTElDS0VEKTtcbiAgICAgIH07XG4gICAgICB2aWV3ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kX2NtZChOT1RJRllfVklFV0VEKTtcbiAgICAgIH07XG4gICAgICBsb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kX2NtZChOT1RJRllfTE9BREVEKTtcbiAgICAgIH07XG4gICAgICB1bnZpZXdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlbmRfY21kKE5PVElGWV9VTlZJRVdFRCk7XG4gICAgICB9O1xuICAgICAgcmVsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VuZF9jbWQoTk9USUZZX1JFTE9BRCk7XG4gICAgICB9O1xuICAgICAgX3JlcXVlc3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9SRVFVRVNURUQpO1xuICAgICAgICByZXR1cm4gX3NlbmRfY21kKE5PVElGWV9SRVFVRVNURUQpO1xuICAgICAgfTtcbiAgICAgIF9zZW5kX2NtZCA9IGZ1bmN0aW9uKGNtZCkge1xuICAgICAgICByZXR1cm4gX3NlbmRfbXNnKF9jc3RyKFtcImNtZD1cIiwgY21kLCBcIiZwb3M9XCIsIHBvc19pZF0pLCBjbWQpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybiBnZW9tZXRyaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgYW5kIGl0J3Mgc3RhdHVzIHdpdGhpbiBhIHBhZ2VcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5nZW9tXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEByZXR1cm4ge09iamVjdH0gZ2VvbV9pbmZvXG4gICAgICAgKi9cbiAgICAgIGdlb20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdlb21faW5mbztcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm4gbWV0YS1kYXRhIGluZm9ybWF0aW9uIHRoYXQgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIHB1Ymxpc2hlciAvIGhvc3QuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQubWV0YVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgdGhlIGtleSBuYW1lIG9mIHRoZSBtZXRhLWRhdGEgdmFsdWUgdG8gYmUgcmV0cmlldmVkXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW293bmVyX2tleV0gdGhlIHN1cGVyIGtleSBuYW1lIG9mIHRoZSBkYXRhIHRvIGJlIHJldHJpZXZlZFxuICAgICAgQHJldHVybiB7U3RyaW5nfSBUaGUgdmFsdWUgb2Ygc29tZSBtZXRhLWRhdGEgdGhhdCBtYXkgaGF2ZSBiZWVuIHNwZWNpZmllZCBieSB0aGUgcHVibGlzaGVyIC8gaG9zdCBvciBcIlwiLlxuICAgICAgICovXG4gICAgICBtZXRhID0gZnVuY3Rpb24ocHJvcE5hbWUsIG93bmVyX2tleSkge1xuICAgICAgICB2YXIgcmV0LCBzaGFyZWQ7XG4gICAgICAgIHJldCA9IFwiXCI7XG4gICAgICAgIHNoYXJlZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHBvc19tZXRhKSB7XG4gICAgICAgICAgaWYgKG93bmVyX2tleSkge1xuICAgICAgICAgICAgaWYgKG93bmVyX2tleSBpbiBwb3NfbWV0YSkge1xuICAgICAgICAgICAgICByZXQgPSBfY3N0cihwb3NfbWV0YVtvd25lcl9rZXldW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocG9zX21ldGEubm9uX3NoYXJlZCAmJiBvd25lcl9rZXkgaW4gcG9zX21ldGEubm9uX3NoYXJlZCkge1xuICAgICAgICAgICAgICAgIHJldCA9IF9jc3RyKHBvc19tZXRhLm5vbl9zaGFyZWRbb3duZXJfa2V5XVtwcm9wTmFtZV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlZCA9IHBvc19tZXRhLnNoYXJlZDtcbiAgICAgICAgICAgIGlmIChzaGFyZWQgJiYgdHlwZW9mIHNoYXJlZCA9PT0gT0JKKSB7XG4gICAgICAgICAgICAgIHJldCA9IF9jc3RyKHNoYXJlZFtwcm9wTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZU1ldGEgPSBmdW5jdGlvbihwcm9wTmFtZSwgb3duZXJfa2V5KSB7XG4gICAgICAgIHZhciBzaGFyZWQ7XG4gICAgICAgIHNoYXJlZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHBvc19tZXRhKSB7XG4gICAgICAgICAgaWYgKG93bmVyX2tleSkge1xuICAgICAgICAgICAgaWYgKG93bmVyX2tleSBpbiBwb3NfbWV0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHBvc19tZXRhW293bmVyX2tleV1bcHJvcE5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHBvc19tZXRhLm5vbl9zaGFyZWQgJiYgb3duZXJfa2V5IGluIHBvc19tZXRhLm5vbl9zaGFyZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHBvc19tZXRhLm5vbl9zaGFyZWRbb3duZXJfa2V5XVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcmVkID0gcG9zX21ldGEuc2hhcmVkO1xuICAgICAgICAgICAgaWYgKHNoYXJlZCAmJiB0eXBlb2Ygc2hhcmVkID09PSBPQkopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBzaGFyZWRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybiB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIFNhZmVGcmFtZSBjb250YWluZXIsIGluIGNhc2VzIHdoZXJlXG4gICAgICBhIGNvbW1hbmQgbWF5IGJlIHBlbmRpbmcuIElmIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCAoXCJcIikgY29udGFpbmVyIGlzIGlkbGUuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuc3RhdHVzXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEByZXR1cm4ge1N0cmluZ30gb2YgYW55IHBlbmRpbmcgc3RhdHVzLCBvdGhlcndpc2UgZW1wdHkgc3RyaW5nLlxuICAgICAgICovXG4gICAgICBzdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnLmNtZCA9PT0gRVhQQU5EX0NPTU1BTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFUVVNfRVhQQU5ESU5HO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ19tc2cuY21kID09PSBDT0xMQVBTRV9DT01NQU5EKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTVEFUVVM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc19leHBhbmRlZCkge1xuICAgICAgICAgIHJldHVybiBTVEFUVVNfRVhQQU5ERUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRVU19DT0xMQVBTRUQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXF1ZXN0cyB0aGUgaG9zdCByZWFkIG9yIHdyaXRlIGEgY29va2llIHRvIHRoZSBob3N0IGRvbWFpbi5cbiAgICAgIFRoZSBob3N0IGRvbWFpbiBtdXN0IGdyYW50IHBlcm1pc3Npb24gZm9yIHRoZSBjb29raWUgdG8gYmUgd3JpdHRlbi5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5jb29raWVcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtjb29raWVOYW1lXSBUaGUgbmFtZSBvZiB0aGUgY29va2llIHRvIHNldCBvciByZWFkXG4gICAgICBAcGFyYW0ge09iamVjdH0gW2Nvb2tpZURhdGFdIEFuIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgdGhlIHZhbHVlIGFuZCBhbiBvcHRpb25hbCBleHBpcmVzXG4gICAgICBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGNvb2tpZSA9IGZ1bmN0aW9uKGNvb2tpZU5hbWUsIGNvb2tpZURhdGEpIHtcbiAgICAgICAgdmFyIGNtZF9ubSwgY21kX3N0ciwgaXNSZWFkO1xuICAgICAgICBpc1JlYWQgPSAhKGNvb2tpZURhdGEgIT0gbnVsbCk7XG4gICAgICAgIGNtZF9ubSA9IChpc1JlYWQgPyBcInJlYWQtY29va2llXCIgOiBcIndyaXRlLWNvb2tpZVwiKTtcbiAgICAgICAgY21kX3N0ciA9IFtcImNtZD1cIiwgY21kX25tLCBcIiZwb3M9XCIsIHBvc19pZCwgXCImY29va2llPVwiLCBjb29raWVOYW1lXTtcbiAgICAgICAgaWYgKCFpc1JlYWQpIHtcbiAgICAgICAgICBjbWRfc3RyLnB1c2goXCImdmFsdWU9XCIpO1xuICAgICAgICAgIGNtZF9zdHIucHVzaChjb29raWVEYXRhLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBfc2VuZF9tc2coX2NzdHIoY21kX3N0ciksIGNtZF9ubSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGhvc3RcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5tZXNzYWdlXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgbWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgX3NlbmRfbXNnKF9jc3RyKFtcImNtZD1cIiwgXCJtc2dcIiwgXCImcG9zPVwiLCBwb3NfaWQsIFwiJm1zZz1cIiwgY29udGVudF0pLCBcIm1zZ1wiKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm4gdGhlIHBlcmNlbnRhZ2UgdGhhdCB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBpcyB2aWV3YWJsZSB3aXRoaW4gdGhlIGJyb3dzZXIgd2luZG93XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuaW5WaWV3UGVyY2VudGFnZVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGluVmlld1BlcmNlbnRhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl2LCB0djtcbiAgICAgICAgaXYgPSBfY251bShnZW9tX2luZm8gJiYgZ2VvbV9pbmZvLnNlbGYgJiYgZ2VvbV9pbmZvLnNlbGYuaXYsIC0xLCAwKTtcbiAgICAgICAgdHYgPSB2b2lkIDA7XG4gICAgICAgIGlmIChpdiA+PSAwKSB7XG4gICAgICAgICAgdHYgPSBNYXRoLmZsb29yKGl2ICogMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHY7XG4gICAgICB9O1xuICAgICAgd2luSGFzRm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbl9oYXNfZm9jdXM7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJuIHdoZXRoZXIgb3Igbm90IGEgcGFydGljdWxhciBmZWF0dXJlIGlzIHN1cHBvcnRlZCwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAgICAgIGtleS92YWx1ZSBwYWlycyBkZW5vdGluZyBhbGwgZmVhdHVyZXMgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIHN1cHBvcnRlZFxuICAgICAgXG4gICAgICBCeSBkZWZhdWx0IFNhZmVGcmFtZXMgdmVyc2lvbiAxIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgZmVhdHVyZTpcbiAgICAgIFxuICAgICAgXCJleHAtb3ZyXCI6IEV4cGFuc2lvbiBvZiB0aGUgY29udGFpbmVyIGJ5IG92ZXJsYXlpbmcgb24gdG9wIG9mIG90aGVyIGNvbnRlbnRcbiAgICAgIFxuICAgICAgTGF0ZXIgaW4gb3RoZXIgdmVyc2lvbnMgdGhlcmUgYXJlIGV4cGV4dGVkIHRvIGJlIG1vcmUgZmVhdHVyZSB3aXRoIHRoZWlyIG93blxuICAgICAgc3RyaW5nIG5hbWUsIHRoYXQgY2FuIGJlIGNoZWNrZWQgYnkgdGhlIGNvbnRlbnQgaW4gdGhlIFNhZmVGcmFtZSwgc28gdGhhdFxuICAgICAgaXQga25vd3Mgd2hhdCB0aGluZ3MgY2FuIGJlIGRvbmUuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuc3VwcG9ydHNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtrZXldIElmIHNwZWNpZmVkLCBjaGVja3MgdG8gc2VlIGlmIHRoYXQgc3BlY2lmaWMgZmVhdHVyZSBoYXMgYmVlbiBlbmFibGVkXG4gICAgICBAcmV0dXJuIHtCb29sZWFufE9iamVjdH1cbiAgICAgICAqL1xuICAgICAgc3VwcG9ydHMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGNvbmYsIHN1cDtcbiAgICAgICAgY29uZiA9IHJlbmRlcl9wYXJhbXMuY29uZjtcbiAgICAgICAgc3VwID0gKGNvbmYgJiYgY29uZi5zdXBwb3J0cykgfHwgZmFsc2U7XG4gICAgICAgIGlmIChzdXApIHtcbiAgICAgICAgICBrZXkgPSBfY3N0cihrZXkpO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHN1cCA9IHN1cFtrZXldIHx8IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN1cCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgc3VwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cCA9IGxhbmcubWl4KHt9LCBzdXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwO1xuICAgICAgfTtcbiAgICAgIHJlbmRlciA9IGZ1bmN0aW9uKHNob3dBZCwgY2IpIHtcbiAgICAgICAgdmFyIGVycl9pbmZvO1xuICAgICAgICBlcnJfaW5mbyA9IHt9O1xuICAgICAgICBpZiAoX2NvbnN0cnVjdGlvbihlcnJfaW5mbykpIHtcbiAgICAgICAgICBpZiAoc2hvd0FkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlbmRlcihjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2hvd0FkID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKCFpc0FkU2hvd24pIHtcbiAgICAgICAgICByZXR1cm4gX3JlbmRlcihjYik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhZFNob3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0FkU2hvd247XG4gICAgICB9O1xuICAgICAgbGFuZy5taXgoc2YuZXh0LCB7XG4gICAgICAgIHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgICAgICAgZXhwYW5kOiBleHBhbmQsXG4gICAgICAgIGNvbGxhcHNlOiBjb2xsYXBzZSxcbiAgICAgICAgZ2VvbTogZ2VvbSxcbiAgICAgICAgbWV0YTogbWV0YSxcbiAgICAgICAgZGVsZXRlTWV0YTogZGVsZXRlTWV0YSxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIHN1cHBvcnRzOiBzdXBwb3J0cyxcbiAgICAgICAgY29va2llOiBjb29raWUsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGluVmlld1BlcmNlbnRhZ2U6IGluVmlld1BlcmNlbnRhZ2UsXG4gICAgICAgIHdpbkhhc0ZvY3VzOiB3aW5IYXNGb2N1cyxcbiAgICAgICAgY2xpY2s6IGNsaWNrLFxuICAgICAgICB2aWV3ZWQ6IHZpZXdlZCxcbiAgICAgICAgdW52aWV3ZWQ6IHVudmlld2VkLFxuICAgICAgICBzaG93QWQ6IHNob3dBZCxcbiAgICAgICAgYWRTaG93bjogYWRTaG93bixcbiAgICAgICAgcmVsb2FkOiByZWxvYWRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc0V4dGVybmFsKSB7XG4gICAgICAgIHdpbmRvdy4kc2YgPSBzZjtcbiAgICAgICAgcmVuZGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuJHNmID0gc2Y7XG4gICAgICAgIHNmLmV4dC5yZW5kZXIgPSByZW5kZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2Y7XG4gICAgfSkod2luZG93LCBzZik7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBkb20sIGVudiwgbGFuZywgbG9nZ2VyO1xuXG4gIGxhbmcgPSByZXF1aXJlKCcuL2xhbmcnKTtcblxuICBlbnYgPSByZXF1aXJlKCcuL2VudicpO1xuXG4gIGRvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbiAgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbihsYW5nLCBlbnYsIGRvbSwgbG9nZ2VyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcjogXCIxLTEtMFwiLFxuICAgICAgc3BlY1ZlcnNpb246IFwiMS4xXCIsXG4gICAgICBsaWI6IHtcbiAgICAgICAgbGFuZzogbGFuZyxcbiAgICAgICAgZG9tOiBkb20sXG4gICAgICAgIGxvZ2dlcjogbG9nZ2VyXG4gICAgICB9LFxuICAgICAgZW52OiBlbnYsXG4gICAgICBob3N0OiB7fSxcbiAgICAgIGV4dDoge30sXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGVycnM6IFtdLFxuICAgICAgICBsaXN0OiBbXVxuICAgICAgfVxuICAgIH07XG4gIH0pKGxhbmcsIGVudiwgZG9tLCBsb2dnZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZW52LCBsYW5nO1xuXG4gIGxhbmcgPSByZXF1aXJlKCcuL2xhbmcnKTtcblxuICBlbnYgPSByZXF1aXJlKCcuL2VudicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdywgbGFuZywgZW52KSB7XG4gICAgdmFyIEJMQU5LX1VSTCwgRVZUX0NOQ0xfTUVUSE9EUywgR0MsIElFX0dDX0lOVEVSVkFMLCBJRlJBTUUsIGFwcGVuZCwgYXR0YWNoLCBhdHRyLCBjbG9uZV9pZnJhbWUsIGNzcywgZGV0YWNoLCBkb2MsIGRvbSwgZG9tX2lzX3JlYWR5LCBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlLCBkb21fbGFzdF9rbm93bl90YWdfY291bnQsIGRvbV9yZWFkeV9jaGtfbWF4X3RyaWVzLCBkb21fcmVhZHlfY2hrX3RpbWVyX2lkLCBkb21fcmVhZHlfY2hrX3RyaWVzLCBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCwgZWx0LCBldnRDbmNsLCBldnRUZ3QsIGV2dF90Z3RfcHJvcF9hLCBldnRfdGd0X3Byb3BfYiwgZ2MsIGdjX3RpbWVyX2lkLCBpZV9hdHRhY2gsIGllX2RldGFjaCwgaWZyYW1lX2Nic19hdHRhY2hlZCwgaWZyYW1lX21zZ19ob3N0X2xpYiwgaWZyYW1lX25leHRfaWQsIGlmcmFtZV92aWV3LCBpc0lFLCBtYWtlX2VsZW1lbnQsIG1ha2VfaWZyYW1lLCBwYXIsIHB1cmdlLCByZWFkeSwgcmVwbGFjZV9pZnJhbWUsIHRhZ05hbWUsIHRhZ3MsIHRoZURvY3VtZW50LCB1c2VPbGRTdHlsZUF0dHJNZXRob2RzLCB1c2VfYXR0YWNoLCB1c2VfZGV0YWNoLCB1c2VfaWVfb2xkX2F0dGFjaCwgdmlldywgdzNjX2F0dGFjaCwgdzNjX2RldGFjaCwgd2FpdCwgd2luLCBfYmluZF9pZnJhbWVfb25sb2FkLCBfYnlJRCwgX2NhbGxfeG1zZ19ob3N0LCBfY2FsbGFibGUsIF9jbGVhcl9yZWFkeV90aW1lcl9jaGVjaywgX2Nsb25lX2lmcmFtZSwgX2NzdHIsIF9lbnYsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0LCBfbGFuZywgX3JlYWR5X3N0YXRlX2NoZWNrLCBfdW5iaW5kX2lmcmFtZV9vbmxvYWQ7XG4gICAgZG9tID0ge307XG4gICAgX2xhbmcgPSBsYW5nO1xuICAgIF9lbnYgPSBlbnY7XG4gICAgd2luID0gd2luZG93O1xuICAgIElGUkFNRSA9IFwiaWZyYW1lXCI7XG4gICAgR0MgPSBcIkNvbGxlY3RHYXJiYWdlXCI7XG4gICAgaWVfYXR0YWNoID0gXCJhdHRhY2hFdmVudFwiO1xuICAgIHczY19hdHRhY2ggPSBcImFkZEV2ZW50TGlzdGVuZXJcIjtcbiAgICBpZV9kZXRhY2ggPSBcImRldGFjaEV2ZW50XCI7XG4gICAgdzNjX2RldGFjaCA9IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiO1xuICAgIHVzZV9hdHRhY2ggPSBcIlwiO1xuICAgIHVzZV9kZXRhY2ggPSBcIlwiO1xuICAgIHVzZV9pZV9vbGRfYXR0YWNoID0gZmFsc2U7XG4gICAgSUVfR0NfSU5URVJWQUwgPSAzMDAwO1xuICAgIEVWVF9DTkNMX01FVEhPRFMgPSB7XG4gICAgICBcInByZXZlbnREZWZhdWx0XCI6IDAsXG4gICAgICBcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiOiAwLFxuICAgICAgXCJzdG9wUHJvcGFnYXRpb25cIjogMCxcbiAgICAgIFwicHJldmVudEJ1YmJsZVwiOiAwXG4gICAgfTtcbiAgICBpc0lFID0gZW52LmlzSUU7XG4gICAgdXNlT2xkU3R5bGVBdHRyTWV0aG9kcyA9IGZhbHNlO1xuICAgIGdjX3RpbWVyX2lkID0gMDtcbiAgICBkb21faXNfcmVhZHkgPSBudWxsO1xuICAgIGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCA9IDA7XG4gICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgZG9tX3JlYWR5X2Noa19tYXhfdHJpZXMgPSAzMDA7XG4gICAgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwgPSA1MDtcbiAgICBkb21fcmVhZHlfY2hrX3RyaWVzID0gMDtcbiAgICBkb21fcmVhZHlfY2hrX3RpbWVyX2lkID0gMDtcbiAgICBpZnJhbWVfbmV4dF9pZCA9IDA7XG4gICAgaWZyYW1lX2Nic19hdHRhY2hlZCA9IHt9O1xuICAgIGV2dF90Z3RfcHJvcF9hID0gXCJcIjtcbiAgICBldnRfdGd0X3Byb3BfYiA9IFwiXCI7XG4gICAgaWZyYW1lX21zZ19ob3N0X2xpYiA9IG51bGw7XG4gICAgdGhlRG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XG4gICAgQkxBTktfVVJMID0gXCJhYm91dDpibGFua1wiO1xuICAgIF9jc3RyID0gbGFuZy5jc3RyO1xuICAgIF9jYWxsYWJsZSA9IGxhbmcuY2FsbGFibGU7XG5cbiAgICAvKlxuICAgIENsZWFyIG91dCB0aGUgdGltZXIgZnVuY3Rpb24gdXNlZCBhcyBhIGZhbGxiYWNrIHdoZW4gcmVhZHkgc3RhdGUgb2YgdGhlIERPTVxuICAgIGNhbm5vdCBiZSBkaXJlY3RseSBkZXRlY3RlZFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLV9jbGVhcl9yZWFkeV90aW1lcl9jaGVja1xuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9jbGVhcl9yZWFkeV90aW1lcl9jaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvbV9yZWFkeV9jaGtfdGltZXJfaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRvbV9yZWFkeV9jaGtfdGltZXJfaWQpO1xuICAgICAgICBkb21fcmVhZHlfY2hrX3RpbWVyX2lkID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9oYW5kbGVfZG9tX2xvYWRfZXZ0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBkZXRhY2god2luLCBcImxvYWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgICAgZGV0YWNoKHdpbiwgXCJET01Db250ZW50TG9hZGVkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIHRvIHNlZSBpZiB0aGUgRE9NIGlzIHJlYWR5IHRvIGJlIG1hbmlwdWxhdGVkLCB3aXRob3V0IHRoZSBuZWVkIGZvciBldmVudCBob29raW5nLlxuICAgIE9mdGVuIHRpbWVzIHlvdSdsbCBzZWUgZm9sa3MgdXNlIHRoZSBvbmxvYWQgZXZlbnQgb3IgRE9NQ29udGVudExvYWRlZCBldmVudC4gIEhvd2V2ZXJcbiAgICB0aGUgcHJvYmxlbSB3aXRoIHRob3NlLCBpcyB0aGF0IHlvdXIgSmF2YVNjcmlwdCBjb2RlIG1heSBoYXZlIGJlZW4gbG9hZGVkIGFzeW5jaHJvbm91c2x5LFxuICAgIGFmdGVyIGVpdGhlciBvbmUgb2YgdGhvc2UgZXZlbnRzIGhhdmUgZmlyZWQsIGFuZCBpbiB3aGljaCBjYXNlIHlvdSBzdGlsbCBkb24ndCBrbm93IGlmIHRoZSBET00gaXMgcmVhbGx5XG4gICAgcmVhZHkuICBNb3N0IG1vZGVybiBicm93c2VycyAoaW5jbHVkaW5nIElFKSwgaW1wbGVtZW50IGEgZG9jdW1lbnQucmVhZHlTdGF0ZSBwcm9wZXJ0eSB0aGF0IHdlIGNhblxuICAgIGNoZWNrLCBidXQgbm90IGFsbC4gIEluIHRoZSBjYXNlIHdoZXJlIHRoaXMgcHJvcGVydHkgaXMgbm90IGltcGxlbWVudGVkLCB3ZSBkbyBhIHNlcmllcyBvZiBub2RlXG4gICAgY2hlY2tzIGFuZCB0YWcgY291bnRzIHZpYSB0aW1lcnMuICBPZiBjb3Vyc2UgdGhpcyBtZWFucyB0aGF0IG9uIHRoZSB2ZXJ5IDFzdCBjYWxsLCB3ZSB3aWxsIGFsd2F5c1xuICAgIGFwcGVhciB0byBiZSBub3QgcmVhZHkgZXZlbnRob3VnaCB0aGUgRE9NIGl0c2VsZiBtYXkgYmUgaW4gYSByZWFkeSBzdGF0ZSwgYnV0IG91ciB0aW1lb3V0IGludGVydmFsXG4gICAgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhpcyBpcyBPSy5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fcmVhZHlfc3RhdGVfY2hlY2tcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfcmVhZHlfc3RhdGVfY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiLCBlLCBraWRzLCBsc3QsIHRhZ19jbnQ7XG4gICAgICBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2soKTtcbiAgICAgIGlmIChkb21fcmVhZHlfY2hrX3RyaWVzID49IGRvbV9yZWFkeV9jaGtfbWF4X3RyaWVzKSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbV9pc19yZWFkeSA9PT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGIgPSB0aGVEb2N1bWVudCAmJiB0aGVEb2N1bWVudC5ib2R5O1xuICAgICAgICAgIGtpZHMgPSBiICYmIHRhZ3MoXCIqXCIsIGIpO1xuICAgICAgICAgIHRhZ19jbnQgPSBraWRzICYmIGtpZHNbTEVOXTtcbiAgICAgICAgICBsc3QgPSBiICYmIGIubGFzdENoaWxkO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCA9IDA7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCAmJiB0YWdfY250ID09PSBkb21fbGFzdF9rbm93bl90YWdfY291bnQgJiYgbHN0ID09PSBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlKSB7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSB0YWdfY250O1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBsc3Q7XG4gICAgICAgICAgZG9tX3JlYWR5X2Noa190cmllcyArPSAxO1xuICAgICAgICAgIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQgPSBzZXRUaW1lb3V0KF9yZWFkeV9zdGF0ZV9jaGVjaywgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBEZXRhY2ggb25sb2FkIGhhbmRsZXJzIG9uIGlmcmFtZXMgdGhhdCB3ZSBoYXZlIGNyZWF0ZWRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLV91bmJpbmRfaWZyYW1lX29ubG9hZFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBpZnJhbWUgZWxlbWVudCB0byB1bmJpbmQgZnJvbVxuICAgICAqL1xuICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgaWQsIG9sZENCO1xuICAgICAgaWQgPSBhdHRyKGVsLCBcImlkXCIpO1xuICAgICAgb2xkQ0IgPSB2b2lkIDA7XG4gICAgICBvbGRDQiA9IGlkICYmIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdO1xuICAgICAgaWYgKG9sZENCKSB7XG4gICAgICAgIGRldGFjaChlbCwgXCJsb2FkXCIsIG9sZENCKTtcbiAgICAgICAgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF0gPSBudWxsO1xuICAgICAgICBkZWxldGUgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBkZWZhdWx0IG9ubG9hZCBldmVudCBoYW5kbGVyIGZvciBJRnJhbWVzLiBXZSBkb24ndFxuICAgIHdhbnQgdG8gYXR0YWNoIHRvIG9ubG9hZCBldmVudHMgZm9yIElGcmFtZXMgdmlhIGF0dHJpYnV0ZXNcbiAgICBiL2Mgd2UgZG9uJ3Qgd2FudCBvdGhlcnMgdG8gc2VlIHdoYXQgaGFuZGxlcnMgYXJlIHRoZXJlLlxuICAgIEluIHR1cm4gd2UgYWxzbyBtYWtlIHN1cmUgdGhlIFwidGhpc1wiIHJlZmVyZW5jZSBmb3IgdGhlIG91dHNpZGVcbiAgICBoYW5kbGUgZ2V0cyBzZXQgcHJvcGVybHksIGFuZCBpdCBhbGxvd3MgdXMgdG8gbWFrZSBzdXJlXG4gICAgdGhhdCB1bmJpbmRpbmcgb2YgdGhlIGV2ZW50IGhhbmRsZXIgYWxzbyBnZXRzIGhhbmRsZWQgYWx3YXlzXG4gICAgc28gYXMgbm90IHRvIGNyZWF0ZSBtZW1vcnkgbGVhayBpc3N1ZXMuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fYmluZF9pZnJhbWVfb25sb2FkXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIGlmcmFtZSBlbGVtZW50IHRvIGJpbmQgdG9vXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIG9ubG9hZCBoYW5kbGVyIGZyb20gdGhlIG91dHNpZGVcbiAgICAgKi9cbiAgICBfYmluZF9pZnJhbWVfb25sb2FkID0gZnVuY3Rpb24oZWwsIGNiKSB7XG4gICAgICB2YXIgaWQsIG5ld0NCO1xuICAgICAgbmV3Q0IgPSB2b2lkIDA7XG4gICAgICBpZCA9IHZvaWQgMDtcbiAgICAgIGlmIChfY2FsbGFibGUoY2IpKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgbmV3Q0IgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICB2YXIgZSwgdGd0O1xuICAgICAgICAgIHRndCA9IGV2dFRndChldnQpO1xuICAgICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKHRndCk7XG4gICAgICAgICAgaWYgKHRndCAmJiBjYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2IuY2FsbCh0Z3QsIGV2dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRndCA9IGVsID0gY2IgPSBuZXdDQiA9IGlkID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWQgPSBhdHRyKGVsLCBcImlkXCIpO1xuICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQoZWwpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXSA9IG5ld0NCO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaChlbCwgXCJsb2FkXCIsIG5ld0NCKTtcbiAgICAgIH1cbiAgICAgIG5ld0NCID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIGVsZW1lbnQgcmVmZXJlbmNlIHBhc3NlZCBpbiwgYW5kIGlmIGl0cyBhIHN0cmluZyB2YWx1ZSBwYXNzZWRcbiAgICBpbiB1c2UgdGhhdCB0byBsb29rdXAgdGhlIGVsZW1lbnQgYnkgaWQgYXR0cmlidXRlLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLV9ieUlEXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IGVsICB0aGUgZWxlbWVudCBpZCAvIGVsZW1lbnQgcmVmZXJlbmNlXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR8ZWx9XG4gICAgICovXG4gICAgX2J5SUQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgaWYgKGVsICYmIHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZWx0KGVsKSB8fCBlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBBIHByb3h5IHdyYXBwZXIgZm9yIGNhbGxpbmcgaW50byB0aGUgY3Jvc3MtZG9tYWluIG1lc3NhZ2luZyBob3N0IGxpYnJhcnlcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLV9jYWxsX3htc2dfaG9zdFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBtZXRoTmFtZSBUaGUgbWV0aG9kIG5hbWUgaW4gdGhlIG1zZyBob3N0IGxpYnJhcnkgdG8gY2FsbFxuICAgIEBwYXJhbSB7Kn0gYXJnMSBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgMXN0IGFyZ1xuICAgIEBwYXJhbSB7Kn0gYXJnMiBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgMm5kIGFyZ1xuICAgIEBwYXJhbSB7Kn0gYXJnMyBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgM3JkIGFyZ1xuICAgIEByZXR1cm4geyp9IHdoYXRldmVyIGNvbWVzIGJhY2sgZnJvbSB0aGUgbWV0aG9kXG4gICAgICovXG4gICAgX2NhbGxfeG1zZ19ob3N0ID0gZnVuY3Rpb24obWV0aE5hbWUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHZhciBlO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaWZyYW1lX21zZ19ob3N0X2xpYikge1xuICAgICAgICAgIGlmcmFtZV9tc2dfaG9zdF9saWIgPSBkb20ubXNnaG9zdDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGlmcmFtZV9tc2dfaG9zdF9saWIgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHdpbiAhPT0gdG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRoTmFtZSAmJiBpZnJhbWVfbXNnX2hvc3RfbGliICYmIGlmcmFtZV9tc2dfaG9zdF9saWJbbWV0aE5hbWVdICYmIGlmcmFtZV9tc2dfaG9zdF9saWJbbWV0aE5hbWVdKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIGEgZG9jdW1lbnQgZm9yIGEgZ2l2ZW4gSFRNTCBFbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZG9jIGFzICRzZi5saWIuZG9tLmRvY1xuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCBmb3Igd2hpY2ggeW91IHdpc2ggdG8gZmluZCBpdCdzIHBhcmVudCBkb2N1bWVudFxuICAgIEByZXR1cm4ge0RvY3VtZW50fG51bGx9IG51bGwgaWYgbm90aGluZyBmb3VuZFxuICAgICAqL1xuICAgIGRvYyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZSwgbG9jYWxEO1xuICAgICAgbG9jYWxEID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgbG9jYWxEID0gZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGVsLmRvY3VtZW50IHx8IGVsLm93bmVyRG9jdW1lbnQgfHwgbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBsb2NhbEQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsRDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSB0aGUgaG9zdCB3aW5kb3cgb2JqZWN0IGZvciBhIGdpdmVuIEhUTUwgRWxlbWVudC9kb2N1bWVudC4gTm90ZSB0aGF0IHRoaXMgaXMgTk9UIHRoZSBzYW1lIGFzICRzZi5saWIuZG9tLmlmcmFtZXMudmlldywgd2hpY2hcbiAgICByZXR1cm5zIHRoZSB3aW5kb3cgcmVmZXJlbmNlIElOU0lERSB0aGUgSUZSQU1FIGVsZW1lbnQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdmlldyBhcyAkc2YubGliLmRvbS52aWV3XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxEb2N1bWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudC9kb2N1bWVudCBmb3Igd2hpY2ggeW91IHdpc2ggdG8gZmluZCBpdCdzIHBhcmVudCB3aW5kb3dcbiAgICBAcmV0dXJuIHtEb2N1bWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICB2aWV3ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBlLCBsb2NhbEQsIHByb3AxLCBwcm9wMiwgdztcbiAgICAgIHcgPSBudWxsO1xuICAgICAgbG9jYWxEID0gdm9pZCAwO1xuICAgICAgcHJvcDEgPSBcInBhcmVudFdpbmRvd1wiO1xuICAgICAgcHJvcDIgPSBcImRlZmF1bHRWaWV3XCI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICB3ID0gZWxbcHJvcDFdIHx8IGVsW3Byb3AyXSB8fCBudWxsO1xuICAgICAgICAgIGlmICghdykge1xuICAgICAgICAgICAgbG9jYWxEID0gZG9jKGVsKTtcbiAgICAgICAgICAgIHcgPSAobG9jYWxEICYmIChsb2NhbERbcHJvcDFdIHx8IGxvY2FsRFtwcm9wMl0pKSB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHc7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgYW4gZWxlbWVudCBieSBpdHMgSUQuIC4gYmFzaWNhbGx5IGEgc2hvcnQgaGFuZCB3cmFwcGVyIGFyb3VuZCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBlbHQgYXMgJHNmLmxpYi5kb20uZWx0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gaWQgKFJlcXVpcmVkKSB0aGUgaWQgb2YgdGhlIEhUTUwgZWxlbWVudCB0byBmaW5kXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MV2luZG93fEhUTUxEb2N1bWVudH0gW3Bhcl0gVGhlIHBhcmVudCBlbGVtZW50LGRvY3VtZW50LHdpbmRvdyB0byBsb29rIGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IG51bGwgaWYgbm90aGluZyBmb3VuZFxuICAgICAqL1xuICAgIGVsdCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgYXJncywgZGMsIGxlbjtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIGRjID0gdm9pZCAwO1xuICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgZGMgPSBkb2MoYXJnc1sxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYyA9IHRoZURvY3VtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIChkYyAmJiBkYy5nZXRFbGVtZW50QnlJZChpZCkpIHx8IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIGFyb3VuZCByZXRyaWV2aW5nIHRoZSB0YWdOYW1lIG9mIGFuIEhUTUwgZWxlbWVudCAobm9ybWFsaXplcyB2YWx1ZXMgdG8gbG93ZXIgY2FzZSBzdHJpbmdzKS5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyB0YWdOYW1lIGFzICRzZi5saWIuZG9tLnRhZ05hbWVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBIVE1MIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGdldCB0aGUgdGFnIG5hbWUuXG4gICAgQHJldHVybiB7U3RyaW5nfSBUaGUgdGFnIG5hbWUgaW4gYWxsIGxvd2VyIGNhc2Ugb2YgYW4gSFRNTCBlbGVtZW50LCBpZiBpdCBjYW5ub3QgYmUgc3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCwgYWx3YXN5cyByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyAod2hpY2ggd2lsbCBldmFsdWF0ZSB0byBmYWxzZSkuXG4gICAgICovXG4gICAgdGFnTmFtZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gKGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgfHwgXCJcIjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIHdyYXBwZXIgYXJvdW5kIHJldHJpZXZpbmcgYSBsaXN0IG9mIHRhZ3MgYnkgbmFtZS5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyB0YWdzIGFzICRzZi5saWIuZG9tLnRhZ3NcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWdzIHRoYXQgeW91IHdpc2ggdG8gbG9vayBmb3IsIG5vdGUgdGhhdCB5b3UgY2FuIHBhc3MgaW4gXCIqXCIgdG8gZmluZCBhbGwuXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxEb2N1bWVudH0gW3Bhck5vZGVdIHRoZSBwYXJlbnQgbm9kZSB0aGF0IHlvdSB3aXNoIHRvIGxvb2sgaW5cbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudENvbGxlY3Rpb259IExpc3Qgb2YgdGFncyBmb3VuZC4gTm90ZSB0aGF0IGlzIE5PVCBhIHJlYWwgSmF2YVNjcmlwdCBBcnJheVxuICAgICAqL1xuICAgIHRhZ3MgPSBmdW5jdGlvbihuYW1lLCBwYXJOb2RlKSB7XG4gICAgICB2YXIgZSwgcmV0O1xuICAgICAgcmV0ID0gW107XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhck5vZGUgJiYgcGFyTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuICAgICAgICAgIHJldCA9IHBhck5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSkgfHwgcmV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IHRoZURvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpIHx8IHJldDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaXZlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBwYXIgYXMgJHNmLmxpYi5kb20ucGFyXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIGNoZWNrXG4gICAgcmV0dXJuIHtIVE1MRWxlbWVudH0gdGhlIG5ldyByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBlbGVtZW50IG9yIG51bGxcbiAgICAgKi9cbiAgICBwYXIgPSBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsICYmIChlbC5wYXJlbnROb2RlIHx8IGVsLnBhcmVudEVsZW1lbnQpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlL1NldC9EZWxldGUgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZS4gTm90ZSB0aGF0IHRoaXMgaGFuZGxlJ3NcbiAgICBzbGlnaHQgZGlmZmVyZW5jZXMgaW4gdGhlIHdheSBIVE1MIGF0dHJpYnV0ZXMgYXJlIGhhbmRsZWQgYWNyb3NzIGJyb3dzZXJzXG4gICAgYXMgd2VsbCBhcyBiZWluZyBzaG9ydGhhbmRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBhdHRyIGFzICRzZi5saWIuZG9tLmF0dHJcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gbWFuaXB1bGF0ZVxuICAgIEBwYXJhbSB7U3RyaW5nfSBhdHRyTmFtZSB0aGUgYXR0cmlidXRlIHRvIHNldC9nZXRcbiAgICBAcGFyYW0ge1N0cmluZ30gW2F0dHJWYWxdLCBpZiBzcGVjaWZpZWQgd2lsbCBzZXQgdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgZm9yIHRoaXMgZWxlbWVudC4gIFBhc3NpbmcgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGNvbXBsZXRlbHlcbiAgICBAcmV0dXJuIHtTdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG5vcm1hbGl6ZWQgdG8gYSBzdHJpbmcgKG1heSBiZSBlbXB0eSlcbiAgICAgKi9cbiAgICBhdHRyID0gZnVuY3Rpb24oZWwsIGF0dHJOYW1lLCBhdHRyVmFsKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBpZiAoYXR0clZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBfY3N0cihhdHRyVmFsKTtcbiAgICAgICAgICAgIGlmIChhdHRyTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0clZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh1c2VPbGRTdHlsZUF0dHJNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsLCAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1c2VPbGRTdHlsZUF0dHJNZXRob2RzKSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lLCAwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBfY3N0cihlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBhdHRyVmFsID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyVmFsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNldC9HZXQgdGhlIENTUyB0ZXh0IG9mIGFuIEhUTUwgZWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGNzcyBhcyAkc2YubGliLmRvbS5jc3NcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gbWFuaXB1bGF0ZVxuICAgIEBwYXJhbSB7U3RyaW5nfSBbdmFsXSB0aGUgQ1NTIHN0cmluZyB0byBzZXQgaWYgc3BlY2lmaWVkIChlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MHB4O2xlZnQ6MHB4XCIpLlxuICAgIEByZXR1cm4ge1N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgbm9ybWFsaXplZCB0byBhIHN0cmluZyAobWF5IGJlIGVtcHR5KVxuICAgICAqL1xuICAgIGNzcyA9IGZ1bmN0aW9uKGVsLCB2YWwpIHtcbiAgICAgIHZhciBlLCBzdDtcbiAgICAgIHN0ID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3QgPSBlbC5zdHlsZTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc3QuY3NzVGV4dCA9IF9jc3RyKHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gc3QuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHZhbCA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIE1ha2UgYSBuZXcgZWxlbWVudFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLm1ha2VcbiAgICBAZXhwb3J0cyBtYWtlX2VsZW1lbnQgYXMgJHNmLmxpYi5kb20ubWFrZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWVcbiAgICBAcGFyYW0ge0RvY3VtZW50fEhUTUxFbGVtZW50fFdpbmRvd30gW3BhcmVudF0gZWxlbWVudCwgZG9jdW1lbnQsIG9yIHdpbmRvdyB0byBtYWtlIHRoZSB0YWcgaW4sIG9wdGlvbmFsLlxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIG1ha2VfZWxlbWVudCA9IGZ1bmN0aW9uKHRhZ05hbWUsIHBhcikge1xuICAgICAgcmV0dXJuICgoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgZG9jKHBhcikpIHx8IHRoZURvY3VtZW50KS5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEFwcGVuZCBhbmQgSFRNTEVsZW1lbnQgdG8gYW5vdGhlciBIVE1MRWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGFwcGVuZCBhcyAkc2YubGliLmRvbS5hcHBlbmRcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhck5vZGUgdGhlIEhUTUwgZWxlbWVudCB0byBtYW5pcHVsYXRlXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGQgKFJlcXVpcmVkKSB0aGUgbmV3IEhUTUwgZWxlbWVudCB0byBhZGQgdG8gdGhlIHBhcmVudFxuICAgIHJldHVybiB7SFRNTEVsZW1lbnR8Qm9vbGVhbn0gdGhlIG5ldyByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIGVsZW1lbnQgdGhhdCB3YXMgYXBwZW5kZWQsIG9yIGZhbHNlIGlmIGZhaWx1cmVcbiAgICAgKi9cbiAgICBhcHBlbmQgPSBmdW5jdGlvbihwYXJOb2RlLCBjaGlsZCkge1xuICAgICAgdmFyIGUsIHN1Y2Nlc3M7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhck5vZGUpIHtcbiAgICAgICAgICBzdWNjZXNzID0gcGFyTm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIHdyYXBwZXIgbWV0aG9kIGZvciByZW1vdmluZyBlbGVtZW50cyBmcm9tIGEgZG9jdW1lbnQgcmF0aGVyIHRoYW4gY2FsbGluZyBwYXJlbnROb2RlLnJlbW92ZUNoaWxkIHJhdy5cbiAgICBIYXMgc3BlY2lhbCBwcm9jZXNzaW5nIHRvIGVuc3VyZSB0aGF0IGNvbnRlbnRzIG9mIElGUkFNRSB0YWdzIGdldHMgcmVsZWFzZWQgZnJvbSBtZW1vcnkgYXMgd2VsbFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHB1cmdlIGFzICRzZi5saWIuZG9tLnB1cmdlXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFRoZSBIVE1MIGVsZW1lbnQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgICBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZWxlbWVudCB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWRcbiAgICAgKi9cbiAgICBwdXJnZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBlLCBpc0lGcmFtZSwgcGFyTm9kZSwgc3VjY2VzcztcbiAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIHBhck5vZGUgPSB2b2lkIDA7XG4gICAgICBpc0lGcmFtZSA9IHRhZ05hbWUobm9kZSkgPT09IElGUkFNRTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBpZiAoaXNJRnJhbWUpIHtcbiAgICAgICAgX2NhbGxfeG1zZ19ob3N0KFwiZGV0YWNoXCIsIG5vZGUpO1xuICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQobm9kZSk7XG4gICAgICAgIGlmICghaXNJRSkge1xuICAgICAgICAgIGF0dHIobm9kZSwgXCJzcmNcIiwgQkxBTktfVVJMKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyTm9kZSA9IHBhcihub2RlKTtcbiAgICAgICAgaWYgKHBhck5vZGUpIHtcbiAgICAgICAgICBwYXJOb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgIGlmIChpc0lFICYmIGlzSUZyYW1lKSB7XG4gICAgICAgICAgICBnYygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgbm9kZSA9IHBhck5vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gSFRNTEVsZW1lbnQuICBOb3RlIG5vcm1hbGl6ZSBldmVudCBuYW1lcyB0byBsb3dlciBjYXNlIC8gdzNjIHN0YW5kYXJkcy5cbiAgICBTZWUgZXhhbXBsZS5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBhdHRhY2ggYXMgJHNmLmxpYi5kb20uYXR0YWNoXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIGF0dGFjaCBhbiBldmVudCBoYW5kbGVyIHRvb1xuICAgIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9vXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoZSBwYXJ0aWN1bGFyIGV2ZW50XG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgZWwgPSAkc2YubGliLmRvbS5lbHQoXCJteV9lbGVtZW50XCIpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZV9jbGljayhldnQpXG4gICAge1xuICAgIGFsZXJ0KCdpIHdhcyBjbGlja2VkJyk7XG4gICAgfVxuICAgIFxuICAgICRzZi5saWIuZG9tLmF0dGFjaChlbCxcImNsaWNrXCIsaGFuZGxlX2NsaWNrKTtcbiAgICAgKi9cbiAgICBhdHRhY2ggPSBmdW5jdGlvbihvYmosIG5hbWUsIGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodXNlX2llX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICBvYmpbdXNlX2F0dGFjaF0oXCJvblwiICsgbmFtZSwgY2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialt1c2VfYXR0YWNoXShuYW1lLCBjYiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBvYmogPSBjYiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRGV0YWNoIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBkZXRhY2ggYXMgJHNmLmxpYi5kb20uZGV0YWNoXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIGF0dGFjaCBhbiBldmVudCBoYW5kbGVyIHRvb1xuICAgIEBwYXJhbSB7U3RyaW5nfSBuYW1ldGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b29cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgZnVuY3Rpb24gdXNlZCB0byBoYW5kbGUgdGhlIHBhcnRpY3VsYXIgZXZlbnRcbiAgICAgKi9cbiAgICBkZXRhY2ggPSBmdW5jdGlvbihvYmosIG5hbWUsIGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodXNlX2llX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICBvYmouZGV0YWNoRXZlbnQoXCJvblwiICsgbmFtZSwgY2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNiLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIG9iaiA9IGNiID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBET00gaXMgcmVhZHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyByZWFkeSBhcyAkc2YubGliLmRvbS5yZWFkeVxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICByZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJzO1xuICAgICAgcnMgPSB2b2lkIDA7XG4gICAgICBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2soKTtcbiAgICAgIGlmIChkb21faXNfcmVhZHkpIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcnMgPSB0aGVEb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgICAgaWYgKHJzKSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICBpZiAocnMgPT09IFwibG9hZGVkXCIgfHwgcnMgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tX2lzX3JlYWR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgZG9tX3JlYWR5X2Noa190cmllcyA9IGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCA9IDA7XG4gICAgICBfcmVhZHlfc3RhdGVfY2hlY2soKTtcbiAgICAgIHJldHVybiAhIWRvbV9pc19yZWFkeTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBGaXJlIG9mZiBhIHBhcnRpY3VsYXIgZnVuY3Rpb24gd2hlbiBpdCBpcyBkZXRlY3RlZCB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICBVc2VmdWwgd2hlbiB5b3UgZG9uJ3Qga25vdyBmb3Igc3VyZSBpZiB0aGUgRE9NIG9mIHRoZSBicm93c2VyIGlzIHJlYWR5IG9yIG5vdCwgc28gdGhpcyB3aWxsIGRldGVjdCBhbmQgZmlyZVxuICAgIHlvdXIgZnVuY3Rpb24gZm9yIHlvdS5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyB3YWl0IGFzICRzZi5saWIuZG9tLndhaXRcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIEEgZnVuY3Rpb24gcmVmZXJlbmNlIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICAgKi9cbiAgICB3YWl0ID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciBlLCByZHk7XG4gICAgICByZHkgPSByZWFkeSgpO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGlmIChyZHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAobGFuZy5jYWxsYWJsZShjYikpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICB3YWl0KGNiKTtcbiAgICAgICAgY2IgPSBudWxsO1xuICAgICAgfSksIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsICsgMSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2FuY2VsIHRoZSB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgYSBwYXJ0aWN1bGFyIERPTSBldmVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGV2dENuY2wgYXMgJHNmLmxpYi5kb20uZXZ0Q25jbFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCAgVGhlIHJhdyBIVE1MIGV2ZW50XG4gICAgICovXG4gICAgZXZ0Q25jbCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGUsIHByb3A7XG4gICAgICBwcm9wID0gXCJcIjtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBldnQgPSBldnQgfHwgd2luLmV2ZW50O1xuICAgICAgaWYgKGV2dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZ0LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgZm9yIChwcm9wIGluIEVWVF9DTkNMX01FVEhPRFMpIHtcbiAgICAgICAgICBpZiAoRVZUX0NOQ0xfTUVUSE9EU1twcm9wXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXZ0W3Byb3BdKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSB0YXJnZXQvc3JjRWxlbWVudCBvZiBhbiBldmVudCBmcm9tIGFuIEhUTUwgZWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGV2dFRndCBhcyAkc2YubGliLmRvbS5ldnRUZ3RcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBIVE1MIGV2ZW50XG4gICAgICovXG4gICAgZXZ0VGd0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgZSwgdGd0O1xuICAgICAgdGd0ID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2dCA9IGV2dCB8fCB3aW4uZXZlbnQ7XG4gICAgICAgIHRndCA9IChldnQgPyBldnRbZXZ0X3RndF9wcm9wX2FdIHx8IGV2dFtldnRfdGd0X3Byb3BfYl0gOiBudWxsKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB0Z3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRndDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAbmFtZXNwYWNlICRzZi5saWIuZG9tLmlmcmFtZXMgRGVmaW5lcyBoZWxwZXIgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHNwZWNpZmljYWxseSB3aXRoIElGUkFNRSB0YWdzLCB3aGljaCBpcyBrZXkgdG8gU2FmZUZyYW1lcyB0ZWNoIGluIGEgYnJvd3Nlci5cbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzXG4gICAgQHJlcXVpcmVzICRzZi5saWIubGFuZ1xuICAgICAqL1xuXG4gICAgLypcbiAgICBDbG9uZXMgYW4gaWZyYW1lLiAuIC5cbiAgICBUaGlzIGNvZGUgY3JlYXRlcyAvIGNsb25lcyBpZnJhbWUgdGFncyBpbiBhIHZlcnkgc3BlY2lmaWMgd2F5IHRvIGVuc3VyZSBib3RoIG9wdGltYWwgcGVyZm9ybWFuY2UgYW5kIHN0YWJpbGl0eS5cbiAgICBXZSB1c2Ugc3RyaW5nIGJ1ZmZlcnMgdG8gYnVpbGQgbWFya3VwIGludGVybmFsbHksIHdoaWNoIGlzIHR5cGljYWxseSBmYXN0ZXIgdGhhbiB1c2luZyBhbGwgRE9NIEFQSXMuICBBbHNvXG4gICAgd2UgYWxsb3cgdGhlIHVzYWdlIG9mIHRoZSBcIm5hbWVcIiBhdHRyaWJ1dGUgYXMgYSBkYXRhIHBpcGVsaW5lLCB3aGljaCBpbiB0dXJuIGFsbG93cyBmb3Igc3luY2hyb25vdXMgZG93bndhcmRcbiAgICB4LWRvbWFpbiBtZXNzYWdpbmcuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy5jbG9uZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudC9TdHJpbmd9IGVsICBBbiBpZnJhbWUgZWxlbWVudCBvciBpZCBvZiBhbiBpZnJhbWUgZWxlbWVudCB0byBjbG9uZVxuICAgIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnNdICBBIGhhc2ggbWFwIG9mIG90aGVyIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBpZnJhbWUuICBEbyBub3Qgc2V0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSBmcmFtZSBoZXJlLCBzZWUgdGhlIG5leHQgYXJndW1lbnQgZm9yIHRoYXQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjc3NUZXh0XSAgVGhlIHN0eWxlIHN0cmluZyAoYXMgaW4gd2hhdCB5b3Ugd291bGQgdXNlIGluIEhUTUwgbWFya3VwLCBlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7Ym9yZGVyOnNvbGlkIDNweCBibHVlO1wiKSwgdG8gdXNlIGZvciB0aGlzIGlmcmFtZVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBvcHRpb25hbCBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gIHRoZSBpZnJhbWUgbm9kZSBpZiBzdWNjZXNmdWxseSBjcmVhdGVkIG9yIG51bGwuICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBpbnNlcnQgdGhlIGlmcmFtZSBpbnRvIHRoZSBkb2N1bWVudCBmb3IgeW91LiAuIC5cbiAgICAgKi9cbiAgICBjbG9uZV9pZnJhbWUgPSBmdW5jdGlvbihlbCwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpIHtcbiAgICAgIHJldHVybiBfY2xvbmVfaWZyYW1lKGVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQik7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQGlnbm9yZVxuICAgICAqL1xuICAgIF9jbG9uZV9pZnJhbWUgPSBmdW5jdGlvbihlbCwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IsIGlmcmFtZV9za2lwX2Nsb25lKSB7XG4gICAgICB2YXIgYXR0clN0ciwgYnVmZmVySFRNTCwgY2wsIGh0bWwsIG5ld0NsLCBwcm9wLCB0ZW1wLCB4bXNnUGlwZTtcbiAgICAgIGJ1ZmZlckhUTUwgPSBbXCI8XCIsIElGUkFNRSwgXCIgXCJdO1xuICAgICAgeG1zZ1BpcGUgPSBcIlwiO1xuICAgICAgcHJvcCA9IHZvaWQgMDtcbiAgICAgIHRlbXAgPSB2b2lkIDA7XG4gICAgICBjbCA9IHZvaWQgMDtcbiAgICAgIG5ld0NsID0gdm9pZCAwO1xuICAgICAgaHRtbCA9IHZvaWQgMDtcbiAgICAgIGF0dHJTdHIgPSB2b2lkIDA7XG4gICAgICBpZiAoIWlmcmFtZV9za2lwX2Nsb25lKSB7XG4gICAgICAgIGVsID0gX2J5SUQoZWwpO1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgIT09IElGUkFNRSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNsID0gZWwuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsID0gZWw7XG4gICAgICB9XG4gICAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgICAgaWYgKFwic3JjXCIgaW4gYXR0cnMpIHtcbiAgICAgICAgYXR0cihjbCwgXCJzcmNcIiwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRycy5zcmMgPSBhdHRyKGVsLCBcInNyY1wiKSB8fCBCTEFOS19VUkw7XG4gICAgICB9XG4gICAgICBpZiAoXCJuYW1lXCIgaW4gYXR0cnMpIHtcbiAgICAgICAgYXR0cihjbCwgXCJuYW1lXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMubmFtZSA9IGF0dHIoZWwsIFwibmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cnMuc3JjKSB7XG4gICAgICAgIGF0dHJzLnNyYyA9IEJMQU5LX1VSTDtcbiAgICAgIH1cbiAgICAgIHhtc2dQaXBlID0geG1zZ0NCICYmIF9jYWxsX3htc2dfaG9zdChcInByZXBcIiwgYXR0cnMpO1xuICAgICAgaWYgKCFpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgICBhdHRyKGNsLCBcIndpZHRoXCIsIG51bGwpO1xuICAgICAgICBhdHRyKGNsLCBcImhlaWdodFwiLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgIHRlbXAgPSBjc3MoY2wpO1xuICAgICAgICBpZiAodGVtcCAmJiB0ZW1wLmNoYXJBdCh0ZW1wLmxlbmd0aCAtIDEpICE9PSBcIjtcIikge1xuICAgICAgICAgIHRlbXAgKz0gXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgY3NzKGNsLCBbdGVtcCwgX2NzdHIoY3NzVGV4dCldKTtcbiAgICAgIH1cbiAgICAgIHRlbXAgPSBtYWtlX2VsZW1lbnQoXCJkaXZcIik7XG4gICAgICBhcHBlbmQodGVtcCwgY2wpO1xuICAgICAgaHRtbCA9IHRlbXAuaW5uZXJIVE1MO1xuICAgICAgYXR0clN0ciA9IGh0bWwucmVwbGFjZSgvPGlmcmFtZSguKj8pPiguKj8pPFxcL2lmcmFtZT4vZywgXCIkMVwiKTtcbiAgICAgIGJ1ZmZlckhUTUwucHVzaChcIm5hbWU9XFxcIlwiLCBhdHRycy5uYW1lLCBcIlxcXCIgXCIsIGF0dHJTdHIsIFwiPjwvXCIsIElGUkFNRSwgXCI+XCIpO1xuICAgICAgZGVsZXRlIGF0dHJzLm5hbWU7XG4gICAgICB0ZW1wLmlubmVySFRNTCA9IF9jc3RyKGJ1ZmZlckhUTUwpO1xuICAgICAgbmV3Q2wgPSB0ZW1wLmZpcnN0Q2hpbGQ7XG4gICAgICBmb3IgKHByb3AgaW4gYXR0cnMpIHtcbiAgICAgICAgYXR0cihuZXdDbCwgcHJvcCwgYXR0cnNbcHJvcF0pO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRyKG5ld0NsLCBcImlkXCIpKSB7XG4gICAgICAgIGF0dHIobmV3Q2wsIFwiaWRcIiwgXCJzZl9cIiArIElGUkFNRSArIFwiX1wiICsgaWZyYW1lX25leHRfaWQpO1xuICAgICAgICBpZnJhbWVfbmV4dF9pZCsrO1xuICAgICAgfVxuICAgICAgYXR0cihuZXdDbCwgXCJGUkFNRUJPUkRFUlwiLCBcIm5vXCIpO1xuICAgICAgYXR0cihuZXdDbCwgXCJTQ1JPTExJTkdcIiwgXCJub1wiKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiQUxMT1dUUkFOU1BBUkVOQ1lcIiwgdHJ1ZSk7XG4gICAgICBhdHRyKG5ld0NsLCBcIkhJREVGT0NVU1wiLCB0cnVlKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiVEFCSU5ERVhcIiwgLTEpO1xuICAgICAgYXR0cihuZXdDbCwgXCJNQVJHSU5XSURUSFwiLCAwKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiTUFSR0lOSEVJR0hUXCIsIDApO1xuICAgICAgX2JpbmRfaWZyYW1lX29ubG9hZChuZXdDbCwgY2IpO1xuICAgICAgaWYgKHhtc2dQaXBlKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdChcImF0dGFjaFwiLCBuZXdDbCwgeG1zZ1BpcGUsIHhtc2dDQik7XG4gICAgICB9XG4gICAgICB4bXNnUGlwZSA9IHhtc2dDQiA9IGNsID0gY2IgPSBlbCA9IHRlbXAgPSBudWxsO1xuICAgICAgcmV0dXJuIG5ld0NsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIE1ha2UgYSBuZXcgaWZyYW1lXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy5tYWtlXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge09iamVjdH0gYXR0cnMgIEEgaGFzaCBtYXAgb2Ygb3RoZXIgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIGlmcmFtZS4gIERvIG5vdCBzZXQgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGZyYW1lIGhlcmUsIHNlZSB0aGUgbmV4dCBhcmd1bWVudCBmb3IgdGhhdC5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2Nzc1RleHRdICBUaGUgc3R5bGUgc3RyaW5nIChhcyBpbiB3aGF0IHlvdSB3b3VsZCB1c2UgaW4gSFRNTCBtYXJrdXAsIGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtib3JkZXI6c29saWQgM3B4IGJsdWU7XCIpLCB0byB1c2UgZm9yIHRoaXMgaWZyYW1lXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSAgQW4gY2FsbGJhY2sgZnVuY3Rpb24gdG8gc3BlY2lmeSBmb3Igd2hlbiB0aGUgaWZyYW1lIGxvYWRzLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFt4bXNnQ0JdIEFuIGNhbGwgYmFjayBmb3IgcmVjZWl2aW5nIG1lc3NhZ2VzIGZyb20gdGhlIGlmcmFtZVxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgdGhlIGlmcmFtZSBub2RlIGlmIHN1Y2Nlc2Z1bGx5IGNyZWF0ZWQgb3IgbnVsbC4gIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGluc2VydCB0aGUgaWZyYW1lIGludG8gdGhlIGRvY3VtZW50IGZvciB5b3UuIC4gLlxuICAgICAqL1xuICAgIG1ha2VfaWZyYW1lID0gZnVuY3Rpb24oYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpIHtcbiAgICAgIHJldHVybiBfY2xvbmVfaWZyYW1lKG1ha2VfZWxlbWVudChJRlJBTUUpLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQiwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBtZXRob2QgdG8gaW5zZXJ0IG9yIHJlcGxhY2UgYW4gSFRNTCB0YWcgd2l0aCBhbiBJRlJBTUUgdGFnLCB3aXRoIGEgbmV3IFVSTCBhbmQgYXR0cmlidXRlcy5cbiAgICBcbiAgICBVc2VkIGZvciAzIHJlYXNvbnM6XG4gICAgPG9sPlxuICAgIDxsaT5JdCBhdm9pZHMgY2xpY2sgc291bmRzIG9uIElFLjwvbGk+XG4gICAgPGxpPkl0IGFsbG93cyBhbHdheXMgcmVzZXR0aW5nIHRoZSB3aW5kb3cubmFtZSBwcm9wZXJ0eSBvZiB0aGUgaWZyYW1lcyB1bmRlcmx5aW5nIEhUTUxXaW5kb3cgb2JqZWN0LCB1bmZvcnVuYXRlbHkgSUUgd2lsbCBub3QgbGV0IHlvdSBzZXQgdGhpcyBhdHRyaWJ1dGUgb24gYSBjbG9uZS48L2xpPlxuICAgIDxsaT5JdCBlbnN1cmVzIHRoYXQgZXZlbnQgaGFuZGxlcnMgaW4gdGhlIHVuZGVybHlpbmcgZG9jdW1lbnQgZm9yIHVubG9hZGluZyBhcmUgZXhlY3V0ZWQuPC9saT5cbiAgICA8bGk+Q2hhbmdpbmcgdGhlIHNyYyBhdHRyaWJ1dGUgZGlyZWN0bHkgd2lsbCByZXN1bHQgaW4gYSBicm93c2VyIGhpc3RvcnkgdXBkYXRlLCB3aGljaCB3ZSBkbyBub3Qgd2FudC48L2xpPlxuICAgIDwvb2w+XG4gICAgXG4gICAgV2UgY291bGQganVzdCBjaGFuZ2UgbG9jYXRpb24uaHJlZiBwcm9wZXJ0eSBvciBjYWxsIGxvY2F0aW9uLnJlcGxhY2UsIGhvd2V2ZXIgdGhhdCBpcyBub3QgYWx3YXlzICBwb3NzaWJsZSBzaW5jZVxuICAgIHRoZSBmcmFtZSBjb3VsZCBiZSB4LWRvbWFpbi5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLnJlcGxhY2VcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAgQSBoYXNoIG1hcCBvZiBvdGhlciBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgaWZyYW1lLiAgRG8gbm90IHNldCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZnJhbWUgaGVyZSwgc2VlIHRoZSBuZXh0IGFyZ3VtZW50IGZvciB0aGF0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbY3NzVGV4dF0gIFRoZSBzdHlsZSBzdHJpbmcgKGFzIGluIHdoYXQgeW91IHdvdWxkIHVzZSBpbiBIVE1MIG1hcmt1cCwgZS5nLiBcImJhY2tncm91bmQtY29sb3I6cmVkO2JvcmRlcjpzb2xpZCAzcHggYmx1ZTtcIiksIHRvIHVzZSBmb3IgdGhpcyBpZnJhbWVcbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gW3BhclJlZl0gIEFuIHBhcmVudCBlbGVtZW50IG9yIHBhcmVudCBlbGVtZW50IGlkLCB0byBiZSB1c2VkIG9ubHkgaWYgYSBuZXcgaWZyYW1lIGlzIGNyZWF0ZWQsIHRoZSBpZnJhbWUgd2lsbCBiZSBhcHBlbmQgdG8gdGhhdCBwYXJlbnQsIGlmIG5vdCBzcGVjaWZpZWQgZG9jdW1lbnQgYm9keSBpcyB1c2VkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSAgQW4gY2FsbGJhY2sgZnVuY3Rpb24gdG8gc3BlY2lmeSBmb3Igd2hlbiB0aGUgaWZyYW1lIGxvYWRzLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFt4bXNnQ0JdIEFuIGNhbGwgYmFjayBmb3IgcmVjZWl2aW5nIG1lc3NhZ2VzIGZyb20gdGhlIGlmcmFtZVxuICAgIFxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fSBhIHJlZmVyZW5jZSB0byB0aGUgbmV3bHkgY3JlYXRlZCBpZnJhbWUgZWxlbWVudCBpZiBzdWNjZXNzZnVsbHkgaW5zZXJ0ZWQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqL1xuICAgIHJlcGxhY2VfaWZyYW1lID0gZnVuY3Rpb24oYXR0cnMsIGNzc1RleHQsIHBhclJlZiwgY2IsIHhtc2dDQikge1xuICAgICAgdmFyIGNsLCBlLCBlbCwgZWxJRCwgZnJhbWVFbCwgcGFyTm9kZSwgdGduO1xuICAgICAgY2wgPSB2b2lkIDA7XG4gICAgICBlbCA9IHZvaWQgMDtcbiAgICAgIGZyYW1lRWwgPSB2b2lkIDA7XG4gICAgICBlbElEID0gdm9pZCAwO1xuICAgICAgdGduID0gdm9pZCAwO1xuICAgICAgcGFyTm9kZSA9IHZvaWQgMDtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgICAgZWxJRCA9IGF0dHJzLmlkO1xuICAgICAgZWwgPSBlbElEICYmIF9ieUlEKGVsSUQpO1xuICAgICAgdGduID0gdGFnTmFtZShlbCk7XG4gICAgICBlbCA9ICh0Z24gPyBlbCA6IG51bGwpO1xuICAgICAgZnJhbWVFbCA9ICh0Z24gPT09IElGUkFNRSA/IGVsIDogbnVsbCk7XG4gICAgICBpZiAoZnJhbWVFbCkge1xuICAgICAgICBfY2FsbF94bXNnX2hvc3QoXCJkZXRhY2hcIiwgZnJhbWVFbCk7XG4gICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZChmcmFtZUVsKTtcbiAgICAgICAgcGFyTm9kZSA9IHBhcihmcmFtZUVsKTtcbiAgICAgICAgY2wgPSBjbG9uZV9pZnJhbWUoZnJhbWVFbCwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpO1xuICAgICAgICBhdHRyKGNsLCBcIm9ubG9hZFwiLCBudWxsKTtcbiAgICAgICAgYXR0cihjbCwgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGFyUmVmKSB7XG4gICAgICAgICAgcGFyUmVmID0gX2J5SUQocGFyUmVmKTtcbiAgICAgICAgICBpZiAodGFnTmFtZShwYXJSZWYpKSB7XG4gICAgICAgICAgICBwYXJOb2RlID0gcGFyUmVmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhck5vZGUgJiYgZWwpIHtcbiAgICAgICAgICBwYXJOb2RlID0gcGFyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjc3NUZXh0ID0gX2NzdHIoY3NzVGV4dCkgfHwgY3NzKGVsKSB8fCBcIlwiO1xuICAgICAgICBjbCA9IG1ha2VfaWZyYW1lKGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghcGFyTm9kZSkge1xuICAgICAgICAgIGFwcGVuZCh0aGVEb2N1bWVudC5ib2R5LCBjbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZyYW1lRWwpIHtcbiAgICAgICAgICAgIHBhck5vZGUucmVwbGFjZUNoaWxkKGNsLCBmcmFtZUVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIHBhck5vZGUucmVwbGFjZUNoaWxkKGNsLCBlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcHBlbmQocGFyTm9kZSwgY2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgY2wgPSBlbCA9IGF0dHJzID0gZnJhbWVFbCA9IHBhck5vZGUgPSBjYiA9IG51bGw7XG4gICAgICByZXR1cm4gZWx0KGVsSUQpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGluc2lkZSBvZiBhbiBJRlJBTUUuIE5vdCB0byBiZSBjb25mdXNlZCB3aXRoICRzZi5saWIuZG9tLnZpZXcgd2hpY2hcbiAgICByZXR1cm5zIHRoZSBwYXJlbnQgd2luZG93IHJlZmVyZW5jZSBvZiBhbiBlbGVtZW50LlxuICAgIFxuICAgIE5vdGUgdGhhdCBldmVuIGluIGNyb3NzLWRvbWFpbiBzY2VuYXJpb3MsIHlvdSBhcmUgc3VwcG9zZWQgdG8gYWJsZSB0byBnZXQgYWNjZXNzIHRvIHRoZSB3aW5kb3cgcmVmZXJlbmNlLlxuICAgIEluIGEgY3Jvc3MtZG9tYWluIHNjZW5hcmlvLCB5b3Ugd291bGQgbm90IGJlIGFibGUgdG8gdGhlbiBhY2Vzc3MgbW9zdCBwcm9wZXJ0aWVzIC8gbWV0aG9kcyAvIG9iamVjdHMgb2YgdGhhdFxuICAgIHdpbmRvdywgYnV0IHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIGFsbG93ZWQuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy52aWV3XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgaWZyYW1lIGVsZW1lbnQgdG8gc2FmZWx5IGdldCBiYWNrIHRoZSB3aW5kb3dcbiAgICBAcmV0dXJuIHtIVE1MV2luZG93fSB0aGUgd2luZG93IHJlZmVyZW5jZSBpbnNpZGUgdGhlIGlmcmFtZS5cbiAgICAgKi9cbiAgICBpZnJhbWVfdmlldyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZSwgZWxEb2MsIGVsV2luLCBlcnIsIGZlLCBmcmFtZSwgZnJhbWVfbGlzdCwgaWR4LCBsb2NhbFdpbjtcbiAgICAgIGxvY2FsV2luID0gdm9pZCAwO1xuICAgICAgZWxXaW4gPSB2b2lkIDA7XG4gICAgICBlbERvYyA9IHZvaWQgMDtcbiAgICAgIGZyYW1lX2xpc3QgPSB2b2lkIDA7XG4gICAgICBmcmFtZSA9IHZvaWQgMDtcbiAgICAgIGZlID0gdm9pZCAwO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBlcnIgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFdpbiA9IGVsLmNvbnRlbnRXaW5kb3cgfHwgbnVsbDtcbiAgICAgICAgaWYgKCF3aW4pIHtcbiAgICAgICAgICBlbERvYyA9IGRvYyhlbCk7XG4gICAgICAgICAgZWxXaW4gPSBlbERvYyAmJiB2aWV3KGVsRG9jKTtcbiAgICAgICAgICBmcmFtZV9saXN0ID0gKGVsV2luICYmIGVsV2luLmZyYW1lcykgfHwgW107XG4gICAgICAgICAgd2hpbGUgKGZyYW1lID0gZnJhbWVfbGlzdFtpZHgrK10pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZlID0gZnJhbWUuZnJhbWVFbGVtZW50O1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgZmUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZlICYmIGZlID09PSBlbCkge1xuICAgICAgICAgICAgICBsb2NhbFdpbiA9IGZyYW1lO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBsb2NhbFdpbiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxXaW47XG4gICAgfTtcblxuICAgIC8qXG4gICAgQGlnbm9yZVxuICAgICAqL1xuICAgIGdjID0gX2xhbmcubm9vcDtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgQVRUUl9OQU1FLCBDUkVBVEVfRVZFTlQsIEVWVF9UWVBFLCBlcnIsIG9iaiwgcHJvcDtcbiAgICAgIG9iaiA9IHZvaWQgMDtcbiAgICAgIEFUVFJfTkFNRSA9IFwiU0NST0xMSU5HXCI7XG4gICAgICBDUkVBVEVfRVZFTlQgPSBcImNyZWF0ZUV2ZW50XCI7XG4gICAgICBFVlRfVFlQRSA9IFwiVUlFdmVudFwiO1xuICAgICAgcHJvcCA9IHZvaWQgMDtcbiAgICAgIGVyciA9IHZvaWQgMDtcbiAgICAgIGlmIChpc0lFKSB7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9hID0gXCJzcmNFbGVtZW50XCI7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9iID0gXCJ0YXJnZXRcIjtcbiAgICAgICAgb2JqID0gbWFrZV9lbGVtZW50KElGUkFNRSk7XG4gICAgICAgIGF0dHIob2JqLCBBVFRSX05BTUUsIFwibm9cIik7XG4gICAgICAgIHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMgPSBhdHRyKG9iaiwgQVRUUl9OQU1FKSAhPT0gXCJub1wiO1xuICAgICAgICBpZiAoR0MgaW4gd2luKSB7XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgIEBpZ25vcmVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGdjX3RpbWVyX2lkKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChnY190aW1lcl9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnY190aW1lcl9pZyhzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbltHQ10oKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgICAgfSwgSUVfR0NfSU5URVJWQUwpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdjID0gX2xhbmcubm9vcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2EgPSBcInRhcmdldFwiO1xuICAgICAgICBldnRfdGd0X3Byb3BfYiA9IFwiY3VycmVudFRhcmdldFwiO1xuICAgICAgfVxuICAgICAgaWYgKHdpblt3M2NfYXR0YWNoXSAmJiAhaXNJRSkge1xuICAgICAgICB1c2VfYXR0YWNoID0gdzNjX2F0dGFjaDtcbiAgICAgICAgdXNlX2RldGFjaCA9IHczY19kZXRhY2g7XG4gICAgICB9IGVsc2UgaWYgKGlzSUUpIHtcbiAgICAgICAgdXNlX2llX29sZF9hdHRhY2ggPSB0cnVlO1xuICAgICAgICB1c2VfYXR0YWNoID0gaWVfYXR0YWNoO1xuICAgICAgICB1c2VfZGV0YWNoID0gaWVfZGV0YWNoO1xuICAgICAgfVxuICAgICAgb2JqID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9iaiA9IHRoZURvY3VtZW50W0NSRUFURV9FVkVOVF0oRVZUX1RZUEUpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgb2JqID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqID0gdGhlRG9jdW1lbnRbQ1JFQVRFX0VWRU5UXShFVlRfVFlQRSArIFwic1wiKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgIG9iaiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgZm9yIChwcm9wIGluIEVWVF9DTkNMX01FVEhPRFMpIHtcbiAgICAgICAgICBpZiAob2JqW3Byb3BdKSB7XG4gICAgICAgICAgICBFVlRfQ05DTF9NRVRIT0RTW3Byb3BdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9iaiA9IG51bGw7XG4gICAgICBhdHRhY2god2luLCBcImxvYWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgICAgcmV0dXJuIGF0dGFjaCh3aW4sIFwiRE9NQ29udGVudExvYWRlZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gZG9tID0ge1xuICAgICAgZG9jOiBkb2MsXG4gICAgICB2aWV3OiB2aWV3LFxuICAgICAgZWx0OiBlbHQsXG4gICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgdGFnczogdGFncyxcbiAgICAgIHBhcjogcGFyLFxuICAgICAgbWFrZTogbWFrZV9lbGVtZW50LFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBhdHRyOiBhdHRyLFxuICAgICAgZ2M6IGdjLFxuICAgICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgICBwdXJnZTogcHVyZ2UsXG4gICAgICBhdHRhY2g6IGF0dGFjaCxcbiAgICAgIGRldGFjaDogZGV0YWNoLFxuICAgICAgcmVhZHk6IHJlYWR5LFxuICAgICAgd2FpdDogd2FpdCxcbiAgICAgIGV2dENuY2w6IGV2dENuY2wsXG4gICAgICBldnRUZ3Q6IGV2dFRndCxcbiAgICAgIGlmcmFtZXM6IHtcbiAgICAgICAgbWFrZTogbWFrZV9pZnJhbWUsXG4gICAgICAgIGNsb25lOiBjbG9uZV9pZnJhbWUsXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2VfaWZyYW1lLFxuICAgICAgICB2aWV3OiBpZnJhbWVfdmlld1xuICAgICAgfVxuICAgIH07XG4gIH0pKHdpbmRvdywgbGFuZywgZW52KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBsYW5nLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIGxhbmcgPSByZXF1aXJlKCcuL2xhbmcnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgY2FjaGVkX3VhLCBpc0lFLCBpc0lFMTEsIG5hdmlnYXRvciwgdGhlRG9jdW1lbnQsIHVhLCB1c2VyQWdlbnQsIHdpbjtcbiAgICB3aW4gPSB3aW5kb3c7XG4gICAgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgICB0aGVEb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB1c2VyQWdlbnQgPSAobmF2aWdhdG9yICE9IG51bGwgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogdm9pZCAwKSB8fCBcIlwiO1xuICAgIGlzSUUxMSA9ICF3aW5kb3cuQWN0aXZlWE9iamVjdCAmJiBfX2luZGV4T2YuY2FsbCh3aW5kb3csIFwiQWN0aXZlWE9iamVjdFwiKSA+PSAwO1xuICAgIGlzSUUgPSAhaXNJRTExICYmICh3aW4gJiYgKF9faW5kZXhPZi5jYWxsKHdpbiwgXCJBY3RpdmVYT2JqZWN0XCIpID49IDApKTtcbiAgICBjYWNoZWRfdWEgPSBudWxsO1xuICAgIHVhID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAvKlxuICAgICAgQ29udmVydCBhIHZlcnNpb24gc3RyaW5nIGludG8gYSBudW1lcmljIHZhbHVlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEtX251bWJlcmlmeVxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHMgVGhlIHN0cmluZyByZXByZXNlbnRpbmcgYSB2ZXJzaW9uIG51bWJlciAoZS5nLiAnbWFqb3IubWlub3IucmV2aXNpb24nKVxuICAgICAgQHJldHVybnMge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgdmFyIHBhcnNlX3VhLCBfbWF0Y2hJdCwgX251bWJlcmlmeSwgX3Rlc3RJdDtcbiAgICAgIF9udW1iZXJpZnkgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBjID0gMDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocy5yZXBsYWNlKC9cXC4vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGMrKyA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIi5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBXcmFwcGVyIG1ldGhvZCBmb3IgcmV0dXJuaW5nIHZhbHVlcyBmcm9tIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoIHNhZmVseS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS1fbWF0Y2hJdFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgIEBwYXJhbSB7UmVnRXhwfSByZWdFeCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHVzZSBmb3IgbWF0Y2hpbmdcbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbaWR4XSBUaGUgaW5kZXggbnVtYmVyIG9mIGEgbWF0Y2ggdG8gcHVsbCBmcm9tXG4gICAgICBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBfbWF0Y2hJdCA9IGZ1bmN0aW9uKHN0ciwgcmVnRXgsIGlkeCkge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgbSA9IHN0ciAmJiBzdHIubWF0Y2gocmVnRXgpO1xuICAgICAgICBpZiAoIShpZHggIT0gbnVsbCkpIHtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKG0gJiYgbVtpZHhdKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgV3JhcHBlciBtZXRob2QgZm9yIHRlc3RpbmcgYSBzdHJpbmcgYWdhaW5zdCBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLV90ZXN0SXRcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7UmVnRXhwfSByZWdFeCBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHRlc3Qgd2l0aFxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICAgICAgQHBhcmFtIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfdGVzdEl0ID0gZnVuY3Rpb24ocmVnRXgsIHN0cikge1xuICAgICAgICByZXR1cm4gcmVnRXgudGVzdChzdHIpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFBhcnNlIGEgdXNlci1hZ2VudCBzdHJpbmcgZnJvbSB0aGUgYnJvd3NlciBhbmQgZ2F0aGVyIHBlcnRpbmVudCBicm93c2VyLCBhbmQgT1MgaW5mb3JtYXRpb25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS5wYXJzZVxuICAgICAgQHN0YXRpY1xuICAgICAgQHB1YmxpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3N1YlVBXSBBbiBhbHRlcm5hdGUgdXNlci1hZ2VudCBzdHJpbmcgdG8gcGFyc2UuIElmIG5vIHZhbGlkIHN0cmluZyBpcyBwYXNzZWQgaW4sIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBiYXNlZCBvbiB0aGUga25vd24gdXNlci1hZ2VudFxuICAgICAgQHJldHVybnMge09iamVjdH0gPGI+cGFyc2VkPC9iPiBCcm93c2VyIGFuZCBPUyBpbmZvcm1hdGlvbjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pZSAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBJbnRlcm5ldCBFeHBsb3JlciBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5vcGVyYSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE9wZXJhIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmdlY2tvIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgR2Vja28gKEZpcmVmb3gpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LndlYmtpdCBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYktpdCBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5zYWZhcmkgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBTYWZhcmkgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uY2hyb21lIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ2hyb21lIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmFpciBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFJUiBTREsgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+Lmlwb2QgV2hldGhlciBvciBub3QgYW4gaVBvZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaXBhZCBXaGV0aGVyIG9yIG5vdCBhbiBpUGFkIGRldmljZSBpcyBiZWluZyB1c2VkIDEgZm9yIHRydWUsIDAgZm9yIGZhbHNlLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pcGhvbmUgV2hldGhlciBvciBub3QgYW4gaVBob25lIGRldmljZSBpcyBiZWluZyB1c2VkIDEgZm9yIHRydWUsIDAgZm9yIGZhbHNlLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5hbmRyb2lkIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQW5kcm9pZCBPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ud2Vib3MgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uc2lsayBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNpbGsgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ubm9kZWpzIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgTm9kZUpTIGVudmlyb25tZW50IGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5waGFudG9tanMgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBQaGFudG9tSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7U3RyaW5nfSA8Yj5wYXJzZWQ8L2I+Lm1vYmlsZSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBvcyBpcyBhIG1vYmlsZSBkZXZpY2UgIGFuZCBpdCdzIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3dpbmRvd3MnLCAnYW5kcm9pZCcsICdzeW1ib3MnLCAnbGludXgnLCAnbWFjaW50b3NoJywgJ3JoaW5vJywgJ2dlY2tvJywgJ0FwcGxlJywgJ2Nocm9tZScuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmlvcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIGlPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtCb29sZWFufSA8Yj5wYXJzZWQ8L2I+LmFjY2VsIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gZW52aXJvbm1lbnQgaW4gcXVlc3Rpb24gaXMgaGFyZHdhcmUgYWNjZWxlcmF0ZWQuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmNhamFWZXJzaW9uIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ0FKQSBlbnZpcm9ubWVudCBvciAwIGlmIG5vdC5cbiAgICAgICAqL1xuICAgICAgcGFyc2VfdWEgPSBmdW5jdGlvbihzdWJVQSkge1xuICAgICAgICB2YXIgZGF0ZSwgZSwgbWF0Y2gsIHJldDtcbiAgICAgICAgcmV0ID0ge307XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAoIXN1YlVBICYmIGNhY2hlZF91YSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWRfdWE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LmllID0gcmV0Lm9wZXJhID0gcmV0LmdlY2tvID0gcmV0LndlYmtpdCA9IHJldC5zYWZhcmkgPSByZXQuY2hyb21lID0gcmV0LmFpciA9IHJldC5pcG9kID0gcmV0LmlwYWQgPSByZXQuaXBob25lID0gcmV0LmFuZHJvaWQgPSByZXQud2Vib3MgPSByZXQuc2lsayA9IHJldC5ub2RlanMgPSByZXQucGhhbnRvbWpzID0gMDtcbiAgICAgICAgcmV0Lm1vYmlsZSA9IHJldC5pb3MgPSByZXQub3MgPSBudWxsO1xuICAgICAgICByZXQuYWNjZWwgPSBmYWxzZTtcbiAgICAgICAgcmV0LmNhamEgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmNhamFWZXJzaW9uO1xuICAgICAgICByZXQuY2tzID0gZmFsc2U7XG4gICAgICAgIHN1YlVBID0gc3ViVUEgfHwgdXNlckFnZW50IHx8IFwiXCI7XG4gICAgICAgIGlmIChzdWJVQSkge1xuICAgICAgICAgIGlmIChfdGVzdEl0KC93aW5kb3dzfHdpbjMyL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJ3aW5kb3dzXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9tYWNpbnRvc2h8bWFjX3Bvd2VycGMvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcIm1hY2ludG9zaFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvYW5kcm9pZC9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwiYW5kcm9pZFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvc3ltYm9zL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJzeW1ib3NcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL2xpbnV4L2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJsaW51eFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoX3Rlc3RJdCgvcmhpbm8vaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICAgIHJldC5vcyA9IFwicmhpbm9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL0tIVE1MLywgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQud2Via2l0ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL0lFTW9iaWxlfFhCTFdQNy8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwid2luZG93c1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvRmVubmVjLywgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQubW9iaWxlID0gXCJnZWNrb1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvQXBwbGVXZWJLaXRcXC8oW15cXHNdKikvLCAxKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldC53ZWJraXQgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgIHJldC5zYWZhcmkgPSByZXQud2Via2l0O1xuICAgICAgICAgICAgaWYgKF90ZXN0SXQoL1BoYW50b21KUy8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvUGhhbnRvbUpTXFwvKFteXFxzXSopLywgMSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5waGFudG9tanMgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90ZXN0SXQoUmVnRXhwKFwiIE1vYmlsZVxcXFwvXCIpLCBzdWJVQSkgfHwgX3Rlc3RJdCgvaVBhZHxpUG9kfGlQaG9uZS8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICByZXQubW9iaWxlID0gXCJBcHBsZVwiO1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT1MgKFteXFxzXSopLywgMSk7XG4gICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2ggJiYgX251bWJlcmlmeShtYXRjaC5yZXBsYWNlKFwiX1wiLCBcIi5cIikpO1xuICAgICAgICAgICAgICByZXQuaW9zID0gbWF0Y2g7XG4gICAgICAgICAgICAgIHJldC5pcGFkID0gcmV0Lmlwb2QgPSByZXQuaXBob25lID0gMDtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL2lQYWR8aVBvZHxpUGhvbmUvLCAwKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0W21hdGNoLnRvTG93ZXJDYXNlKCldID0gcmV0LmlvcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL05va2lhTlteXFwvXSp8QW5kcm9pZCBcXGRcXC5cXGR8d2ViT1NcXC9cXGRcXC5cXGQvLCAwKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IG1hdGNoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGVzdEl0KC93ZWJPUy8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIldlYk9TXCI7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL3dlYk9TXFwvKFteXFxzXSopOy8sIDEpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgcmV0LndlYm9zID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGVzdEl0KFJlZ0V4cChcIiBBbmRyb2lkXCIpLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gXCJBbmRyb2lkXCI7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL0FuZHJvaWQgKFteXFxzXSopOy8sIDEpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgcmV0LmFuZHJvaWQgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoL1NpbGsvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvU2lsa1xcLyhbXlxcc10qKVxcKS8sIDEpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgcmV0LnNpbGsgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuYW5kcm9pZCkge1xuICAgICAgICAgICAgICAgICAgcmV0LmFuZHJvaWQgPSAyLjM0O1xuICAgICAgICAgICAgICAgICAgcmV0Lm9zID0gXCJBbmRyb2lkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGVzdEl0KC9BY2NlbGVyYXRlZD10cnVlLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgICByZXQuYWNjZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2ggPSBzdWJVQS5tYXRjaCgvKENocm9tZXxDck1vKVxcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdICYmIG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgIHJldC5jaHJvbWUgPSBfbnVtYmVyaWZ5KG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgcmV0LnNhZmFyaSA9IDA7XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gXCJDck1vXCIpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gXCJjaHJvbWVcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL0Fkb2JlQUlSXFwvKFteXFxzXSopLyk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5haXIgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldC53ZWJraXQpIHtcbiAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9PcGVyYVtcXHNcXC9dKFteXFxzXSopLywgMSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgcmV0Lm9wZXJhID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9PcGVyYSBNaW5pW147XSovLCAwKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IG1hdGNoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvTVNJRVxccyhbXjtdKikvLCAxKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0LmllID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL0dlY2tvXFwvKFteXFxzXSopLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQuZ2Vja28gPSAxO1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL3J2OihbXlxcc1xcKV0qKS8sIDEpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5nZWNrbyA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIDEwMDApO1xuICAgICAgICAgIHRoZURvY3VtZW50LmNvb2tpZSA9IGxhbmcuY3N0cihbXCJzZl9ja190c3Q9dGVzdDsgZXhwaXJlcz1cIiwgZGF0ZS50b0dNVFN0cmluZygpLCBcIjsgcGF0aD0vXCJdKTtcbiAgICAgICAgICBpZiAodGhlRG9jdW1lbnQuY29va2llLmluZGV4T2YoXCJzZl9ja190c3RcIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXQuY2tzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgcmV0LmNrcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0Lm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICAgICAgICAgICAgcmV0Lm5vZGVqcyA9IG51bWJlcmlmeShwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICByZXQubm9kZWpzID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pZVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBPcGVyYSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQG5hbWUgJHNmLmVudi51YS5vcGVyYVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBHZWNrbyAoRmlyZWZveCkgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuZ2Vja29cbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViS2l0IGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLndlYmtpdFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBTYWZhcmkgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuc2FmYXJpXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENocm9tZSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5jaHJvbWVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQUlSIFNESyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuYWlyXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCBhbiBpUG9kIGRldmljZSBpcyBiZWluZyB1c2VkLCAwIGZvciBmYWxzZSwgJmd0OyAwID09IHRydWVcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaXBvZFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgYW4gaVBhZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCwgMCBmb3IgZmFsc2UsICZndDsgMCA9PSB0cnVlXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlwYWRcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IGFuIGlQaG9uZSBkZXZpY2UgaXMgYmVpbmcgdXNlZCwgMCBmb3IgZmFsc2UsICZndDsgMCA9PSB0cnVlXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlwaG9uZVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBbmRyb2lkIE9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5hbmRyb2lkXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYk9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS53ZWJvc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBTaWxrIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnNpbGtcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgTm9kZUpTIGVudmlyb25tZW50IGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5ub2RlanNcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgUGhhbnRvbUpTIGVudmlyb25tZW50IGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5waGFudG9tanNcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIG9zIGlzIGEgbW9iaWxlIGRldmljZSAgYW5kIGl0J3MgdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSAnd2luZG93cycsICdhbmRyb2lkJywgJ3N5bWJvcycsICdsaW51eCcsICdtYWNpbnRvc2gnLCAncmhpbm8nLCAnZ2Vja28nLCAnQXBwbGUnLCAnY2hyb21lJy5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS5tb2JpbGVcbiAgICAgIEB0eXBlIHtTdHJpbmd9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgaU9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pb3NcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gZW52aXJvbm1lbnQgaW4gcXVlc3Rpb24gaXMgaGFyZHdhcmUgYWNjZWxlcmF0ZWQuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmFjY2VsXG4gICAgICBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDQUpBIGVudmlyb25tZW50IG9yIDAgaWYgbm90XG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmNhamFWZXJzaW9uXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG4gICAgICBjYWNoZWRfdWEgPSBwYXJzZV91YSgpO1xuICAgICAgY2FjaGVkX3VhLnBhcnNlID0gcGFyc2VfdWE7XG4gICAgICByZXR1cm4gY2FjaGVkX3VhO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVhOiB1YSxcbiAgICAgIGlzSUU6IGlzSUVcbiAgICB9O1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjhEd29oUlwiKSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBQYXJhbUhhc2gsIGJhY2tTbGFzaCwgY2FsbGFibGUsIGNib29sLCBjbnVtLCBjc3RyLCBkZWYsIGVudGl0eU1hcCwgZW50aXR5UmVnZXhlcywgZ3VpZCwgaXNBcnJheSwganNzYWZlX2h0bWwsIGxhbmcsIG1peCwgbmV4dF9pZCwgbm9vcCwgbnMsIHByb3RvLCByYW5kLCBzY3JpcF9zdHIsIHRpbWUsIHRvU3RyaW5nLCB0cmltLCB3aW4sIHdyYXAsIF9lcywgX2tleXMsIF91ZTtcbiAgICBuZXh0X2lkID0gMDtcbiAgICB3aW4gPSB3aW5kb3c7XG4gICAgYmFja1NsYXNoID0gU3RyaW5nLmZyb21DaGFyQ29kZSg5Mik7XG4gICAgc2NyaXBfc3RyID0gJ3NjclwiK1wiaXB0JztcbiAgICBfZXMgPSB3aW4uZXNjYXBlO1xuICAgIF91ZSA9IHdpbi51bmVzY2FwZTtcblxuICAgIC8qXG4gICAgQSBmdW5jdGlvbiByZWZlcmVuY2UgdGhhdCBkb2VzIG5vdGhpbmcuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG5vb3AgYXMgJHNmLmxpYi5sYW5nLm5vb3BcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHB1YmxpY1xuICAgIEByZXR1cm4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgbm9vcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAvKlxuICAgICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIHN0cmluZyB2YWx1ZS5cbiAgICAgIE5vdGUgdGhhdCBcImZhbHN5XCIgdmFsdWVzIG9yIHZhbHVlcyB0aGF0IGNhbm5vdCBiZSBjb252ZXJ0ZWQgd2lsbCBiZSByZXR1cm5lZFxuICAgICAgYXMgYW4gZW1wdHkgc3RyaW5nIChcIlwiKS5cbiAgICAgIFxuICAgICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgICAgQGV4cG9ydHMgY3N0ciBhcyAkc2YubGliLmxhbmcuY3N0clxuICAgICAgQHN0YXRpY1xuICAgICAgQHB1YmxpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyp9IHN0ciAgQW55IG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZyB2YWx1ZS5cbiAgICAgIEByZXR1cm4ge1N0cmluZ30gIFRoZSBub3JtYWxpemVkIHN0cmluZyB2YWx1ZS5cbiAgICAgICAqL1xuICAgIH07XG4gICAgY3N0ciA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHR5cDtcbiAgICAgIHR5cCA9IHR5cGVvZiBzdHI7XG4gICAgICBpZiAodHlwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBpZiAodHlwID09PSBcIm51bWJlclwiICYmICFzdHIpIHtcbiAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJvYmplY3RcIiAmJiBzdHIgJiYgc3RyLmpvaW4pIHtcbiAgICAgICAgcmV0dXJuIHN0ci5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBGb3JjZXMgdHlwZSBjb252ZXJzaW9uIG9mIGFueSBKYXZhU2NyaXB0IHZhcmlhYmxlIHRvIGEgYm9vbGVhbi5cbiAgICBcIkZhbHN5XCIgdmFsdWVzIHN1Y2ggYXMgXCJcIiwgMCwgbnVsbCwgYW5kIHVuZGVmaW5lZCBhbGwgcmV0dXJuIGZhbHNlXG4gICAgU3RyaW5nIHZhbHVlcyBvZiAgXCIwXCIsIFwiZmFsc2VcIiwgXCJub1wiLCBcInVuZGVmaW5lZFwiLCBcIm51bGxcIiBhbHNvIHJldHVybiBmYWxzZVxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjYm9vbCBhcyAkc2YubGliLmxhbmcuY2Jvb2xcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7Kn0gdmFsIEFueSBKYXZhU2NyaXB0IHJlZmVyZW5jZSAvIHZhbHVlXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vcm1hbGl6ZWQgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIGNib29sID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAoIXZhbCB8fCB2YWwgPT09IFwiMFwiIHx8IHZhbCA9PT0gXCJmYWxzZVwiIHx8IHZhbCA9PT0gXCJub1wiIHx8IHZhbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWwgPT09IFwibnVsbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgX2tleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBrLCBfdjtcbiAgICAgIHJldHVybiAodHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3Qua2V5cyhvYmopIDogdm9pZCAwKSB8fCAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICBfdiA9IG9ialtrXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBudW1iZXIuXG4gICAgVmFsdWVzIC8gb2JqZWN0cyB0aGF0IGNhbm5vdCBiZSBjb252ZXJ0ZWQsIHdpbGwgYmUgcmV0dXJuZWQgYXMgTmFOLCB1bmxlc3NcbiAgICBhIGRlZmF1bHQgdmFsdWUgaXMgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHVzZWQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGNudW0gYXMgJHNmLmxpYi5sYW5nLmNudW1cbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7Kn0gdmFsIEFueSBKYXZhU2NyaXB0IHJlZmVyZW5jZSAvIHZhbHVlXG4gICAgQHBhcmFtIHsqfSBbZGVmVmFsXSB1c2UgdGhpcyB2YWx1ZSBpZiBvcmlnaW5hbCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLCBvciBpZiB2YWx1ZSBpcyBsZXNzIHRoYW4gbWluIHZhbHVlLCBvciBpZiB2YWx1ZSBpcyBsZXNzIHRoYW4gbWF4IHZhbHVlLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbbWluVmFsXSBzcGVjaWZpZXMgdGhlIGxvd2VzdCBudW1lcmljYWwgdmFsdWUsIGlmIG9yaWdpbmFsIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLCB0aGUgZGVmVmFsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgQHBhcmFtIHtOdW1iZXJ9IFttYXhWYWxdIHNwZWNpZmllcyB0aGUgZ3JlYXRlc3QgbnVtZXJpY2FsIHZhbHVlLCBpZiBvcmlnaW5hbCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGRlZlZhbCB3aWxsIGJlIHJldHVybmVkLlxuICAgIEByZXR1cm4ge051bWJlcnxOYU58Kn0gdGhlIGNvbnZlcnRlZCB2YWx1ZSwgb3RoZXJ3aXNlIE5hTiBvciBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgY251bSA9IGZ1bmN0aW9uKHZhbCwgZGVmVmFsLCBtaW5WYWwsIG1heFZhbCkge1xuICAgICAgdmFyIGU7XG4gICAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHZhbCA9IE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXhWYWwgPT0gbnVsbCkge1xuICAgICAgICBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKG1pblZhbCA9PSBudWxsKSB7XG4gICAgICAgIG1pblZhbCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKChpc05hTih2YWwpIHx8IHZhbCA8IG1pblZhbCB8fCB2YWwgPiBtYXhWYWwpICYmIChkZWZWYWwgIT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZlZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIHRoYXQgYSBmdW5jdGlvbiByZWZlcmVuY2UgY2FuIGJlIGNhbGxlZCBzYWZlbHkuICBTb21ldGltZXMgZnVuY3Rpb24gcmVmZXJlbmNlcyBhcmUgcGFydFxuICAgIG9mIG9iamVjdHMgdGhhdCBtYXkgaGF2ZSBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkIChzdWNoIGFzIGEgZnVuY3Rpb24gcmVmZXJlbmNlIGZyb20gYW5vdGhlciB3aW5kb3cgb3IgZG9tIGVsZW1lbnQpLlxuICAgIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGUgcmVmZXJlbmNlIGJ5IG1ha2luZyBzdXJlIGl0IGhhcyBhIGNvbnN0cnVjdG9yIGFuZCB0b1N0cmluZyBwcm9wZXJ0aWVzLlxuICAgIFxuICAgIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBmdW5jdGlvbiBpdHNlbGYgd2hlbiBjYWxsZWQgKG9yIGl0cyBzdWJzcXVlbnQgY2FsbCBzdGFjayksIGNhbid0IHRocm93IGFuIGVycm9yLiAuIC5cbiAgICBzaW1wbHkgdGhhdCB5b3UgYXJlIGFibGUgdG8gY2FsbCBpdC4gLiAuXG4gICAgXG4gICAgdGhpcyBjYW4gcHJvYmxlbSBiZSByZW1vdmVkIGluIGxpZXUgb2YgZnVuYz8oKSBpbiBjc1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjYWxsYWJsZSBhcyAkc2YubGliLmxhbmcuY2FsbGFibGVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IEEgcmVmZXJlbmNlIHRvIGEgSmF2YVNjcmlwdCBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBzYWZlbHksIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBjYWxsYWJsZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHZhciBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiA9IChmICYmIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIgJiYgZi50b1N0cmluZygpICYmIChuZXcgZi5jb25zdHJ1Y3RvcigpKSA/IGYgOiBudWxsKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBmID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIWY7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2VuZXJhdGUgYSB1bmlxdWUgaWQgc3RyaW5nXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGd1aWQgYXMgJHNmLmxpYi5sYW5nLmd1aWRcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBhIHN1YnN0cmluZyB0byB1c2UgYSBwcmVmaXhcbiAgICBAcmV0dXJuIHtTdHJpbmd9IHVuaXF1ZSBpZCBzdHJpbmdcbiAgICAgKi9cbiAgICBndWlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICByZXR1cm4gY3N0cihbcHJlZml4IHx8IFwiXCIsIFwiX1wiLCB0aW1lKCksIFwiX1wiLCByYW5kKCksIFwiX1wiLCBuZXh0X2lkKytdKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNaXhlZCB0aGUgcHJvcGVydGllcyBvZiBvbmUgb2JqZWN0IGludG8gYW5vdGhlciBvYmplY3QuXG4gICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgcmVjdXJzaXZlXG4gICAgXG4gICAgXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG1peCBhcyAkc2YubGliLmxhbmcubWl4XG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge09iamVjdH0gIHIgIFRoZSBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGVydGllc1xuICAgIEBwYXJhbSB7T2JqZWN0fSAgcyAgVGhlIG9iamVjdCB0aGF0IHdpbGwgZGVsaWV2ZXIgcHJvcGVydGllc1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW293bmVkXSBXaGV0aGVyIG9yIG5vdCB0byBza2lwIG92ZXIgcHJvcGVydGllcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBvYmplY3QgcHJvdG90eXBlXG4gICAgQHBhcmFtIHtCb29sZWFufSBbc2tpcEZ1bmNzXSBXaGV0aGVyIG9yIG5vdCB0byBza2lwIG92ZXIgZnVuY3Rpb24gcmVmZXJlbmNlc1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW25vX292cl0gV2hldGhlciBvciBub3QgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgdGhhdCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gZmlsbGVkIG91dFxuICAgIEByZXR1cm4ge09iamVjdH0gVGhlIHJlY2VpdmVyIG9iamVjdCBwYXNzZWQgaW4gd2l0aCBwb3RlbnRpYWxseSBuZXcgcHJvcGVydGllcyBhZGRlZFxuICAgICAqL1xuICAgIG1peCA9IGZ1bmN0aW9uKHIsIHMsIG93bmVkLCBza2lwRnVuY3MsIG5vX292cikge1xuICAgICAgdmFyIGl0ZW0sIHAsIHR5cDtcbiAgICAgIGlmICghcyB8fCAhcikge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGZvciAocCBpbiBzKSB7XG4gICAgICAgIGl0ZW0gPSBzW3BdO1xuICAgICAgICB0eXAgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKG93bmVkICYmICFzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vX292ciAmJiAocCBpbiByKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwRnVuY3MgJiYgdHlwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwID09PSBcIm9iamVjdFwiICYmIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoaXRlbS5zbGljZSkge1xuICAgICAgICAgICAgaXRlbSA9IG1peChbXSwgaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtaXgoe30sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByW3BdID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcywgZnJvbSB0aGUgZXBvY2hcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgdGltZSBhcyAkc2YubGliLmxhbmcudGltZVxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHJldHVybiB7TnVtYmVyfSBjdXJyZW50IHRpbWVcbiAgICAgKi9cbiAgICB0aW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBhbnl3aGVyZSBmcm9tIDAgdG8gOTlcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgcmFuZCBhcyAkc2YubGliLmxhbmcucmFuZFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHJldHVybiB7TnVtYmVyfSByYW5kb20gbnVtYmVyXG4gICAgICovXG4gICAgcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVHJpbSB0aGUgYmVnaW5pbmcgYW5kIGVuZGluZyB3aGl0ZXNwYWNlIGZyb20gYSBzdHJpbmcuXG4gICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGFuIGFyZ3VtZW50IHRvIGEgc3RyaW5nIGZpcnN0XG4gICAgZm9yIHR5cGUgc2FmZXR5IHB1cnBvc2VzLiBJZiBzdHJpbmcgY2Fubm90IGJlIGNvbnZlcnRlZCwgYW5kIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyB0cmltIGFzICRzZi5saWIubGFuZy50cmltXG4gICAgQHJldHVybiB7U3RyaW5nfSB0cmltbWVkIHN0cmluZ1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgdHJpbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHJldDtcbiAgICAgIHJldCA9IGNzdHIoc3RyKTtcbiAgICAgIHJldHVybiByZXQgJiYgcmV0LnJlcGxhY2UoL15cXHNcXHMqLywgXCJcIikucmVwbGFjZSgvXFxzXFxzKiQvLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBEZWZpbmUgYSBKYXZhU2NyaXB0IE5hbWVzcGFjZSB3aXRoaW4gYSBnaXZlbiBjb250ZXh0XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGRlZiBhcyAkc2YubGliLmxhbmcuZGVmXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cl9ucyAgVGhlIG5hbWUgb2YgdGhlIG5hbWVzcGFjZSBpbiBkb3Qgbm90YXRpb24gYXMgYSBzdHJpbmcgKGUuZy4gXCJGb28uYmFyXCIpXG4gICAgQHBhcmFtIHtPYmplY3R9IFthdWddIGRlZmluZXMgdGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lc3BhY2UuICBJZiBuYW1lc3BhY2UgaXMgYWxyZWFkeSBzcGVjaWZpZWQsIGFuZCB0aGlzIG9iamVjdCBpcyBwcm92aWRlZCwgdGhlIG5hbWVzcGFjZSB3aWxsIGJlIGF1Z21lbnRlZCB3aXRoIHByb3BlcnRpZXMgZnJvbSB0aGlzIG9iamVjdC4gSWYgbm90aGluZyBpcyBwYXNzZWQgaW4sIGRlZmF1bHRzIHRvIHVzaW5nIGFuIGVtcHR5IG9iamVjdC5cbiAgICBAcGFyYW0ge09iamVjdH0gW3Jvb3RdIHRoZSByb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBuYW1lc3BhY2UgaXMgZGVmaW5lZC4gIElmIG5vdCBwYXNzZWQgaW4gZGVmYXVsdHMgdG8gdGhlIGdsb2JhbC93aW5kb3cgb2JqZWN0XG4gICAgQHBhcmFtIHtCb29sZWFufSBbbm9fb3ZyXSBpZiB0cnVlLCBwcm9wZXJ0aWVzIGFscmVhZHkgZGVmaW5lZCBvbiByb290IHdpdGggdGhlIHNhbWUgbmFtZSB3aWxsIGJlIGlnbm9yZWRcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBkZWYgPSBmdW5jdGlvbihzdHJfbnMsIGF1Zywgcm9vdCwgbm9fb3ZyKSB7XG4gICAgICB2YXIgYXIsIGlkeCwgaXRlbSwgb2JqLCBwZXIsIHJldDtcbiAgICAgIG9iaiA9IChyb290ICYmIHR5cGVvZiByb290ID09PSBcIm9iamVjdFwiID8gcm9vdCA6IHdpbik7XG4gICAgICBpZHggPSAwO1xuICAgICAgcGVyID0gXCIuXCI7XG4gICAgICByZXQgPSBudWxsO1xuICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICBzdHJfbnMgPSBjc3RyKHN0cl9ucyk7XG4gICAgICAgIGF1ZyA9IChhdWcgJiYgdHlwZW9mIGF1ZyA9PT0gXCJvYmplY3RcIiA/IGF1ZyA6IG51bGwpO1xuICAgICAgICBpZiAoc3RyX25zLmluZGV4T2YocGVyKSkge1xuICAgICAgICAgIGFyID0gc3RyX25zLnNwbGl0KHBlcik7XG4gICAgICAgICAgd2hpbGUgKGl0ZW0gPSBhcltpZHgrK10pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0cmltKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChvYmpbaXRlbV0gJiYgYXVnKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gbWl4KG9ialtpdGVtXSwgYXVnLCBmYWxzZSwgbnVsbCwgbm9fb3ZyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9fb3ZyICYmIChpdGVtIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gb2JqW2l0ZW1dIHx8IGF1ZyB8fCB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChub19vdnIgJiYgKGl0ZW0gaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV0gPSBvYmpbaXRlbV0gfHwge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9ialtpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9ialtzdHJfbnNdICYmIGF1Zykge1xuICAgICAgICAgICAgcmV0ID0gb2JqW3N0cl9uc10gPSBtaXgob2JqW3N0cl9uc10sIGF1ZywgZmFsc2UsIG51bGwsIG5vX292cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IG9ialtzdHJfbnNdID0gb2JqW3N0cl9uc10gfHwgYXVnIHx8IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBKYXZhU2NyaXB0IG5hbWVzcGFjZVxuICAgIGFzIG9wcG9zZWQgdG8gZGVmLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmaW5lIHRoZSBuYW1lc3BhY2VcbiAgICB3aXRoIGEgZ2l2ZW4gY29udGV4dC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgbnMgYXMgJHNmLmxpYi5sYW5nLm5zXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cl9ucyAgQSBzdHJpbmcgd2l0aCAuIG9yIFtdIG5vdGF0aW9uIG9mIGEgSmF2YVNjcmlwdCBuYW1lc2FjZSAoZS5nLiBcImZvby5iYXIuc2hvd1wiLCBvciBcImZvb1snYmFyJ11bJ3Nob3cnXVwiKS5cbiAgICBAcGFyYW0ge09iamVjdH0gW3Jvb3RdIHRoZSByb290IG9iamVjdCB0byBjaGVjayB3aXRoaW4uIC5kZWZhdWx0cyB0byBnbG9iYWwgLyB3aW5kb3dcbiAgICBAcmV0dXJuIHsqfSBUaGUgZW5kcG9pbnQgcmVmZXJlbmNlIG9mIHRoZSBuYW1lc3BhY2Ugb3IgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICBucyA9IGZ1bmN0aW9uKHN0cl9ucywgcm9vdCkge1xuICAgICAgdmFyIGV4aXN0cywgZXhwLCBleHAyLCBleHAzLCBleHA0LCBpZHgsIG1hdGNoZXMsIG9iaiwgcHJvcCwgcm9vdFN0cjtcbiAgICAgIGV4cCA9IC8oXFxbKC57MSx9KVxcXSl8KFxcLlxcdyspL2c7XG4gICAgICBleHAyID0gL1xcWygoJ3xcIik/KSgoXFxzfC4pKj8pKCgnfFwiKT8pXFxdL2c7XG4gICAgICBleHAzID0gLyhcXFsuKil8KFxcLi4qKS9nO1xuICAgICAgZXhwNCA9IC9cXC4vZztcbiAgICAgIGlkeCA9IDA7XG4gICAgICByb290U3RyID0gXCJcIjtcbiAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICBvYmogPSByb290ID0gcm9vdCB8fCB3aW47XG4gICAgICBpZiAoc3RyX25zKSB7XG4gICAgICAgIHN0cl9ucyA9IGNzdHIoc3RyX25zKTtcbiAgICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICAgIHN0cl9ucyA9IHRyaW0oc3RyX25zKTtcbiAgICAgICAgICBtYXRjaGVzID0gc3RyX25zLm1hdGNoKGV4cCk7XG4gICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJvb3RTdHIgPSBzdHJfbnMucmVwbGFjZShleHAzLCBcIlwiKTtcbiAgICAgICAgICAgIG1hdGNoZXMudW5zaGlmdChyb290U3RyKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9wID0gbWF0Y2hlc1tpZHgrK10pIHtcbiAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZShleHAyLCBcIiQzXCIpLnJlcGxhY2UoZXhwNCwgXCJcIik7XG4gICAgICAgICAgICAgIGlmICghb2JqW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wID0gc3RyX25zO1xuICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGV4aXN0cyAmJiBvYmopIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBmdW5jdGlvblxuICAgIFRlc3RzIHRvIHNlZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpcyBhbiBhcnJheVxuICAgICAqL1xuICAgIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKG9iai5sZW5ndGggIT0gbnVsbCkgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBKYXZhU2NyaXB0IG5hbWVzcGFjZVxuICAgIGFzIG9wcG9zZWQgdG8gZGVmLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmaW5lIHRoZSBuYW1lc3BhY2VcbiAgICB3aXRoIGEgZ2l2ZW4gY29udGV4dC4gICAgICAgICB2aWEgdW5kZXJzY29yZS5qc1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBucyBhcyAkc2YubGliLmxhbmcud3JhcFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIGZ1bmN0aW9uXG4gICAgQHJldHVybiB7RnVuY3Rpb259XG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICB3cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgYXJncyA9IFtmdW5jXTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdpdmVuIGEgc3RyaW5nIG9mIEhUTUwgZXNjYXBlIHF1b3RlIG1hcmtzIGFuZCBzZXBlcmF0ZSBzY3JpcHQgdGFncyBzbyB0aGF0IGJyb3dzZXJzIGRvbid0IGdldCB0cmlwcGVkIHVwXG4gICAgZHVyaW5nIHByb2Nlc3NpbmcuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGpzc2FmZV9odG1sIGFzICRzZi5saWIubGFuZy5qc3NhZmVfaHRtbFxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBzdHJpbmcgb2YgSFRNTCBtYXJrdXAgdG8gYmUgcHJvY2Vzc2VkXG4gICAgQHJldHVybiB7U3RyaW5nfVxuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgICovXG4gICAgZW50aXR5TWFwID0ge1xuICAgICAgZXNjYXBlOiB7XG4gICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgICB9XG4gICAgfTtcbiAgICBlbnRpdHlSZWdleGVzID0ge1xuICAgICAgZXNjYXBlOiBuZXcgUmVnRXhwKCdbJyArIF9rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpXG4gICAgfTtcbiAgICBqc3NhZmVfaHRtbCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoJycgKyBzdHJpbmcpLnJlcGxhY2UoZW50aXR5UmVnZXhlcy5lc2NhcGUsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlNYXAuZXNjYXBlW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBjbGFzcyBJbnRhbnRpYWJsZSBjbGFzcyB1c2VkIHRvIGNvbnZlcnQgYSBkZWxpbWl0ZWQgc3RyaW5nIGludG8gYW4gb2JqZWN0LjxiciAvPlxuICAgIEZvciBleGFtcGxlIHF1ZXJ5c3RyaW5nczogXCJuYW1lXzE9dmFsdWVfMSZuYW1lXzI9dmFsdWVfMlwiID09PiB7bmFtZV8xOnZhbHVlXzEsbmFtZV8yOnZhbHVlXzJ9Ozxici8+PGJyIC8+XG4gICAgXG4gICAgTm90ZSB0aGF0IHByb3BlcnR5IHZhbHVlcyBjb3VsZCBhbHNvIGNvbnRhaW4gdGhlIHNhbWUgc1Byb3BEZWxpbSBhbmQgc1ZhbHVlRGVsaW0gc3RyaW5ncy4gIFByb3BlciBzdHJpbmcgZW5jb2Rpbmcgc2hvdWxkIG9jY3VyXG4gICAgdG8gbm90IHRyaXAgdXAgdGhlIHBhcnNpbmcgb2YgdGhlIHN0cmluZy4gIFNhaWQgdmFsdWVzIG1heSBiZSBhc2NpaSBlc2NhcGVkLCBhbmQgaW4gdHVybiwgYWxvbmcgd2l0aCB0aGUgPGk+PGI+YlJlY3Vyc2U8L2I+PC9pPiBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc2V0IHRvIHRydWUsIHdpbGwgY2F1c2UgbmVzdGVkIFBhcmFtSGFzaCBvYmplY3RzIHRvIGJlIGNyZWF0ZWQuXG4gICAgXG4gICAgQGNvbnN0cnVjdG9yXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIFBhcmFtSGFzaCBhcyAkc2YubGliLmxhbmcuUGFyYW1IYXNoXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzU3RyaW5nXSAgVGhlIGRlbGltaXRlZCBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzUHJvcERlbGltPVwiJlwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZXIgdXNlZCB0byBzZXBlcmF0ZSBwcm9wZXJ0aWVzLiBEZWZhdWx0IGlzIFwiJlwiLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1ZhbHVlRGVsaW09XCI9XCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlZCB1c2VkIHRvIHNlcGVyYXRlIHZhbHVlcy4gIERlZmF1bHQgaXMgXCI9XCIuXG4gICAgQHBhcmFtIHtCb29sZWFufSBbYk5vT3ZlcndyaXRlPWZhbHNlXSAgSWYgdHJ1ZSwgd2hlbiBhIG5hbWUgaXMgZW5jb3VudGVyZWQgbW9yZSB0aGFuIDEgdGltZSBpbiB0aGUgc3RyaW5nIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtiUmVjdXJzZT1mYWxzZV0gIElmIHRydWUsIHdoZW4gYSB2YWx1ZSBvZiBhIHByb3BlcnR5IHRoYXQgaXMgcGFyc2VkIGFsc28gaGFzIGJvdGggdGhlIHNQcm9wRGVsaW0gYW5kIHNWYWx1ZURlbGltIGluc2lkZSwgY29udmVydCB0aGF0IHZhbHVlIHRvIGFub3RoZXIgUGFyYW1IYXNoIG9iamVjdCBhdXRvbWF0aWNhbGx5XG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng9MSZ5PTEmej0xXCIpO1xuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vID09IDFcbiAgICBhbGVydChwaC56KTsgLy8gPT0gMVxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4OjE7eToyO3o6M1wiLCBcIjtcIiwgXCI6XCIpO1xuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vID09IDJcbiAgICBhbGVydChwaC56KTsgLy8gPT0gM1xuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4PTEmeT0xJno9MSZ6PTJcIik7XG4gICAgYWxlcnQocGgueCk7IC8vID09IDFcbiAgICBhbGVydChwaC55KTsgLy8gMVxuICAgIGFsZXJ0KHBoLnopOyAvL05vdGUgdGhhdCB6ID09IDIgYi9jIG9mIDIgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieD0xJnk9MSZ6PTEmej0yXCIsbnVsbCxudWxsLHRydWUpOyAvL251bGwgZm9yIHNQcm9wRGVsaW0gYW5kIHNWYWx1ZURlbGltID09IHVzZSBkZWZhdWx0IHZhbHVlcyBvZiBcIiZcIiBhbmQgXCI9XCIgcmVzcGVjdGl2ZWx5XG4gICAgYWxlcnQocGgueCk7IC8vID09IDFcbiAgICBhbGVydChwaC55KTsgLy8gMVxuICAgIGFsZXJ0KHBoLnopOyAvL05vdGUgdGhhdCB6ID09IDEgYi9jIGJOb092ZXJ3cml0ZSB3YXMgc2V0IHRvIHRydWVcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIC8vWW91IGNhbiBhbHNvIGRvIHJlY3Vyc2l2ZSBwcm9jZXNzaW5nIGlmIG5lZWQgYmVcbiAgICB2YXIgcG9pbnRzXHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKCksXG4gICAgcG9pbnRfMVx0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpLFxuICAgIHBvaW50XzJcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKTtcbiAgICBcbiAgICBwb2ludF8xLnggPSAxMDA7XG4gICAgcG9pbnRfMS55ID0gNzU7XG4gICAgXG4gICAgcG9pbnRfMi54ID0gMjAwO1xuICAgIHBvaW50XzIueSA9IDE1MDtcbiAgICBcbiAgICBwb2ludHMucG9pbnRfMVx0PSBwb2ludF8xO1xuICAgIHBvaW50cy5wb2ludF8yXHQ9IHBvaW50XzI7XG4gICAgXG4gICAgdmFyIHBvaW50X3N0clx0PSBwb2ludHMudG9TdHJpbmcoKTsgIC8vID09IFwicG9pbnRfMT14JTNEMTAwJTI2eSUzRDc1JTI2JnBvaW50XzI9eCUzRDIwMCUyNnklM0QxNTAlMjYmXCI7XG4gICAgdmFyIHBvaW50c19jb3B5XHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKHBvaW50X3N0ciwgbnVsbCwgbnVsbCwgdHJ1ZSwgdHJ1ZSk7IC8vbm90ZSBwYXNzaW5nIHRydWUsIGIvYyB3ZSB3YW50IHRvIHJlY3Vyc2VcbiAgICBcbiAgICBhbGVydChwb2ludHNfY29weS5wb2ludF8xLngpIC8vID09IFwiMTAwXCI7XG4gICAgICovXG4gICAgUGFyYW1IYXNoID0gZnVuY3Rpb24oc1N0cmluZywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpIHtcbiAgICAgIHZhciBhZGRlZCwgY250LCBkb0FkZCwgaWR4LCBpZHgyLCBpZHgzLCBpbywgbGVuLCBsZW4yLCBtZSwgbm0sIG52LCBvYmosIHBhaXJzLCBzVGVtcCwgc1RlbXAyLCBzVGVtcDMsIHNzO1xuICAgICAgbWUgPSB0aGlzO1xuICAgICAgaW8gPSBcImluZGV4T2ZcIjtcbiAgICAgIHNzID0gXCJzdWJzdHJpbmdcIjtcbiAgICAgIGRvQWRkID0gZmFsc2U7XG4gICAgICBpZiAoIShtZSBpbnN0YW5jZW9mIFBhcmFtSGFzaCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbUhhc2goc1N0cmluZywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpO1xuICAgICAgfVxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtZTtcbiAgICAgIH1cbiAgICAgIGlmIChzU3RyaW5nICYmIHR5cGVvZiBzU3RyaW5nID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBtaXgobmV3IFBhcmFtSGFzaChcIlwiLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSksIHNTdHJpbmcpO1xuICAgICAgfVxuICAgICAgc1N0cmluZyA9IGNzdHIoc1N0cmluZyk7XG4gICAgICBzUHJvcERlbGltID0gY3N0cihzUHJvcERlbGltKSB8fCBcIiZcIjtcbiAgICAgIHNWYWx1ZURlbGltID0gY3N0cihzVmFsdWVEZWxpbSkgfHwgXCI9XCI7XG4gICAgICBpZiAoIXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgfVxuICAgICAgaWYgKHNQcm9wRGVsaW0gIT09IFwiP1wiICYmIHNWYWx1ZURlbGltICE9PSBcIj9cIiAmJiBzU3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHtcbiAgICAgICAgc1N0cmluZyA9IHNTdHJpbmdbc3NdKDEpO1xuICAgICAgfVxuICAgICAgaWR4ID0gc1N0cmluZ1tpb10oXCI/XCIpO1xuICAgICAgaWR4MiA9IHNTdHJpbmdbaW9dKHNWYWx1ZURlbGltKTtcbiAgICAgIGlmIChpZHggIT09IC0xICYmIGlkeDIgIT09IC0xICYmIGlkeCA+IGlkeDIpIHtcbiAgICAgICAgc1RlbXAgPSBfZXMoc1N0cmluZ1tzc10oaWR4MiArIDEpKTtcbiAgICAgICAgc1RlbXAyID0gc1N0cmluZy5zdWJzdHIoMCwgaWR4MiArIDEpO1xuICAgICAgICBzU3RyaW5nID0gc1RlbXAyICsgc1RlbXA7XG4gICAgICB9IGVsc2UgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgc1N0cmluZyA9IHNTdHJpbmdbc3NdKGlkeCArIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtSGFzaChzU3RyaW5nLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzU3RyaW5nLmNoYXJBdCgwKSA9PT0gc1Byb3BEZWxpbSkge1xuICAgICAgICBzU3RyaW5nID0gc1N0cmluZ1tzc10oMSk7XG4gICAgICB9XG4gICAgICBwYWlycyA9IHNTdHJpbmcuc3BsaXQoc1Byb3BEZWxpbSk7XG4gICAgICBjbnQgPSBwYWlycy5sZW5ndGg7XG4gICAgICBpZHggPSAwO1xuICAgICAgd2hpbGUgKGNudC0tKSB7XG4gICAgICAgIHNUZW1wID0gcGFpcnNbaWR4KytdO1xuICAgICAgICBhZGRlZCA9IGZhbHNlO1xuICAgICAgICBkb0FkZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc1RlbXApIHtcbiAgICAgICAgICBudiA9IHNUZW1wLnNwbGl0KHNWYWx1ZURlbGltKTtcbiAgICAgICAgICBsZW4gPSBudi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgIG5tID0gX3VlKG52WzBdKTtcbiAgICAgICAgICAgIG52LnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoYlJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgc1RlbXAyID0gbm0gKyBzVmFsdWVEZWxpbTtcbiAgICAgICAgICAgICAgaWR4MiA9IHNTdHJpbmdbaW9dKHNUZW1wMik7XG4gICAgICAgICAgICAgIGxlbiA9IHNUZW1wMltMRU5dO1xuICAgICAgICAgICAgICBzVGVtcDMgPSBzU3RyaW5nW3NzXShpZHgyICsgbGVuKTtcbiAgICAgICAgICAgICAgc1RlbXAyID0gc1Byb3BEZWxpbSArIHNQcm9wRGVsaW07XG4gICAgICAgICAgICAgIGxlbjIgPSBzVGVtcDJbTEVOXTtcbiAgICAgICAgICAgICAgaWR4MyA9IHNUZW1wM1tpb10oc1RlbXAyKTtcbiAgICAgICAgICAgICAgaWYgKGlkeDMgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc1RlbXAzID0gc1N0cmluZy5zdWJzdHIoaWR4MiArIGxlbiwgaWR4MyArIGxlbjIpO1xuICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBQYXJhbUhhc2goc1RlbXAzLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSk7XG4gICAgICAgICAgICAgICAgc1RlbXAzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoc1RlbXAzIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBpZHggKz0gbGVuIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc1RlbXAgPSBvYmo7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc1RlbXAgPSBfdWUobnYuam9pbihzVmFsdWVEZWxpbSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzVGVtcCA9IF91ZShudi5qb2luKHNWYWx1ZURlbGltKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb0FkZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICAgIG5tID0gX3VlKG52WzBdKTtcbiAgICAgICAgICAgIHNUZW1wID0gX3VlKG52WzFdKTtcbiAgICAgICAgICAgIGRvQWRkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvQWRkKSB7XG4gICAgICAgICAgICBpZiAoYk5vT3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgIGlmICghKG5tIGluIG1lKSkge1xuICAgICAgICAgICAgICAgIG1lW25tXSA9IHNUZW1wO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWVbbm1dID0gc1RlbXA7XG4gICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiUmVjdXJzZSAmJiBhZGRlZCAmJiBubSAmJiBzVGVtcCAmJiB0eXBlb2Ygc1RlbXAgIT09IFwib2JqZWN0XCIgJiYgKHNUZW1wW2lvXShzUHJvcERlbGltKSA+PSAwIHx8IHNUZW1wW2lvXShzVmFsdWVEZWxpbSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgbWVbbm1dID0gbmV3IFBhcmFtSGFzaChzVGVtcCwgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIENvbnZlcnRzIGEgUGFyYW1IYXNoIG9iamVjdCBiYWNrIGludG8gYSBzdHJpbmcgdXNpbmcgdGhlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWxpbWl0ZXJzIHNwZWNpZmVkIChkZWZhdWx0cyB0byBcIiZcIiBhbmQgXCI9XCIpLlxuICAgIEFnYWluIHRoaXMgbWV0aG9kIHdvcmtzIHJlY3Vyc2l2ZWx5LiAgSWYgYW4gb2JqZWN0IGlzIGZvdW5kIGFzIGEgcHJvcGVydHksIGl0IHdpbGwgY29udmVydCB0aGF0IG9iamVjdCBpbnRvIGEgUGFyYW1IYXNoIHN0cmluZ1xuICAgIGFuZCB0aGVuIGVzY2FwZSBpdC4gTm90ZSBhbHNvIHRoYXQgdGhpcyBjbGFzcydzIHZhbHVlT2YgbWV0aG9kIGlzIGVxdWFsIHRvIHRoaXMgbWV0aG9kLlxuICAgIFxuICAgIEBtZXRob2RPZiBQYXJhbUhhc2gjXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1Byb3BEZWxpbT1cIiZcIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVyIHVzZWQgdG8gc2VwZXJhdGUgcHJvcGVydGllcy4gRGVmYXVsdCBpcyBcIiZcIi5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NWYWx1ZURlbGltPVwiPVwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZWQgdXNlZCB0byBzZXBlcmF0ZSB2YWx1ZXMuICBEZWZhdWx0IGlzIFwiPVwiLlxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2VzY2FwZVByb3A9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGFzY2lpIGVzY2FwZSB0aGUgbmFtZSBvZiBhIHByb3BlcnR5XG4gICAgQHBhcmFtIHtCb29sZWFufSBbZG9udEVzY2FwZVZhbHVlPWZhbHNlXSBEbyBub3QgZXNjYXBlIHZhbHVlcyBvciBwcm9wZXJ0aWVzIGF1dG9tYXRpY2FsbHlcbiAgICBAcmV0dXJuIHtTdHJpbmd9IHRoZSBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nID0gZnVuY3Rpb24oc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGVzY2FwZVByb3AsIGRvbnRFc2NhcGVWYWx1ZSkge1xuICAgICAgdmFyIGJ1ZmZlciwgaXRlbSwgaXRlbVR5cGUsIG1lLCBwcm9wO1xuICAgICAgcHJvcCA9IHZvaWQgMDtcbiAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgbWUgPSB0aGlzO1xuICAgICAgaXRlbVR5cGUgPSB2b2lkIDA7XG4gICAgICBpdGVtID0gdm9pZCAwO1xuICAgICAgc1Byb3BEZWxpbSA9IHNQcm9wRGVsaW0gfHwgXCImXCI7XG4gICAgICBzVmFsdWVEZWxpbSA9IHNWYWx1ZURlbGltIHx8IFwiPVwiO1xuICAgICAgZm9yIChwcm9wIGluIG1lKSB7XG4gICAgICAgIGl0ZW0gPSBtZVtwcm9wXTtcbiAgICAgICAgaXRlbVR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbVR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW1UeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaXRlbSA9IHRvU3RyaW5nLmFwcGx5KGl0ZW0sIFtzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgZXNjYXBlUHJvcCwgZG9udEVzY2FwZVZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVzY2FwZVByb3ApIHtcbiAgICAgICAgICBwcm9wID0gX2VzKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9udEVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXRlbSA9IF9lcyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChwcm9wLCBzVmFsdWVEZWxpbSwgaXRlbSwgc1Byb3BEZWxpbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3N0cihidWZmZXIpO1xuICAgIH07XG4gICAgcHJvdG8gPSBQYXJhbUhhc2gucHJvdG90eXBlO1xuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG4gICAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSB0cmltO1xuICAgIH1cblxuICAgIC8qXG4gICAgQGlnbm9yZVxuICAgICAqL1xuICAgIHByb3RvLnRvU3RyaW5nID0gcHJvdG8udmFsdWVPZiA9IHRvU3RyaW5nO1xuICAgIGxhbmcgPSB7XG4gICAgICBQYXJhbUhhc2g6IFBhcmFtSGFzaCxcbiAgICAgIGNzdHI6IGNzdHIsXG4gICAgICBjbnVtOiBjbnVtLFxuICAgICAgY2Jvb2w6IGNib29sLFxuICAgICAgbm9vcDogbm9vcCxcbiAgICAgIHRyaW06IHRyaW0sXG4gICAgICBjYWxsYWJsZTogY2FsbGFibGUsXG4gICAgICBndWlkOiBndWlkLFxuICAgICAgbWl4OiBtaXgsXG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgcmFuZDogcmFuZCxcbiAgICAgIGRlZjogZGVmLFxuICAgICAgbnM6IG5zLFxuICAgICAganNzYWZlX2h0bWw6IGpzc2FmZV9odG1sLFxuICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgIHdyYXA6IHdyYXBcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBleHBvcnRzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5sYW5nID0gbGFuZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgbG9nRXJyb3IsIGxvZ0luZm8sIHdpbjtcbiAgICB3aW4gPSB3aW5kb3c7XG5cbiAgICAvKlxuICAgIFdyaXRlIGFuIGVudHJ5IHRvIHRoZSBjb25zb2xlIGxvZyBhbmQgZmlyZSBhbnkgbG9nIGxpc3RlbmVyc1xuICAgIFxuICAgIEBtZXNzYWdlICBUaGUgbG9nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBsb2dJbmZvID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgaWYgKHdpbi5jb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFdyaXRlIGFuIGVudHJ5IHRvIHRoZSBjb25zb2xlIGVycm9yIGxvZyBhbmQgZmlyZSBhbnkgbG9nIGxpc3RlbmVyc1xuICAgIFxuICAgIEBtZXNzYWdlICBUaGUgbG9nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBsb2dFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh3aW4uY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod2luLmNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZm86IGxvZ0luZm8sXG4gICAgICBlcnJvcjogbG9nRXJyb3JcbiAgICB9O1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iXX0=
