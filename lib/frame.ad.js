(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var $sf, Request, config, currentName, events, stream, utils;

  currentName = window.name;

  $sf = require('../node_modules/safeframe/lib/js/ext/ext')(true);

  events = require('./shared/event')(["request", "load", "view", "click", "expanded", "collapsed", "engage", "unview", "unload"]);

  utils = require('./shared/utils');

  Request = require('./request');

  stream = require('./shared/stream');

  config = require('./shared/config');

  (function($sf, window) {
    var AdJS, VIEWED_STRIKE, attributes, controller, didShow, findController, forceNuke, height, host, isViewedInterval, location, maxViewPercentage, onUpdate, referrerLevel, registerAdJSendpoints, registerForEvents, registered, request, requested, sfDom, showAd, showAdTimer, showPage, startTicks, unviewedTicks, updateIsViewed, updateReferrer, viewedPercentages, viewedTicks, width;
    document.domain = config.domain;
    controller = null;
    sfDom = $sf.lib.dom;
    AdJS = {};
    utils.defineProperty(AdJS, "isController", {
      writable: false,
      value: false,
      configurable: false
    });
    request = new Request();
    request.set({
      load_pos: utils.getFramePosition(window),
      v_js: config.version,
      req_url_blind: true,
      tz: (new Date()).getTimezoneOffset()
    });
    findController = function() {
      var frame, _i, _len, _ref, _ref1;
      _ref = window.parent.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        try {
          if ((_ref1 = frame.$ad) != null ? _ref1.isController : void 0) {
            controller = frame.$ad;
            request.change(function() {
              return controller.send(request);
            });
            controller.send(request);
            return;
          }
        } catch (_error) {

        }
      }
      if (!controller) {
        return setTimeout(findController, 100);
      }
    };
    findController();
    VIEWED_STRIKE = 9;
    viewedTicks = 0;
    unviewedTicks = 0;
    width = window.innerWidth;
    height = window.innerHeight;
    registered = false;
    didShow = false;
    requested = false;
    startTicks = utils.now();
    maxViewPercentage = 0;
    viewedPercentages = [];
    attributes = {};
    AdJS.setDimensions = function(w, h) {
      width = w;
      return height = h;
    };
    registerForEvents = function() {
      registered = true;
      return $sf.ext.register(width, height, onUpdate);
    };
    registerAdJSendpoints = function() {
      return true;
    };
    updateReferrer = function(level) {
      if (level == null) {
        level = "all";
      }
      switch (level) {
        case "all":
          return true;
        case "host":
          utils.defineProperty(document, "referrer", {
            get: function() {
              return "" + document.location.protocol + "//" + host;
            }
          });
          return true;
        case "none":
          return false;
        default:
          return true;
      }
    };
    onUpdate = function(status, data) {
      switch (status) {
        case "expanded":
          return function() {
            return AdJS.expanded();
          };
        case "collapsed":
          return function() {
            return AdJS.collapsed();
          };
        case "geom-update":
          return showAd();
        case "engaged":
          return AdJS.engage();
        case "requested":
          if (!requested) {
            return AdJS.request();
          }
      }
    };
    isViewedInterval = null;
    updateIsViewed = function() {
      var viewPercent, _base;
      viewPercent = (typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) || 0;
      if (!AdJS.isViewed && viewPercent > 50 && $sf.ext.winHasFocus()) {
        viewedTicks++;
        viewedPercentages.push(viewPercent);
      } else if (AdJS.isViewed && (viewPercent < 50 || !$sf.ext.winHasFocus())) {
        unviewedTicks++;
      } else {
        unviewedTicks = viewedTicks = 0;
        viewedPercentages = [];
      }
      if (viewedTicks === VIEWED_STRIKE) {
        if (!AdJS.isViewed) {
          AdJS.view();
        }
        AdJS.isViewed = true;
      }
      if (unviewedTicks === VIEWED_STRIKE) {
        if (!AdJS.isunViewed) {
          AdJS.unview();
        }
        AdJS.isunViewed = true;
        clearInterval(isViewedInterval);
      }
      if (viewPercent > maxViewPercentage) {
        return maxViewPercentage = viewPercent;
      }
    };
    showAdTimer = null;
    showAd = function(show) {
      var startTime, _base;
      if (((typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 5 && !didShow) || show) {
        if (showAdTimer) {
          clearInterval(showAdTimer);
        }
        startTime = utils.now();
        AdJS.request();
        $sf.ext.showAd(function() {
          return AdJS.load();
        });
        return didShow = true;
      } else if (!(showAdTimer || didShow)) {
        return showAdTimer = setInterval(forceNuke, 50);
      }
    };
    forceNuke = function() {
      var _base;
      if ((typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0) > 5 && showAdTimer) {
        clearInterval(showAdTimer);
        showAdTimer = null;
        return $sf.ext.reload();
      }
    };
    $sf.lib.lang.mix(AdJS, events);
    AdJS.on = function(event, cb) {
      return events.on.apply(this, [event, cb]);
    };
    AdJS.expand = function(deltaXorDesc, deltaY, p) {
      return $sf.ext.expand(deltaXorDesc, deltaY, p);
    };
    AdJS.collapse = function() {
      return $sf.ext.collapse();
    };
    AdJS.cookie = function(cookieName, cookieData) {
      return $sf.ext.cookie(coookieName, cookieData);
    };
    AdJS.supports = function(key) {
      return $sf.ext.supports(key);
    };
    AdJS.sendMessage = function(content) {
      return setTimeout(function() {
        return $sf.ext.message(encodeURIComponent(content));
      }, 1);
    };
    sfDom.attach(document.body, "mouseup", function() {
      AdJS.click();
      return true;
    });
    window.$ad = AdJS;
    registerAdJSendpoints();
    AdJS.click(function() {
      return $sf.ext.click();
    });
    AdJS.view(function() {
      return $sf.ext.viewed();
    });
    AdJS.unview(function() {
      return $sf.ext.unviewed();
    });
    AdJS.load(function() {
      return registerForEvents();
    });
    AdJS.load(function() {
      return isViewedInterval = setInterval(updateIsViewed, 100);
    });
    AdJS.load(function() {
      AdJS.loadChain = utils.countFrames(window);
      return request.set({
        load_chain: AdJS.loadChain
      });
    });
    AdJS.request(function() {
      var geoInfo, _base;
      AdJS.requestTime = utils.now();
      geoInfo = $sf.ext.geom();
      return request.set({
        requested: true,
        requestedAt: utils.now(),
        req_t: utils.now() - startTicks,
        req_view_pct: typeof (_base = $sf.ext).inViewPercentage === "function" ? _base.inViewPercentage() : void 0,
        slot_x: geoInfo.self.l,
        slot_y: geoInfo.self.t,
        slot_w: geoInfo.self.w,
        slot_h: geoInfo.self.h,
        screen_w: window.screen.width,
        screen_h: window.screen.height,
        vp_x: geoInfo.win.l,
        vp_y: geoInfo.win.t,
        vp_w: geoInfo.win.w,
        vp_h: geoInfo.win.h
      });
    });
    AdJS.load(function() {
      AdJS.loadTime = utils.now();
      console.log("loooooaddeddddd");
      sfDom.attach(window, "unload", function() {
        return $ad.unload();
      });
      return request.set({
        loaded: true,
        loadedAt: utils.now(),
        load_t: utils.now() - startTicks
      });
    });
    AdJS.view(function() {
      AdJS.viewTime = utils.now();
      return request.set({
        viewed: true,
        viewedAt: utils.now(),
        view_t: utils.now() - startTicks,
        view_meas: true,
        view_pct: utils.reduce(viewedPercentages, (function(memo, num) {
          return memo + num;
        }), 0) / viewedPercentages.length,
        view_pct_max: maxViewPercentage
      });
    });
    AdJS.engage(function() {
      AdJS.engageTime = utils.now();
      return request.set({
        engaged: true,
        view_eng: true,
        engagedAt: utils.now()
      });
    });
    AdJS.click(function() {
      AdJS.clickTime = utils.now();
      return request.set({
        clicked: true,
        clickedAt: utils.now(),
        clk_t: utils.now() - startTicks
      });
    });
    AdJS.unview(function() {
      AdJS.unviewTime = utils.now();
      return request.set({
        unviewed: true,
        unviewedAt: utils.now(),
        view_dur: utils.now() - AdJS.viewedAt,
        view_pct_max: maxViewPercentage
      });
    });
    AdJS.unload(function() {
      AdJS.unloadTime = utils.now();
      return request.set({
        unloaded: true,
        unloadedAt: utils.now(),
        unl_t: utils.now() - startTicks
      });
    });
    $sf.ext.render(false);
    didShow = !$sf.lib.lang.cbool($sf.ext.meta("inview", "extended"));
    referrerLevel = $sf.ext.meta("referrer", "extended") || "all";
    host = $sf.ext.meta("host", "extended");
    $sf.ext.deleteMeta("host", "extended");
    location = $sf.ext.meta("location", "extended");
    $sf.ext.deleteMeta("location", "extended");
    $ad.slotId = $sf.ext.meta("slot_id", "extended");
    $ad.count = $sf.ext.meta("load_n", "extended");
    request.set({
      slot_id: $sf.ext.meta("slot_id", "extended"),
      load_n: $sf.ext.meta("load_n", "extended"),
      page_url: location,
      page_host: host
    }, {
      silent: true
    });
    showPage = document.location.href === document.referrer || updateReferrer(referrerLevel);
    if (showPage) {
      showAd(didShow);
    } else {
      window.name = currentName;
      document.location = document.location;
    }
    return AdJS;
  })($sf, window);

}).call(this);

},{"../node_modules/safeframe/lib/js/ext/ext":11,"./request":2,"./shared/config":4,"./shared/event":5,"./shared/stream":6,"./shared/utils":7}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, uuid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require('./shared/base');

  uuid = require('node-uuid');

  module.exports = (function(window) {
    var Request;
    Request = (function(_super) {
      __extends(Request, _super);

      function Request(clientId, sessionId) {
        this.clientId = clientId;
        this.sessionId = sessionId;
        Request.__super__.constructor.apply(this, arguments);
        this.id = uuid.v4();
      }

      Request.prototype.path = "/event";

      Request.prototype.constantFields = ["site_user_id", "page_id", "visit_id", "full_url", "req_id"];

      return Request;

    })(Base);
    return Request;
  })(window);

}).call(this);

},{"./shared/base":3,"node-uuid":9}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils, uuid;

  uuid = require('node-uuid');

  utils = require('./utils');

  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.id = uuid.v4();
        this.attributes || (this.attributes = {});
        this._events = [];
        this._dirty = {};
      }

      Base.prototype.set = function(attrs, options) {
        var changed, changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        if (typeof attrs !== "object") {
          throw "attrs must be an object";
        }
        changed = false;
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
            this._dirty[k] = v;
          }
          this.attributes[k] = v;
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      Base.prototype._cleanDirty = function() {
        return this._dirty = {};
      };

      Base.prototype.changedFields = function() {
        var field, k, params, v, _i, _len, _ref, _ref1;
        params = {};
        _ref = this._dirty;
        for (k in _ref) {
          v = _ref[k];
          params[k] = v;
        }
        _ref1 = this.constantFields;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          field = _ref1[_i];
          if (this.attributes[field]) {
            params[field] = this.attributes[field];
          }
        }
        this._cleanDirty();
        return params;
      };

      Base.prototype.serialize = function() {
        return utils.toQuery(this.attributes);
      };

      Base.prototype.deserialize = function(str) {
        return this.set(utils.fromQuery(str), {
          silent: true
        });
      };

      return Base;

    })();
  })();

}).call(this);

},{"./utils":7,"node-uuid":9}],4:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html',
        controller_url: "base/lib/html/controllerframe.html",
        visit_expiry: 5,
        version: "0.0.1",
        domain: "localhost"
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//api.adjs.net/1",
        cdn_url: "//cdn.adjs.net/html/adjsframe.html",
        visit_expiry: 30,
        version: "0.0.1",
        domain: "adjs.net",
        controller_url: "//cdn.adjs.net/html/controllerframe.html"
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html',
        visit_expiry: 3,
        version: "0.0.1",
        domain: "localhost",
        controller_url: "../lib/html/controllerframe.html"
      };
    }
  })();

}).call(this);

}).call(this,require("8DwohR"))
},{"8DwohR":26}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(eventNames) {
    return (function() {
      var event, events, _i, _len;
      events = {
        on: function(event, cb) {
          var eventList;
          this.events || (this.events = {});
          eventList = this.events[event] || [];
          eventList.push(cb);
          this.events[event] = eventList;
          return this;
        },

        /*
          optionalData needs to be fixed
         */
        trigger: function(event, data, optionalData) {
          var e, ex, _i, _len, _ref;
          this.events || (this.events = {});
          _ref = this.events[event] || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            try {
              e.call(this, data, optionalData);
            } catch (_error) {
              ex = _error;
            }
          }
          return this;
        }
      };
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        event = eventNames[_i];
        events[event] = (function(event) {
          var f;
          return f = function(data) {
            if (typeof data === "function") {
              return this.on(event, data);
            } else {
              return this.trigger(event, data);
            }
          };
        })(event);
      }
      return events;
    })();
  };

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var config, reqwest;

  reqwest = require('reqwest');

  config = require('./config');

  module.exports = (function() {
    var mapping, pendingRequests, prefix, send, sendingRequests;
    prefix = config.api;
    pendingRequests = {};
    sendingRequests = {};
    mapping = {
      id: "user_id",
      p: "site_page_vw",
      a: "site_ad_req",
      av: "site_ad_vw",
      ac: "site_ad_clk",
      ae: "site_ad_vw_eng",
      v: "site_vis",
      vp: "vis_page_vw",
      va: "vis_ad_req",
      vav: "vis_ad_vw",
      vae: "vis_ad_vw_eng",
      vac: "vis_ad_clk"
    };
    send = function(url, data, success, error) {
      return reqwest({
        url: url,
        type: 'jsonp',
        data: data,
        success: success,
        error: error
      });
    };
    return {
      page: function(session) {
        var error, success;
        success = function(resp) {
          return session.set(resp);
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        return send(prefix + '/page', session.attributes, success, error);
      },
      event: function(request, cb, isAttempt) {
        var error, k, params, success, v, _ref;
        success = function(resp) {
          request.set(resp, {
            silent: true
          });
          if (typeof cb === "function") {
            cb(resp);
          }
          return delete sendingRequests[request.id];
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        if (!sendingRequests[request.id]) {
          delete pendingRequests[request.id];
          sendingRequests[request.id] = true;
          params = {};
          _ref = request.attributes;
          for (k in _ref) {
            v = _ref[k];
            params[mapping[k] || k] = v;
          }
          return send(prefix + '/event', params, success, error);
        } else if (!pendingRequests[request.id] || isAttempt) {
          pendingRequests[request.id];
          return setTimeout((function(_this) {
            return function() {
              return _this.event(request, cb, true);
            };
          })(this), 500);
        }
      }
    };
  })();

}).call(this);

},{"./config":4,"reqwest":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var reqwest;

  window.JSON || (window.JSON = require('json'));

  reqwest = require('reqwest');

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf) {
    var capitalizeString, countFrames, defineProperty, fromQuery, getFramePosition, keys, nativeReduce, now, reduce, reduceError, sendRequest, toNumber, toQuery;
    sendRequest = function(options) {
      return reqwest(options);
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        } else {
          if (descriptor.value) {
            return obj[prop] = descriptor.value;
          }
        }
      } catch (_error) {
        e = _error;
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    getFramePosition = function(win) {
      var count;
      count = 0;
      if (win.parent !== win.top) {
        count = 1 + getFramePosition(win.parent);
      }
      return count;
    };
    nativeReduce = Array.prototype.reduce;
    reduceError = 'Reduce of empty array with no initial value';
    reduce = function(obj, iterator, memo, context) {
      var index, initial, value, _fn, _i, _len;
      initial = arguments.length > 2;
      if (obj == null) {
        obj = [];
      }
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) {
          iterator = _.bind(iterator, context);
        }
        return (initial ? obj.reduce(iterator, memo) : obj.reduce(iterator));
      }
      _fn = function(value, index, obj) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, obj);
        }
      };
      for (index = _i = 0, _len = obj.length; _i < _len; index = ++_i) {
        value = obj[index];
        _fn(value, index, obj);
      }
      if (!initial) {
        throw new TypeError(reduceError);
      }
      return memo;
    };
    keys = function(obj) {
      return $sf != null ? $sf.lib.lang.keys(obj) : void 0;
    };
    capitalizeString = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return {
      sendRequest: sendRequest,
      toQuery: toQuery,
      fromQuery: fromQuery,
      toNumber: toNumber,
      now: now,
      defineProperty: defineProperty,
      countFrames: countFrames,
      capitalizeString: capitalizeString,
      keys: keys,
      getFramePosition: getFramePosition,
      reduce: reduce
    };
  })($sf);

}).call(this);

},{"json":8,"reqwest":10}],8:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],9:[function(require,module,exports){
(function (Buffer){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

}).call(this,require("buffer").Buffer)
},{"buffer":17,"crypto":21}],10:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@fileOverview This file contains JavaScript code that handles the HTML document where HTML is rendered for a SafeFrame, as well as defining the External Vendor/Client API.
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.3
 */


/*
@namespace $sf.ext The external vendor / client API for functionality inside a SafeFrame
@name $sf.ext
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require("../shared/base");

  module.exports = function(isExternal) {
    return (function(window, sf) {
      var COLLAPSE_COMMAND, DG, DOM_WATCH_INTERVAL, DP, DS, ERROR_COMMAND, EXPAND_COMMAND, GUID_VALID_TIME, IE_ATTACH, IE_DETACH, LOAD, MAX_MSG_WAIT_TIME, MSG, NOTIFY_CLICKED, NOTIFY_COLLAPSE, NOTIFY_COLLAPSED, NOTIFY_EXPAND, NOTIFY_FAILURE, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, NOTIFY_LOADED, NOTIFY_READ_COOKIE, NOTIFY_RELOAD, NOTIFY_REQUESTED, NOTIFY_UNVIEWED, NOTIFY_VIEWED, NOTIFY_WRITE_COOKIE, OBJ, ONLOAD, ONMSG, ONUNLOAD, ON_STR, OUR_TAG_CLS_NAME, ParamHash, STATUS_COLLAPSED, STATUS_COLLAPSING, STATUS_EXPANDED, STATUS_EXPANDING, TOLOWERCASE, UNLOAD, W3C_ATTACH, W3C_DETACH, adShown, can_use_html5, click, cmdRetries, collapse, cookie, d, deleteMeta, dom, env, err_msg_timer_id, err_msgs, expand, force_collapse, frame_id, geom, geom_info, guid, hasLoaded, host_cname, ie_old_attach, ie_old_detach, iframes, inViewPercentage, init_height, init_width, inline_handler_timer_id, isAdShown, isIE, is_expanded, is_registered, lang, lib, loaded, message, messageQueue, meta, msgclient_fb, originalWrite, orphan_timer_id, par, pending_msg, pos_id, pos_meta, register, reload, render, render_conf, render_params, sandbox_cb, showAd, status, supports, unload_handlers, unviewed, viewed, w3c_old_attach, w3c_old_detach, win, winHasFocus, win_has_focus, _append, _attach, _attach_override, _attr, _call_client_fb, _call_raw_evt_func, _check_orphaned, _cnum, _collapse, _construction, _create_stylesheet, _cstr, _destruction, _detach, _detach_override, _detect_bad_iframe, _elt, _fire_sandbox_callback, _handle_err, _handle_load, _handle_msg, _handle_unload, _nuke_doc, _purge, _reattach_messaging, _receive_msg, _render, _report_errs, _requested, _reset_inline_handlers, _send_cmd, _send_msg, _set_alignment, _set_hyperlink_targets, _setup_win_evt_props, _shiftMessageQueue, _tags, _ue, _wrapiFrame;
      win = window;
      LOAD = "load";
      ON_STR = "on";
      MSG = "message";
      UNLOAD = "un" + LOAD;
      ONUNLOAD = ON_STR + UNLOAD;
      ONMSG = ON_STR + MSG;
      ONLOAD = ON_STR + LOAD;
      DG = "__defineGetter__";
      DS = "__defineSetter__";
      DP = "__defineProperty__";
      W3C_ATTACH = "addEventListener";
      W3C_DETACH = "removeEventListener";
      IE_ATTACH = "attachEvent";
      IE_DETACH = "detachEvent";
      TOLOWERCASE = "toLowerCase";
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_EXPAND = "expand";
      NOTIFY_FOCUS_CHANGE = "focus-change";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_COLLAPSED = NOTIFY_COLLAPSE + "d";
      NOTIFY_FAILURE = "failed";
      NOTIFY_READ_COOKIE = "read-cookie";
      NOTIFY_WRITE_COOKIE = "write-cookie";
      NOTIFY_CLICKED = "clicked";
      NOTIFY_VIEWED = "viewed";
      NOTIFY_UNVIEWED = "unviewed";
      NOTIFY_LOADED = "loaded";
      NOTIFY_REQUESTED = "requested";
      NOTIFY_RELOAD = "reload";
      STATUS_COLLAPSED = NOTIFY_COLLAPSED;
      STATUS_EXPANDED = NOTIFY_EXPAND + "ed";
      STATUS_COLLAPSING = "collapsing";
      STATUS_EXPANDING = NOTIFY_EXPAND + "ing";
      OUR_TAG_CLS_NAME = "sf";
      MAX_MSG_WAIT_TIME = 4000;
      DOM_WATCH_INTERVAL = 3000;
      GUID_VALID_TIME = 30000;
      OBJ = "object";
      d = win && win.document;
      par = win && win.parent;
      lib = sf.lib;
      env = sf.env;
      lang = lib.lang;
      ParamHash = lang.ParamHash;
      dom = lib.dom;
      iframes = dom.iframes;
      msgclient_fb = dom.msgclient_fb;
      isIE = env.isIE;
      _ue = win.unescape;
      _cstr = lang.cstr;
      _cnum = lang.cnum;
      _append = dom.append;
      _tags = dom.tags;
      _elt = dom && dom.elt;
      _purge = dom && dom.purge;
      _attach = dom && dom.attach;
      _detach = dom && dom.detach;
      _attr = dom && dom.attr;
      hasLoaded = false;
      is_expanded = false;
      force_collapse = false;
      is_registered = false;
      init_width = 0;
      init_height = 0;
      sandbox_cb = null;
      pending_msg = null;
      messageQueue = [];
      geom_info = null;
      pos_meta = null;
      win_has_focus = false;
      guid = "";
      host_cname = "";
      can_use_html5 = false;
      frame_id = "";
      pos_id = "";
      err_msg_timer_id = 0;
      orphan_timer_id = 0;
      inline_handler_timer_id = 0;
      err_msgs = [];
      unload_handlers = [];
      render_params = void 0;
      render_conf = void 0;
      ie_old_attach = void 0;
      w3c_old_attach = void 0;
      ie_old_detach = void 0;
      w3c_old_detach = void 0;
      isAdShown = false;

      /*
      Creates and appends a style sheet for any custom CSS passed
      
      @name $sf.ext-_create_stylesheet
      @function
      @static
      @private
      @param {String} cssText A string of CSS rules, or a URL string
      @param {String} [id] The id attribute of the tag created and appended
       */
      _create_stylesheet = function(cssText, id) {
        var e, oHead, oSS, oTxt;
        oHead = void 0;
        oSS = void 0;
        oTxt = void 0;
        e = void 0;
        try {
          oHead = _tags("head")[0];
          if (cssText.search(/\{[^\}]*}/g) === -1) {
            oSS = dom.make("link");
            oSS.type = "text/css";
            oSS.rel = "stylesheet";
            oSS.href = cssText;
          } else {
            oSS = dom.make("style");
            oSS.type = "text/css";
            if (isIE) {
              oSS.styleSheet.cssText = cssText;
            } else {
              oTxt = d.createTextNode(cssText);
              _append(oSS, oTxt);
            }
          }
          if (id) {
            oSS.id = id;
          }
          _append(oHead, oSS);
        } catch (_error) {}
      };

      /*
      Fires of unload event handlers and performs the necessary clean up when a SafeFrame is destroyed
      
      @name $sf.ext-_destruction
      @function
      @static
      @private
      @param {HTMLEvent} [evt] The raw dom event object if it exists
       */
      _destruction = function(evt) {
        var e, grand_par, handler, success, w;
        handler = void 0;
        w = window;
        success = 1;
        e = void 0;
        try {
          evt = evt || w.event || {};
        } catch (_error) {
          e = _error;
          evt = {
            type: UNLOAD
          };
        }
        while (handler = unload_handlers.shift()) {
          try {
            handler(evt);
          } catch (_error) {}
        }
        try {
          if (ie_old_attach) {
            w[IE_ATTACH] = ie_old_attach;
            w[IE_DETACH] = ie_old_detach;
          }
        } catch (_error) {}
        try {
          if (w3c_old_attach) {
            w[W3C_ATTACH] = w3c_old_attach;
            w[W3C_DETACH] = w3c_old_detach;
          }
        } catch (_error) {}
        if (!hasLoaded) {
          _detach(w, LOAD, _handle_load);
        }
        _detach(w, UNLOAD, _handle_unload);
        try {
          w.onerror = null;
        } catch (_error) {}
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (orphan_timer_id) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        w = ie_old_attach = w3c_old_attach = ie_old_detach = w3c_old_detach = d = _ue = par = handler = grand_par = null;
        return success;
      };

      /*
      Maintains that the window.onmessage property remains unset.
      We don't want content in our document listening to HTML5 messages.
      We override attaching to listeners below to maintain that functionality,
      however IE won't let you override properties directly hangning off of the
      window object, so we have a timer as a fallback for that purpose
      
      @name $sf.ext-_reset_inline_handlers
      @function
      @static
      @private
       */
      _reset_inline_handlers = function() {
        var e;
        e = void 0;
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (isIE && win.onmessage) {
            win.onmessage = null;
          }
        } catch (_error) {}
        try {
          win.onerror = _handle_err;
        } catch (_error) {}
        inline_handler_timer_id = setTimeout(_reset_inline_handlers, DOM_WATCH_INTERVAL);
      };

      /*
      Clears out the HTML document (which will force an unload event as well).
      
      @name $sf.ext-_nuke_doc
      @function
      @static
      @private
       */
      _nuke_doc = function() {
        var e;
        e = void 0;
        try {
          document.open("text/html", "replace");
          document.write("");
          document.close();
        } catch (_error) {}
      };

      /*
      Iteratively checks to see if the IFRAME HTML document is no longer
      attached to the main dom, doing this by checking that our internal
      window reference is still valid. . .as well as running the checks to make
      sure invalid iframes (iframes from origin) are not created.
      
      If we detect that the IFRAME has been removed from the main dom of the
      publisher, then we call to destroy the HTML document, forcing onunload
      event and subsquent cleanup
      
      @name $sf.ext-_check_orphaned
      @function
      @static
      @private
       */
      _check_orphaned = function() {
        var e, is_orphaned;
        is_orphaned = false;
        e = void 0;
        _detect_bad_iframe();
        if (!isIE) {
          return;
        }
        try {
          if (orphan_timer_id && orphan_timer_id !== -1) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          is_orphaned = win === top && orphan_timer_id !== -1;
        } catch (_error) {
          e = _error;
          is_orphaned = false;
        }
        if (is_orphaned) {
          orphan_timer_id = -1;
          _destruction();
          _nuke_doc();
          return;
        }
        try {
          if (!orphan_timer_id) {
            orphan_timer_id = setTimeout(_check_orphaned, DOM_WATCH_INTERVAL);
          }
        } catch (_error) {}
      };

      /*
      Detect whether or not an IFRAME tag has been inserted into the DOM that has the same
      origin / cname as the publisher, which should not be allowed as it's a security issue
      If said IFRAME tag(s) are found, remove them.
      
      @name $sf.ext-_detect_bad_iframe
      @function
      @static
      @private
       */
      _detect_bad_iframe = function() {
        var idx, srcHost, tag, written;
        iframes = _tags("iframe");
        idx = 0;
        srcHost = "";
        written = false;
        tag = void 0;
        if (host_cname) {
          while (tag = iframes[idx++]) {
            srcHost = _attr(tag, "src");
            srcHost = (srcHost && srcHost.length >= 9 ? srcHost.substring(0, srcHost.indexOf("/", 9))[TOLOWERCASE]() : "");
            if (srcHost && srcHost === host_cname && tag.className !== OUR_TAG_CLS_NAME) {
              try {
                _purge(tag);
              } catch (_error) {}
            }
          }
        }
      };

      /*
      Make sure that all hyperlinks in the document are set with the property "target" attribute
      such that links will navigate to the right window properly.
      
      @name $sf.ext-_set_hyperlink_targets
      @function
      @static
      @private
       */
      _set_hyperlink_targets = function() {
        var atgt, idx, ln, lns, ttgt;
        idx = 0;
        ttgt = (render_conf && render_conf.tgt) || "_top";
        ln = void 0;
        atgt = void 0;
        lns = void 0;
        lns = _tags("a");
        if (ttgt === "_self") {
          ttgt = "_top";
        }
        while (ln = lns[idx++]) {
          atgt = _attr(ln, "target");
          if (atgt !== ttgt) {
            _attr(ln, "target", ttgt);
          }
          if (idx > 10) {
            break;
          }
        }
      };

      /*
      Handle the onunload event from the HTML document of the IFRAME, which in turn will trigger clean up
      
      @name $sf.ext-_handle_unload
      @function
      @static
      @private
      @param {HTMLEvent} evt The raw DOM event object
       */
      _handle_unload = function(evt) {
        _destruction(evt);
        _nuke_doc();
      };

      /*
      Handle the load event from the HTML document of the IFRAME, which will also setup
      to make sure link targets are set properly
      
      @name $sf.ext-_handle_load
      @function
      @static
      @private
       */
      _handle_load = function() {
        if (loaded) {
          return;
        }
        hasLoaded = true;
        _detach(win, LOAD, _handle_load);
        _set_hyperlink_targets();
      };

      /*
      Handle onmessage HTML5 x-domain events. We always cancel the event
      never allowing it to go to other listeners besides our own, as we don't allow HTML5 messaging
      beyond us and the publisher / host.
      
      @name $sf.ext-_handle_msg
      @function
      @static
      @private
       */
      _handle_msg = function(evt) {
        var e, msg_guid, msg_obj, msg_params, org, src, str;
        str = void 0;
        src = void 0;
        org = void 0;
        e = void 0;
        msg_params = void 0;
        msg_guid = void 0;
        msg_obj = void 0;

        /*
        TODO, also validate origin
         */
        try {
          str = evt.data;
          src = evt.source;
          org = evt.origin;
        } catch (_error) {}
        dom.evtCncl(evt);
        if (str && src && src === top) {
          msg_params = ParamHash(str, null, null, true, true);
          msg_guid = msg_params.guid;
          msg_obj = msg_params.msg;
          if (guid === msg_guid && msg_obj && typeof msg_obj === OBJ) {
            try {
              setTimeout((function() {
                _receive_msg(msg_obj, evt);
                msg_params = evt = msg_guid = msg_obj = null;
              }), 1);
            } catch (_error) {}
          }
        }
      };

      /*
      This SafeFrames implementation internally handles all event attachment to maintain that the listener order
      for events that it cares about (onload, onunload, onbeforeunload, onmessage).
      This is done to make sure that proper clean up and intialization happens, as well as to enforce
      security.
      
      For events that it SafeFrames does not care about we allow the attachment listeners
      to proceed as normal, so we call the raw attachEvent / addEventListener functions.
      
      @name $sf.ext-_call_raw_evt_func
      @function
      @static
      @private
      @param {String} type The name of the event for which to attach/detach a listener
      @param {Function} f The callback function to use as a listener for said event
      @param {Boolean} [remove] If set to true, remove/detach this function as a listener, otherwise add
       */
      _call_raw_evt_func = function(type, f, remove) {
        var bOK, e, ie_f, w3c_f;
        bOK = false;
        ie_f = void 0;
        w3c_f = void 0;
        e = void 0;
        if (remove) {
          ie_f = ie_old_detach || w3c_old_detach;
          w3c_f = w3c_old_detach;
        } else {
          ie_f = ie_old_attach || w3c_old_attach;
          w3c_f = w3c_old_attach;
        }
        if (ie_f) {
          try {
            ie_f(type, f);
            bOK = true;
          } catch (_error) {
            e = _error;
            bOK = false;
          }
          if (!bOK) {
            try {
              ie_f.call(win, type, f);
              bOK = true;
            } catch (_error) {
              e = _error;
              bOK = false;
            }
          }
        }
        if (w3c_f && !bOK) {
          try {
            w3c_f.call(win, type, f, false);
          } catch (_error) {}
        }
      };

      /*
      Override default event attachment, and send load, beforeunload, and unload handlers into our
      own ques, so that we can enforce the proper firing order.  if message event is passed in,
      we do not allow attachment, since we do not want n-party code listening to HTML5 messages
      
      @name $sf.ext-_attach_override
      @function
      @static
      @private
      @param {String} type the event name to listen too
      @param {Function} f The function to be called whenever the event fires
       */
      _attach_override = function(type, f) {
        var bDoDefault;
        bDoDefault = false;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            unload_handlers.push(f);
            break;
          case MSG:
          case ONMSG:
            true;
            break;
          default:
            bDoDefault = true;
        }
        if (bDoDefault) {
          _call_raw_evt_func(type, f);
        }
      };

      /*
      Override default event detachment, and remove load, beforeunload, and unload handlers
      from our own que.  if message event is passed in, we do nothing (since we don't alllow
      attachment either).  If not one of those event types, then we call the default event detachment
      
      @name $sf.ext-_detach_override
      @function
      @static
      @private
      @param {String} type the event name to unlisten too
      @param {Function} f The function to no longer be called for the specific event
       */
      _detach_override = function(type, f) {
        var handler, handlers, idx;
        idx = 0;
        handler = void 0;
        handlers = void 0;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            handlers = unload_handlers;
            break;
          case MSG:
          case ONMSG:
            true;
        }
        if (handlers != null ? handlers.length : void 0) {
          while (handler = handlers[idx]) {
            if (handler === f) {
              handlers.splice(idx, 1);
              break;
            }
            idx++;
          }
        } else {

        }
        _call_raw_evt_func(type, f, true);
      };

      /*
      Report any internal uncaught JavaScript errors up to the publisher / host
      
      @name $sf.ext-_report_errs
      @static
      @function
      @private
       */
      _report_errs = function() {
        var cmd_str, e, errs;
        e = void 0;
        errs = void 0;
        try {
          if (err_msgs.length > 0) {
            errs = err_msgs[0];
            cmd_str = ["cmd=", ERROR_COMMAND, "&pos=", pos_id, "&errors=", errs];
            _send_msg(_cstr(cmd_str), ERROR_COMMAND);
          }
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        err_msgs = [];
      };

      /*
      Handle any uncaught JavaScript errors
      
      @name $sf.ext-_handle_err
      @static
      @function
      @private
      @param {String} a The the error message / description string
      @param {String} b The URL / file that the JavaScript error occured within
      @param {Number} c The line number that the error occured on. . .
       */
      _handle_err = function(a, b, c) {
        var e;
        e = void 0;
        err_msgs.push(_cstr(["Error occurred inside SafeFrame:\nMessage: ", a, "\nURL:", b, "\nLine:", c]));
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
          err_msg_timer_id = setTimeout(_report_errs, DOM_WATCH_INTERVAL);
        } catch (_error) {}
        return true;
      };

      /*
      Override native window methods and properties so that we can control
      how the events that we need to manage
      
      @name $sf.ext-_setup_win_evt_props
      @static
      @function
      @private
      @param {Object} obj The window object / prototype
       */
      _setup_win_evt_props = function(obj) {
        var O, e, n, nobj, ret;
        n = lang.noop;
        O = Object;
        nobj = {
          get: n,
          set: n
        };
        ret = false;
        if (obj) {
          if (ie_old_attach) {
            obj[IE_ATTACH] = _attach_override;
            obj[IE_DETACH] = _detach_override;
          }
          if (w3c_old_attach) {
            obj[W3C_ATTACH] = _attach_override;
            obj[W3C_DETACH] = _detach_override;
          }
          if (obj[DG]) {
            try {
              obj[DG](ONLOAD, n);
              obj[DS](ONLOAD, n);
              obj[DG](ONUNLOAD, n);
              obj[DS](ONUNLOAD, n);
              obj[DG](ONMSG, n);
              obj[DS](ONMSG, n);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
          if (!ret && O[DP]) {
            try {
              O[DP](obj, ONLOAD, nobj);
              O[DP](obj, ONUNLOAD, nobj);
              O[DP](obj, ONMSG, nobg);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Intialize / setup the safeframe, the environment according to the configuration found within the serialized
      window.name property.
      
      @name $sf.ext-_construction
      @param {Object} [details] An optional object to pass in status / error information into
      @static
      @private
      @function
       */
      _construction = function(details) {
        var cont, cur_time, e, el, guid_time, nm, ret, temp, time_delta;
        cont = false;
        ret = true;
        el = void 0;
        nm = void 0;
        temp = void 0;
        cur_time = void 0;
        guid_time = void 0;
        time_delta = void 0;
        e = void 0;
        details = (details && (details instanceof Object) ? details : {});
        try {
          nm = win.name;
        } catch (_error) {}
        try {
          win.name = "";
        } catch (_error) {}
        if (!nm) {
          details.status = 500.101;
          return cont;
        }
        try {
          if (top === par) {
            render_params = ParamHash(nm, null, null, true, true);
            cur_time = lang.time();
            guid = render_params.guid;
            guid_time = _cnum(guid.replace(/[^_]*_(\d+)_\d+_\d+/g, "$1"), 0);
            time_delta = cur_time - guid_time;
            cont = guid && guid_time && time_delta > 0 && time_delta < GUID_VALID_TIME;
            if (render_params.loc) {
              render_params.loc = unescape(render_params.loc);
            }
            if (!cont) {
              details.status = 500.104;
            }
          } else {
            details.status = 500.102;
          }
        } catch (_error) {
          e = _error;
          render_params = guid = null;
          cont = false;
          details.status = 500.103;
        }
        if (cont) {
          try {
            render_conf = render_params.conf;
            frame_id = win.name = render_conf.dest;
            pos_id = render_conf.id;
            pos_meta = render_params.meta;
            host_cname = render_params.host;
            geom_info = render_params.geom;
            can_use_html5 = lang.cbool(render_params.html5);
            win_has_focus = lang.cbool(render_params.has_focus);
            temp = render_conf.bg;
            if (geom_info) {
              geom_info = ParamHash(_ue(geom_info), null, null, true, true);
              if (!geom_info.self || !geom_info.exp) {
                geom_info = null;
              }
            }
            if (!host_cname) {
              host_cname = d.referrer;
              host_cname = host_cname.substring(0, host_cname.indexOf("/", 9));
            }
            if (temp) {
              _create_stylesheet(_cstr(["#sf_body { background-color: ", temp, "; }"]), "sf_bg_css");
            }
            temp = render_conf.tgt;
            if (temp === "_self") {
              render_conf.tgt = "_top";
            }
            if (!temp) {
              render_conf.tgt = "_top";
            }
            if (temp !== "_top") {
              while (_purge(_tags("base")[0])) {
                true;
              }
            }
            el = dom.make("base");
            _attr(el, "target", temp);
            _append(_tags("head")[0], el);
            if (isIE) {
              ie_old_attach = win[IE_ATTACH];
              ie_old_detach = win[IE_DETACH];
            }
            w3c_old_attach = win[W3C_ATTACH];
            w3c_old_detach = win[W3C_DETACH];
            _attach(win, UNLOAD, _handle_unload);
            _attach(win, LOAD, _handle_load);
            _attach(win, MSG, _handle_msg);
            _setup_win_evt_props(win);
            _setup_win_evt_props(win.__proto__);
            _setup_win_evt_props(win.Window && win.Window.prototype);
          } catch (_error) {
            e = _error;
            details.status = 500.105;
            render_params = render_conf = guid = null;
            ret = false;
          }
        } else {
          render_params = guid = null;
          ret = false;
        }
        return ret;
      };
      _wrapiFrame = function(html, cbName) {
        return "<iframe style=\"width:100%;height:100%;\" allowtransparency=\"true\"\nscrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" onload='" + cbName + "()'>\n<html><head><base target=\"_top\"></head><body style=\"margin: 0; padding: 0\">\n<script>\n  $ad = window.parent.$ad\n  $sf = window.parent.$sf\n</script>\n  " + html + "\n</html>\n</iframe>";
      };
      originalWrite = document.write;

      /*
      Render the HTML and CSS content passed in through the window.name message via a document.write
      
      @name $sf.ext-_render
      @function
      @static
      @private
       */
      _render = function(callback) {
        var cbName, css, e, html, otherCallbackApplied;
        if (callback == null) {
          callback = function() {};
        }
        cbName = lib.lang.guid("load_cb");
        otherCallbackApplied = false;
        window[cbName] = function(fromFrame) {
          return (sf.lib.lang.wrap(callback, function() {
            if (fromFrame || !otherCallbackApplied) {
              callback.apply(sf, arguments);
              _handle_load();
              loaded();
              document.write = originalWrite;
              return delete window[cbName];
            }
          }))();
        };
        document.write = function(str) {
          var domElem, iframe, oldOnload, _i, _len, _ref;
          if (!(hasLoaded || otherCallbackApplied)) {
            domElem = document.createElement("div");
            domElem.innerHTML = "_" + str;
            _ref = domElem.getElementsByTagName("iframe");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              iframe = _ref[_i];
              if (_cnum(_attr(iframe, "width"), 0) > 1) {
                otherCallbackApplied = true;
                if (oldOnload = _attr(iframe, "onload")) {
                  _attr(iframe, "onload", "" + cbName + "(true);" + oldOnload + ";");
                } else {
                  _attr(iframe, "onload", "" + cbName + "(true);");
                }
                break;
              }
            }
            if (otherCallbackApplied) {
              str = domElem.innerHTML.substring(1);
            }
          }
          return originalWrite.call(this, str);
        };
        html = void 0;
        css = void 0;
        isAdShown = true;
        css = _cstr(render_conf && render_conf.css);
        html = _cstr(render_params && render_params.html);
        if (css) {
          css = _ue(css);
          _create_stylesheet(css, "sf_custom_css");
        }
        if (html) {
          html = _ue(html);
          try {
            _reattach_messaging();
            _requested();
            document.write(html + "<scr" + ("ipt> " + cbName + "() ;</scr") + "ipt>");
            _check_orphaned();
            _reset_inline_handlers();
          } catch (_error) {
            e = _error;
            _handle_err("Error while rendering content: " + e[MSG]);
          }
        }
      };

      /*
      Call into the fallback x-msging library client if possible when no HTML5 style messaging
      exists
      
      @name $sf.ext-_call_client_fb
      @function
      @private
      @static
      @param {String} methName The name of the message in the library to call
      @param {*} [arg1] An arbitrary argument to hand into the library
      @param {*} [arg2] An arbitrary argument to hand into the library
       */
      _call_client_fb = function(methName, arg1, arg2) {
        var msg_clientfb;
        if (msgclient_fb) {
          msg_clientfb = dom.msgclient_fb;
        }
        return methName && msgclient_fb && msgclient_fb[methName] && msgclient_fb[methName](arg1, arg2);
      };

      /*
      Process a validated message to notify the contents of the SafeFrame of state updates
      
      @name $sf.ext-_receive_msg
      @function
      @private
      @static
      @param {$sf.lib.lang.ParamHash} params The message parameter hash object containing information about what has occured
      @param {HTMLEvent} [evt] The raw DOM event from the x-domain message
      @return {Boolean} Whether or not the message received could be handled
       */
      _receive_msg = function(params, evt) {
        var cmd, data, e, g, msg, ret;
        ret = false;
        msg = void 0;
        cmd = void 0;
        g = void 0;
        e = void 0;
        data = {};
        if (params) {
          g = params.geom || "";
          cmd = params.cmd;
          if (g) {
            geom_info = ParamHash(_ue(g), null, null, true, true);
          }
        }
        data.cmd = cmd;
        data.value = data.info = params && params.value;
        data.reason = params && params.reason;
        if (cmd === NOTIFY_COLLAPSED) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            force_collapse = true;
            _collapse();
            force_collapse = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_COLLAPSE) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_EXPAND) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            is_expanded = true;
            _fire_sandbox_callback(NOTIFY_EXPAND + "ed");
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_GEOM_UPDATE) {
          _fire_sandbox_callback(NOTIFY_GEOM_UPDATE);
        } else if (cmd === NOTIFY_FOCUS_CHANGE) {
          data.info = data.value = lang.cbool(data.value);
          win_has_focus = data.value;
          _fire_sandbox_callback(NOTIFY_FOCUS_CHANGE, data);
        } else if (cmd === NOTIFY_READ_COOKIE) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            data = params && params.value;
            _fire_sandbox_callback(NOTIFY_READ_COOKIE, data);
            _shiftMessageQueue();
          }
        } else if ([NOTIFY_WRITE_COOKIE, NOTIFY_FAILURE, NOTIFY_CLICKED, NOTIFY_VIEWED, NOTIFY_UNVIEWED, NOTIFY_LOADED, NOTIFY_REQUESTED, NOTIFY_RELOAD].indexOf(cmd) > -1) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
          _shiftMessageQueue();
        } else {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
          _shiftMessageQueue();
        }
        params = null;
        return ret;
      };
      cmdRetries = {};

      /*
       */
      _shiftMessageQueue = function() {
        var result;
        if (result = messageQueue.shift()) {
          return _send_msg.apply(this, result);
        }
      };

      /*
      Send a command message up to the SafeFrames publisher / host code
      
      @name $sf.ext-_send_msg
      @private
      @function
      @static
      @param {String} str An encoded string (query-string/$sf.lib.lang.ParamHash format) that contains the command message to send
      @param {String} cmd The command to be sent itself (note that this string should also be present in the 1st argument)
       */
      _send_msg = function(str, cmd) {
        var e, id, params, sent, sent_time;
        id = lang.guid("sf_pnd_cmd");
        frame_id = render_params.dest;
        sent = false;
        sent_time = lang.time();
        params = void 0;
        if (!str || !cmd || pending_msg) {
          if (pending_msg) {
            messageQueue.push([str, cmd]);
          }
          return;
        }
        params = ParamHash({
          msg: str,
          id: frame_id,
          guid: guid,
          cmd: cmd
        });
        pending_msg = {
          id: id,
          sent: sent_time,
          cmd: cmd
        };
        setTimeout((function() {
          if (pending_msg && pending_msg.id === id) {
            if (cmd === EXPAND_COMMAND || cmd === "exp-push") {
              force_collapse = true;
              _collapse();
              force_collapse = false;
            }
            _fire_sandbox_callback(NOTIFY_FAILURE + ":" + cmd + ":timeout");
          }
          id = sent = sent_time = cmd = str = pending_msg = params = null;
          _shiftMessageQueue();
        }), MAX_MSG_WAIT_TIME);
        if (can_use_html5) {
          try {
            top.postMessage(params.toString(), (host_cname === "file" || host_cname === "" ? "*" : host_cname));
            sent = true;
          } catch (_error) {
            e = _error;
            sent = false;
          }
        }
        if (!sent) {
          _call_client_fb("send", params);
        }
      };

      /*
      Fire a notification off to the SafeFrame contents if a callback function was specified
      
      @name $sf.ext-_fire_sandbox_callback
      @private
      @function
      @static
      @param {String} msg The status update / message to send
      @param {Object} data The data from the response
       */
      _fire_sandbox_callback = function(msg, data) {
        var e;
        e = void 0;
        try {
          if (typeof sandbox_cb === "function") {
            sandbox_cb(msg, data);
          }
        } catch (_error) {}
      };

      /*
      Set the alignment of our internal DIV whenever expansion occurs uni-directionaly
      
      @name $sf.ext-_set_alignment
      @private
      @function
      @static
      @param {Boolean} xn Whether or not horizontal axis is growing to the left or right (xn == true == left)
      @param {Boolean} yn Whether or not vertical axis is growing to the top or bottom (yn == true == top)
       */
      _set_alignment = function(xn, yn) {
        var fcDiv, fcDivStyle, preTxt, xTxt, yTxt;
        fcDiv = _elt("sf_align");
        fcDivStyle = fcDiv.style;
        xTxt = void 0;
        yTxt = void 0;
        preTxt = "position:absolute;";
        if (xn) {
          xTxt = "right:0px;";
        } else {
          xTxt = "left:0px;";
        }
        if (yn) {
          yTxt = "bottom:0px;";
        } else {
          yTxt = "top:0px;";
        }
        fcDivStyle.cssText = preTxt + xTxt + yTxt;
        fcDiv = fcDivStyle = null;
      };

      /*
      Internal function for collapsing the SafeFrame, which checks that there is
      not some other pending state which may get in the way
      
      @name $sf.ext._collapse
      @private
      @function
      @static
       */
      _collapse = function() {
        if (!force_collapse && (!is_registered || !is_expanded || pending_msg)) {
          return false;
        }
        _set_alignment(0, 0);
        return true;
      };
      _reattach_messaging = function() {
        if (ie_old_attach) {
          ie_old_detach(ONMSG, _handle_msg);
          return ie_old_attach(ONMSG, _handle_msg);
        } else if (w3c_old_attach) {
          w3c_old_detach(MSG, _handle_msg);
          return w3c_old_attach(MSG, _handle_msg);
        }
      };

      /*
      Intialize the SafeFrame external vendor/client API, so that other features may be used
      This method MUST be called prior to using any other rich-media functionality (like expansion).
      
      @name $sf.ext.register
      @public
      @function
      @static
      @param {Number} initWidth The initial width (in pixels) expected of the content within the SafeFrame container
      @param {Number} initHeight The initial height (in pixels) expected of the content within the SafeFrame container
      @param {Function} [notify] A callback function that content can specify to be notified of status updates
       */
      register = function(initWidth, initHeight, notify) {
        if (is_registered || !guid) {
          return;
        }
        initWidth = _cnum(initWidth, 0, 0);
        initHeight = _cnum(initHeight, 0, 0);
        init_width = initWidth;
        init_height = initHeight;
        is_registered = true;
        if (lang.callable(notify)) {
          sandbox_cb = notify;
        } else {
          sandbox_cb = null;
        }
      };

      /*
      Make a request to expand the SafeFrame container to a certain size. Note that you may only call $sf.ext.expand
      to expand to the largest size needed, followed by calling collapse (and then repeat the same process if needed).
      Tweening or animation done, should be reserved for your own content, and you cannot make multiple calls to expand
      without a corresponding collapse.
      
      Note that when setting t, l, b, and r offset values, expansion will not cause the content inside the SafeFrame
      to hold it's current alignment, whereas using dx/dy or only setting partial offfsets (e.g {t:100,l:100} ==  dx:-100,dy:-100) will cause expansion to
      hold it's current alignment.
      
      @name $sf.ext.expand
      @public
      @static
      @function
      @param {Number|Object} deltaXorDesc If a number is specifed, SafeFrame will grow in size by this amount in pixels along the horizontal axis. Specifiy a negative value to grow to the left, and a postive value to grow to the right. <br />
      If an object is specified, it should contain "t","l","r","b" properties (top,left,bottom,right) for the amount in pixels to grow the container in each dimension
      @param {Number} deltaXorDesc.t Specifies to shift the top position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.l Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.b Specifies to shift the bottom position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Number} deltaXorDesc.r Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Boolean}deltaXorDesc.push  When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      @param {Number} deltaY If a number is specifed, SafeFrame will grow in size by this amount in pixels along the vertical axis. Specifiy a negative value to grow to the top, and a postive value to grow to the bottom. <br />
      Note that this value is ignored if deltaXorDesc is passed in as an object.
      
      @param {Boolean} push When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      
      @return {Boolean} true/false if the request to expand the container was sent. This does not mean that expansion is complete as expansion is an asynchronous process. Pass in a callback function to $sf.ext.register to get status updates.
       */
      expand = function(deltaXorDesc, deltaY, p) {
        var align_buffer, align_el, align_el_st, b, cmd_nm, cmd_str, doAlign, dx, dy, l, r, t, xn, yn;
        xn = false;
        yn = false;
        doAlign = false;
        cmd_nm = (p ? "exp-push" : EXPAND_COMMAND);
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id];
        dx = 0;
        dy = 0;
        r = void 0;
        b = void 0;
        t = void 0;
        l = void 0;
        align_el = void 0;
        align_el_st = void 0;
        align_buffer = void 0;
        if (!is_registered || pending_msg) {
          return;
        }
        if (p && !supports("exp-push")) {
          return;
        }
        if (deltaXorDesc && typeof deltaXorDesc === OBJ) {
          r = _cnum(deltaXorDesc.r, 0, 0);
          b = _cnum(deltaXorDesc.b, 0, 0);
          t = _cnum(deltaXorDesc.t, 0, 0);
          l = _cnum(deltaXorDesc.l, 0, 0);
          if (deltaXorDesc.push) {
            if (!supports("exp-push")) {
              return;
            }
            cmd_nm = "exp-push";
            cmd_str[1] = cmd_nm;
          }
          if (!r && l) {
            xn = true;
            dx = -1 * l;
          }
          if (r && !l) {
            dx = r;
          }
          if (!b && t) {
            yn = true;
            dy = -1 * t;
          }
          if (b && !t) {
            dy = b;
          }
          if ((t && b) || (l && r)) {
            doAlign = false;
          } else {
            doAlign = true;
          }
          if (doAlign) {
            _set_alignment(xn, yn);
            cmd_str.push("&dx=", dx, "&dy=", dy);
            _send_msg(_cstr(cmd_str), cmd_nm);
          } else {
            align_el = _elt("sf_align");
            align_el_st = align_el && align_el.style;
            align_buffer = ["position:absolute;"];
            if (t && b) {
              align_buffer.push("top:", t, "px;");
            } else if (t) {
              align_buffer.push("bottom:0px;");
            } else {
              if (b) {
                align_buffer.push("top:0px;");
              }
            }
            if (l && r) {
              align_buffer.push("left:", l, "px;");
            } else if (l) {
              align_buffer.push("right:0px;");
            } else {
              if (b) {
                align_buffer.push("left:0px;");
              }
            }
            if (align_el_st) {
              align_el_st.cssText = _cstr(align_buffer);
            }
            cmd_str.push("&exp_obj=", escape(ParamHash(deltaXorDesc)));
            _send_msg(_cstr(cmd_str), cmd_nm);
          }
        } else {
          deltaXorDesc = _cnum(deltaXorDesc, 0);
          deltaY = _cnum(deltaY, 0);
          if (deltaXorDesc <= 0 && deltaY <= 0) {
            return;
          }
          xn = deltaXorDesc <= 0;
          yn = deltaY <= 0;
          _set_alignment(xn, yn);
          cmd_str.push("&dx=", deltaXorDesc, "&dy=", deltaY);
          _send_msg(_cstr(cmd_str), cmd_nm);
        }
        return true;
      };

      /*
      Collapse the SafeFrame container after having called to expand. If no previous call to expand has been made, this call will do nothing.
      
      @name $sf.ext.collapse
      @public
      @static
      @function
       */
      collapse = function() {
        if (_collapse()) {
          _send_msg(_cstr(["cmd=", COLLAPSE_COMMAND, "&pos=", pos_id]), COLLAPSE_COMMAND);
        }
      };
      click = function() {
        return _send_cmd(NOTIFY_CLICKED);
      };
      viewed = function() {
        return _send_cmd(NOTIFY_VIEWED);
      };
      loaded = function() {
        return _send_cmd(NOTIFY_LOADED);
      };
      unviewed = function() {
        return _send_cmd(NOTIFY_UNVIEWED);
      };
      reload = function() {
        return _send_cmd(NOTIFY_RELOAD);
      };
      _requested = function() {
        _fire_sandbox_callback(NOTIFY_REQUESTED);
        return _send_cmd(NOTIFY_REQUESTED);
      };
      _send_cmd = function(cmd) {
        return _send_msg(_cstr(["cmd=", cmd, "&pos=", pos_id]), cmd);
      };

      /*
      Return geometric information about the SafeFrame container and it's status within a page
      
      @name $sf.ext.geom
      @public
      @static
      @function
      @return {Object} geom_info
       */
      geom = function() {
        return geom_info;
      };

      /*
      Return meta-data information that may have been specified by the publisher / host.
      
      @name $sf.ext.meta
      @public
      @static
      @function
      @param {String} propName the key name of the meta-data value to be retrieved
      @param {String} [owner_key] the super key name of the data to be retrieved
      @return {String} The value of some meta-data that may have been specified by the publisher / host or "".
       */
      meta = function(propName, owner_key) {
        var ret, shared;
        ret = "";
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              ret = _cstr(pos_meta[owner_key][propName]);
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                ret = _cstr(pos_meta.non_shared[owner_key][propName]);
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              ret = _cstr(shared[propName]);
            }
          }
        }
        return ret;
      };
      deleteMeta = function(propName, owner_key) {
        var shared;
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              return delete pos_meta[owner_key][propName];
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                return delete pos_meta.non_shared[owner_key][propName];
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              return delete shared[propName];
            }
          }
        }
      };

      /*
      Return the current status of the SafeFrame container, in cases where
      a command may be pending. If an empty string is returned ("") container is idle.
      
      @name $sf.ext.status
      @public
      @static
      @function
      @return {String} of any pending status, otherwise empty string.
       */
      status = function() {
        if (pending_msg) {
          if (pending_msg.cmd === EXPAND_COMMAND) {
            return STATUS_EXPANDING;
          } else {
            if (pending_msg.cmd === COLLAPSE_COMMAND) {
              return STATUS;
            }
          }
        }
        if (is_expanded) {
          return STATUS_EXPANDED;
        } else {
          return STATUS_COLLAPSED;
        }
      };

      /*
      Requests the host read or write a cookie to the host domain.
      The host domain must grant permission for the cookie to be written.
      
      @name $sf.ext.cookie
      @public
      @static
      @function
      @param {String} [cookieName] The name of the cookie to set or read
      @param {Object} [cookieData] An object hash containing the value and an optional expires
      @return {Number}
       */
      cookie = function(cookieName, cookieData) {
        var cmd_nm, cmd_str, isRead;
        isRead = !(cookieData != null);
        cmd_nm = (isRead ? "read-cookie" : "write-cookie");
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id, "&cookie=", cookieName];
        if (!isRead) {
          cmd_str.push("&value=");
          cmd_str.push(cookieData.value);
        }
        _send_msg(_cstr(cmd_str), cmd_nm);
      };

      /*
      Send a message to the host
      
      @name $sf.ext.message
      @public
      @static
      @function
       */
      message = function(content) {
        _send_msg(_cstr(["cmd=", "msg", "&pos=", pos_id, "&msg=", content]), "msg");
      };

      /*
      Return the percentage that the SafeFrame container is viewable within the browser window
      
      @name $sf.ext.inViewPercentage
      @public
      @static
      @function
      @return {Number}
       */
      inViewPercentage = function() {
        var iv, tv;
        iv = _cnum(geom_info && geom_info.self && geom_info.self.iv, -1, 0);
        tv = void 0;
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      winHasFocus = function() {
        return win_has_focus;
      };

      /*
      Return whether or not a particular feature is supported, or an object containing
      key/value pairs denoting all features and whether or not they are supported
      
      By default SafeFrames version 1 supports the following feature:
      
      "exp-ovr": Expansion of the container by overlaying on top of other content
      
      Later in other versions there are expexted to be more feature with their own
      string name, that can be checked by the content in the SafeFrame, so that
      it knows what things can be done.
      
      @name $sf.ext.supports
      @public
      @static
      @function
      @param {String} [key] If specifed, checks to see if that specific feature has been enabled
      @return {Boolean|Object}
       */
      supports = function(key) {
        var conf, sup;
        conf = render_params.conf;
        sup = (conf && conf.supports) || false;
        if (sup) {
          key = _cstr(key);
          if (key) {
            sup = sup[key] || false;
            if (sup === "0") {
              sup = false;
            }
          } else {
            sup = lang.mix({}, sup);
          }
        }
        return sup;
      };
      render = function(showAd, cb) {
        var err_info;
        err_info = {};
        if (_construction(err_info)) {
          if (showAd) {
            return _render(cb);
          }
        }
      };
      showAd = function(cb) {
        if (!isAdShown) {
          return _render(cb);
        }
      };
      adShown = function() {
        return isAdShown;
      };
      lang.mix(sf.ext, {
        register: register,
        expand: expand,
        collapse: collapse,
        geom: geom,
        meta: meta,
        deleteMeta: deleteMeta,
        status: status,
        supports: supports,
        cookie: cookie,
        message: message,
        inViewPercentage: inViewPercentage,
        winHasFocus: winHasFocus,
        click: click,
        viewed: viewed,
        unviewed: unviewed,
        showAd: showAd,
        adShown: adShown,
        reload: reload
      });
      if (!isExternal) {
        window.$sf = sf;
        render();
      } else {
        window.$sf = sf;
        sf.ext.render = render;
      }
      return sf;
    })(window, sf);
  };

}).call(this);

},{"../shared/base":12}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":13,"./env":14,"./lang":15,"./logger":16}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":14,"./lang":15}],14:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./lang":15,"8DwohR":26}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, keys, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, wrap, _es, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray,
      wrap: wrap,
      keys: keys
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],17:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":18,"ieee754":19}],18:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],19:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],20:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":17}],21:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":22,"./rng":23,"./sha":24,"./sha256":25,"buffer":17}],22:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":20}],23:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],24:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":20}],25:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":20}],26:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL2ZyYW1lLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvcmVxdWVzdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9iYXNlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL2NvbmZpZy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9ldmVudC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9zdHJlYW0uanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvdXRpbHMuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9qc29uL2pzb24yLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvbm9kZS11dWlkL3V1aWQuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9yZXF3ZXN0L3JlcXdlc3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL2V4dC9leHQuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9iYXNlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvZG9tLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvZW52LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvbGFuZy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2xvZ2dlci5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2hlbHBlcnMuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3JuZy5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEyNTYuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzduQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyICRzZiwgUmVxdWVzdCwgY29uZmlnLCBjdXJyZW50TmFtZSwgZXZlbnRzLCBzdHJlYW0sIHV0aWxzO1xuXG4gIGN1cnJlbnROYW1lID0gd2luZG93Lm5hbWU7XG5cbiAgJHNmID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvZXh0L2V4dCcpKHRydWUpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4vc2hhcmVkL2V2ZW50JykoW1wicmVxdWVzdFwiLCBcImxvYWRcIiwgXCJ2aWV3XCIsIFwiY2xpY2tcIiwgXCJleHBhbmRlZFwiLCBcImNvbGxhcHNlZFwiLCBcImVuZ2FnZVwiLCBcInVudmlld1wiLCBcInVubG9hZFwiXSk7XG5cbiAgdXRpbHMgPSByZXF1aXJlKCcuL3NoYXJlZC91dGlscycpO1xuXG4gIFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcblxuICBzdHJlYW0gPSByZXF1aXJlKCcuL3NoYXJlZC9zdHJlYW0nKTtcblxuICBjb25maWcgPSByZXF1aXJlKCcuL3NoYXJlZC9jb25maWcnKTtcblxuICAoZnVuY3Rpb24oJHNmLCB3aW5kb3cpIHtcbiAgICB2YXIgQWRKUywgVklFV0VEX1NUUklLRSwgYXR0cmlidXRlcywgY29udHJvbGxlciwgZGlkU2hvdywgZmluZENvbnRyb2xsZXIsIGZvcmNlTnVrZSwgaGVpZ2h0LCBob3N0LCBpc1ZpZXdlZEludGVydmFsLCBsb2NhdGlvbiwgbWF4Vmlld1BlcmNlbnRhZ2UsIG9uVXBkYXRlLCByZWZlcnJlckxldmVsLCByZWdpc3RlckFkSlNlbmRwb2ludHMsIHJlZ2lzdGVyRm9yRXZlbnRzLCByZWdpc3RlcmVkLCByZXF1ZXN0LCByZXF1ZXN0ZWQsIHNmRG9tLCBzaG93QWQsIHNob3dBZFRpbWVyLCBzaG93UGFnZSwgc3RhcnRUaWNrcywgdW52aWV3ZWRUaWNrcywgdXBkYXRlSXNWaWV3ZWQsIHVwZGF0ZVJlZmVycmVyLCB2aWV3ZWRQZXJjZW50YWdlcywgdmlld2VkVGlja3MsIHdpZHRoO1xuICAgIGRvY3VtZW50LmRvbWFpbiA9IGNvbmZpZy5kb21haW47XG4gICAgY29udHJvbGxlciA9IG51bGw7XG4gICAgc2ZEb20gPSAkc2YubGliLmRvbTtcbiAgICBBZEpTID0ge307XG4gICAgdXRpbHMuZGVmaW5lUHJvcGVydHkoQWRKUywgXCJpc0NvbnRyb2xsZXJcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Quc2V0KHtcbiAgICAgIGxvYWRfcG9zOiB1dGlscy5nZXRGcmFtZVBvc2l0aW9uKHdpbmRvdyksXG4gICAgICB2X2pzOiBjb25maWcudmVyc2lvbixcbiAgICAgIHJlcV91cmxfYmxpbmQ6IHRydWUsXG4gICAgICB0ejogKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClcbiAgICB9KTtcbiAgICBmaW5kQ29udHJvbGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZyYW1lLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBfcmVmID0gd2luZG93LnBhcmVudC5mcmFtZXM7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZnJhbWUgPSBfcmVmW19pXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoKF9yZWYxID0gZnJhbWUuJGFkKSAhPSBudWxsID8gX3JlZjEuaXNDb250cm9sbGVyIDogdm9pZCAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gZnJhbWUuJGFkO1xuICAgICAgICAgICAgcmVxdWVzdC5jaGFuZ2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnNlbmQocmVxdWVzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2VuZChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmaW5kQ29udHJvbGxlciwgMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZpbmRDb250cm9sbGVyKCk7XG4gICAgVklFV0VEX1NUUklLRSA9IDk7XG4gICAgdmlld2VkVGlja3MgPSAwO1xuICAgIHVudmlld2VkVGlja3MgPSAwO1xuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBkaWRTaG93ID0gZmFsc2U7XG4gICAgcmVxdWVzdGVkID0gZmFsc2U7XG4gICAgc3RhcnRUaWNrcyA9IHV0aWxzLm5vdygpO1xuICAgIG1heFZpZXdQZXJjZW50YWdlID0gMDtcbiAgICB2aWV3ZWRQZXJjZW50YWdlcyA9IFtdO1xuICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBBZEpTLnNldERpbWVuc2lvbnMgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgICByZXR1cm4gaGVpZ2h0ID0gaDtcbiAgICB9O1xuICAgIHJlZ2lzdGVyRm9yRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiAkc2YuZXh0LnJlZ2lzdGVyKHdpZHRoLCBoZWlnaHQsIG9uVXBkYXRlKTtcbiAgICB9O1xuICAgIHJlZ2lzdGVyQWRKU2VuZHBvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB1cGRhdGVSZWZlcnJlciA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICBsZXZlbCA9IFwiYWxsXCI7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBcImhvc3RcIjpcbiAgICAgICAgICB1dGlscy5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgXCJyZWZlcnJlclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBvblVwZGF0ZSA9IGZ1bmN0aW9uKHN0YXR1cywgZGF0YSkge1xuICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImV4cGFuZGVkXCI6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEFkSlMuZXhwYW5kZWQoKTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiY29sbGFwc2VkXCI6XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEFkSlMuY29sbGFwc2VkKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImdlb20tdXBkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHNob3dBZCgpO1xuICAgICAgICBjYXNlIFwiZW5nYWdlZFwiOlxuICAgICAgICAgIHJldHVybiBBZEpTLmVuZ2FnZSgpO1xuICAgICAgICBjYXNlIFwicmVxdWVzdGVkXCI6XG4gICAgICAgICAgaWYgKCFyZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBBZEpTLnJlcXVlc3QoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpc1ZpZXdlZEludGVydmFsID0gbnVsbDtcbiAgICB1cGRhdGVJc1ZpZXdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpZXdQZXJjZW50LCBfYmFzZTtcbiAgICAgIHZpZXdQZXJjZW50ID0gKHR5cGVvZiAoX2Jhc2UgPSAkc2YuZXh0KS5pblZpZXdQZXJjZW50YWdlID09PSBcImZ1bmN0aW9uXCIgPyBfYmFzZS5pblZpZXdQZXJjZW50YWdlKCkgOiB2b2lkIDApIHx8IDA7XG4gICAgICBpZiAoIUFkSlMuaXNWaWV3ZWQgJiYgdmlld1BlcmNlbnQgPiA1MCAmJiAkc2YuZXh0Lndpbkhhc0ZvY3VzKCkpIHtcbiAgICAgICAgdmlld2VkVGlja3MrKztcbiAgICAgICAgdmlld2VkUGVyY2VudGFnZXMucHVzaCh2aWV3UGVyY2VudCk7XG4gICAgICB9IGVsc2UgaWYgKEFkSlMuaXNWaWV3ZWQgJiYgKHZpZXdQZXJjZW50IDwgNTAgfHwgISRzZi5leHQud2luSGFzRm9jdXMoKSkpIHtcbiAgICAgICAgdW52aWV3ZWRUaWNrcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW52aWV3ZWRUaWNrcyA9IHZpZXdlZFRpY2tzID0gMDtcbiAgICAgICAgdmlld2VkUGVyY2VudGFnZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3ZWRUaWNrcyA9PT0gVklFV0VEX1NUUklLRSkge1xuICAgICAgICBpZiAoIUFkSlMuaXNWaWV3ZWQpIHtcbiAgICAgICAgICBBZEpTLnZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBBZEpTLmlzVmlld2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnZpZXdlZFRpY2tzID09PSBWSUVXRURfU1RSSUtFKSB7XG4gICAgICAgIGlmICghQWRKUy5pc3VuVmlld2VkKSB7XG4gICAgICAgICAgQWRKUy51bnZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBBZEpTLmlzdW5WaWV3ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhckludGVydmFsKGlzVmlld2VkSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgaWYgKHZpZXdQZXJjZW50ID4gbWF4Vmlld1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1heFZpZXdQZXJjZW50YWdlID0gdmlld1BlcmNlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaG93QWRUaW1lciA9IG51bGw7XG4gICAgc2hvd0FkID0gZnVuY3Rpb24oc2hvdykge1xuICAgICAgdmFyIHN0YXJ0VGltZSwgX2Jhc2U7XG4gICAgICBpZiAoKCh0eXBlb2YgKF9iYXNlID0gJHNmLmV4dCkuaW5WaWV3UGVyY2VudGFnZSA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2UuaW5WaWV3UGVyY2VudGFnZSgpIDogdm9pZCAwKSA+IDUgJiYgIWRpZFNob3cpIHx8IHNob3cpIHtcbiAgICAgICAgaWYgKHNob3dBZFRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChzaG93QWRUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIEFkSlMucmVxdWVzdCgpO1xuICAgICAgICAkc2YuZXh0LnNob3dBZChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQWRKUy5sb2FkKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlkU2hvdyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEoc2hvd0FkVGltZXIgfHwgZGlkU2hvdykpIHtcbiAgICAgICAgcmV0dXJuIHNob3dBZFRpbWVyID0gc2V0SW50ZXJ2YWwoZm9yY2VOdWtlLCA1MCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3JjZU51a2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYmFzZTtcbiAgICAgIGlmICgodHlwZW9mIChfYmFzZSA9ICRzZi5leHQpLmluVmlld1BlcmNlbnRhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IF9iYXNlLmluVmlld1BlcmNlbnRhZ2UoKSA6IHZvaWQgMCkgPiA1ICYmIHNob3dBZFRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoc2hvd0FkVGltZXIpO1xuICAgICAgICBzaG93QWRUaW1lciA9IG51bGw7XG4gICAgICAgIHJldHVybiAkc2YuZXh0LnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgJHNmLmxpYi5sYW5nLm1peChBZEpTLCBldmVudHMpO1xuICAgIEFkSlMub24gPSBmdW5jdGlvbihldmVudCwgY2IpIHtcbiAgICAgIHJldHVybiBldmVudHMub24uYXBwbHkodGhpcywgW2V2ZW50LCBjYl0pO1xuICAgIH07XG4gICAgQWRKUy5leHBhbmQgPSBmdW5jdGlvbihkZWx0YVhvckRlc2MsIGRlbHRhWSwgcCkge1xuICAgICAgcmV0dXJuICRzZi5leHQuZXhwYW5kKGRlbHRhWG9yRGVzYywgZGVsdGFZLCBwKTtcbiAgICB9O1xuICAgIEFkSlMuY29sbGFwc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAkc2YuZXh0LmNvbGxhcHNlKCk7XG4gICAgfTtcbiAgICBBZEpTLmNvb2tpZSA9IGZ1bmN0aW9uKGNvb2tpZU5hbWUsIGNvb2tpZURhdGEpIHtcbiAgICAgIHJldHVybiAkc2YuZXh0LmNvb2tpZShjb29va2llTmFtZSwgY29va2llRGF0YSk7XG4gICAgfTtcbiAgICBBZEpTLnN1cHBvcnRzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gJHNmLmV4dC5zdXBwb3J0cyhrZXkpO1xuICAgIH07XG4gICAgQWRKUy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJHNmLmV4dC5tZXNzYWdlKGVuY29kZVVSSUNvbXBvbmVudChjb250ZW50KSk7XG4gICAgICB9LCAxKTtcbiAgICB9O1xuICAgIHNmRG9tLmF0dGFjaChkb2N1bWVudC5ib2R5LCBcIm1vdXNldXBcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLmNsaWNrKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICB3aW5kb3cuJGFkID0gQWRKUztcbiAgICByZWdpc3RlckFkSlNlbmRwb2ludHMoKTtcbiAgICBBZEpTLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICRzZi5leHQuY2xpY2soKTtcbiAgICB9KTtcbiAgICBBZEpTLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNmLmV4dC52aWV3ZWQoKTtcbiAgICB9KTtcbiAgICBBZEpTLnVudmlldyhmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAkc2YuZXh0LnVudmlld2VkKCk7XG4gICAgfSk7XG4gICAgQWRKUy5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyRm9yRXZlbnRzKCk7XG4gICAgfSk7XG4gICAgQWRKUy5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzVmlld2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh1cGRhdGVJc1ZpZXdlZCwgMTAwKTtcbiAgICB9KTtcbiAgICBBZEpTLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLmxvYWRDaGFpbiA9IHV0aWxzLmNvdW50RnJhbWVzKHdpbmRvdyk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICBsb2FkX2NoYWluOiBBZEpTLmxvYWRDaGFpblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy5yZXF1ZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdlb0luZm8sIF9iYXNlO1xuICAgICAgQWRKUy5yZXF1ZXN0VGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgZ2VvSW5mbyA9ICRzZi5leHQuZ2VvbSgpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgcmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICByZXF1ZXN0ZWRBdDogdXRpbHMubm93KCksXG4gICAgICAgIHJlcV90OiB1dGlscy5ub3coKSAtIHN0YXJ0VGlja3MsXG4gICAgICAgIHJlcV92aWV3X3BjdDogdHlwZW9mIChfYmFzZSA9ICRzZi5leHQpLmluVmlld1BlcmNlbnRhZ2UgPT09IFwiZnVuY3Rpb25cIiA/IF9iYXNlLmluVmlld1BlcmNlbnRhZ2UoKSA6IHZvaWQgMCxcbiAgICAgICAgc2xvdF94OiBnZW9JbmZvLnNlbGYubCxcbiAgICAgICAgc2xvdF95OiBnZW9JbmZvLnNlbGYudCxcbiAgICAgICAgc2xvdF93OiBnZW9JbmZvLnNlbGYudyxcbiAgICAgICAgc2xvdF9oOiBnZW9JbmZvLnNlbGYuaCxcbiAgICAgICAgc2NyZWVuX3c6IHdpbmRvdy5zY3JlZW4ud2lkdGgsXG4gICAgICAgIHNjcmVlbl9oOiB3aW5kb3cuc2NyZWVuLmhlaWdodCxcbiAgICAgICAgdnBfeDogZ2VvSW5mby53aW4ubCxcbiAgICAgICAgdnBfeTogZ2VvSW5mby53aW4udCxcbiAgICAgICAgdnBfdzogZ2VvSW5mby53aW4udyxcbiAgICAgICAgdnBfaDogZ2VvSW5mby53aW4uaFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgQWRKUy5sb2FkVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgY29uc29sZS5sb2coXCJsb29vb29hZGRlZGRkZGRcIik7XG4gICAgICBzZkRvbS5hdHRhY2god2luZG93LCBcInVubG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRhZC51bmxvYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICBsb2FkZWRBdDogdXRpbHMubm93KCksXG4gICAgICAgIGxvYWRfdDogdXRpbHMubm93KCkgLSBzdGFydFRpY2tzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICBBZEpTLnZpZXdUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICB2aWV3ZWQ6IHRydWUsXG4gICAgICAgIHZpZXdlZEF0OiB1dGlscy5ub3coKSxcbiAgICAgICAgdmlld190OiB1dGlscy5ub3coKSAtIHN0YXJ0VGlja3MsXG4gICAgICAgIHZpZXdfbWVhczogdHJ1ZSxcbiAgICAgICAgdmlld19wY3Q6IHV0aWxzLnJlZHVjZSh2aWV3ZWRQZXJjZW50YWdlcywgKGZ1bmN0aW9uKG1lbW8sIG51bSkge1xuICAgICAgICAgIHJldHVybiBtZW1vICsgbnVtO1xuICAgICAgICB9KSwgMCkgLyB2aWV3ZWRQZXJjZW50YWdlcy5sZW5ndGgsXG4gICAgICAgIHZpZXdfcGN0X21heDogbWF4Vmlld1BlcmNlbnRhZ2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIEFkSlMuZW5nYWdlKGZ1bmN0aW9uKCkge1xuICAgICAgQWRKUy5lbmdhZ2VUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICBlbmdhZ2VkOiB0cnVlLFxuICAgICAgICB2aWV3X2VuZzogdHJ1ZSxcbiAgICAgICAgZW5nYWdlZEF0OiB1dGlscy5ub3coKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgQWRKUy5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMuY2xpY2tUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5zZXQoe1xuICAgICAgICBjbGlja2VkOiB0cnVlLFxuICAgICAgICBjbGlja2VkQXQ6IHV0aWxzLm5vdygpLFxuICAgICAgICBjbGtfdDogdXRpbHMubm93KCkgLSBzdGFydFRpY2tzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnVudmlldyhmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMudW52aWV3VGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgdW52aWV3ZWQ6IHRydWUsXG4gICAgICAgIHVudmlld2VkQXQ6IHV0aWxzLm5vdygpLFxuICAgICAgICB2aWV3X2R1cjogdXRpbHMubm93KCkgLSBBZEpTLnZpZXdlZEF0LFxuICAgICAgICB2aWV3X3BjdF9tYXg6IG1heFZpZXdQZXJjZW50YWdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBBZEpTLnVubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIEFkSlMudW5sb2FkVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2V0KHtcbiAgICAgICAgdW5sb2FkZWQ6IHRydWUsXG4gICAgICAgIHVubG9hZGVkQXQ6IHV0aWxzLm5vdygpLFxuICAgICAgICB1bmxfdDogdXRpbHMubm93KCkgLSBzdGFydFRpY2tzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAkc2YuZXh0LnJlbmRlcihmYWxzZSk7XG4gICAgZGlkU2hvdyA9ICEkc2YubGliLmxhbmcuY2Jvb2woJHNmLmV4dC5tZXRhKFwiaW52aWV3XCIsIFwiZXh0ZW5kZWRcIikpO1xuICAgIHJlZmVycmVyTGV2ZWwgPSAkc2YuZXh0Lm1ldGEoXCJyZWZlcnJlclwiLCBcImV4dGVuZGVkXCIpIHx8IFwiYWxsXCI7XG4gICAgaG9zdCA9ICRzZi5leHQubWV0YShcImhvc3RcIiwgXCJleHRlbmRlZFwiKTtcbiAgICAkc2YuZXh0LmRlbGV0ZU1ldGEoXCJob3N0XCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgbG9jYXRpb24gPSAkc2YuZXh0Lm1ldGEoXCJsb2NhdGlvblwiLCBcImV4dGVuZGVkXCIpO1xuICAgICRzZi5leHQuZGVsZXRlTWV0YShcImxvY2F0aW9uXCIsIFwiZXh0ZW5kZWRcIik7XG4gICAgJGFkLnNsb3RJZCA9ICRzZi5leHQubWV0YShcInNsb3RfaWRcIiwgXCJleHRlbmRlZFwiKTtcbiAgICAkYWQuY291bnQgPSAkc2YuZXh0Lm1ldGEoXCJsb2FkX25cIiwgXCJleHRlbmRlZFwiKTtcbiAgICByZXF1ZXN0LnNldCh7XG4gICAgICBzbG90X2lkOiAkc2YuZXh0Lm1ldGEoXCJzbG90X2lkXCIsIFwiZXh0ZW5kZWRcIiksXG4gICAgICBsb2FkX246ICRzZi5leHQubWV0YShcImxvYWRfblwiLCBcImV4dGVuZGVkXCIpLFxuICAgICAgcGFnZV91cmw6IGxvY2F0aW9uLFxuICAgICAgcGFnZV9ob3N0OiBob3N0XG4gICAgfSwge1xuICAgICAgc2lsZW50OiB0cnVlXG4gICAgfSk7XG4gICAgc2hvd1BhZ2UgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmID09PSBkb2N1bWVudC5yZWZlcnJlciB8fCB1cGRhdGVSZWZlcnJlcihyZWZlcnJlckxldmVsKTtcbiAgICBpZiAoc2hvd1BhZ2UpIHtcbiAgICAgIHNob3dBZChkaWRTaG93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93Lm5hbWUgPSBjdXJyZW50TmFtZTtcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uID0gZG9jdW1lbnQubG9jYXRpb247XG4gICAgfVxuICAgIHJldHVybiBBZEpTO1xuICB9KSgkc2YsIHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBCYXNlLCB1dWlkLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIEJhc2UgPSByZXF1aXJlKCcuL3NoYXJlZC9iYXNlJyk7XG5cbiAgdXVpZCA9IHJlcXVpcmUoJ25vZGUtdXVpZCcpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBSZXF1ZXN0O1xuICAgIFJlcXVlc3QgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMoUmVxdWVzdCwgX3N1cGVyKTtcblxuICAgICAgZnVuY3Rpb24gUmVxdWVzdChjbGllbnRJZCwgc2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgICAgIFJlcXVlc3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaWQgPSB1dWlkLnY0KCk7XG4gICAgICB9XG5cbiAgICAgIFJlcXVlc3QucHJvdG90eXBlLnBhdGggPSBcIi9ldmVudFwiO1xuXG4gICAgICBSZXF1ZXN0LnByb3RvdHlwZS5jb25zdGFudEZpZWxkcyA9IFtcInNpdGVfdXNlcl9pZFwiLCBcInBhZ2VfaWRcIiwgXCJ2aXNpdF9pZFwiLCBcImZ1bGxfdXJsXCIsIFwicmVxX2lkXCJdO1xuXG4gICAgICByZXR1cm4gUmVxdWVzdDtcblxuICAgIH0pKEJhc2UpO1xuICAgIHJldHVybiBSZXF1ZXN0O1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgdXRpbHMsIHV1aWQ7XG5cbiAgdXVpZCA9IHJlcXVpcmUoJ25vZGUtdXVpZCcpO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBCYXNlO1xuICAgIHJldHVybiBCYXNlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQmFzZSgpIHtcbiAgICAgICAgdGhpcy5pZCA9IHV1aWQudjQoKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzIHx8ICh0aGlzLmF0dHJpYnV0ZXMgPSB7fSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIGYsIGssIHYsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgXCJhdHRycyBtdXN0IGJlIGFuIG9iamVjdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIGF0dHJzKSB7XG4gICAgICAgICAgdiA9IGF0dHJzW2tdO1xuICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXNba10gIT09IHYpIHtcbiAgICAgICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzLnB1c2goayk7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eVtrXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiBjaGFuZ2VkQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmLmFwcGx5KHRoaXMsIFt0aGlzLCBjaGFuZ2VkQXR0cmlidXRlc10pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBCYXNlLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIGlmIChmICYmIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWYpIHtcbiAgICAgICAgICBfcmVmID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmID0gX3JlZltfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuX2NsZWFuRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5ID0ge307XG4gICAgICB9O1xuXG4gICAgICBCYXNlLnByb3RvdHlwZS5jaGFuZ2VkRmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWVsZCwgaywgcGFyYW1zLCB2LCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfcmVmID0gdGhpcy5fZGlydHk7XG4gICAgICAgIGZvciAoayBpbiBfcmVmKSB7XG4gICAgICAgICAgdiA9IF9yZWZba107XG4gICAgICAgICAgcGFyYW1zW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICBfcmVmMSA9IHRoaXMuY29uc3RhbnRGaWVsZHM7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBmaWVsZCA9IF9yZWYxW19pXTtcbiAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW2ZpZWxkXSkge1xuICAgICAgICAgICAgcGFyYW1zW2ZpZWxkXSA9IHRoaXMuYXR0cmlidXRlc1tmaWVsZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFuRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH07XG5cbiAgICAgIEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXRpbHMudG9RdWVyeSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHV0aWxzLmZyb21RdWVyeShzdHIpLCB7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEJhc2U7XG5cbiAgICB9KSgpO1xuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJ2Jhc2UvbGliL2h0bWwvYWRqc2ZyYW1lLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyX3VybDogXCJiYXNlL2xpYi9odG1sL2NvbnRyb2xsZXJmcmFtZS5odG1sXCIsXG4gICAgICAgIHZpc2l0X2V4cGlyeTogNSxcbiAgICAgICAgdmVyc2lvbjogXCIwLjAuMVwiLFxuICAgICAgICBkb21haW46IFwibG9jYWxob3N0XCJcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcGk6IFwiLy9hcGkuYWRqcy5uZXQvMVwiLFxuICAgICAgICBjZG5fdXJsOiBcIi8vY2RuLmFkanMubmV0L2h0bWwvYWRqc2ZyYW1lLmh0bWxcIixcbiAgICAgICAgdmlzaXRfZXhwaXJ5OiAzMCxcbiAgICAgICAgdmVyc2lvbjogXCIwLjAuMVwiLFxuICAgICAgICBkb21haW46IFwiYWRqcy5uZXRcIixcbiAgICAgICAgY29udHJvbGxlcl91cmw6IFwiLy9jZG4uYWRqcy5uZXQvaHRtbC9jb250cm9sbGVyZnJhbWUuaHRtbFwiXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcGk6ICcvL2VuZHBvaW50LmFkanMuZGV2OjgwODAvMScsXG4gICAgICAgIGNkbl91cmw6ICcuLi9saWIvaHRtbC9hZGpzZnJhbWUuaHRtbCcsXG4gICAgICAgIHZpc2l0X2V4cGlyeTogMyxcbiAgICAgICAgdmVyc2lvbjogXCIwLjAuMVwiLFxuICAgICAgICBkb21haW46IFwibG9jYWxob3N0XCIsXG4gICAgICAgIGNvbnRyb2xsZXJfdXJsOiBcIi4uL2xpYi9odG1sL2NvbnRyb2xsZXJmcmFtZS5odG1sXCJcbiAgICAgIH07XG4gICAgfVxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjhEd29oUlwiKSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXZlbnROYW1lcykge1xuICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIGV2ZW50cywgX2ksIF9sZW47XG4gICAgICBldmVudHMgPSB7XG4gICAgICAgIG9uOiBmdW5jdGlvbihldmVudCwgY2IpIHtcbiAgICAgICAgICB2YXIgZXZlbnRMaXN0O1xuICAgICAgICAgIHRoaXMuZXZlbnRzIHx8ICh0aGlzLmV2ZW50cyA9IHt9KTtcbiAgICAgICAgICBldmVudExpc3QgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgW107XG4gICAgICAgICAgZXZlbnRMaXN0LnB1c2goY2IpO1xuICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IGV2ZW50TGlzdDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgIG9wdGlvbmFsRGF0YSBuZWVkcyB0byBiZSBmaXhlZFxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGRhdGEsIG9wdGlvbmFsRGF0YSkge1xuICAgICAgICAgIHZhciBlLCBleCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICAgICAgdGhpcy5ldmVudHMgfHwgKHRoaXMuZXZlbnRzID0ge30pO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBlID0gX3JlZltfaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlLmNhbGwodGhpcywgZGF0YSwgb3B0aW9uYWxEYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBleCA9IF9lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGV2ZW50TmFtZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZXZlbnQgPSBldmVudE5hbWVzW19pXTtcbiAgICAgICAgZXZlbnRzW2V2ZW50XSA9IChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIHJldHVybiBmID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9KSgpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgY29uZmlnLCByZXF3ZXN0O1xuXG4gIHJlcXdlc3QgPSByZXF1aXJlKCdyZXF3ZXN0Jyk7XG5cbiAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFwcGluZywgcGVuZGluZ1JlcXVlc3RzLCBwcmVmaXgsIHNlbmQsIHNlbmRpbmdSZXF1ZXN0cztcbiAgICBwcmVmaXggPSBjb25maWcuYXBpO1xuICAgIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuICAgIHNlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuICAgIG1hcHBpbmcgPSB7XG4gICAgICBpZDogXCJ1c2VyX2lkXCIsXG4gICAgICBwOiBcInNpdGVfcGFnZV92d1wiLFxuICAgICAgYTogXCJzaXRlX2FkX3JlcVwiLFxuICAgICAgYXY6IFwic2l0ZV9hZF92d1wiLFxuICAgICAgYWM6IFwic2l0ZV9hZF9jbGtcIixcbiAgICAgIGFlOiBcInNpdGVfYWRfdndfZW5nXCIsXG4gICAgICB2OiBcInNpdGVfdmlzXCIsXG4gICAgICB2cDogXCJ2aXNfcGFnZV92d1wiLFxuICAgICAgdmE6IFwidmlzX2FkX3JlcVwiLFxuICAgICAgdmF2OiBcInZpc19hZF92d1wiLFxuICAgICAgdmFlOiBcInZpc19hZF92d19lbmdcIixcbiAgICAgIHZhYzogXCJ2aXNfYWRfY2xrXCJcbiAgICB9O1xuICAgIHNlbmQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICByZXR1cm4gcmVxd2VzdCh7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICB0eXBlOiAnanNvbnAnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2U6IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIGVycm9yLCBzdWNjZXNzO1xuICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHJldHVybiBzZXNzaW9uLnNldChyZXNwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJFUlJPUjpcIiArIGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZW5kKHByZWZpeCArICcvcGFnZScsIHNlc3Npb24uYXR0cmlidXRlcywgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50OiBmdW5jdGlvbihyZXF1ZXN0LCBjYiwgaXNBdHRlbXB0KSB7XG4gICAgICAgIHZhciBlcnJvciwgaywgcGFyYW1zLCBzdWNjZXNzLCB2LCBfcmVmO1xuICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHJlcXVlc3Quc2V0KHJlc3AsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2IocmVzcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWxldGUgc2VuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVSUk9SOlwiICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF0pIHtcbiAgICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICAgIHNlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSA9IHRydWU7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgX3JlZiA9IHJlcXVlc3QuYXR0cmlidXRlcztcbiAgICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgICAgdiA9IF9yZWZba107XG4gICAgICAgICAgICBwYXJhbXNbbWFwcGluZ1trXSB8fCBrXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZW5kKHByZWZpeCArICcvZXZlbnQnLCBwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICghcGVuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdIHx8IGlzQXR0ZW1wdCkge1xuICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXTtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV2ZW50KHJlcXVlc3QsIGNiLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkodGhpcyksIDUwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgcmVxd2VzdDtcblxuICB3aW5kb3cuSlNPTiB8fCAod2luZG93LkpTT04gPSByZXF1aXJlKCdqc29uJykpO1xuXG4gIHJlcXdlc3QgPSByZXF1aXJlKCdyZXF3ZXN0Jyk7XG5cbiAgd2luZG93LkpTT04gfHwgKHdpbmRvdy5KU09OID0gcmVxdWlyZSgnanNvbicpKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigkc2YpIHtcbiAgICB2YXIgY2FwaXRhbGl6ZVN0cmluZywgY291bnRGcmFtZXMsIGRlZmluZVByb3BlcnR5LCBmcm9tUXVlcnksIGdldEZyYW1lUG9zaXRpb24sIGtleXMsIG5hdGl2ZVJlZHVjZSwgbm93LCByZWR1Y2UsIHJlZHVjZUVycm9yLCBzZW5kUmVxdWVzdCwgdG9OdW1iZXIsIHRvUXVlcnk7XG4gICAgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxd2VzdChvcHRpb25zKTtcbiAgICB9O1xuICAgIGZyb21RdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5LCBkZWxpbSkge1xuICAgICAgdmFyIGl0ZW0sIGtleSwgcGFyYW1zLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKHF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgcXVlcnkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGltID09IG51bGwpIHtcbiAgICAgICAgZGVsaW0gPSBcIiZcIjtcbiAgICAgIH1cbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgX3JlZiA9IHF1ZXJ5LnNwbGl0KGRlbGltKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpdGVtID0gX3JlZltfaV07XG4gICAgICAgIF9yZWYxID0gaXRlbS5zcGxpdChcIj1cIiksIGtleSA9IF9yZWYxWzBdLCB2YWx1ZSA9IF9yZWYxWzFdO1xuICAgICAgICBwYXJhbXNba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgdG9RdWVyeSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiByZXF3ZXN0LnRvUXVlcnlTdHJpbmcoYXR0cmlidXRlcyk7XG4gICAgfTtcbiAgICB0b051bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICRzZiAhPSBudWxsID8gJHNmLmxpYi5sYW5nLmNudW0odmFsLCAwKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIG5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgdmFyIGU7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXCJkZWZpbmVQcm9wZXJ0eVwiIGluIE9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIl9fZGVmaW5lR2V0dGVyX19cIiBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18ocHJvcCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci53cml0YWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai5fX2RlZmluZVNldHRlcl9fKHByb3AsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvdW50RnJhbWVzID0gZnVuY3Rpb24od2luKSB7XG4gICAgICB2YXIgY291bnQsIGZyYW1lLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGNvdW50ID0gd2luLmZyYW1lcy5sZW5ndGg7XG4gICAgICBfcmVmID0gd2luLmZyYW1lcztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBmcmFtZSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoZnJhbWUgIT09IHdpbikge1xuICAgICAgICAgIGNvdW50ICs9IGNvdW50RnJhbWVzKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgZ2V0RnJhbWVQb3NpdGlvbiA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgdmFyIGNvdW50O1xuICAgICAgY291bnQgPSAwO1xuICAgICAgaWYgKHdpbi5wYXJlbnQgIT09IHdpbi50b3ApIHtcbiAgICAgICAgY291bnQgPSAxICsgZ2V0RnJhbWVQb3NpdGlvbih3aW4ucGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIG5hdGl2ZVJlZHVjZSA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2U7XG4gICAgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG4gICAgcmVkdWNlID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgICAgdmFyIGluZGV4LCBpbml0aWFsLCB2YWx1ZSwgX2ZuLCBfaSwgX2xlbjtcbiAgICAgIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICBvYmogPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcikpO1xuICAgICAgfVxuICAgICAgX2ZuID0gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmopIHtcbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgbWVtbyA9IHZhbHVlO1xuICAgICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvciAoaW5kZXggPSBfaSA9IDAsIF9sZW4gPSBvYmoubGVuZ3RoOyBfaSA8IF9sZW47IGluZGV4ID0gKytfaSkge1xuICAgICAgICB2YWx1ZSA9IG9ialtpbmRleF07XG4gICAgICAgIF9mbih2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICB9XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICAgIGtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAkc2YgIT0gbnVsbCA/ICRzZi5saWIubGFuZy5rZXlzKG9iaikgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjYXBpdGFsaXplU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmRSZXF1ZXN0OiBzZW5kUmVxdWVzdCxcbiAgICAgIHRvUXVlcnk6IHRvUXVlcnksXG4gICAgICBmcm9tUXVlcnk6IGZyb21RdWVyeSxcbiAgICAgIHRvTnVtYmVyOiB0b051bWJlcixcbiAgICAgIG5vdzogbm93LFxuICAgICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5LFxuICAgICAgY291bnRGcmFtZXM6IGNvdW50RnJhbWVzLFxuICAgICAgY2FwaXRhbGl6ZVN0cmluZzogY2FwaXRhbGl6ZVN0cmluZyxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBnZXRGcmFtZVBvc2l0aW9uOiBnZXRGcmFtZVBvc2l0aW9uLFxuICAgICAgcmVkdWNlOiByZWR1Y2VcbiAgICB9O1xuICB9KSgkc2YpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLypcbiAgICBodHRwOi8vd3d3LkpTT04ub3JnL2pzb24yLmpzXG4gICAgMjAxMS0wMi0yM1xuXG4gICAgUHVibGljIERvbWFpbi5cblxuICAgIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cblxuICAgIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcblxuXG4gICAgVGhpcyBjb2RlIHNob3VsZCBiZSBtaW5pZmllZCBiZWZvcmUgZGVwbG95bWVudC5cbiAgICBTZWUgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9qc21pbi5odG1sXG5cbiAgICBVU0UgWU9VUiBPV04gQ09QWS4gSVQgSVMgRVhUUkVNRUxZIFVOV0lTRSBUTyBMT0FEIENPREUgRlJPTSBTRVJWRVJTIFlPVSBET1xuICAgIE5PVCBDT05UUk9MLlxuXG5cbiAgICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbiAgICBhbmQgcGFyc2UuXG5cbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSlcbiAgICAgICAgICAgIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cblxuICAgICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cblxuICAgICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgJ1xcdCcgb3IgJyZuYnNwOycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cblxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG5cbiAgICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4gICAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuICAgICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuICAgICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4gICAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbiAgICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZVxuXG4gICAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBzZXJpYWxpemUgRGF0ZXMgYXMgSVNPIHN0cmluZ3MuXG5cbiAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbiAgICAgICAgICAgIGtleSBhbmQgdmFsdWUgb2YgZWFjaCBtZW1iZXIsIHdpdGggdGhpcyBib3VuZCB0byB0aGUgY29udGFpbmluZ1xuICAgICAgICAgICAgb2JqZWN0LiBUaGUgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHlvdXIgbWV0aG9kIHdpbGwgYmVcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuICAgICAgICAgICAgYmUgZXhjbHVkZWQgZnJvbSB0aGUgc2VyaWFsaXphdGlvbi5cblxuICAgICAgICAgICAgSWYgdGhlIHJlcGxhY2VyIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgICAgICAgIHVzZWQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHNlcmlhbGl6ZWQuIEl0IGZpbHRlcnMgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIHN1Y2ggdGhhdCBvbmx5IG1lbWJlcnMgd2l0aCBrZXlzIGxpc3RlZCBpbiB0aGUgcmVwbGFjZXIgYXJyYXkgYXJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgVmFsdWVzIHRoYXQgZG8gbm90IGhhdmUgSlNPTiByZXByZXNlbnRhdGlvbnMsIHN1Y2ggYXMgdW5kZWZpbmVkIG9yXG4gICAgICAgICAgICBmdW5jdGlvbnMsIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuIFN1Y2ggdmFsdWVzIGluIG9iamVjdHMgd2lsbCBiZVxuICAgICAgICAgICAgZHJvcHBlZDsgaW4gYXJyYXlzIHRoZXkgd2lsbCBiZSByZXBsYWNlZCB3aXRoIG51bGwuIFlvdSBjYW4gdXNlXG4gICAgICAgICAgICBhIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhvc2Ugd2l0aCBKU09OIHZhbHVlcy5cbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4gICAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4gICAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuICAgICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuICAgICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbiAgICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcImVcIix7XCJwbHVyaWJ1c1wiOlwidW51bVwifV0nXG5cblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFsnZScsIHtwbHVyaWJ1czogJ3VudW0nfV0sIG51bGwsICdcXHQnKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgICAgICAgICAgICAgJ0RhdGUoJyArIHRoaXNba2V5XSArICcpJyA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cblxuICAgICAgICBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpXG4gICAgICAgICAgICBUaGlzIG1ldGhvZCBwYXJzZXMgYSBKU09OIHRleHQgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICAgICAgICBJdCBjYW4gdGhyb3cgYSBTeW50YXhFcnJvciBleGNlcHRpb24uXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbiAgICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuICAgICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuICAgICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuICAgICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPVxuL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gJ0RhdGUoJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTEpID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgVGhpcyBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi4gWW91IGFyZSBmcmVlIHRvIGNvcHksIG1vZGlmeSwgb3JcbiAgICByZWRpc3RyaWJ1dGUuXG4qL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCByZWdleHA6IGZhbHNlICovXG5cbi8qbWVtYmVycyBcIlwiLCBcIlxcYlwiLCBcIlxcdFwiLCBcIlxcblwiLCBcIlxcZlwiLCBcIlxcclwiLCBcIlxcXCJcIiwgSlNPTiwgXCJcXFxcXCIsIGFwcGx5LFxuICAgIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgICBnZXRVVENNaW51dGVzLCBnZXRVVENNb250aCwgZ2V0VVRDU2Vjb25kcywgaGFzT3duUHJvcGVydHksIGpvaW4sXG4gICAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG4gICAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuKi9cblxuXG4vLyBDcmVhdGUgYSBKU09OIG9iamVjdCBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBXZSBjcmVhdGUgdGhlXG4vLyBtZXRob2RzIGluIGEgY2xvc3VyZSB0byBhdm9pZCBjcmVhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxuXG52YXIgSlNPTjtcbmlmICghSlNPTikge1xuICAgIEpTT04gPSB7fTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBnbG9iYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpXG4gICAgICAsIEpTT04gPSBnbG9iYWwuSlNPTlxuICAgICAgO1xuXG4gICAgaWYgKCFKU09OKSB7XG4gICAgICBKU09OID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRVVENGdWxsWWVhcigpICAgICArICctJyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJyA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gICAgICA9XG4gICAgICAgICAgICBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiAgPVxuICAgICAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgIGdhcCxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICB9LFxuICAgICAgICByZXA7XG5cblxuICAgIGZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXG4vLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4vLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4vLyBzZXF1ZW5jZXMuXG5cbiAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblxuLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXG4gICAgICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgICAgIHBhcnRpYWwsXG4gICAgICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4vLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbi8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuXG4vLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4vLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4vLyBudWxsLlxuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG5cbi8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyAnb2JqZWN0Jyxcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4vLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXG4vLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4vLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4vLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBzdHJpbmdpZnkgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuXG4vLyBUaGUgc3RyaW5naWZ5IG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCByZXBsYWNlciwgYW5kIGFuIG9wdGlvbmFsXG4vLyBzcGFjZSBwYXJhbWV0ZXIsIGFuZCByZXR1cm5zIGEgSlNPTiB0ZXh0LiBUaGUgcmVwbGFjZXIgY2FuIGJlIGEgZnVuY3Rpb25cbi8vIHRoYXQgY2FuIHJlcGxhY2UgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGtleXMuXG4vLyBBIGRlZmF1bHQgcmVwbGFjZXIgbWV0aG9kIGNhbiBiZSBwcm92aWRlZC4gVXNlIG9mIHRoZSBzcGFjZSBwYXJhbWV0ZXIgY2FuXG4vLyBwcm9kdWNlIHRleHQgdGhhdCBpcyBtb3JlIGVhc2lseSByZWFkYWJsZS5cblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBnYXAgPSAnJztcbiAgICAgICAgICAgIGluZGVudCA9ICcnO1xuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4vLyBtYW55IHNwYWNlcy5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICAgICAgICAgICAgcmVwID0gcmVwbGFjZXI7XG4gICAgICAgICAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5wYXJzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cblxuLy8gUGFyc2luZyBoYXBwZW5zIGluIGZvdXIgc3RhZ2VzLiBJbiB0aGUgZmlyc3Qgc3RhZ2UsIHdlIHJlcGxhY2UgY2VydGFpblxuLy8gVW5pY29kZSBjaGFyYWN0ZXJzIHdpdGggZXNjYXBlIHNlcXVlbmNlcy4gSmF2YVNjcmlwdCBoYW5kbGVzIG1hbnkgY2hhcmFjdGVyc1xuLy8gaW5jb3JyZWN0bHksIGVpdGhlciBzaWxlbnRseSBkZWxldGluZyB0aGVtLCBvciB0cmVhdGluZyB0aGVtIGFzIGxpbmUgZW5kaW5ncy5cblxuICAgICAgICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0KTtcbiAgICAgICAgICAgIGN4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoY3gudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoY3gsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbi8vIEluIHRoZSBzZWNvbmQgc3RhZ2UsIHdlIHJ1biB0aGUgdGV4dCBhZ2FpbnN0IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBsb29rXG4vLyBmb3Igbm9uLUpTT04gcGF0dGVybnMuIFdlIGFyZSBlc3BlY2lhbGx5IGNvbmNlcm5lZCB3aXRoICcoKScgYW5kICduZXcnXG4vLyBiZWNhdXNlIHRoZXkgY2FuIGNhdXNlIGludm9jYXRpb24sIGFuZCAnPScgYmVjYXVzZSBpdCBjYW4gY2F1c2UgbXV0YXRpb24uXG4vLyBCdXQganVzdCB0byBiZSBzYWZlLCB3ZSB3YW50IHRvIHJlamVjdCBhbGwgdW5leHBlY3RlZCBmb3Jtcy5cblxuLy8gV2Ugc3BsaXQgdGhlIHNlY29uZCBzdGFnZSBpbnRvIDQgcmVnZXhwIG9wZXJhdGlvbnMgaW4gb3JkZXIgdG8gd29yayBhcm91bmRcbi8vIGNyaXBwbGluZyBpbmVmZmljaWVuY2llcyBpbiBJRSdzIGFuZCBTYWZhcmkncyByZWdleHAgZW5naW5lcy4gRmlyc3Qgd2Vcbi8vIHJlcGxhY2UgdGhlIEpTT04gYmFja3NsYXNoIHBhaXJzIHdpdGggJ0AnIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCAnXScgY2hhcmFjdGVycy4gVGhpcmQsIHdlIGRlbGV0ZSBhbGxcbi8vIG9wZW4gYnJhY2tldHMgdGhhdCBmb2xsb3cgYSBjb2xvbiBvciBjb21tYSBvciB0aGF0IGJlZ2luIHRoZSB0ZXh0LiBGaW5hbGx5LFxuLy8gd2UgbG9vayB0byBzZWUgdGhhdCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYXJlIG9ubHkgd2hpdGVzcGFjZSBvciAnXScgb3Jcbi8vICcsJyBvciAnOicgb3IgJ3snIG9yICd9Jy4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoL15bXFxdLDp7fVxcc10qJC9cbiAgICAgICAgICAgICAgICAgICAgLnRlc3QodGV4dC5yZXBsYWNlKC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2csICdAJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZywgJ10nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLCAnJykpKSB7XG5cbi8vIEluIHRoZSB0aGlyZCBzdGFnZSB3ZSB1c2UgdGhlIGV2YWwgZnVuY3Rpb24gdG8gY29tcGlsZSB0aGUgdGV4dCBpbnRvIGFcbi8vIEphdmFTY3JpcHQgc3RydWN0dXJlLiBUaGUgJ3snIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9IGV2YWwoJygnICsgdGV4dCArICcpJyk7XG5cbi8vIEluIHRoZSBvcHRpb25hbCBmb3VydGggc3RhZ2UsIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsIHBhc3Npbmdcbi8vIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIGEgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGUgdHJhbnNmb3JtYXRpb24uXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICB3YWxrKHsnJzogan0sICcnKSA6IGo7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSB0ZXh0IGlzIG5vdCBKU09OIHBhcnNlYWJsZSwgdGhlbiBhIFN5bnRheEVycm9yIGlzIHRocm93bi5cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdKU09OLnBhcnNlJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2xvYmFsLkpTT04gPSBKU09OO1xuICAgIG1vZHVsZS5leHBvcnRzID0gSlNPTjtcbn0oKSk7XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyAgICAgdXVpZC5qc1xuLy9cbi8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuICAvLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuICB2YXIgX3JuZztcblxuICAvLyBOb2RlLmpzIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vbm9kZWpzLm9yZy9kb2NzL3YwLjYuMi9hcGkvY3J5cHRvLmh0bWxcbiAgLy9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgaWYgKHR5cGVvZihyZXF1aXJlKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmIgPSByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICAgIF9ybmcgPSBfcmIgJiYgZnVuY3Rpb24oKSB7cmV0dXJuIF9yYigxNik7fTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoIV9ybmcgJiYgX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vXG4gICAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgICByZXR1cm4gX3JuZHM4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIV9ybmcpIHtcbiAgICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gICAgLy9cbiAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAgIC8vIHF1YWxpdHkuXG4gICAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9ybmRzO1xuICAgIH07XG4gIH1cblxuICAvLyBCdWZmZXIgY2xhc3MgdG8gdXNlXG4gIHZhciBCdWZmZXJDbGFzcyA9IHR5cGVvZihCdWZmZXIpID09ICdmdW5jdGlvbicgPyBCdWZmZXIgOiBBcnJheTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgICBidWYgPSBidWYgfHwgW107XG4gICAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgICAgaWYgKGlpIDwgMTYpIHsgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICAgIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgICBidWZbaSArIGlpKytdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG4gIGZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IG9mZnNldCB8fCAwLCBidGggPSBfYnl0ZVRvSGV4O1xuICAgIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW1xuICAgIF9zZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbiAgXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsIF9sYXN0TlNlY3MgPSAwO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPSBudWxsID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAgIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gICAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICAgIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICAgIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAgIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICAgIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAgIC8vIHRpbWUgaW50ZXJ2YWxcbiAgICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT0gbnVsbCkge1xuICAgICAgbnNlY3MgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICAgIH1cblxuICAgIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAgIC8vIGB0aW1lX2xvd2BcbiAgICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gICAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9taWRgXG4gICAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICAgIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gICAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gICAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gICAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gICAgLy8gYG5vZGVgXG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgYltpICsgbl0gPSBub2RlW25dO1xuICAgIH1cblxuICAgIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xuICB9XG5cbiAgLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQnVmZmVyQ2xhc3MoMTYpIDogbnVsbDtcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG4gIHV1aWQuQnVmZmVyQ2xhc3MgPSBCdWZmZXJDbGFzcztcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUHVibGlzaCBhcyBBTUQgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge3JldHVybiB1dWlkO30pO1xuICB9IGVsc2UgaWYgKHR5cGVvZihtb2R1bGUpICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gUHVibGlzaCBhcyBub2RlLmpzIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBQdWJsaXNoIGFzIGdsb2JhbCAoaW4gYnJvd3NlcnMpXG4gICAgdmFyIF9wcmV2aW91c1Jvb3QgPSBfZ2xvYmFsLnV1aWQ7XG5cbiAgICAvLyAqKmBub0NvbmZsaWN0KClgIC0gKGJyb3dzZXIgb25seSkgdG8gcmVzZXQgZ2xvYmFsICd1dWlkJyB2YXIqKlxuICAgIHV1aWQubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX2dsb2JhbC51dWlkID0gX3ByZXZpb3VzUm9vdDtcbiAgICAgIHJldHVybiB1dWlkO1xuICAgIH07XG5cbiAgICBfZ2xvYmFsLnV1aWQgPSB1dWlkO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiLyohXG4gICogUmVxd2VzdCEgQSBnZW5lcmFsIHB1cnBvc2UgWEhSIGNvbm5lY3Rpb24gbWFuYWdlclxuICAqIGxpY2Vuc2UgTUlUIChjKSBEdXN0aW4gRGlheiAyMDE0XG4gICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9yZXF3ZXN0XG4gICovXG5cbiFmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0oJ3JlcXdlc3QnLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHdpbiA9IHdpbmRvd1xuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIHR3b0h1bmRvID0gL14oMjBcXGR8MTIyMykkL1xuICAgICwgYnlUYWcgPSAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnXG4gICAgLCByZWFkeVN0YXRlID0gJ3JlYWR5U3RhdGUnXG4gICAgLCBjb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnXG4gICAgLCByZXF1ZXN0ZWRXaXRoID0gJ1gtUmVxdWVzdGVkLVdpdGgnXG4gICAgLCBoZWFkID0gZG9jW2J5VGFnXSgnaGVhZCcpWzBdXG4gICAgLCB1bmlxaWQgPSAwXG4gICAgLCBjYWxsYmFja1ByZWZpeCA9ICdyZXF3ZXN0XycgKyAoK25ldyBEYXRlKCkpXG4gICAgLCBsYXN0VmFsdWUgLy8gZGF0YSBzdG9yZWQgYnkgdGhlIG1vc3QgcmVjZW50IEpTT05QIGNhbGxiYWNrXG4gICAgLCB4bWxIdHRwUmVxdWVzdCA9ICdYTUxIdHRwUmVxdWVzdCdcbiAgICAsIHhEb21haW5SZXF1ZXN0ID0gJ1hEb21haW5SZXF1ZXN0J1xuICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgICAsIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gQXJyYXkuaXNBcnJheVxuICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgfVxuXG4gICAgLCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICAgICAnY29udGVudFR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAsICdyZXF1ZXN0ZWRXaXRoJzogeG1sSHR0cFJlcXVlc3RcbiAgICAgICAgLCAnYWNjZXB0Jzoge1xuICAgICAgICAgICAgICAnKic6ICAndGV4dC9qYXZhc2NyaXB0LCB0ZXh0L2h0bWwsIGFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwsICovKidcbiAgICAgICAgICAgICwgJ3htbCc6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCdcbiAgICAgICAgICAgICwgJ2h0bWwnOiAndGV4dC9odG1sJ1xuICAgICAgICAgICAgLCAndGV4dCc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgLCAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICAsICdqcyc6ICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQsIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsIHhociA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgLy8gaXMgaXQgeC1kb21haW5cbiAgICAgICAgaWYgKG9bJ2Nyb3NzT3JpZ2luJ10gPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgeGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbFxuICAgICAgICAgIGlmICh4aHIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyXG4gICAgICAgICAgfSBlbHNlIGlmICh3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2luW3htbEh0dHBSZXF1ZXN0XSkge1xuICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCBnbG9iYWxTZXR1cE9wdGlvbnMgPSB7XG4gICAgICAgIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlYWR5U3RhdGUociwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdXNlIF9hYm9ydGVkIHRvIG1pdGlnYXRlIGFnYWluc3QgSUUgZXJyIGMwMGMwMjNmXG4gICAgICAvLyAoY2FuJ3QgcmVhZCBwcm9wcyBvbiBhYm9ydGVkIHJlcXVlc3Qgb2JqZWN0cylcbiAgICAgIGlmIChyLl9hYm9ydGVkKSByZXR1cm4gZXJyb3Ioci5yZXF1ZXN0KVxuICAgICAgaWYgKHIucmVxdWVzdCAmJiByLnJlcXVlc3RbcmVhZHlTdGF0ZV0gPT0gNCkge1xuICAgICAgICByLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcFxuICAgICAgICBpZiAodHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSkgc3VjY2VzcyhyLnJlcXVlc3QpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlcnJvcihyLnJlcXVlc3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGVhZGVycyhodHRwLCBvKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBvWydoZWFkZXJzJ10gfHwge31cbiAgICAgICwgaFxuXG4gICAgaGVhZGVyc1snQWNjZXB0J10gPSBoZWFkZXJzWydBY2NlcHQnXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddW29bJ3R5cGUnXV1cbiAgICAgIHx8IGRlZmF1bHRIZWFkZXJzWydhY2NlcHQnXVsnKiddXG5cbiAgICAvLyBicmVha3MgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIHdpdGggbGVnYWN5IGJyb3dzZXJzXG4gICAgaWYgKCFvWydjcm9zc09yaWdpbiddICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnNbJ3JlcXVlc3RlZFdpdGgnXVxuICAgIGlmICghaGVhZGVyc1tjb250ZW50VHlwZV0pIGhlYWRlcnNbY29udGVudFR5cGVdID0gb1snY29udGVudFR5cGUnXSB8fCBkZWZhdWx0SGVhZGVyc1snY29udGVudFR5cGUnXVxuICAgIGZvciAoaCBpbiBoZWFkZXJzKVxuICAgICAgaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoKSAmJiAnc2V0UmVxdWVzdEhlYWRlcicgaW4gaHR0cCAmJiBodHRwLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pIHtcbiAgICBpZiAodHlwZW9mIG9bJ3dpdGhDcmVkZW50aWFscyddICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhb1snd2l0aENyZWRlbnRpYWxzJ11cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2soZGF0YSkge1xuICAgIGxhc3RWYWx1ZSA9IGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHVybGFwcGVuZCAodXJsLCBzKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKSB7XG4gICAgdmFyIHJlcUlkID0gdW5pcWlkKytcbiAgICAgICwgY2JrZXkgPSBvWydqc29ucENhbGxiYWNrJ10gfHwgJ2NhbGxiYWNrJyAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICwgY2J2YWwgPSBvWydqc29ucENhbGxiYWNrTmFtZSddIHx8IHJlcXdlc3QuZ2V0Y2FsbGJhY2tQcmVmaXgocmVxSWQpXG4gICAgICAsIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpXG4gICAgICAsIG1hdGNoID0gdXJsLm1hdGNoKGNicmVnKVxuICAgICAgLCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICwgbG9hZGVkID0gMFxuICAgICAgLCBpc0lFMTAgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgMTAuMCcpICE9PSAtMVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAobWF0Y2hbM10gPT09ICc/Jykge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCkgLy8gd2lsZGNhcmQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYnZhbCA9IG1hdGNoWzNdIC8vIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBjYmtleSArICc9JyArIGNidmFsKSAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgfVxuXG4gICAgd2luW2NidmFsXSA9IGdlbmVyYWxDYWxsYmFja1xuXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlICE9PSAndW5kZWZpbmVkJyAmJiAhaXNJRTEwKSB7XG4gICAgICAvLyBuZWVkIHRoaXMgZm9yIElFIGR1ZSB0byBvdXQtb2Ytb3JkZXIgb25yZWFkeXN0YXRlY2hhbmdlKCksIGJpbmRpbmcgc2NyaXB0XG4gICAgICAvLyBleGVjdXRpb24gdG8gYW4gZXZlbnQgbGlzdGVuZXIgZ2l2ZXMgdXMgY29udHJvbCBvdmVyIHdoZW4gdGhlIHNjcmlwdFxuICAgICAgLy8gaXMgZXhlY3V0ZWQuIFNlZSBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkID0gJ19yZXF3ZXN0XycgKyByZXFJZFxuICAgIH1cblxuICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKChzY3JpcHRbcmVhZHlTdGF0ZV0gJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnY29tcGxldGUnICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2xvYWRlZCcpIHx8IGxvYWRlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgc2NyaXB0Lm9uY2xpY2sgJiYgc2NyaXB0Lm9uY2xpY2soKVxuICAgICAgLy8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayB3aXRoIHRoZSBsYXN0IHZhbHVlIHN0b3JlZCBhbmQgY2xlYW4gdXAgdmFsdWVzIGFuZCBzY3JpcHRzLlxuICAgICAgZm4obGFzdFZhbHVlKVxuICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICAgIGxvYWRlZCA9IDFcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHNjcmlwdCB0byB0aGUgRE9NIGhlYWRcbiAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcblxuICAgIC8vIEVuYWJsZSBKU09OUCB0aW1lb3V0XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSlcbiAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgICBsb2FkZWQgPSAxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdChmbiwgZXJyKSB7XG4gICAgdmFyIG8gPSB0aGlzLm9cbiAgICAgICwgbWV0aG9kID0gKG9bJ21ldGhvZCddIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG4gICAgICAsIHVybCA9IHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgICAgLy8gY29udmVydCBub24tc3RyaW5nIG9iamVjdHMgdG8gcXVlcnktc3RyaW5nIGZvcm0gdW5sZXNzIG9bJ3Byb2Nlc3NEYXRhJ10gaXMgZmFsc2VcbiAgICAgICwgZGF0YSA9IChvWydwcm9jZXNzRGF0YSddICE9PSBmYWxzZSAmJiBvWydkYXRhJ10gJiYgdHlwZW9mIG9bJ2RhdGEnXSAhPT0gJ3N0cmluZycpXG4gICAgICAgID8gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKG9bJ2RhdGEnXSlcbiAgICAgICAgOiAob1snZGF0YSddIHx8IG51bGwpXG4gICAgICAsIGh0dHBcbiAgICAgICwgc2VuZFdhaXQgPSBmYWxzZVxuXG4gICAgLy8gaWYgd2UncmUgd29ya2luZyBvbiBhIEdFVCByZXF1ZXN0IGFuZCB3ZSBoYXZlIGRhdGEgdGhlbiB3ZSBzaG91bGQgYXBwZW5kXG4gICAgLy8gcXVlcnkgc3RyaW5nIHRvIGVuZCBvZiBVUkwgYW5kIG5vdCBwb3N0IGRhdGFcbiAgICBpZiAoKG9bJ3R5cGUnXSA9PSAnanNvbnAnIHx8IG1ldGhvZCA9PSAnR0VUJykgJiYgZGF0YSkge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgZGF0YSlcbiAgICAgIGRhdGEgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKG9bJ3R5cGUnXSA9PSAnanNvbnAnKSByZXR1cm4gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKVxuXG4gICAgLy8gZ2V0IHRoZSB4aHIgZnJvbSB0aGUgZmFjdG9yeSBpZiBwYXNzZWRcbiAgICAvLyBpZiB0aGUgZmFjdG9yeSByZXR1cm5zIG51bGwsIGZhbGwtYmFjayB0byBvdXJzXG4gICAgaHR0cCA9IChvLnhociAmJiBvLnhocihvKSkgfHwgeGhyKG8pXG5cbiAgICBodHRwLm9wZW4obWV0aG9kLCB1cmwsIG9bJ2FzeW5jJ10gPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKVxuICAgIHNldEhlYWRlcnMoaHR0cCwgbylcbiAgICBzZXRDcmVkZW50aWFscyhodHRwLCBvKVxuICAgIGlmICh3aW5beERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiB3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgIGh0dHAub25sb2FkID0gZm5cbiAgICAgICAgaHR0cC5vbmVycm9yID0gZXJyXG4gICAgICAgIC8vIE5PVEU6IHNlZVxuICAgICAgICAvLyBodHRwOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvaWV3ZWJkZXZlbG9wbWVudC90aHJlYWQvMzBlZjNhZGQtNzY3Yy00NDM2LWI4YTktZjFjYTE5YjQ4MTJlXG4gICAgICAgIGh0dHAub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge31cbiAgICAgICAgc2VuZFdhaXQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlUmVhZHlTdGF0ZSh0aGlzLCBmbiwgZXJyKVxuICAgIH1cbiAgICBvWydiZWZvcmUnXSAmJiBvWydiZWZvcmUnXShodHRwKVxuICAgIGlmIChzZW5kV2FpdCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0dHAuc2VuZChkYXRhKVxuICAgICAgfSwgMjAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICB9XG4gICAgcmV0dXJuIGh0dHBcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXdlc3QobywgZm4pIHtcbiAgICB0aGlzLm8gPSBvXG4gICAgdGhpcy5mbiA9IGZuXG5cbiAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFR5cGUoaGVhZGVyKSB7XG4gICAgLy8ganNvbiwgamF2YXNjcmlwdCwgdGV4dC9wbGFpbiwgdGV4dC9odG1sLCB4bWxcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqc29uJykpIHJldHVybiAnanNvbidcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqYXZhc2NyaXB0JykpIHJldHVybiAnanMnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgndGV4dCcpKSByZXR1cm4gJ2h0bWwnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgneG1sJykpIHJldHVybiAneG1sJ1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdChvLCBmbikge1xuXG4gICAgdGhpcy51cmwgPSB0eXBlb2YgbyA9PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcblxuICAgIC8vIHdoZXRoZXIgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQgZm9yIHB1cnBvc2VcbiAgICAvLyBvZiB0cmFja2luZyB0aGUgUHJvbWlzZXNcbiAgICB0aGlzLl9mdWxmaWxsZWQgPSBmYWxzZVxuICAgIC8vIHN1Y2Nlc3MgaGFuZGxlcnNcbiAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uKCl7fVxuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMgPSBbXVxuICAgIC8vIGVycm9yIGhhbmRsZXJzXG4gICAgdGhpcy5fZXJyb3JIYW5kbGVycyA9IFtdXG4gICAgLy8gY29tcGxldGUgKGJvdGggc3VjY2VzcyBhbmQgZmFpbCkgaGFuZGxlcnNcbiAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzID0gW11cbiAgICB0aGlzLl9lcnJlZCA9IGZhbHNlXG4gICAgdGhpcy5fcmVzcG9uc2VBcmdzID0ge31cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgaWYgKG9bJ3RpbWVvdXQnXSkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYWJvcnQoKVxuICAgICAgfSwgb1sndGltZW91dCddKVxuICAgIH1cblxuICAgIGlmIChvWydzdWNjZXNzJ10pIHtcbiAgICAgIHRoaXMuX3N1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydzdWNjZXNzJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvWydlcnJvciddKSB7XG4gICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydlcnJvciddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG9bJ2NvbXBsZXRlJ10pIHtcbiAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ2NvbXBsZXRlJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSAocmVzcCkge1xuICAgICAgb1sndGltZW91dCddICYmIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG4gICAgICBzZWxmLnRpbWVvdXQgPSBudWxsXG4gICAgICB3aGlsZSAoc2VsZi5fY29tcGxldGVIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuX2NvbXBsZXRlSGFuZGxlcnMuc2hpZnQoKShyZXNwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1Y2Nlc3MgKHJlc3ApIHtcbiAgICAgIHZhciB0eXBlID0gb1sndHlwZSddIHx8IHNldFR5cGUocmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykpXG4gICAgICByZXNwID0gKHR5cGUgIT09ICdqc29ucCcpID8gc2VsZi5yZXF1ZXN0IDogcmVzcFxuICAgICAgLy8gdXNlIGdsb2JhbCBkYXRhIGZpbHRlciBvbiByZXNwb25zZSB0ZXh0XG4gICAgICB2YXIgZmlsdGVyZWRSZXNwb25zZSA9IGdsb2JhbFNldHVwT3B0aW9ucy5kYXRhRmlsdGVyKHJlc3AucmVzcG9uc2VUZXh0LCB0eXBlKVxuICAgICAgICAsIHIgPSBmaWx0ZXJlZFJlc3BvbnNlXG4gICAgICB0cnkge1xuICAgICAgICByZXNwLnJlc3BvbnNlVGV4dCA9IHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gY2FuJ3QgYXNzaWduIHRoaXMgaW4gSUU8PTgsIGp1c3QgaWdub3JlXG4gICAgICB9XG4gICAgICBpZiAocikge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3AgPSB3aW4uSlNPTiA/IHdpbi5KU09OLnBhcnNlKHIpIDogZXZhbCgnKCcgKyByICsgJyknKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKHJlc3AsICdDb3VsZCBub3QgcGFyc2UgSlNPTiBpbiByZXNwb25zZScsIGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnanMnOlxuICAgICAgICAgIHJlc3AgPSBldmFsKHIpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgcmVzcCA9IHJcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgIHJlc3AgPSByZXNwLnJlc3BvbnNlWE1MXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvciAvLyBJRSB0cm9sb2xvXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5lcnJvckNvZGVcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLnJlYXNvblxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fZnVsZmlsbGVkID0gdHJ1ZVxuICAgICAgZm4ocmVzcClcbiAgICAgIHNlbGYuX3N1Y2Nlc3NIYW5kbGVyKHJlc3ApXG4gICAgICB3aGlsZSAoc2VsZi5fZnVsZmlsbG1lbnRIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3AgPSBzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cblxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihyZXNwLCBtc2csIHQpIHtcbiAgICAgIHJlc3AgPSBzZWxmLnJlcXVlc3RcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLm1zZyA9IG1zZ1xuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnQgPSB0XG4gICAgICBzZWxmLl9lcnJlZCA9IHRydWVcbiAgICAgIHdoaWxlIChzZWxmLl9lcnJvckhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fZXJyb3JIYW5kbGVycy5zaGlmdCgpKHJlc3AsIG1zZywgdClcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlKHJlc3ApXG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0ID0gZ2V0UmVxdWVzdC5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9yKVxuICB9XG5cbiAgUmVxd2VzdC5wcm90b3R5cGUgPSB7XG4gICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlXG4gICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKVxuICAgIH1cblxuICAsIHJldHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbml0LmNhbGwodGhpcywgdGhpcy5vLCB0aGlzLmZuKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNtYWxsIGRldmlhdGlvbiBmcm9tIHRoZSBQcm9taXNlcyBBIENvbW1vbkpzIHNwZWNpZmljYXRpb25cbiAgICAgKiBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Qcm9taXNlcy9BXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBgdGhlbmAgd2lsbCBleGVjdXRlIHVwb24gc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICAgICAqL1xuICAsIHRoZW46IGZ1bmN0aW9uIChzdWNjZXNzLCBmYWlsKSB7XG4gICAgICBzdWNjZXNzID0gc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgZmFpbCA9IGZhaWwgfHwgZnVuY3Rpb24gKCkge31cbiAgICAgIGlmICh0aGlzLl9mdWxmaWxsZWQpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AgPSBzdWNjZXNzKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmYWlsKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwLCB0aGlzLl9yZXNwb25zZUFyZ3MubXNnLCB0aGlzLl9yZXNwb25zZUFyZ3MudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMucHVzaChzdWNjZXNzKVxuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZmFpbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGFsd2F5c2Agd2lsbCBleGVjdXRlIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZHMgb3IgZmFpbHNcbiAgICAgKi9cbiAgLCBhbHdheXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCB8fCB0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGZhaWxgIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZSByZXF1ZXN0IGZhaWxzXG4gICAgICovXG4gICwgZmFpbDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZm4odGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXF3ZXN0KG8sIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIG5ld2xpbmUgdmFyaWFudHMgYWNjb3JkaW5nIHRvIHNwZWMgLT4gQ1JMRlxuICBmdW5jdGlvbiBub3JtYWxpemUocykge1xuICAgIHJldHVybiBzID8gcy5yZXBsYWNlKC9cXHI/XFxuL2csICdcXHJcXG4nKSA6ICcnXG4gIH1cblxuICBmdW5jdGlvbiBzZXJpYWwoZWwsIGNiKSB7XG4gICAgdmFyIG4gPSBlbC5uYW1lXG4gICAgICAsIHQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICwgb3B0Q2IgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgIC8vIElFIGdpdmVzIHZhbHVlPVwiXCIgZXZlbiB3aGVyZSB0aGVyZSBpcyBubyB2YWx1ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAvLyAnc3BlY2lmaWVkJyByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvY29yZS5odG1sI0lELTg2MjUyOTI3M1xuICAgICAgICAgIGlmIChvICYmICFvWydkaXNhYmxlZCddKVxuICAgICAgICAgICAgY2Iobiwgbm9ybWFsaXplKG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXSAmJiBvWydhdHRyaWJ1dGVzJ11bJ3ZhbHVlJ11bJ3NwZWNpZmllZCddID8gb1sndmFsdWUnXSA6IG9bJ3RleHQnXSkpXG4gICAgICAgIH1cbiAgICAgICwgY2gsIHJhLCB2YWwsIGlcblxuICAgIC8vIGRvbid0IHNlcmlhbGl6ZSBlbGVtZW50cyB0aGF0IGFyZSBkaXNhYmxlZCBvciB3aXRob3V0IGEgbmFtZVxuICAgIGlmIChlbC5kaXNhYmxlZCB8fCAhbikgcmV0dXJuXG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpZiAoIS9yZXNldHxidXR0b258aW1hZ2V8ZmlsZS9pLnRlc3QoZWwudHlwZSkpIHtcbiAgICAgICAgY2ggPSAvY2hlY2tib3gvaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHJhID0gL3JhZGlvL2kudGVzdChlbC50eXBlKVxuICAgICAgICB2YWwgPSBlbC52YWx1ZVxuICAgICAgICAvLyBXZWJLaXQgZ2l2ZXMgdXMgXCJcIiBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIGNoZWNrYm94IGhhcyBubyB2YWx1ZSwgc28gY29ycmVjdCBpdCBoZXJlXG4gICAgICAgIDsoIShjaCB8fCByYSkgfHwgZWwuY2hlY2tlZCkgJiYgY2Iobiwgbm9ybWFsaXplKGNoICYmIHZhbCA9PT0gJycgPyAnb24nIDogdmFsKSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgY2Iobiwgbm9ybWFsaXplKGVsLnZhbHVlKSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGlmIChlbC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3Qtb25lJykge1xuICAgICAgICBvcHRDYihlbC5zZWxlY3RlZEluZGV4ID49IDAgPyBlbC5vcHRpb25zW2VsLnNlbGVjdGVkSW5kZXhdIDogbnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGVsLmxlbmd0aCAmJiBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbC5vcHRpb25zW2ldLnNlbGVjdGVkICYmIG9wdENiKGVsLm9wdGlvbnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gY29sbGVjdCB1cCBhbGwgZm9ybSBlbGVtZW50cyBmb3VuZCBmcm9tIHRoZSBwYXNzZWQgYXJndW1lbnQgZWxlbWVudHMgYWxsXG4gIC8vIHRoZSB3YXkgZG93biB0byBjaGlsZCBlbGVtZW50czsgcGFzcyBhICc8Zm9ybT4nIG9yIGZvcm0gZmllbGRzLlxuICAvLyBjYWxsZWQgd2l0aCAndGhpcyc9Y2FsbGJhY2sgdG8gdXNlIGZvciBzZXJpYWwoKSBvbiBlYWNoIGVsZW1lbnRcbiAgZnVuY3Rpb24gZWFjaEZvcm1FbGVtZW50KCkge1xuICAgIHZhciBjYiA9IHRoaXNcbiAgICAgICwgZSwgaVxuICAgICAgLCBzZXJpYWxpemVTdWJ0YWdzID0gZnVuY3Rpb24gKGUsIHRhZ3MpIHtcbiAgICAgICAgICB2YXIgaSwgaiwgZmFcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmEgPSBlW2J5VGFnXSh0YWdzW2ldKVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZhLmxlbmd0aDsgaisrKSBzZXJpYWwoZmFbal0sIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZSA9IGFyZ3VtZW50c1tpXVxuICAgICAgaWYgKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWEvaS50ZXN0KGUudGFnTmFtZSkpIHNlcmlhbChlLCBjYilcbiAgICAgIHNlcmlhbGl6ZVN1YnRhZ3MoZSwgWyAnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJyBdKVxuICAgIH1cbiAgfVxuXG4gIC8vIHN0YW5kYXJkIHF1ZXJ5IHN0cmluZyBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5U3RyaW5nKCkge1xuICAgIHJldHVybiByZXF3ZXN0LnRvUXVlcnlTdHJpbmcocmVxd2VzdC5zZXJpYWxpemVBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKVxuICB9XG5cbiAgLy8geyAnbmFtZSc6ICd2YWx1ZScsIC4uLiB9IHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplSGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IHt9XG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgaW4gaGFzaCkge1xuICAgICAgICBoYXNoW25hbWVdICYmICFpc0FycmF5KGhhc2hbbmFtZV0pICYmIChoYXNoW25hbWVdID0gW2hhc2hbbmFtZV1dKVxuICAgICAgICBoYXNoW25hbWVdLnB1c2godmFsdWUpXG4gICAgICB9IGVsc2UgaGFzaFtuYW1lXSA9IHZhbHVlXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvLyBbIHsgbmFtZTogJ25hbWUnLCB2YWx1ZTogJ3ZhbHVlJyB9LCAuLi4gXSBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIHJlcXdlc3Quc2VyaWFsaXplQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyciA9IFtdXG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgYXJyLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIHJlcXdlc3Quc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgICB2YXIgb3B0LCBmblxuICAgICAgLCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuXG4gICAgb3B0ID0gYXJncy5wb3AoKVxuICAgIG9wdCAmJiBvcHQubm9kZVR5cGUgJiYgYXJncy5wdXNoKG9wdCkgJiYgKG9wdCA9IG51bGwpXG4gICAgb3B0ICYmIChvcHQgPSBvcHQudHlwZSlcblxuICAgIGlmIChvcHQgPT0gJ21hcCcpIGZuID0gc2VyaWFsaXplSGFzaFxuICAgIGVsc2UgaWYgKG9wdCA9PSAnYXJyYXknKSBmbiA9IHJlcXdlc3Quc2VyaWFsaXplQXJyYXlcbiAgICBlbHNlIGZuID0gc2VyaWFsaXplUXVlcnlTdHJpbmdcblxuICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG5cbiAgcmVxd2VzdC50b1F1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKG8sIHRyYWQpIHtcbiAgICB2YXIgcHJlZml4LCBpXG4gICAgICAsIHRyYWRpdGlvbmFsID0gdHJhZCB8fCBmYWxzZVxuICAgICAgLCBzID0gW11cbiAgICAgICwgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAsIGFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gICAgICAgICAgdmFsdWUgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlKSA/IHZhbHVlKCkgOiAodmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpXG4gICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmMoa2V5KSArICc9JyArIGVuYyh2YWx1ZSlcbiAgICAgICAgfVxuICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgaWYgKGlzQXJyYXkobykpIHtcbiAgICAgIGZvciAoaSA9IDA7IG8gJiYgaSA8IG8ubGVuZ3RoOyBpKyspIGFkZChvW2ldWyduYW1lJ10sIG9baV1bJ3ZhbHVlJ10pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgIGZvciAocHJlZml4IGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJlZml4KSkgYnVpbGRQYXJhbXMocHJlZml4LCBvW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BhY2VzIHNob3VsZCBiZSArIGFjY29yZGluZyB0byBzcGVjXG4gICAgcmV0dXJuIHMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgIHZhciBuYW1lLCBpLCB2XG4gICAgICAsIHJicmFja2V0ID0gL1xcW1xcXSQvXG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgIGZvciAoaSA9IDA7IG9iaiAmJiBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHYgPSBvYmpbaV1cbiAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xuICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICBhZGQocHJlZml4LCB2KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyBpIDogJycpICsgJ10nLCB2LCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArIG5hbWUgKyAnXScsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICBhZGQocHJlZml4LCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxd2VzdC5nZXRjYWxsYmFja1ByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2tQcmVmaXhcbiAgfVxuXG4gIC8vIGpRdWVyeSBhbmQgWmVwdG8gY29tcGF0aWJpbGl0eSwgZGlmZmVyZW5jZXMgY2FuIGJlIHJlbWFwcGVkIGhlcmUgc28geW91IGNhbiBjYWxsXG4gIC8vIC5hamF4LmNvbXBhdChvcHRpb25zLCBjYWxsYmFjaylcbiAgcmVxd2VzdC5jb21wYXQgPSBmdW5jdGlvbiAobywgZm4pIHtcbiAgICBpZiAobykge1xuICAgICAgb1sndHlwZSddICYmIChvWydtZXRob2QnXSA9IG9bJ3R5cGUnXSkgJiYgZGVsZXRlIG9bJ3R5cGUnXVxuICAgICAgb1snZGF0YVR5cGUnXSAmJiAob1sndHlwZSddID0gb1snZGF0YVR5cGUnXSlcbiAgICAgIG9bJ2pzb25wQ2FsbGJhY2snXSAmJiAob1snanNvbnBDYWxsYmFja05hbWUnXSA9IG9bJ2pzb25wQ2FsbGJhY2snXSkgJiYgZGVsZXRlIG9bJ2pzb25wQ2FsbGJhY2snXVxuICAgICAgb1snanNvbnAnXSAmJiAob1snanNvbnBDYWxsYmFjayddID0gb1snanNvbnAnXSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgcmVxd2VzdC5hamF4U2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgZm9yICh2YXIgayBpbiBvcHRpb25zKSB7XG4gICAgICBnbG9iYWxTZXR1cE9wdGlvbnNba10gPSBvcHRpb25zW2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXdlc3Rcbn0pO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuXG4vKlxuQGZpbGVPdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgSmF2YVNjcmlwdCBjb2RlIHRoYXQgaGFuZGxlcyB0aGUgSFRNTCBkb2N1bWVudCB3aGVyZSBIVE1MIGlzIHJlbmRlcmVkIGZvciBhIFNhZmVGcmFtZSwgYXMgd2VsbCBhcyBkZWZpbmluZyB0aGUgRXh0ZXJuYWwgVmVuZG9yL0NsaWVudCBBUEkuXG5AYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86c3NuaWRlckB5YWhvby1pbmMuY29tXCI+U2VhbiBTbmlkZXI8L2E+XG5AYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Y2NvbGVbQVRdZW1pbmF0aW9uLmNvbVwiPkNocmlzIENvbGU8L2E+XG5AdmVyc2lvbiAxLjAuM1xuICovXG5cblxuLypcbkBuYW1lc3BhY2UgJHNmLmV4dCBUaGUgZXh0ZXJuYWwgdmVuZG9yIC8gY2xpZW50IEFQSSBmb3IgZnVuY3Rpb25hbGl0eSBpbnNpZGUgYSBTYWZlRnJhbWVcbkBuYW1lICRzZi5leHRcbiAqL1xuXG5cbi8qXG5AaWdub3JlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2Jhc2VcIik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0V4dGVybmFsKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbih3aW5kb3csIHNmKSB7XG4gICAgICB2YXIgQ09MTEFQU0VfQ09NTUFORCwgREcsIERPTV9XQVRDSF9JTlRFUlZBTCwgRFAsIERTLCBFUlJPUl9DT01NQU5ELCBFWFBBTkRfQ09NTUFORCwgR1VJRF9WQUxJRF9USU1FLCBJRV9BVFRBQ0gsIElFX0RFVEFDSCwgTE9BRCwgTUFYX01TR19XQUlUX1RJTUUsIE1TRywgTk9USUZZX0NMSUNLRUQsIE5PVElGWV9DT0xMQVBTRSwgTk9USUZZX0NPTExBUFNFRCwgTk9USUZZX0VYUEFORCwgTk9USUZZX0ZBSUxVUkUsIE5PVElGWV9GT0NVU19DSEFOR0UsIE5PVElGWV9HRU9NX1VQREFURSwgTk9USUZZX0xPQURFRCwgTk9USUZZX1JFQURfQ09PS0lFLCBOT1RJRllfUkVMT0FELCBOT1RJRllfUkVRVUVTVEVELCBOT1RJRllfVU5WSUVXRUQsIE5PVElGWV9WSUVXRUQsIE5PVElGWV9XUklURV9DT09LSUUsIE9CSiwgT05MT0FELCBPTk1TRywgT05VTkxPQUQsIE9OX1NUUiwgT1VSX1RBR19DTFNfTkFNRSwgUGFyYW1IYXNoLCBTVEFUVVNfQ09MTEFQU0VELCBTVEFUVVNfQ09MTEFQU0lORywgU1RBVFVTX0VYUEFOREVELCBTVEFUVVNfRVhQQU5ESU5HLCBUT0xPV0VSQ0FTRSwgVU5MT0FELCBXM0NfQVRUQUNILCBXM0NfREVUQUNILCBhZFNob3duLCBjYW5fdXNlX2h0bWw1LCBjbGljaywgY21kUmV0cmllcywgY29sbGFwc2UsIGNvb2tpZSwgZCwgZGVsZXRlTWV0YSwgZG9tLCBlbnYsIGVycl9tc2dfdGltZXJfaWQsIGVycl9tc2dzLCBleHBhbmQsIGZvcmNlX2NvbGxhcHNlLCBmcmFtZV9pZCwgZ2VvbSwgZ2VvbV9pbmZvLCBndWlkLCBoYXNMb2FkZWQsIGhvc3RfY25hbWUsIGllX29sZF9hdHRhY2gsIGllX29sZF9kZXRhY2gsIGlmcmFtZXMsIGluVmlld1BlcmNlbnRhZ2UsIGluaXRfaGVpZ2h0LCBpbml0X3dpZHRoLCBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCwgaXNBZFNob3duLCBpc0lFLCBpc19leHBhbmRlZCwgaXNfcmVnaXN0ZXJlZCwgbGFuZywgbGliLCBsb2FkZWQsIG1lc3NhZ2UsIG1lc3NhZ2VRdWV1ZSwgbWV0YSwgbXNnY2xpZW50X2ZiLCBvcmlnaW5hbFdyaXRlLCBvcnBoYW5fdGltZXJfaWQsIHBhciwgcGVuZGluZ19tc2csIHBvc19pZCwgcG9zX21ldGEsIHJlZ2lzdGVyLCByZWxvYWQsIHJlbmRlciwgcmVuZGVyX2NvbmYsIHJlbmRlcl9wYXJhbXMsIHNhbmRib3hfY2IsIHNob3dBZCwgc3RhdHVzLCBzdXBwb3J0cywgdW5sb2FkX2hhbmRsZXJzLCB1bnZpZXdlZCwgdmlld2VkLCB3M2Nfb2xkX2F0dGFjaCwgdzNjX29sZF9kZXRhY2gsIHdpbiwgd2luSGFzRm9jdXMsIHdpbl9oYXNfZm9jdXMsIF9hcHBlbmQsIF9hdHRhY2gsIF9hdHRhY2hfb3ZlcnJpZGUsIF9hdHRyLCBfY2FsbF9jbGllbnRfZmIsIF9jYWxsX3Jhd19ldnRfZnVuYywgX2NoZWNrX29ycGhhbmVkLCBfY251bSwgX2NvbGxhcHNlLCBfY29uc3RydWN0aW9uLCBfY3JlYXRlX3N0eWxlc2hlZXQsIF9jc3RyLCBfZGVzdHJ1Y3Rpb24sIF9kZXRhY2gsIF9kZXRhY2hfb3ZlcnJpZGUsIF9kZXRlY3RfYmFkX2lmcmFtZSwgX2VsdCwgX2ZpcmVfc2FuZGJveF9jYWxsYmFjaywgX2hhbmRsZV9lcnIsIF9oYW5kbGVfbG9hZCwgX2hhbmRsZV9tc2csIF9oYW5kbGVfdW5sb2FkLCBfbnVrZV9kb2MsIF9wdXJnZSwgX3JlYXR0YWNoX21lc3NhZ2luZywgX3JlY2VpdmVfbXNnLCBfcmVuZGVyLCBfcmVwb3J0X2VycnMsIF9yZXF1ZXN0ZWQsIF9yZXNldF9pbmxpbmVfaGFuZGxlcnMsIF9zZW5kX2NtZCwgX3NlbmRfbXNnLCBfc2V0X2FsaWdubWVudCwgX3NldF9oeXBlcmxpbmtfdGFyZ2V0cywgX3NldHVwX3dpbl9ldnRfcHJvcHMsIF9zaGlmdE1lc3NhZ2VRdWV1ZSwgX3RhZ3MsIF91ZSwgX3dyYXBpRnJhbWU7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICBMT0FEID0gXCJsb2FkXCI7XG4gICAgICBPTl9TVFIgPSBcIm9uXCI7XG4gICAgICBNU0cgPSBcIm1lc3NhZ2VcIjtcbiAgICAgIFVOTE9BRCA9IFwidW5cIiArIExPQUQ7XG4gICAgICBPTlVOTE9BRCA9IE9OX1NUUiArIFVOTE9BRDtcbiAgICAgIE9OTVNHID0gT05fU1RSICsgTVNHO1xuICAgICAgT05MT0FEID0gT05fU1RSICsgTE9BRDtcbiAgICAgIERHID0gXCJfX2RlZmluZUdldHRlcl9fXCI7XG4gICAgICBEUyA9IFwiX19kZWZpbmVTZXR0ZXJfX1wiO1xuICAgICAgRFAgPSBcIl9fZGVmaW5lUHJvcGVydHlfX1wiO1xuICAgICAgVzNDX0FUVEFDSCA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiO1xuICAgICAgVzNDX0RFVEFDSCA9IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiO1xuICAgICAgSUVfQVRUQUNIID0gXCJhdHRhY2hFdmVudFwiO1xuICAgICAgSUVfREVUQUNIID0gXCJkZXRhY2hFdmVudFwiO1xuICAgICAgVE9MT1dFUkNBU0UgPSBcInRvTG93ZXJDYXNlXCI7XG4gICAgICBFWFBBTkRfQ09NTUFORCA9IFwiZXhwLW92clwiO1xuICAgICAgQ09MTEFQU0VfQ09NTUFORCA9IFwiY29sbGFwc2VcIjtcbiAgICAgIEVSUk9SX0NPTU1BTkQgPSBcImVycm9yXCI7XG4gICAgICBOT1RJRllfR0VPTV9VUERBVEUgPSBcImdlb20tdXBkYXRlXCI7XG4gICAgICBOT1RJRllfRVhQQU5EID0gXCJleHBhbmRcIjtcbiAgICAgIE5PVElGWV9GT0NVU19DSEFOR0UgPSBcImZvY3VzLWNoYW5nZVwiO1xuICAgICAgTk9USUZZX0NPTExBUFNFID0gQ09MTEFQU0VfQ09NTUFORDtcbiAgICAgIE5PVElGWV9DT0xMQVBTRUQgPSBOT1RJRllfQ09MTEFQU0UgKyBcImRcIjtcbiAgICAgIE5PVElGWV9GQUlMVVJFID0gXCJmYWlsZWRcIjtcbiAgICAgIE5PVElGWV9SRUFEX0NPT0tJRSA9IFwicmVhZC1jb29raWVcIjtcbiAgICAgIE5PVElGWV9XUklURV9DT09LSUUgPSBcIndyaXRlLWNvb2tpZVwiO1xuICAgICAgTk9USUZZX0NMSUNLRUQgPSBcImNsaWNrZWRcIjtcbiAgICAgIE5PVElGWV9WSUVXRUQgPSBcInZpZXdlZFwiO1xuICAgICAgTk9USUZZX1VOVklFV0VEID0gXCJ1bnZpZXdlZFwiO1xuICAgICAgTk9USUZZX0xPQURFRCA9IFwibG9hZGVkXCI7XG4gICAgICBOT1RJRllfUkVRVUVTVEVEID0gXCJyZXF1ZXN0ZWRcIjtcbiAgICAgIE5PVElGWV9SRUxPQUQgPSBcInJlbG9hZFwiO1xuICAgICAgU1RBVFVTX0NPTExBUFNFRCA9IE5PVElGWV9DT0xMQVBTRUQ7XG4gICAgICBTVEFUVVNfRVhQQU5ERUQgPSBOT1RJRllfRVhQQU5EICsgXCJlZFwiO1xuICAgICAgU1RBVFVTX0NPTExBUFNJTkcgPSBcImNvbGxhcHNpbmdcIjtcbiAgICAgIFNUQVRVU19FWFBBTkRJTkcgPSBOT1RJRllfRVhQQU5EICsgXCJpbmdcIjtcbiAgICAgIE9VUl9UQUdfQ0xTX05BTUUgPSBcInNmXCI7XG4gICAgICBNQVhfTVNHX1dBSVRfVElNRSA9IDQwMDA7XG4gICAgICBET01fV0FUQ0hfSU5URVJWQUwgPSAzMDAwO1xuICAgICAgR1VJRF9WQUxJRF9USU1FID0gMzAwMDA7XG4gICAgICBPQkogPSBcIm9iamVjdFwiO1xuICAgICAgZCA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XG4gICAgICBwYXIgPSB3aW4gJiYgd2luLnBhcmVudDtcbiAgICAgIGxpYiA9IHNmLmxpYjtcbiAgICAgIGVudiA9IHNmLmVudjtcbiAgICAgIGxhbmcgPSBsaWIubGFuZztcbiAgICAgIFBhcmFtSGFzaCA9IGxhbmcuUGFyYW1IYXNoO1xuICAgICAgZG9tID0gbGliLmRvbTtcbiAgICAgIGlmcmFtZXMgPSBkb20uaWZyYW1lcztcbiAgICAgIG1zZ2NsaWVudF9mYiA9IGRvbS5tc2djbGllbnRfZmI7XG4gICAgICBpc0lFID0gZW52LmlzSUU7XG4gICAgICBfdWUgPSB3aW4udW5lc2NhcGU7XG4gICAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICAgIF9jbnVtID0gbGFuZy5jbnVtO1xuICAgICAgX2FwcGVuZCA9IGRvbS5hcHBlbmQ7XG4gICAgICBfdGFncyA9IGRvbS50YWdzO1xuICAgICAgX2VsdCA9IGRvbSAmJiBkb20uZWx0O1xuICAgICAgX3B1cmdlID0gZG9tICYmIGRvbS5wdXJnZTtcbiAgICAgIF9hdHRhY2ggPSBkb20gJiYgZG9tLmF0dGFjaDtcbiAgICAgIF9kZXRhY2ggPSBkb20gJiYgZG9tLmRldGFjaDtcbiAgICAgIF9hdHRyID0gZG9tICYmIGRvbS5hdHRyO1xuICAgICAgaGFzTG9hZGVkID0gZmFsc2U7XG4gICAgICBpc19leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgZm9yY2VfY29sbGFwc2UgPSBmYWxzZTtcbiAgICAgIGlzX3JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgIGluaXRfd2lkdGggPSAwO1xuICAgICAgaW5pdF9oZWlnaHQgPSAwO1xuICAgICAgc2FuZGJveF9jYiA9IG51bGw7XG4gICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICBtZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgIGdlb21faW5mbyA9IG51bGw7XG4gICAgICBwb3NfbWV0YSA9IG51bGw7XG4gICAgICB3aW5faGFzX2ZvY3VzID0gZmFsc2U7XG4gICAgICBndWlkID0gXCJcIjtcbiAgICAgIGhvc3RfY25hbWUgPSBcIlwiO1xuICAgICAgY2FuX3VzZV9odG1sNSA9IGZhbHNlO1xuICAgICAgZnJhbWVfaWQgPSBcIlwiO1xuICAgICAgcG9zX2lkID0gXCJcIjtcbiAgICAgIGVycl9tc2dfdGltZXJfaWQgPSAwO1xuICAgICAgb3JwaGFuX3RpbWVyX2lkID0gMDtcbiAgICAgIGlubGluZV9oYW5kbGVyX3RpbWVyX2lkID0gMDtcbiAgICAgIGVycl9tc2dzID0gW107XG4gICAgICB1bmxvYWRfaGFuZGxlcnMgPSBbXTtcbiAgICAgIHJlbmRlcl9wYXJhbXMgPSB2b2lkIDA7XG4gICAgICByZW5kZXJfY29uZiA9IHZvaWQgMDtcbiAgICAgIGllX29sZF9hdHRhY2ggPSB2b2lkIDA7XG4gICAgICB3M2Nfb2xkX2F0dGFjaCA9IHZvaWQgMDtcbiAgICAgIGllX29sZF9kZXRhY2ggPSB2b2lkIDA7XG4gICAgICB3M2Nfb2xkX2RldGFjaCA9IHZvaWQgMDtcbiAgICAgIGlzQWRTaG93biA9IGZhbHNlO1xuXG4gICAgICAvKlxuICAgICAgQ3JlYXRlcyBhbmQgYXBwZW5kcyBhIHN0eWxlIHNoZWV0IGZvciBhbnkgY3VzdG9tIENTUyBwYXNzZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fY3JlYXRlX3N0eWxlc2hlZXRcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0IEEgc3RyaW5nIG9mIENTUyBydWxlcywgb3IgYSBVUkwgc3RyaW5nXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2lkXSBUaGUgaWQgYXR0cmlidXRlIG9mIHRoZSB0YWcgY3JlYXRlZCBhbmQgYXBwZW5kZWRcbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZV9zdHlsZXNoZWV0ID0gZnVuY3Rpb24oY3NzVGV4dCwgaWQpIHtcbiAgICAgICAgdmFyIGUsIG9IZWFkLCBvU1MsIG9UeHQ7XG4gICAgICAgIG9IZWFkID0gdm9pZCAwO1xuICAgICAgICBvU1MgPSB2b2lkIDA7XG4gICAgICAgIG9UeHQgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb0hlYWQgPSBfdGFncyhcImhlYWRcIilbMF07XG4gICAgICAgICAgaWYgKGNzc1RleHQuc2VhcmNoKC9cXHtbXlxcfV0qfS9nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9TUyA9IGRvbS5tYWtlKFwibGlua1wiKTtcbiAgICAgICAgICAgIG9TUy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICAgICAgb1NTLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuICAgICAgICAgICAgb1NTLmhyZWYgPSBjc3NUZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvU1MgPSBkb20ubWFrZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgb1NTLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgICBvU1Muc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9UeHQgPSBkLmNyZWF0ZVRleHROb2RlKGNzc1RleHQpO1xuICAgICAgICAgICAgICBfYXBwZW5kKG9TUywgb1R4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgb1NTLmlkID0gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9hcHBlbmQob0hlYWQsIG9TUyk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBGaXJlcyBvZiB1bmxvYWQgZXZlbnQgaGFuZGxlcnMgYW5kIHBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgY2xlYW4gdXAgd2hlbiBhIFNhZmVGcmFtZSBpcyBkZXN0cm95ZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fZGVzdHJ1Y3Rpb25cbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBbZXZ0XSBUaGUgcmF3IGRvbSBldmVudCBvYmplY3QgaWYgaXQgZXhpc3RzXG4gICAgICAgKi9cbiAgICAgIF9kZXN0cnVjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgZSwgZ3JhbmRfcGFyLCBoYW5kbGVyLCBzdWNjZXNzLCB3O1xuICAgICAgICBoYW5kbGVyID0gdm9pZCAwO1xuICAgICAgICB3ID0gd2luZG93O1xuICAgICAgICBzdWNjZXNzID0gMTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQgPSBldnQgfHwgdy5ldmVudCB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBldnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBVTkxPQURcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChoYW5kbGVyID0gdW5sb2FkX2hhbmRsZXJzLnNoaWZ0KCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGFuZGxlcihldnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgICB3W0lFX0FUVEFDSF0gPSBpZV9vbGRfYXR0YWNoO1xuICAgICAgICAgICAgd1tJRV9ERVRBQ0hdID0gaWVfb2xkX2RldGFjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodzNjX29sZF9hdHRhY2gpIHtcbiAgICAgICAgICAgIHdbVzNDX0FUVEFDSF0gPSB3M2Nfb2xkX2F0dGFjaDtcbiAgICAgICAgICAgIHdbVzNDX0RFVEFDSF0gPSB3M2Nfb2xkX2RldGFjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgaWYgKCFoYXNMb2FkZWQpIHtcbiAgICAgICAgICBfZGV0YWNoKHcsIExPQUQsIF9oYW5kbGVfbG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgX2RldGFjaCh3LCBVTkxPQUQsIF9oYW5kbGVfdW5sb2FkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGVycl9tc2dfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlcnJfbXNnX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIGVycl9tc2dfdGltZXJfaWQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChvcnBoYW5fdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvcnBoYW5fdGltZXJfaWQpO1xuICAgICAgICAgICAgb3JwaGFuX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaW5saW5lX2hhbmRsZXJfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCk7XG4gICAgICAgICAgICBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHcgPSBpZV9vbGRfYXR0YWNoID0gdzNjX29sZF9hdHRhY2ggPSBpZV9vbGRfZGV0YWNoID0gdzNjX29sZF9kZXRhY2ggPSBkID0gX3VlID0gcGFyID0gaGFuZGxlciA9IGdyYW5kX3BhciA9IG51bGw7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE1haW50YWlucyB0aGF0IHRoZSB3aW5kb3cub25tZXNzYWdlIHByb3BlcnR5IHJlbWFpbnMgdW5zZXQuXG4gICAgICBXZSBkb24ndCB3YW50IGNvbnRlbnQgaW4gb3VyIGRvY3VtZW50IGxpc3RlbmluZyB0byBIVE1MNSBtZXNzYWdlcy5cbiAgICAgIFdlIG92ZXJyaWRlIGF0dGFjaGluZyB0byBsaXN0ZW5lcnMgYmVsb3cgdG8gbWFpbnRhaW4gdGhhdCBmdW5jdGlvbmFsaXR5LFxuICAgICAgaG93ZXZlciBJRSB3b24ndCBsZXQgeW91IG92ZXJyaWRlIHByb3BlcnRpZXMgZGlyZWN0bHkgaGFuZ25pbmcgb2ZmIG9mIHRoZVxuICAgICAgd2luZG93IG9iamVjdCwgc28gd2UgaGF2ZSBhIHRpbWVyIGFzIGEgZmFsbGJhY2sgZm9yIHRoYXQgcHVycG9zZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9yZXNldF9pbmxpbmVfaGFuZGxlcnNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3Jlc2V0X2lubGluZV9oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaW5saW5lX2hhbmRsZXJfdGltZXJfaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCk7XG4gICAgICAgICAgICBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGlzSUUgJiYgd2luLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgd2luLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luLm9uZXJyb3IgPSBfaGFuZGxlX2VycjtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBpbmxpbmVfaGFuZGxlcl90aW1lcl9pZCA9IHNldFRpbWVvdXQoX3Jlc2V0X2lubGluZV9oYW5kbGVycywgRE9NX1dBVENIX0lOVEVSVkFMKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDbGVhcnMgb3V0IHRoZSBIVE1MIGRvY3VtZW50ICh3aGljaCB3aWxsIGZvcmNlIGFuIHVubG9hZCBldmVudCBhcyB3ZWxsKS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fbnVrZV9kb2NcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX251a2VfZG9jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY3VtZW50Lm9wZW4oXCJ0ZXh0L2h0bWxcIiwgXCJyZXBsYWNlXCIpO1xuICAgICAgICAgIGRvY3VtZW50LndyaXRlKFwiXCIpO1xuICAgICAgICAgIGRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBJdGVyYXRpdmVseSBjaGVja3MgdG8gc2VlIGlmIHRoZSBJRlJBTUUgSFRNTCBkb2N1bWVudCBpcyBubyBsb25nZXJcbiAgICAgIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvbSwgZG9pbmcgdGhpcyBieSBjaGVja2luZyB0aGF0IG91ciBpbnRlcm5hbFxuICAgICAgd2luZG93IHJlZmVyZW5jZSBpcyBzdGlsbCB2YWxpZC4gLiAuYXMgd2VsbCBhcyBydW5uaW5nIHRoZSBjaGVja3MgdG8gbWFrZVxuICAgICAgc3VyZSBpbnZhbGlkIGlmcmFtZXMgKGlmcmFtZXMgZnJvbSBvcmlnaW4pIGFyZSBub3QgY3JlYXRlZC5cbiAgICAgIFxuICAgICAgSWYgd2UgZGV0ZWN0IHRoYXQgdGhlIElGUkFNRSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1haW4gZG9tIG9mIHRoZVxuICAgICAgcHVibGlzaGVyLCB0aGVuIHdlIGNhbGwgdG8gZGVzdHJveSB0aGUgSFRNTCBkb2N1bWVudCwgZm9yY2luZyBvbnVubG9hZFxuICAgICAgZXZlbnQgYW5kIHN1YnNxdWVudCBjbGVhbnVwXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2NoZWNrX29ycGhhbmVkXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9jaGVja19vcnBoYW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZSwgaXNfb3JwaGFuZWQ7XG4gICAgICAgIGlzX29ycGhhbmVkID0gZmFsc2U7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIF9kZXRlY3RfYmFkX2lmcmFtZSgpO1xuICAgICAgICBpZiAoIWlzSUUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAob3JwaGFuX3RpbWVyX2lkICYmIG9ycGhhbl90aW1lcl9pZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvcnBoYW5fdGltZXJfaWQpO1xuICAgICAgICAgICAgb3JwaGFuX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpc19vcnBoYW5lZCA9IHdpbiA9PT0gdG9wICYmIG9ycGhhbl90aW1lcl9pZCAhPT0gLTE7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgaXNfb3JwaGFuZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfb3JwaGFuZWQpIHtcbiAgICAgICAgICBvcnBoYW5fdGltZXJfaWQgPSAtMTtcbiAgICAgICAgICBfZGVzdHJ1Y3Rpb24oKTtcbiAgICAgICAgICBfbnVrZV9kb2MoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIW9ycGhhbl90aW1lcl9pZCkge1xuICAgICAgICAgICAgb3JwaGFuX3RpbWVyX2lkID0gc2V0VGltZW91dChfY2hlY2tfb3JwaGFuZWQsIERPTV9XQVRDSF9JTlRFUlZBTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgRGV0ZWN0IHdoZXRoZXIgb3Igbm90IGFuIElGUkFNRSB0YWcgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NIHRoYXQgaGFzIHRoZSBzYW1lXG4gICAgICBvcmlnaW4gLyBjbmFtZSBhcyB0aGUgcHVibGlzaGVyLCB3aGljaCBzaG91bGQgbm90IGJlIGFsbG93ZWQgYXMgaXQncyBhIHNlY3VyaXR5IGlzc3VlXG4gICAgICBJZiBzYWlkIElGUkFNRSB0YWcocykgYXJlIGZvdW5kLCByZW1vdmUgdGhlbS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fZGV0ZWN0X2JhZF9pZnJhbWVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX2RldGVjdF9iYWRfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZHgsIHNyY0hvc3QsIHRhZywgd3JpdHRlbjtcbiAgICAgICAgaWZyYW1lcyA9IF90YWdzKFwiaWZyYW1lXCIpO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBzcmNIb3N0ID0gXCJcIjtcbiAgICAgICAgd3JpdHRlbiA9IGZhbHNlO1xuICAgICAgICB0YWcgPSB2b2lkIDA7XG4gICAgICAgIGlmIChob3N0X2NuYW1lKSB7XG4gICAgICAgICAgd2hpbGUgKHRhZyA9IGlmcmFtZXNbaWR4KytdKSB7XG4gICAgICAgICAgICBzcmNIb3N0ID0gX2F0dHIodGFnLCBcInNyY1wiKTtcbiAgICAgICAgICAgIHNyY0hvc3QgPSAoc3JjSG9zdCAmJiBzcmNIb3N0Lmxlbmd0aCA+PSA5ID8gc3JjSG9zdC5zdWJzdHJpbmcoMCwgc3JjSG9zdC5pbmRleE9mKFwiL1wiLCA5KSlbVE9MT1dFUkNBU0VdKCkgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChzcmNIb3N0ICYmIHNyY0hvc3QgPT09IGhvc3RfY25hbWUgJiYgdGFnLmNsYXNzTmFtZSAhPT0gT1VSX1RBR19DTFNfTkFNRSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wdXJnZSh0YWcpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTWFrZSBzdXJlIHRoYXQgYWxsIGh5cGVybGlua3MgaW4gdGhlIGRvY3VtZW50IGFyZSBzZXQgd2l0aCB0aGUgcHJvcGVydHkgXCJ0YXJnZXRcIiBhdHRyaWJ1dGVcbiAgICAgIHN1Y2ggdGhhdCBsaW5rcyB3aWxsIG5hdmlnYXRlIHRvIHRoZSByaWdodCB3aW5kb3cgcHJvcGVybHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3NldF9oeXBlcmxpbmtfdGFyZ2V0c1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfc2V0X2h5cGVybGlua190YXJnZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdGd0LCBpZHgsIGxuLCBsbnMsIHR0Z3Q7XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIHR0Z3QgPSAocmVuZGVyX2NvbmYgJiYgcmVuZGVyX2NvbmYudGd0KSB8fCBcIl90b3BcIjtcbiAgICAgICAgbG4gPSB2b2lkIDA7XG4gICAgICAgIGF0Z3QgPSB2b2lkIDA7XG4gICAgICAgIGxucyA9IHZvaWQgMDtcbiAgICAgICAgbG5zID0gX3RhZ3MoXCJhXCIpO1xuICAgICAgICBpZiAodHRndCA9PT0gXCJfc2VsZlwiKSB7XG4gICAgICAgICAgdHRndCA9IFwiX3RvcFwiO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsbiA9IGxuc1tpZHgrK10pIHtcbiAgICAgICAgICBhdGd0ID0gX2F0dHIobG4sIFwidGFyZ2V0XCIpO1xuICAgICAgICAgIGlmIChhdGd0ICE9PSB0dGd0KSB7XG4gICAgICAgICAgICBfYXR0cihsbiwgXCJ0YXJnZXRcIiwgdHRndCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpZHggPiAxMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIHRoZSBvbnVubG9hZCBldmVudCBmcm9tIHRoZSBIVE1MIGRvY3VtZW50IG9mIHRoZSBJRlJBTUUsIHdoaWNoIGluIHR1cm4gd2lsbCB0cmlnZ2VyIGNsZWFuIHVwXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2hhbmRsZV91bmxvYWRcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBET00gZXZlbnQgb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfdW5sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF9kZXN0cnVjdGlvbihldnQpO1xuICAgICAgICBfbnVrZV9kb2MoKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIGxvYWQgZXZlbnQgZnJvbSB0aGUgSFRNTCBkb2N1bWVudCBvZiB0aGUgSUZSQU1FLCB3aGljaCB3aWxsIGFsc28gc2V0dXBcbiAgICAgIHRvIG1ha2Ugc3VyZSBsaW5rIHRhcmdldHMgYXJlIHNldCBwcm9wZXJseVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9oYW5kbGVfbG9hZFxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfaGFuZGxlX2xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBfZGV0YWNoKHdpbiwgTE9BRCwgX2hhbmRsZV9sb2FkKTtcbiAgICAgICAgX3NldF9oeXBlcmxpbmtfdGFyZ2V0cygpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSBvbm1lc3NhZ2UgSFRNTDUgeC1kb21haW4gZXZlbnRzLiBXZSBhbHdheXMgY2FuY2VsIHRoZSBldmVudFxuICAgICAgbmV2ZXIgYWxsb3dpbmcgaXQgdG8gZ28gdG8gb3RoZXIgbGlzdGVuZXJzIGJlc2lkZXMgb3VyIG93biwgYXMgd2UgZG9uJ3QgYWxsb3cgSFRNTDUgbWVzc2FnaW5nXG4gICAgICBiZXlvbmQgdXMgYW5kIHRoZSBwdWJsaXNoZXIgLyBob3N0LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9oYW5kbGVfbXNnXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfbXNnID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBlLCBtc2dfZ3VpZCwgbXNnX29iaiwgbXNnX3BhcmFtcywgb3JnLCBzcmMsIHN0cjtcbiAgICAgICAgc3RyID0gdm9pZCAwO1xuICAgICAgICBzcmMgPSB2b2lkIDA7XG4gICAgICAgIG9yZyA9IHZvaWQgMDtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgbXNnX3BhcmFtcyA9IHZvaWQgMDtcbiAgICAgICAgbXNnX2d1aWQgPSB2b2lkIDA7XG4gICAgICAgIG1zZ19vYmogPSB2b2lkIDA7XG5cbiAgICAgICAgLypcbiAgICAgICAgVE9ETywgYWxzbyB2YWxpZGF0ZSBvcmlnaW5cbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RyID0gZXZ0LmRhdGE7XG4gICAgICAgICAgc3JjID0gZXZ0LnNvdXJjZTtcbiAgICAgICAgICBvcmcgPSBldnQub3JpZ2luO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIGRvbS5ldnRDbmNsKGV2dCk7XG4gICAgICAgIGlmIChzdHIgJiYgc3JjICYmIHNyYyA9PT0gdG9wKSB7XG4gICAgICAgICAgbXNnX3BhcmFtcyA9IFBhcmFtSGFzaChzdHIsIG51bGwsIG51bGwsIHRydWUsIHRydWUpO1xuICAgICAgICAgIG1zZ19ndWlkID0gbXNnX3BhcmFtcy5ndWlkO1xuICAgICAgICAgIG1zZ19vYmogPSBtc2dfcGFyYW1zLm1zZztcbiAgICAgICAgICBpZiAoZ3VpZCA9PT0gbXNnX2d1aWQgJiYgbXNnX29iaiAmJiB0eXBlb2YgbXNnX29iaiA9PT0gT0JKKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfcmVjZWl2ZV9tc2cobXNnX29iaiwgZXZ0KTtcbiAgICAgICAgICAgICAgICBtc2dfcGFyYW1zID0gZXZ0ID0gbXNnX2d1aWQgPSBtc2dfb2JqID0gbnVsbDtcbiAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFRoaXMgU2FmZUZyYW1lcyBpbXBsZW1lbnRhdGlvbiBpbnRlcm5hbGx5IGhhbmRsZXMgYWxsIGV2ZW50IGF0dGFjaG1lbnQgdG8gbWFpbnRhaW4gdGhhdCB0aGUgbGlzdGVuZXIgb3JkZXJcbiAgICAgIGZvciBldmVudHMgdGhhdCBpdCBjYXJlcyBhYm91dCAob25sb2FkLCBvbnVubG9hZCwgb25iZWZvcmV1bmxvYWQsIG9ubWVzc2FnZSkuXG4gICAgICBUaGlzIGlzIGRvbmUgdG8gbWFrZSBzdXJlIHRoYXQgcHJvcGVyIGNsZWFuIHVwIGFuZCBpbnRpYWxpemF0aW9uIGhhcHBlbnMsIGFzIHdlbGwgYXMgdG8gZW5mb3JjZVxuICAgICAgc2VjdXJpdHkuXG4gICAgICBcbiAgICAgIEZvciBldmVudHMgdGhhdCBpdCBTYWZlRnJhbWVzIGRvZXMgbm90IGNhcmUgYWJvdXQgd2UgYWxsb3cgdGhlIGF0dGFjaG1lbnQgbGlzdGVuZXJzXG4gICAgICB0byBwcm9jZWVkIGFzIG5vcm1hbCwgc28gd2UgY2FsbCB0aGUgcmF3IGF0dGFjaEV2ZW50IC8gYWRkRXZlbnRMaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2NhbGxfcmF3X2V2dF9mdW5jXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIGF0dGFjaC9kZXRhY2ggYSBsaXN0ZW5lclxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdXNlIGFzIGEgbGlzdGVuZXIgZm9yIHNhaWQgZXZlbnRcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbW92ZV0gSWYgc2V0IHRvIHRydWUsIHJlbW92ZS9kZXRhY2ggdGhpcyBmdW5jdGlvbiBhcyBhIGxpc3RlbmVyLCBvdGhlcndpc2UgYWRkXG4gICAgICAgKi9cbiAgICAgIF9jYWxsX3Jhd19ldnRfZnVuYyA9IGZ1bmN0aW9uKHR5cGUsIGYsIHJlbW92ZSkge1xuICAgICAgICB2YXIgYk9LLCBlLCBpZV9mLCB3M2NfZjtcbiAgICAgICAgYk9LID0gZmFsc2U7XG4gICAgICAgIGllX2YgPSB2b2lkIDA7XG4gICAgICAgIHczY19mID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgaWVfZiA9IGllX29sZF9kZXRhY2ggfHwgdzNjX29sZF9kZXRhY2g7XG4gICAgICAgICAgdzNjX2YgPSB3M2Nfb2xkX2RldGFjaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZV9mID0gaWVfb2xkX2F0dGFjaCB8fCB3M2Nfb2xkX2F0dGFjaDtcbiAgICAgICAgICB3M2NfZiA9IHczY19vbGRfYXR0YWNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZV9mKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGllX2YodHlwZSwgZik7XG4gICAgICAgICAgICBiT0sgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIGJPSyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWJPSykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWVfZi5jYWxsKHdpbiwgdHlwZSwgZik7XG4gICAgICAgICAgICAgIGJPSyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgYk9LID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3M2NfZiAmJiAhYk9LKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHczY19mLmNhbGwod2luLCB0eXBlLCBmLCBmYWxzZSk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgT3ZlcnJpZGUgZGVmYXVsdCBldmVudCBhdHRhY2htZW50LCBhbmQgc2VuZCBsb2FkLCBiZWZvcmV1bmxvYWQsIGFuZCB1bmxvYWQgaGFuZGxlcnMgaW50byBvdXJcbiAgICAgIG93biBxdWVzLCBzbyB0aGF0IHdlIGNhbiBlbmZvcmNlIHRoZSBwcm9wZXIgZmlyaW5nIG9yZGVyLiAgaWYgbWVzc2FnZSBldmVudCBpcyBwYXNzZWQgaW4sXG4gICAgICB3ZSBkbyBub3QgYWxsb3cgYXR0YWNobWVudCwgc2luY2Ugd2UgZG8gbm90IHdhbnQgbi1wYXJ0eSBjb2RlIGxpc3RlbmluZyB0byBIVE1MNSBtZXNzYWdlc1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9hdHRhY2hfb3ZlcnJpZGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lIHRvIGxpc3RlbiB0b29cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgZXZlbnQgZmlyZXNcbiAgICAgICAqL1xuICAgICAgX2F0dGFjaF9vdmVycmlkZSA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtcbiAgICAgICAgdmFyIGJEb0RlZmF1bHQ7XG4gICAgICAgIGJEb0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IF9jc3RyKHR5cGUpW1RPTE9XRVJDQVNFXSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFVOTE9BRDpcbiAgICAgICAgICBjYXNlIE9OVU5MT0FEOlxuICAgICAgICAgICAgdW5sb2FkX2hhbmRsZXJzLnB1c2goZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1TRzpcbiAgICAgICAgICBjYXNlIE9OTVNHOlxuICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBiRG9EZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYkRvRGVmYXVsdCkge1xuICAgICAgICAgIF9jYWxsX3Jhd19ldnRfZnVuYyh0eXBlLCBmKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE92ZXJyaWRlIGRlZmF1bHQgZXZlbnQgZGV0YWNobWVudCwgYW5kIHJlbW92ZSBsb2FkLCBiZWZvcmV1bmxvYWQsIGFuZCB1bmxvYWQgaGFuZGxlcnNcbiAgICAgIGZyb20gb3VyIG93biBxdWUuICBpZiBtZXNzYWdlIGV2ZW50IGlzIHBhc3NlZCBpbiwgd2UgZG8gbm90aGluZyAoc2luY2Ugd2UgZG9uJ3QgYWxsbG93XG4gICAgICBhdHRhY2htZW50IGVpdGhlcikuICBJZiBub3Qgb25lIG9mIHRob3NlIGV2ZW50IHR5cGVzLCB0aGVuIHdlIGNhbGwgdGhlIGRlZmF1bHQgZXZlbnQgZGV0YWNobWVudFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9kZXRhY2hfb3ZlcnJpZGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lIHRvIHVubGlzdGVuIHRvb1xuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gZiBUaGUgZnVuY3Rpb24gdG8gbm8gbG9uZ2VyIGJlIGNhbGxlZCBmb3IgdGhlIHNwZWNpZmljIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIF9kZXRhY2hfb3ZlcnJpZGUgPSBmdW5jdGlvbih0eXBlLCBmKSB7XG4gICAgICAgIHZhciBoYW5kbGVyLCBoYW5kbGVycywgaWR4O1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBoYW5kbGVyID0gdm9pZCAwO1xuICAgICAgICBoYW5kbGVycyA9IHZvaWQgMDtcbiAgICAgICAgdHlwZSA9IF9jc3RyKHR5cGUpW1RPTE9XRVJDQVNFXSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFVOTE9BRDpcbiAgICAgICAgICBjYXNlIE9OVU5MT0FEOlxuICAgICAgICAgICAgaGFuZGxlcnMgPSB1bmxvYWRfaGFuZGxlcnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1TRzpcbiAgICAgICAgICBjYXNlIE9OTVNHOlxuICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlcnMgIT0gbnVsbCA/IGhhbmRsZXJzLmxlbmd0aCA6IHZvaWQgMCkge1xuICAgICAgICAgIHdoaWxlIChoYW5kbGVyID0gaGFuZGxlcnNbaWR4XSkge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IGYpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgIH1cbiAgICAgICAgX2NhbGxfcmF3X2V2dF9mdW5jKHR5cGUsIGYsIHRydWUpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlcG9ydCBhbnkgaW50ZXJuYWwgdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvcnMgdXAgdG8gdGhlIHB1Ymxpc2hlciAvIGhvc3RcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fcmVwb3J0X2VycnNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX3JlcG9ydF9lcnJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbWRfc3RyLCBlLCBlcnJzO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBlcnJzID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChlcnJfbXNncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnJzID0gZXJyX21zZ3NbMF07XG4gICAgICAgICAgICBjbWRfc3RyID0gW1wiY21kPVwiLCBFUlJPUl9DT01NQU5ELCBcIiZwb3M9XCIsIHBvc19pZCwgXCImZXJyb3JzPVwiLCBlcnJzXTtcbiAgICAgICAgICAgIF9zZW5kX21zZyhfY3N0cihjbWRfc3RyKSwgRVJST1JfQ09NTUFORCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJfbXNnX3RpbWVyX2lkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZXJyX21zZ190aW1lcl9pZCk7XG4gICAgICAgICAgICBlcnJfbXNnX3RpbWVyX2lkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgZXJyX21zZ3MgPSBbXTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgYW55IHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3JzXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2hhbmRsZV9lcnJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBhIFRoZSB0aGUgZXJyb3IgbWVzc2FnZSAvIGRlc2NyaXB0aW9uIHN0cmluZ1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IGIgVGhlIFVSTCAvIGZpbGUgdGhhdCB0aGUgSmF2YVNjcmlwdCBlcnJvciBvY2N1cmVkIHdpdGhpblxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGxpbmUgbnVtYmVyIHRoYXQgdGhlIGVycm9yIG9jY3VyZWQgb24uIC4gLlxuICAgICAgICovXG4gICAgICBfaGFuZGxlX2VyciA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGVycl9tc2dzLnB1c2goX2NzdHIoW1wiRXJyb3Igb2NjdXJyZWQgaW5zaWRlIFNhZmVGcmFtZTpcXG5NZXNzYWdlOiBcIiwgYSwgXCJcXG5VUkw6XCIsIGIsIFwiXFxuTGluZTpcIiwgY10pKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZXJyX21zZ190aW1lcl9pZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVycl9tc2dfdGltZXJfaWQpO1xuICAgICAgICAgICAgZXJyX21zZ190aW1lcl9pZCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycl9tc2dfdGltZXJfaWQgPSBzZXRUaW1lb3V0KF9yZXBvcnRfZXJycywgRE9NX1dBVENIX0lOVEVSVkFMKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBPdmVycmlkZSBuYXRpdmUgd2luZG93IG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gY29udHJvbFxuICAgICAgaG93IHRoZSBldmVudHMgdGhhdCB3ZSBuZWVkIHRvIG1hbmFnZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9zZXR1cF93aW5fZXZ0X3Byb3BzXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwcml2YXRlXG4gICAgICBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSB3aW5kb3cgb2JqZWN0IC8gcHJvdG90eXBlXG4gICAgICAgKi9cbiAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBPLCBlLCBuLCBub2JqLCByZXQ7XG4gICAgICAgIG4gPSBsYW5nLm5vb3A7XG4gICAgICAgIE8gPSBPYmplY3Q7XG4gICAgICAgIG5vYmogPSB7XG4gICAgICAgICAgZ2V0OiBuLFxuICAgICAgICAgIHNldDogblxuICAgICAgICB9O1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgIGlmIChpZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgICBvYmpbSUVfQVRUQUNIXSA9IF9hdHRhY2hfb3ZlcnJpZGU7XG4gICAgICAgICAgICBvYmpbSUVfREVUQUNIXSA9IF9kZXRhY2hfb3ZlcnJpZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3M2Nfb2xkX2F0dGFjaCkge1xuICAgICAgICAgICAgb2JqW1czQ19BVFRBQ0hdID0gX2F0dGFjaF9vdmVycmlkZTtcbiAgICAgICAgICAgIG9ialtXM0NfREVUQUNIXSA9IF9kZXRhY2hfb3ZlcnJpZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmpbREddKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvYmpbREddKE9OTE9BRCwgbik7XG4gICAgICAgICAgICAgIG9ialtEU10oT05MT0FELCBuKTtcbiAgICAgICAgICAgICAgb2JqW0RHXShPTlVOTE9BRCwgbik7XG4gICAgICAgICAgICAgIG9ialtEU10oT05VTkxPQUQsIG4pO1xuICAgICAgICAgICAgICBvYmpbREddKE9OTVNHLCBuKTtcbiAgICAgICAgICAgICAgb2JqW0RTXShPTk1TRywgbik7XG4gICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmV0ICYmIE9bRFBdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBPW0RQXShvYmosIE9OTE9BRCwgbm9iaik7XG4gICAgICAgICAgICAgIE9bRFBdKG9iaiwgT05VTkxPQUQsIG5vYmopO1xuICAgICAgICAgICAgICBPW0RQXShvYmosIE9OTVNHLCBub2JnKTtcbiAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBJbnRpYWxpemUgLyBzZXR1cCB0aGUgc2FmZWZyYW1lLCB0aGUgZW52aXJvbm1lbnQgYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGZvdW5kIHdpdGhpbiB0aGUgc2VyaWFsaXplZFxuICAgICAgd2luZG93Lm5hbWUgcHJvcGVydHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX2NvbnN0cnVjdGlvblxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzXSBBbiBvcHRpb25hbCBvYmplY3QgdG8gcGFzcyBpbiBzdGF0dXMgLyBlcnJvciBpbmZvcm1hdGlvbiBpbnRvXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9jb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbihkZXRhaWxzKSB7XG4gICAgICAgIHZhciBjb250LCBjdXJfdGltZSwgZSwgZWwsIGd1aWRfdGltZSwgbm0sIHJldCwgdGVtcCwgdGltZV9kZWx0YTtcbiAgICAgICAgY29udCA9IGZhbHNlO1xuICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICBlbCA9IHZvaWQgMDtcbiAgICAgICAgbm0gPSB2b2lkIDA7XG4gICAgICAgIHRlbXAgPSB2b2lkIDA7XG4gICAgICAgIGN1cl90aW1lID0gdm9pZCAwO1xuICAgICAgICBndWlkX3RpbWUgPSB2b2lkIDA7XG4gICAgICAgIHRpbWVfZGVsdGEgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGRldGFpbHMgPSAoZGV0YWlscyAmJiAoZGV0YWlscyBpbnN0YW5jZW9mIE9iamVjdCkgPyBkZXRhaWxzIDoge30pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5tID0gd2luLm5hbWU7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW4ubmFtZSA9IFwiXCI7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgaWYgKCFubSkge1xuICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwMTtcbiAgICAgICAgICByZXR1cm4gY29udDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0b3AgPT09IHBhcikge1xuICAgICAgICAgICAgcmVuZGVyX3BhcmFtcyA9IFBhcmFtSGFzaChubSwgbnVsbCwgbnVsbCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBjdXJfdGltZSA9IGxhbmcudGltZSgpO1xuICAgICAgICAgICAgZ3VpZCA9IHJlbmRlcl9wYXJhbXMuZ3VpZDtcbiAgICAgICAgICAgIGd1aWRfdGltZSA9IF9jbnVtKGd1aWQucmVwbGFjZSgvW15fXSpfKFxcZCspX1xcZCtfXFxkKy9nLCBcIiQxXCIpLCAwKTtcbiAgICAgICAgICAgIHRpbWVfZGVsdGEgPSBjdXJfdGltZSAtIGd1aWRfdGltZTtcbiAgICAgICAgICAgIGNvbnQgPSBndWlkICYmIGd1aWRfdGltZSAmJiB0aW1lX2RlbHRhID4gMCAmJiB0aW1lX2RlbHRhIDwgR1VJRF9WQUxJRF9USU1FO1xuICAgICAgICAgICAgaWYgKHJlbmRlcl9wYXJhbXMubG9jKSB7XG4gICAgICAgICAgICAgIHJlbmRlcl9wYXJhbXMubG9jID0gdW5lc2NhcGUocmVuZGVyX3BhcmFtcy5sb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250KSB7XG4gICAgICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5zdGF0dXMgPSA1MDAuMTAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICByZW5kZXJfcGFyYW1zID0gZ3VpZCA9IG51bGw7XG4gICAgICAgICAgY29udCA9IGZhbHNlO1xuICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJfY29uZiA9IHJlbmRlcl9wYXJhbXMuY29uZjtcbiAgICAgICAgICAgIGZyYW1lX2lkID0gd2luLm5hbWUgPSByZW5kZXJfY29uZi5kZXN0O1xuICAgICAgICAgICAgcG9zX2lkID0gcmVuZGVyX2NvbmYuaWQ7XG4gICAgICAgICAgICBwb3NfbWV0YSA9IHJlbmRlcl9wYXJhbXMubWV0YTtcbiAgICAgICAgICAgIGhvc3RfY25hbWUgPSByZW5kZXJfcGFyYW1zLmhvc3Q7XG4gICAgICAgICAgICBnZW9tX2luZm8gPSByZW5kZXJfcGFyYW1zLmdlb207XG4gICAgICAgICAgICBjYW5fdXNlX2h0bWw1ID0gbGFuZy5jYm9vbChyZW5kZXJfcGFyYW1zLmh0bWw1KTtcbiAgICAgICAgICAgIHdpbl9oYXNfZm9jdXMgPSBsYW5nLmNib29sKHJlbmRlcl9wYXJhbXMuaGFzX2ZvY3VzKTtcbiAgICAgICAgICAgIHRlbXAgPSByZW5kZXJfY29uZi5iZztcbiAgICAgICAgICAgIGlmIChnZW9tX2luZm8pIHtcbiAgICAgICAgICAgICAgZ2VvbV9pbmZvID0gUGFyYW1IYXNoKF91ZShnZW9tX2luZm8pLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKCFnZW9tX2luZm8uc2VsZiB8fCAhZ2VvbV9pbmZvLmV4cCkge1xuICAgICAgICAgICAgICAgIGdlb21faW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdF9jbmFtZSkge1xuICAgICAgICAgICAgICBob3N0X2NuYW1lID0gZC5yZWZlcnJlcjtcbiAgICAgICAgICAgICAgaG9zdF9jbmFtZSA9IGhvc3RfY25hbWUuc3Vic3RyaW5nKDAsIGhvc3RfY25hbWUuaW5kZXhPZihcIi9cIiwgOSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXApIHtcbiAgICAgICAgICAgICAgX2NyZWF0ZV9zdHlsZXNoZWV0KF9jc3RyKFtcIiNzZl9ib2R5IHsgYmFja2dyb3VuZC1jb2xvcjogXCIsIHRlbXAsIFwiOyB9XCJdKSwgXCJzZl9iZ19jc3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wID0gcmVuZGVyX2NvbmYudGd0O1xuICAgICAgICAgICAgaWYgKHRlbXAgPT09IFwiX3NlbGZcIikge1xuICAgICAgICAgICAgICByZW5kZXJfY29uZi50Z3QgPSBcIl90b3BcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGVtcCkge1xuICAgICAgICAgICAgICByZW5kZXJfY29uZi50Z3QgPSBcIl90b3BcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wICE9PSBcIl90b3BcIikge1xuICAgICAgICAgICAgICB3aGlsZSAoX3B1cmdlKF90YWdzKFwiYmFzZVwiKVswXSkpIHtcbiAgICAgICAgICAgICAgICB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbCA9IGRvbS5tYWtlKFwiYmFzZVwiKTtcbiAgICAgICAgICAgIF9hdHRyKGVsLCBcInRhcmdldFwiLCB0ZW1wKTtcbiAgICAgICAgICAgIF9hcHBlbmQoX3RhZ3MoXCJoZWFkXCIpWzBdLCBlbCk7XG4gICAgICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgICBpZV9vbGRfYXR0YWNoID0gd2luW0lFX0FUVEFDSF07XG4gICAgICAgICAgICAgIGllX29sZF9kZXRhY2ggPSB3aW5bSUVfREVUQUNIXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHczY19vbGRfYXR0YWNoID0gd2luW1czQ19BVFRBQ0hdO1xuICAgICAgICAgICAgdzNjX29sZF9kZXRhY2ggPSB3aW5bVzNDX0RFVEFDSF07XG4gICAgICAgICAgICBfYXR0YWNoKHdpbiwgVU5MT0FELCBfaGFuZGxlX3VubG9hZCk7XG4gICAgICAgICAgICBfYXR0YWNoKHdpbiwgTE9BRCwgX2hhbmRsZV9sb2FkKTtcbiAgICAgICAgICAgIF9hdHRhY2god2luLCBNU0csIF9oYW5kbGVfbXNnKTtcbiAgICAgICAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzKHdpbik7XG4gICAgICAgICAgICBfc2V0dXBfd2luX2V2dF9wcm9wcyh3aW4uX19wcm90b19fKTtcbiAgICAgICAgICAgIF9zZXR1cF93aW5fZXZ0X3Byb3BzKHdpbi5XaW5kb3cgJiYgd2luLldpbmRvdy5wcm90b3R5cGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIGRldGFpbHMuc3RhdHVzID0gNTAwLjEwNTtcbiAgICAgICAgICAgIHJlbmRlcl9wYXJhbXMgPSByZW5kZXJfY29uZiA9IGd1aWQgPSBudWxsO1xuICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcl9wYXJhbXMgPSBndWlkID0gbnVsbDtcbiAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICAgIF93cmFwaUZyYW1lID0gZnVuY3Rpb24oaHRtbCwgY2JOYW1lKSB7XG4gICAgICAgIHJldHVybiBcIjxpZnJhbWUgc3R5bGU9XFxcIndpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7XFxcIiBhbGxvd3RyYW5zcGFyZW5jeT1cXFwidHJ1ZVxcXCJcXG5zY3JvbGxpbmc9XFxcIm5vXFxcIiBtYXJnaW53aWR0aD1cXFwiMFxcXCIgbWFyZ2luaGVpZ2h0PVxcXCIwXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgb25sb2FkPSdcIiArIGNiTmFtZSArIFwiKCknPlxcbjxodG1sPjxoZWFkPjxiYXNlIHRhcmdldD1cXFwiX3RvcFxcXCI+PC9oZWFkPjxib2R5IHN0eWxlPVxcXCJtYXJnaW46IDA7IHBhZGRpbmc6IDBcXFwiPlxcbjxzY3JpcHQ+XFxuICAkYWQgPSB3aW5kb3cucGFyZW50LiRhZFxcbiAgJHNmID0gd2luZG93LnBhcmVudC4kc2ZcXG48L3NjcmlwdD5cXG4gIFwiICsgaHRtbCArIFwiXFxuPC9odG1sPlxcbjwvaWZyYW1lPlwiO1xuICAgICAgfTtcbiAgICAgIG9yaWdpbmFsV3JpdGUgPSBkb2N1bWVudC53cml0ZTtcblxuICAgICAgLypcbiAgICAgIFJlbmRlciB0aGUgSFRNTCBhbmQgQ1NTIGNvbnRlbnQgcGFzc2VkIGluIHRocm91Z2ggdGhlIHdpbmRvdy5uYW1lIG1lc3NhZ2UgdmlhIGEgZG9jdW1lbnQud3JpdGVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC1fcmVuZGVyXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9yZW5kZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2JOYW1lLCBjc3MsIGUsIGh0bWwsIG90aGVyQ2FsbGJhY2tBcHBsaWVkO1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjYk5hbWUgPSBsaWIubGFuZy5ndWlkKFwibG9hZF9jYlwiKTtcbiAgICAgICAgb3RoZXJDYWxsYmFja0FwcGxpZWQgPSBmYWxzZTtcbiAgICAgICAgd2luZG93W2NiTmFtZV0gPSBmdW5jdGlvbihmcm9tRnJhbWUpIHtcbiAgICAgICAgICByZXR1cm4gKHNmLmxpYi5sYW5nLndyYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZyb21GcmFtZSB8fCAhb3RoZXJDYWxsYmFja0FwcGxpZWQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2YsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIF9oYW5kbGVfbG9hZCgpO1xuICAgICAgICAgICAgICBsb2FkZWQoKTtcbiAgICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUgPSBvcmlnaW5hbFdyaXRlO1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHdpbmRvd1tjYk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSgpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHZhciBkb21FbGVtLCBpZnJhbWUsIG9sZE9ubG9hZCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICAgICAgaWYgKCEoaGFzTG9hZGVkIHx8IG90aGVyQ2FsbGJhY2tBcHBsaWVkKSkge1xuICAgICAgICAgICAgZG9tRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBkb21FbGVtLmlubmVySFRNTCA9IFwiX1wiICsgc3RyO1xuICAgICAgICAgICAgX3JlZiA9IGRvbUVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIik7XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgaWZyYW1lID0gX3JlZltfaV07XG4gICAgICAgICAgICAgIGlmIChfY251bShfYXR0cihpZnJhbWUsIFwid2lkdGhcIiksIDApID4gMSkge1xuICAgICAgICAgICAgICAgIG90aGVyQ2FsbGJhY2tBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAob2xkT25sb2FkID0gX2F0dHIoaWZyYW1lLCBcIm9ubG9hZFwiKSkge1xuICAgICAgICAgICAgICAgICAgX2F0dHIoaWZyYW1lLCBcIm9ubG9hZFwiLCBcIlwiICsgY2JOYW1lICsgXCIodHJ1ZSk7XCIgKyBvbGRPbmxvYWQgKyBcIjtcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF9hdHRyKGlmcmFtZSwgXCJvbmxvYWRcIiwgXCJcIiArIGNiTmFtZSArIFwiKHRydWUpO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlckNhbGxiYWNrQXBwbGllZCkge1xuICAgICAgICAgICAgICBzdHIgPSBkb21FbGVtLmlubmVySFRNTC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbFdyaXRlLmNhbGwodGhpcywgc3RyKTtcbiAgICAgICAgfTtcbiAgICAgICAgaHRtbCA9IHZvaWQgMDtcbiAgICAgICAgY3NzID0gdm9pZCAwO1xuICAgICAgICBpc0FkU2hvd24gPSB0cnVlO1xuICAgICAgICBjc3MgPSBfY3N0cihyZW5kZXJfY29uZiAmJiByZW5kZXJfY29uZi5jc3MpO1xuICAgICAgICBodG1sID0gX2NzdHIocmVuZGVyX3BhcmFtcyAmJiByZW5kZXJfcGFyYW1zLmh0bWwpO1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgY3NzID0gX3VlKGNzcyk7XG4gICAgICAgICAgX2NyZWF0ZV9zdHlsZXNoZWV0KGNzcywgXCJzZl9jdXN0b21fY3NzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaHRtbCA9IF91ZShodG1sKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3JlYXR0YWNoX21lc3NhZ2luZygpO1xuICAgICAgICAgICAgX3JlcXVlc3RlZCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoaHRtbCArIFwiPHNjclwiICsgKFwiaXB0PiBcIiArIGNiTmFtZSArIFwiKCkgOzwvc2NyXCIpICsgXCJpcHQ+XCIpO1xuICAgICAgICAgICAgX2NoZWNrX29ycGhhbmVkKCk7XG4gICAgICAgICAgICBfcmVzZXRfaW5saW5lX2hhbmRsZXJzKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgX2hhbmRsZV9lcnIoXCJFcnJvciB3aGlsZSByZW5kZXJpbmcgY29udGVudDogXCIgKyBlW01TR10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENhbGwgaW50byB0aGUgZmFsbGJhY2sgeC1tc2dpbmcgbGlicmFyeSBjbGllbnQgaWYgcG9zc2libGUgd2hlbiBubyBIVE1MNSBzdHlsZSBtZXNzYWdpbmdcbiAgICAgIGV4aXN0c1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9jYWxsX2NsaWVudF9mYlxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IG1ldGhOYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIGluIHRoZSBsaWJyYXJ5IHRvIGNhbGxcbiAgICAgIEBwYXJhbSB7Kn0gW2FyZzFdIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBoYW5kIGludG8gdGhlIGxpYnJhcnlcbiAgICAgIEBwYXJhbSB7Kn0gW2FyZzJdIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBoYW5kIGludG8gdGhlIGxpYnJhcnlcbiAgICAgICAqL1xuICAgICAgX2NhbGxfY2xpZW50X2ZiID0gZnVuY3Rpb24obWV0aE5hbWUsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgdmFyIG1zZ19jbGllbnRmYjtcbiAgICAgICAgaWYgKG1zZ2NsaWVudF9mYikge1xuICAgICAgICAgIG1zZ19jbGllbnRmYiA9IGRvbS5tc2djbGllbnRfZmI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhOYW1lICYmIG1zZ2NsaWVudF9mYiAmJiBtc2djbGllbnRfZmJbbWV0aE5hbWVdICYmIG1zZ2NsaWVudF9mYlttZXRoTmFtZV0oYXJnMSwgYXJnMik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUHJvY2VzcyBhIHZhbGlkYXRlZCBtZXNzYWdlIHRvIG5vdGlmeSB0aGUgY29udGVudHMgb2YgdGhlIFNhZmVGcmFtZSBvZiBzdGF0ZSB1cGRhdGVzXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQtX3JlY2VpdmVfbXNnXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IHBhcmFtcyBUaGUgbWVzc2FnZSBwYXJhbWV0ZXIgaGFzaCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhcyBvY2N1cmVkXG4gICAgICBAcGFyYW0ge0hUTUxFdmVudH0gW2V2dF0gVGhlIHJhdyBET00gZXZlbnQgZnJvbSB0aGUgeC1kb21haW4gbWVzc2FnZVxuICAgICAgQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG1lc3NhZ2UgcmVjZWl2ZWQgY291bGQgYmUgaGFuZGxlZFxuICAgICAgICovXG4gICAgICBfcmVjZWl2ZV9tc2cgPSBmdW5jdGlvbihwYXJhbXMsIGV2dCkge1xuICAgICAgICB2YXIgY21kLCBkYXRhLCBlLCBnLCBtc2csIHJldDtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIG1zZyA9IHZvaWQgMDtcbiAgICAgICAgY21kID0gdm9pZCAwO1xuICAgICAgICBnID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICBnID0gcGFyYW1zLmdlb20gfHwgXCJcIjtcbiAgICAgICAgICBjbWQgPSBwYXJhbXMuY21kO1xuICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICBnZW9tX2luZm8gPSBQYXJhbUhhc2goX3VlKGcpLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5jbWQgPSBjbWQ7XG4gICAgICAgIGRhdGEudmFsdWUgPSBkYXRhLmluZm8gPSBwYXJhbXMgJiYgcGFyYW1zLnZhbHVlO1xuICAgICAgICBkYXRhLnJlYXNvbiA9IHBhcmFtcyAmJiBwYXJhbXMucmVhc29uO1xuICAgICAgICBpZiAoY21kID09PSBOT1RJRllfQ09MTEFQU0VEKSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNfZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICAgIGlzX2V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JjZV9jb2xsYXBzZSA9IHRydWU7XG4gICAgICAgICAgICBfY29sbGFwc2UoKTtcbiAgICAgICAgICAgIGZvcmNlX2NvbGxhcHNlID0gZmFsc2U7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9DT0xMQVBTRUQpO1xuICAgICAgICAgICAgX3NoaWZ0TWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0NPTExBUFNFKSB7XG4gICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNfZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHBlbmRpbmdfbXNnID0gbnVsbDtcbiAgICAgICAgICAgIGlzX2V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9DT0xMQVBTRUQpO1xuICAgICAgICAgICAgX3NoaWZ0TWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0VYUEFORCkge1xuICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICAgICAgICBpc19leHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9FWFBBTkQgKyBcImVkXCIpO1xuICAgICAgICAgICAgX3NoaWZ0TWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0dFT01fVVBEQVRFKSB7XG4gICAgICAgICAgX2ZpcmVfc2FuZGJveF9jYWxsYmFjayhOT1RJRllfR0VPTV9VUERBVEUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gTk9USUZZX0ZPQ1VTX0NIQU5HRSkge1xuICAgICAgICAgIGRhdGEuaW5mbyA9IGRhdGEudmFsdWUgPSBsYW5nLmNib29sKGRhdGEudmFsdWUpO1xuICAgICAgICAgIHdpbl9oYXNfZm9jdXMgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX0ZPQ1VTX0NIQU5HRSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSBOT1RJRllfUkVBRF9DT09LSUUpIHtcbiAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwZW5kaW5nX21zZykge1xuICAgICAgICAgICAgcGVuZGluZ19tc2cgPSBudWxsO1xuICAgICAgICAgICAgZGF0YSA9IHBhcmFtcyAmJiBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKE5PVElGWV9SRUFEX0NPT0tJRSwgZGF0YSk7XG4gICAgICAgICAgICBfc2hpZnRNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoW05PVElGWV9XUklURV9DT09LSUUsIE5PVElGWV9GQUlMVVJFLCBOT1RJRllfQ0xJQ0tFRCwgTk9USUZZX1ZJRVdFRCwgTk9USUZZX1VOVklFV0VELCBOT1RJRllfTE9BREVELCBOT1RJRllfUkVRVUVTVEVELCBOT1RJRllfUkVMT0FEXS5pbmRleE9mKGNtZCkgPiAtMSkge1xuICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgICBwZW5kaW5nX21zZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soY21kLCBkYXRhKTtcbiAgICAgICAgICBfc2hpZnRNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwZW5kaW5nX21zZykge1xuICAgICAgICAgICAgcGVuZGluZ19tc2cgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZmlyZV9zYW5kYm94X2NhbGxiYWNrKGNtZCwgZGF0YSk7XG4gICAgICAgICAgX3NoaWZ0TWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgICBjbWRSZXRyaWVzID0ge307XG5cbiAgICAgIC8qXG4gICAgICAgKi9cbiAgICAgIF9zaGlmdE1lc3NhZ2VRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0ID0gbWVzc2FnZVF1ZXVlLnNoaWZ0KCkpIHtcbiAgICAgICAgICByZXR1cm4gX3NlbmRfbXNnLmFwcGx5KHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBTZW5kIGEgY29tbWFuZCBtZXNzYWdlIHVwIHRvIHRoZSBTYWZlRnJhbWVzIHB1Ymxpc2hlciAvIGhvc3QgY29kZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9zZW5kX21zZ1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHBhcmFtIHtTdHJpbmd9IHN0ciBBbiBlbmNvZGVkIHN0cmluZyAocXVlcnktc3RyaW5nLyRzZi5saWIubGFuZy5QYXJhbUhhc2ggZm9ybWF0KSB0aGF0IGNvbnRhaW5zIHRoZSBjb21tYW5kIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGNtZCBUaGUgY29tbWFuZCB0byBiZSBzZW50IGl0c2VsZiAobm90ZSB0aGF0IHRoaXMgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHByZXNlbnQgaW4gdGhlIDFzdCBhcmd1bWVudClcbiAgICAgICAqL1xuICAgICAgX3NlbmRfbXNnID0gZnVuY3Rpb24oc3RyLCBjbWQpIHtcbiAgICAgICAgdmFyIGUsIGlkLCBwYXJhbXMsIHNlbnQsIHNlbnRfdGltZTtcbiAgICAgICAgaWQgPSBsYW5nLmd1aWQoXCJzZl9wbmRfY21kXCIpO1xuICAgICAgICBmcmFtZV9pZCA9IHJlbmRlcl9wYXJhbXMuZGVzdDtcbiAgICAgICAgc2VudCA9IGZhbHNlO1xuICAgICAgICBzZW50X3RpbWUgPSBsYW5nLnRpbWUoKTtcbiAgICAgICAgcGFyYW1zID0gdm9pZCAwO1xuICAgICAgICBpZiAoIXN0ciB8fCAhY21kIHx8IHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnKSB7XG4gICAgICAgICAgICBtZXNzYWdlUXVldWUucHVzaChbc3RyLCBjbWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IFBhcmFtSGFzaCh7XG4gICAgICAgICAgbXNnOiBzdHIsXG4gICAgICAgICAgaWQ6IGZyYW1lX2lkLFxuICAgICAgICAgIGd1aWQ6IGd1aWQsXG4gICAgICAgICAgY21kOiBjbWRcbiAgICAgICAgfSk7XG4gICAgICAgIHBlbmRpbmdfbXNnID0ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBzZW50OiBzZW50X3RpbWUsXG4gICAgICAgICAgY21kOiBjbWRcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdfbXNnICYmIHBlbmRpbmdfbXNnLmlkID09PSBpZCkge1xuICAgICAgICAgICAgaWYgKGNtZCA9PT0gRVhQQU5EX0NPTU1BTkQgfHwgY21kID09PSBcImV4cC1wdXNoXCIpIHtcbiAgICAgICAgICAgICAgZm9yY2VfY29sbGFwc2UgPSB0cnVlO1xuICAgICAgICAgICAgICBfY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgZm9yY2VfY29sbGFwc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX0ZBSUxVUkUgKyBcIjpcIiArIGNtZCArIFwiOnRpbWVvdXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkID0gc2VudCA9IHNlbnRfdGltZSA9IGNtZCA9IHN0ciA9IHBlbmRpbmdfbXNnID0gcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICBfc2hpZnRNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfSksIE1BWF9NU0dfV0FJVF9USU1FKTtcbiAgICAgICAgaWYgKGNhbl91c2VfaHRtbDUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9wLnBvc3RNZXNzYWdlKHBhcmFtcy50b1N0cmluZygpLCAoaG9zdF9jbmFtZSA9PT0gXCJmaWxlXCIgfHwgaG9zdF9jbmFtZSA9PT0gXCJcIiA/IFwiKlwiIDogaG9zdF9jbmFtZSkpO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgc2VudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbnQpIHtcbiAgICAgICAgICBfY2FsbF9jbGllbnRfZmIoXCJzZW5kXCIsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBGaXJlIGEgbm90aWZpY2F0aW9uIG9mZiB0byB0aGUgU2FmZUZyYW1lIGNvbnRlbnRzIGlmIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2FzIHNwZWNpZmllZFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9maXJlX3NhbmRib3hfY2FsbGJhY2tcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBtc2cgVGhlIHN0YXR1cyB1cGRhdGUgLyBtZXNzYWdlIHRvIHNlbmRcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgKi9cbiAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2sgPSBmdW5jdGlvbihtc2csIGRhdGEpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzYW5kYm94X2NiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNhbmRib3hfY2IobXNnLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBTZXQgdGhlIGFsaWdubWVudCBvZiBvdXIgaW50ZXJuYWwgRElWIHdoZW5ldmVyIGV4cGFuc2lvbiBvY2N1cnMgdW5pLWRpcmVjdGlvbmFseVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LV9zZXRfYWxpZ25tZW50XG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IHhuIFdoZXRoZXIgb3Igbm90IGhvcml6b250YWwgYXhpcyBpcyBncm93aW5nIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0ICh4biA9PSB0cnVlID09IGxlZnQpXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IHluIFdoZXRoZXIgb3Igbm90IHZlcnRpY2FsIGF4aXMgaXMgZ3Jvd2luZyB0byB0aGUgdG9wIG9yIGJvdHRvbSAoeW4gPT0gdHJ1ZSA9PSB0b3ApXG4gICAgICAgKi9cbiAgICAgIF9zZXRfYWxpZ25tZW50ID0gZnVuY3Rpb24oeG4sIHluKSB7XG4gICAgICAgIHZhciBmY0RpdiwgZmNEaXZTdHlsZSwgcHJlVHh0LCB4VHh0LCB5VHh0O1xuICAgICAgICBmY0RpdiA9IF9lbHQoXCJzZl9hbGlnblwiKTtcbiAgICAgICAgZmNEaXZTdHlsZSA9IGZjRGl2LnN0eWxlO1xuICAgICAgICB4VHh0ID0gdm9pZCAwO1xuICAgICAgICB5VHh0ID0gdm9pZCAwO1xuICAgICAgICBwcmVUeHQgPSBcInBvc2l0aW9uOmFic29sdXRlO1wiO1xuICAgICAgICBpZiAoeG4pIHtcbiAgICAgICAgICB4VHh0ID0gXCJyaWdodDowcHg7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeFR4dCA9IFwibGVmdDowcHg7XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHluKSB7XG4gICAgICAgICAgeVR4dCA9IFwiYm90dG9tOjBweDtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5VHh0ID0gXCJ0b3A6MHB4O1wiO1xuICAgICAgICB9XG4gICAgICAgIGZjRGl2U3R5bGUuY3NzVGV4dCA9IHByZVR4dCArIHhUeHQgKyB5VHh0O1xuICAgICAgICBmY0RpdiA9IGZjRGl2U3R5bGUgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEludGVybmFsIGZ1bmN0aW9uIGZvciBjb2xsYXBzaW5nIHRoZSBTYWZlRnJhbWUsIHdoaWNoIGNoZWNrcyB0aGF0IHRoZXJlIGlzXG4gICAgICBub3Qgc29tZSBvdGhlciBwZW5kaW5nIHN0YXRlIHdoaWNoIG1heSBnZXQgaW4gdGhlIHdheVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0Ll9jb2xsYXBzZVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgICovXG4gICAgICBfY29sbGFwc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFmb3JjZV9jb2xsYXBzZSAmJiAoIWlzX3JlZ2lzdGVyZWQgfHwgIWlzX2V4cGFuZGVkIHx8IHBlbmRpbmdfbXNnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0X2FsaWdubWVudCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgX3JlYXR0YWNoX21lc3NhZ2luZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaWVfb2xkX2F0dGFjaCkge1xuICAgICAgICAgIGllX29sZF9kZXRhY2goT05NU0csIF9oYW5kbGVfbXNnKTtcbiAgICAgICAgICByZXR1cm4gaWVfb2xkX2F0dGFjaChPTk1TRywgX2hhbmRsZV9tc2cpO1xuICAgICAgICB9IGVsc2UgaWYgKHczY19vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgdzNjX29sZF9kZXRhY2goTVNHLCBfaGFuZGxlX21zZyk7XG4gICAgICAgICAgcmV0dXJuIHczY19vbGRfYXR0YWNoKE1TRywgX2hhbmRsZV9tc2cpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSW50aWFsaXplIHRoZSBTYWZlRnJhbWUgZXh0ZXJuYWwgdmVuZG9yL2NsaWVudCBBUEksIHNvIHRoYXQgb3RoZXIgZmVhdHVyZXMgbWF5IGJlIHVzZWRcbiAgICAgIFRoaXMgbWV0aG9kIE1VU1QgYmUgY2FsbGVkIHByaW9yIHRvIHVzaW5nIGFueSBvdGhlciByaWNoLW1lZGlhIGZ1bmN0aW9uYWxpdHkgKGxpa2UgZXhwYW5zaW9uKS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5yZWdpc3RlclxuICAgICAgQHB1YmxpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0ge051bWJlcn0gaW5pdFdpZHRoIFRoZSBpbml0aWFsIHdpZHRoIChpbiBwaXhlbHMpIGV4cGVjdGVkIG9mIHRoZSBjb250ZW50IHdpdGhpbiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lclxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGluaXRIZWlnaHQgVGhlIGluaXRpYWwgaGVpZ2h0IChpbiBwaXhlbHMpIGV4cGVjdGVkIG9mIHRoZSBjb250ZW50IHdpdGhpbiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lclxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW25vdGlmeV0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNvbnRlbnQgY2FuIHNwZWNpZnkgdG8gYmUgbm90aWZpZWQgb2Ygc3RhdHVzIHVwZGF0ZXNcbiAgICAgICAqL1xuICAgICAgcmVnaXN0ZXIgPSBmdW5jdGlvbihpbml0V2lkdGgsIGluaXRIZWlnaHQsIG5vdGlmeSkge1xuICAgICAgICBpZiAoaXNfcmVnaXN0ZXJlZCB8fCAhZ3VpZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbml0V2lkdGggPSBfY251bShpbml0V2lkdGgsIDAsIDApO1xuICAgICAgICBpbml0SGVpZ2h0ID0gX2NudW0oaW5pdEhlaWdodCwgMCwgMCk7XG4gICAgICAgIGluaXRfd2lkdGggPSBpbml0V2lkdGg7XG4gICAgICAgIGluaXRfaGVpZ2h0ID0gaW5pdEhlaWdodDtcbiAgICAgICAgaXNfcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIGlmIChsYW5nLmNhbGxhYmxlKG5vdGlmeSkpIHtcbiAgICAgICAgICBzYW5kYm94X2NiID0gbm90aWZ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhbmRib3hfY2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTWFrZSBhIHJlcXVlc3QgdG8gZXhwYW5kIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIHRvIGEgY2VydGFpbiBzaXplLiBOb3RlIHRoYXQgeW91IG1heSBvbmx5IGNhbGwgJHNmLmV4dC5leHBhbmRcbiAgICAgIHRvIGV4cGFuZCB0byB0aGUgbGFyZ2VzdCBzaXplIG5lZWRlZCwgZm9sbG93ZWQgYnkgY2FsbGluZyBjb2xsYXBzZSAoYW5kIHRoZW4gcmVwZWF0IHRoZSBzYW1lIHByb2Nlc3MgaWYgbmVlZGVkKS5cbiAgICAgIFR3ZWVuaW5nIG9yIGFuaW1hdGlvbiBkb25lLCBzaG91bGQgYmUgcmVzZXJ2ZWQgZm9yIHlvdXIgb3duIGNvbnRlbnQsIGFuZCB5b3UgY2Fubm90IG1ha2UgbXVsdGlwbGUgY2FsbHMgdG8gZXhwYW5kXG4gICAgICB3aXRob3V0IGEgY29ycmVzcG9uZGluZyBjb2xsYXBzZS5cbiAgICAgIFxuICAgICAgTm90ZSB0aGF0IHdoZW4gc2V0dGluZyB0LCBsLCBiLCBhbmQgciBvZmZzZXQgdmFsdWVzLCBleHBhbnNpb24gd2lsbCBub3QgY2F1c2UgdGhlIGNvbnRlbnQgaW5zaWRlIHRoZSBTYWZlRnJhbWVcbiAgICAgIHRvIGhvbGQgaXQncyBjdXJyZW50IGFsaWdubWVudCwgd2hlcmVhcyB1c2luZyBkeC9keSBvciBvbmx5IHNldHRpbmcgcGFydGlhbCBvZmZmc2V0cyAoZS5nIHt0OjEwMCxsOjEwMH0gPT0gIGR4Oi0xMDAsZHk6LTEwMCkgd2lsbCBjYXVzZSBleHBhbnNpb24gdG9cbiAgICAgIGhvbGQgaXQncyBjdXJyZW50IGFsaWdubWVudC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5leHBhbmRcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkZWx0YVhvckRlc2MgSWYgYSBudW1iZXIgaXMgc3BlY2lmZWQsIFNhZmVGcmFtZSB3aWxsIGdyb3cgaW4gc2l6ZSBieSB0aGlzIGFtb3VudCBpbiBwaXhlbHMgYWxvbmcgdGhlIGhvcml6b250YWwgYXhpcy4gU3BlY2lmaXkgYSBuZWdhdGl2ZSB2YWx1ZSB0byBncm93IHRvIHRoZSBsZWZ0LCBhbmQgYSBwb3N0aXZlIHZhbHVlIHRvIGdyb3cgdG8gdGhlIHJpZ2h0LiA8YnIgLz5cbiAgICAgIElmIGFuIG9iamVjdCBpcyBzcGVjaWZpZWQsIGl0IHNob3VsZCBjb250YWluIFwidFwiLFwibFwiLFwiclwiLFwiYlwiIHByb3BlcnRpZXMgKHRvcCxsZWZ0LGJvdHRvbSxyaWdodCkgZm9yIHRoZSBhbW91bnQgaW4gcGl4ZWxzIHRvIGdyb3cgdGhlIGNvbnRhaW5lciBpbiBlYWNoIGRpbWVuc2lvblxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWG9yRGVzYy50IFNwZWNpZmllcyB0byBzaGlmdCB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGJ5IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHNwZWNpZmllZCwgcmVsYXRpdmUgdG8gb3JpZ2luYWwgbG9jYXRpb24gKG5lZ2F0aXZlIHZhbHVlcyBub3QgYWxsb3dlZCkuXG4gICAgICBAcGFyYW0ge051bWJlcn0gZGVsdGFYb3JEZXNjLmwgU3BlY2lmaWVzIHRvIHNoaWZ0IHRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGJ5IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHNwZWNpZmllZCwgcmVsYXRpdmUgdG8gb3JpZ2luYWwgbG9jYXRpb24gKG5lZ2F0aXZlIHZhbHVlcyBub3QgYWxsb3dlZCkuXG4gICAgICBAcGFyYW0ge051bWJlcn0gZGVsdGFYb3JEZXNjLmIgU3BlY2lmaWVzIHRvIHNoaWZ0IHRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgYnkgdGhlIG51bWJlciBvZiBwaXhlbHMgc3BlY2lmaWVkLCByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgbG9jYXRpb24gKG5lZ2F0aXZlIHZhbHVlcyBub3QgYWxsb3dlZCkuXG4gICAgICBAcGFyYW0ge051bWJlcn0gZGVsdGFYb3JEZXNjLnIgU3BlY2lmaWVzIHRvIHNoaWZ0IHRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGJ5IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHNwZWNpZmllZCwgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIChuZWdhdGl2ZSB2YWx1ZXMgbm90IGFsbG93ZWQpLlxuICAgICAgQHBhcmFtIHtCb29sZWFufWRlbHRhWG9yRGVzYy5wdXNoICBXaGVuIGV4cGFuZGluZywgcHVzaCBvdGhlciBwYWdlIGNvbnRlbnQgcmF0aGVyIHRoYW4gZG9pbmcgYW4gb3ZlcmxheS4gIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gdHJ1ZSB3aWxsIG9ubHkgd29yayBpZiB0aGUgcHVibGlzaGVyIC8gaG9zdCBleHBsaWNpdGx5IGFsbG93cyBwdXNoIGV4cGFuc2lvblxuICAgICAgQ2hlY2sgJHNmLmV4dC5zdXBwb3J0cyhcImV4cC1wdXNoXCIpLCBhaGVhZCBvZiB0aW1lIHRvIHZlcmlmeVxuICAgICAgXG4gICAgICBAcGFyYW0ge051bWJlcn0gZGVsdGFZIElmIGEgbnVtYmVyIGlzIHNwZWNpZmVkLCBTYWZlRnJhbWUgd2lsbCBncm93IGluIHNpemUgYnkgdGhpcyBhbW91bnQgaW4gcGl4ZWxzIGFsb25nIHRoZSB2ZXJ0aWNhbCBheGlzLiBTcGVjaWZpeSBhIG5lZ2F0aXZlIHZhbHVlIHRvIGdyb3cgdG8gdGhlIHRvcCwgYW5kIGEgcG9zdGl2ZSB2YWx1ZSB0byBncm93IHRvIHRoZSBib3R0b20uIDxiciAvPlxuICAgICAgTm90ZSB0aGF0IHRoaXMgdmFsdWUgaXMgaWdub3JlZCBpZiBkZWx0YVhvckRlc2MgaXMgcGFzc2VkIGluIGFzIGFuIG9iamVjdC5cbiAgICAgIFxuICAgICAgQHBhcmFtIHtCb29sZWFufSBwdXNoIFdoZW4gZXhwYW5kaW5nLCBwdXNoIG90aGVyIHBhZ2UgY29udGVudCByYXRoZXIgdGhhbiBkb2luZyBhbiBvdmVybGF5LiAgTm90ZSB0aGF0IHNldHRpbmcgdGhpcyB2YWx1ZSB0byB0cnVlIHdpbGwgb25seSB3b3JrIGlmIHRoZSBwdWJsaXNoZXIgLyBob3N0IGV4cGxpY2l0bHkgYWxsb3dzIHB1c2ggZXhwYW5zaW9uXG4gICAgICBDaGVjayAkc2YuZXh0LnN1cHBvcnRzKFwiZXhwLXB1c2hcIiksIGFoZWFkIG9mIHRpbWUgdG8gdmVyaWZ5XG4gICAgICBcbiAgICAgIFxuICAgICAgQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiB0aGUgcmVxdWVzdCB0byBleHBhbmQgdGhlIGNvbnRhaW5lciB3YXMgc2VudC4gVGhpcyBkb2VzIG5vdCBtZWFuIHRoYXQgZXhwYW5zaW9uIGlzIGNvbXBsZXRlIGFzIGV4cGFuc2lvbiBpcyBhbiBhc3luY2hyb25vdXMgcHJvY2Vzcy4gUGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvICRzZi5leHQucmVnaXN0ZXIgdG8gZ2V0IHN0YXR1cyB1cGRhdGVzLlxuICAgICAgICovXG4gICAgICBleHBhbmQgPSBmdW5jdGlvbihkZWx0YVhvckRlc2MsIGRlbHRhWSwgcCkge1xuICAgICAgICB2YXIgYWxpZ25fYnVmZmVyLCBhbGlnbl9lbCwgYWxpZ25fZWxfc3QsIGIsIGNtZF9ubSwgY21kX3N0ciwgZG9BbGlnbiwgZHgsIGR5LCBsLCByLCB0LCB4biwgeW47XG4gICAgICAgIHhuID0gZmFsc2U7XG4gICAgICAgIHluID0gZmFsc2U7XG4gICAgICAgIGRvQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgY21kX25tID0gKHAgPyBcImV4cC1wdXNoXCIgOiBFWFBBTkRfQ09NTUFORCk7XG4gICAgICAgIGNtZF9zdHIgPSBbXCJjbWQ9XCIsIGNtZF9ubSwgXCImcG9zPVwiLCBwb3NfaWRdO1xuICAgICAgICBkeCA9IDA7XG4gICAgICAgIGR5ID0gMDtcbiAgICAgICAgciA9IHZvaWQgMDtcbiAgICAgICAgYiA9IHZvaWQgMDtcbiAgICAgICAgdCA9IHZvaWQgMDtcbiAgICAgICAgbCA9IHZvaWQgMDtcbiAgICAgICAgYWxpZ25fZWwgPSB2b2lkIDA7XG4gICAgICAgIGFsaWduX2VsX3N0ID0gdm9pZCAwO1xuICAgICAgICBhbGlnbl9idWZmZXIgPSB2b2lkIDA7XG4gICAgICAgIGlmICghaXNfcmVnaXN0ZXJlZCB8fCBwZW5kaW5nX21zZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCAmJiAhc3VwcG9ydHMoXCJleHAtcHVzaFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGFYb3JEZXNjICYmIHR5cGVvZiBkZWx0YVhvckRlc2MgPT09IE9CSikge1xuICAgICAgICAgIHIgPSBfY251bShkZWx0YVhvckRlc2MuciwgMCwgMCk7XG4gICAgICAgICAgYiA9IF9jbnVtKGRlbHRhWG9yRGVzYy5iLCAwLCAwKTtcbiAgICAgICAgICB0ID0gX2NudW0oZGVsdGFYb3JEZXNjLnQsIDAsIDApO1xuICAgICAgICAgIGwgPSBfY251bShkZWx0YVhvckRlc2MubCwgMCwgMCk7XG4gICAgICAgICAgaWYgKGRlbHRhWG9yRGVzYy5wdXNoKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRzKFwiZXhwLXB1c2hcIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kX25tID0gXCJleHAtcHVzaFwiO1xuICAgICAgICAgICAgY21kX3N0clsxXSA9IGNtZF9ubTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyICYmIGwpIHtcbiAgICAgICAgICAgIHhuID0gdHJ1ZTtcbiAgICAgICAgICAgIGR4ID0gLTEgKiBsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiAhbCkge1xuICAgICAgICAgICAgZHggPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWIgJiYgdCkge1xuICAgICAgICAgICAgeW4gPSB0cnVlO1xuICAgICAgICAgICAgZHkgPSAtMSAqIHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiICYmICF0KSB7XG4gICAgICAgICAgICBkeSA9IGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgodCAmJiBiKSB8fCAobCAmJiByKSkge1xuICAgICAgICAgICAgZG9BbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb0FsaWduID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvQWxpZ24pIHtcbiAgICAgICAgICAgIF9zZXRfYWxpZ25tZW50KHhuLCB5bik7XG4gICAgICAgICAgICBjbWRfc3RyLnB1c2goXCImZHg9XCIsIGR4LCBcIiZkeT1cIiwgZHkpO1xuICAgICAgICAgICAgX3NlbmRfbXNnKF9jc3RyKGNtZF9zdHIpLCBjbWRfbm0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGlnbl9lbCA9IF9lbHQoXCJzZl9hbGlnblwiKTtcbiAgICAgICAgICAgIGFsaWduX2VsX3N0ID0gYWxpZ25fZWwgJiYgYWxpZ25fZWwuc3R5bGU7XG4gICAgICAgICAgICBhbGlnbl9idWZmZXIgPSBbXCJwb3NpdGlvbjphYnNvbHV0ZTtcIl07XG4gICAgICAgICAgICBpZiAodCAmJiBiKSB7XG4gICAgICAgICAgICAgIGFsaWduX2J1ZmZlci5wdXNoKFwidG9wOlwiLCB0LCBcInB4O1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodCkge1xuICAgICAgICAgICAgICBhbGlnbl9idWZmZXIucHVzaChcImJvdHRvbTowcHg7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICBhbGlnbl9idWZmZXIucHVzaChcInRvcDowcHg7XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobCAmJiByKSB7XG4gICAgICAgICAgICAgIGFsaWduX2J1ZmZlci5wdXNoKFwibGVmdDpcIiwgbCwgXCJweDtcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGwpIHtcbiAgICAgICAgICAgICAgYWxpZ25fYnVmZmVyLnB1c2goXCJyaWdodDowcHg7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICBhbGlnbl9idWZmZXIucHVzaChcImxlZnQ6MHB4O1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduX2VsX3N0KSB7XG4gICAgICAgICAgICAgIGFsaWduX2VsX3N0LmNzc1RleHQgPSBfY3N0cihhbGlnbl9idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kX3N0ci5wdXNoKFwiJmV4cF9vYmo9XCIsIGVzY2FwZShQYXJhbUhhc2goZGVsdGFYb3JEZXNjKSkpO1xuICAgICAgICAgICAgX3NlbmRfbXNnKF9jc3RyKGNtZF9zdHIpLCBjbWRfbm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVhvckRlc2MgPSBfY251bShkZWx0YVhvckRlc2MsIDApO1xuICAgICAgICAgIGRlbHRhWSA9IF9jbnVtKGRlbHRhWSwgMCk7XG4gICAgICAgICAgaWYgKGRlbHRhWG9yRGVzYyA8PSAwICYmIGRlbHRhWSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHhuID0gZGVsdGFYb3JEZXNjIDw9IDA7XG4gICAgICAgICAgeW4gPSBkZWx0YVkgPD0gMDtcbiAgICAgICAgICBfc2V0X2FsaWdubWVudCh4biwgeW4pO1xuICAgICAgICAgIGNtZF9zdHIucHVzaChcIiZkeD1cIiwgZGVsdGFYb3JEZXNjLCBcIiZkeT1cIiwgZGVsdGFZKTtcbiAgICAgICAgICBfc2VuZF9tc2coX2NzdHIoY21kX3N0ciksIGNtZF9ubSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ29sbGFwc2UgdGhlIFNhZmVGcmFtZSBjb250YWluZXIgYWZ0ZXIgaGF2aW5nIGNhbGxlZCB0byBleHBhbmQuIElmIG5vIHByZXZpb3VzIGNhbGwgdG8gZXhwYW5kIGhhcyBiZWVuIG1hZGUsIHRoaXMgY2FsbCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5leHQuY29sbGFwc2VcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBjb2xsYXBzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2NvbGxhcHNlKCkpIHtcbiAgICAgICAgICBfc2VuZF9tc2coX2NzdHIoW1wiY21kPVwiLCBDT0xMQVBTRV9DT01NQU5ELCBcIiZwb3M9XCIsIHBvc19pZF0pLCBDT0xMQVBTRV9DT01NQU5EKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VuZF9jbWQoTk9USUZZX0NMSUNLRUQpO1xuICAgICAgfTtcbiAgICAgIHZpZXdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlbmRfY21kKE5PVElGWV9WSUVXRUQpO1xuICAgICAgfTtcbiAgICAgIGxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlbmRfY21kKE5PVElGWV9MT0FERUQpO1xuICAgICAgfTtcbiAgICAgIHVudmlld2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VuZF9jbWQoTk9USUZZX1VOVklFV0VEKTtcbiAgICAgIH07XG4gICAgICByZWxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kX2NtZChOT1RJRllfUkVMT0FEKTtcbiAgICAgIH07XG4gICAgICBfcmVxdWVzdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9maXJlX3NhbmRib3hfY2FsbGJhY2soTk9USUZZX1JFUVVFU1RFRCk7XG4gICAgICAgIHJldHVybiBfc2VuZF9jbWQoTk9USUZZX1JFUVVFU1RFRCk7XG4gICAgICB9O1xuICAgICAgX3NlbmRfY21kID0gZnVuY3Rpb24oY21kKSB7XG4gICAgICAgIHJldHVybiBfc2VuZF9tc2coX2NzdHIoW1wiY21kPVwiLCBjbWQsIFwiJnBvcz1cIiwgcG9zX2lkXSksIGNtZCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJuIGdlb21ldHJpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciBhbmQgaXQncyBzdGF0dXMgd2l0aGluIGEgcGFnZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0Lmdlb21cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHJldHVybiB7T2JqZWN0fSBnZW9tX2luZm9cbiAgICAgICAqL1xuICAgICAgZ2VvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2VvbV9pbmZvO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybiBtZXRhLWRhdGEgaW5mb3JtYXRpb24gdGhhdCBtYXkgaGF2ZSBiZWVuIHNwZWNpZmllZCBieSB0aGUgcHVibGlzaGVyIC8gaG9zdC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5tZXRhXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUga2V5IG5hbWUgb2YgdGhlIG1ldGEtZGF0YSB2YWx1ZSB0byBiZSByZXRyaWV2ZWRcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbb3duZXJfa2V5XSB0aGUgc3VwZXIga2V5IG5hbWUgb2YgdGhlIGRhdGEgdG8gYmUgcmV0cmlldmVkXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2YWx1ZSBvZiBzb21lIG1ldGEtZGF0YSB0aGF0IG1heSBoYXZlIGJlZW4gc3BlY2lmaWVkIGJ5IHRoZSBwdWJsaXNoZXIgLyBob3N0IG9yIFwiXCIuXG4gICAgICAgKi9cbiAgICAgIG1ldGEgPSBmdW5jdGlvbihwcm9wTmFtZSwgb3duZXJfa2V5KSB7XG4gICAgICAgIHZhciByZXQsIHNoYXJlZDtcbiAgICAgICAgcmV0ID0gXCJcIjtcbiAgICAgICAgc2hhcmVkID0gdm9pZCAwO1xuICAgICAgICBpZiAocG9zX21ldGEpIHtcbiAgICAgICAgICBpZiAob3duZXJfa2V5KSB7XG4gICAgICAgICAgICBpZiAob3duZXJfa2V5IGluIHBvc19tZXRhKSB7XG4gICAgICAgICAgICAgIHJldCA9IF9jc3RyKHBvc19tZXRhW293bmVyX2tleV1bcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwb3NfbWV0YS5ub25fc2hhcmVkICYmIG93bmVyX2tleSBpbiBwb3NfbWV0YS5ub25fc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gX2NzdHIocG9zX21ldGEubm9uX3NoYXJlZFtvd25lcl9rZXldW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcmVkID0gcG9zX21ldGEuc2hhcmVkO1xuICAgICAgICAgICAgaWYgKHNoYXJlZCAmJiB0eXBlb2Ygc2hhcmVkID09PSBPQkopIHtcbiAgICAgICAgICAgICAgcmV0ID0gX2NzdHIoc2hhcmVkW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgICAgZGVsZXRlTWV0YSA9IGZ1bmN0aW9uKHByb3BOYW1lLCBvd25lcl9rZXkpIHtcbiAgICAgICAgdmFyIHNoYXJlZDtcbiAgICAgICAgc2hhcmVkID0gdm9pZCAwO1xuICAgICAgICBpZiAocG9zX21ldGEpIHtcbiAgICAgICAgICBpZiAob3duZXJfa2V5KSB7XG4gICAgICAgICAgICBpZiAob3duZXJfa2V5IGluIHBvc19tZXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgcG9zX21ldGFbb3duZXJfa2V5XVtwcm9wTmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocG9zX21ldGEubm9uX3NoYXJlZCAmJiBvd25lcl9rZXkgaW4gcG9zX21ldGEubm9uX3NoYXJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWxldGUgcG9zX21ldGEubm9uX3NoYXJlZFtvd25lcl9rZXldW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFyZWQgPSBwb3NfbWV0YS5zaGFyZWQ7XG4gICAgICAgICAgICBpZiAoc2hhcmVkICYmIHR5cGVvZiBzaGFyZWQgPT09IE9CSikge1xuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHNoYXJlZFtwcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgU2FmZUZyYW1lIGNvbnRhaW5lciwgaW4gY2FzZXMgd2hlcmVcbiAgICAgIGEgY29tbWFuZCBtYXkgYmUgcGVuZGluZy4gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIChcIlwiKSBjb250YWluZXIgaXMgaWRsZS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5zdGF0dXNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHJldHVybiB7U3RyaW5nfSBvZiBhbnkgcGVuZGluZyBzdGF0dXMsIG90aGVyd2lzZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgKi9cbiAgICAgIHN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocGVuZGluZ19tc2cpIHtcbiAgICAgICAgICBpZiAocGVuZGluZ19tc2cuY21kID09PSBFWFBBTkRfQ09NTUFORCkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRVU19FWFBBTkRJTkc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nX21zZy5jbWQgPT09IENPTExBUFNFX0NPTU1BTkQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNUQVRVUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX2V4cGFuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRVU19FWFBBTkRFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1RBVFVTX0NPTExBUFNFRDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlcXVlc3RzIHRoZSBob3N0IHJlYWQgb3Igd3JpdGUgYSBjb29raWUgdG8gdGhlIGhvc3QgZG9tYWluLlxuICAgICAgVGhlIGhvc3QgZG9tYWluIG11c3QgZ3JhbnQgcGVybWlzc2lvbiBmb3IgdGhlIGNvb2tpZSB0byBiZSB3cml0dGVuLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0LmNvb2tpZVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2Nvb2tpZU5hbWVdIFRoZSBuYW1lIG9mIHRoZSBjb29raWUgdG8gc2V0IG9yIHJlYWRcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBbY29va2llRGF0YV0gQW4gb2JqZWN0IGhhc2ggY29udGFpbmluZyB0aGUgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIGV4cGlyZXNcbiAgICAgIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgY29va2llID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llRGF0YSkge1xuICAgICAgICB2YXIgY21kX25tLCBjbWRfc3RyLCBpc1JlYWQ7XG4gICAgICAgIGlzUmVhZCA9ICEoY29va2llRGF0YSAhPSBudWxsKTtcbiAgICAgICAgY21kX25tID0gKGlzUmVhZCA/IFwicmVhZC1jb29raWVcIiA6IFwid3JpdGUtY29va2llXCIpO1xuICAgICAgICBjbWRfc3RyID0gW1wiY21kPVwiLCBjbWRfbm0sIFwiJnBvcz1cIiwgcG9zX2lkLCBcIiZjb29raWU9XCIsIGNvb2tpZU5hbWVdO1xuICAgICAgICBpZiAoIWlzUmVhZCkge1xuICAgICAgICAgIGNtZF9zdHIucHVzaChcIiZ2YWx1ZT1cIik7XG4gICAgICAgICAgY21kX3N0ci5wdXNoKGNvb2tpZURhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIF9zZW5kX21zZyhfY3N0cihjbWRfc3RyKSwgY21kX25tKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBTZW5kIGEgbWVzc2FnZSB0byB0aGUgaG9zdFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZXh0Lm1lc3NhZ2VcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBtZXNzYWdlID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICBfc2VuZF9tc2coX2NzdHIoW1wiY21kPVwiLCBcIm1zZ1wiLCBcIiZwb3M9XCIsIHBvc19pZCwgXCImbXNnPVwiLCBjb250ZW50XSksIFwibXNnXCIpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybiB0aGUgcGVyY2VudGFnZSB0aGF0IHRoZSBTYWZlRnJhbWUgY29udGFpbmVyIGlzIHZpZXdhYmxlIHdpdGhpbiB0aGUgYnJvd3NlciB3aW5kb3dcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5pblZpZXdQZXJjZW50YWdlXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgaW5WaWV3UGVyY2VudGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXYsIHR2O1xuICAgICAgICBpdiA9IF9jbnVtKGdlb21faW5mbyAmJiBnZW9tX2luZm8uc2VsZiAmJiBnZW9tX2luZm8uc2VsZi5pdiwgLTEsIDApO1xuICAgICAgICB0diA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGl2ID49IDApIHtcbiAgICAgICAgICB0diA9IE1hdGguZmxvb3IoaXYgKiAxMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0djtcbiAgICAgIH07XG4gICAgICB3aW5IYXNGb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luX2hhc19mb2N1cztcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm4gd2hldGhlciBvciBub3QgYSBwYXJ0aWN1bGFyIGZlYXR1cmUgaXMgc3VwcG9ydGVkLCBvciBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAga2V5L3ZhbHVlIHBhaXJzIGRlbm90aW5nIGFsbCBmZWF0dXJlcyBhbmQgd2hldGhlciBvciBub3QgdGhleSBhcmUgc3VwcG9ydGVkXG4gICAgICBcbiAgICAgIEJ5IGRlZmF1bHQgU2FmZUZyYW1lcyB2ZXJzaW9uIDEgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBmZWF0dXJlOlxuICAgICAgXG4gICAgICBcImV4cC1vdnJcIjogRXhwYW5zaW9uIG9mIHRoZSBjb250YWluZXIgYnkgb3ZlcmxheWluZyBvbiB0b3Agb2Ygb3RoZXIgY29udGVudFxuICAgICAgXG4gICAgICBMYXRlciBpbiBvdGhlciB2ZXJzaW9ucyB0aGVyZSBhcmUgZXhwZXh0ZWQgdG8gYmUgbW9yZSBmZWF0dXJlIHdpdGggdGhlaXIgb3duXG4gICAgICBzdHJpbmcgbmFtZSwgdGhhdCBjYW4gYmUgY2hlY2tlZCBieSB0aGUgY29udGVudCBpbiB0aGUgU2FmZUZyYW1lLCBzbyB0aGF0XG4gICAgICBpdCBrbm93cyB3aGF0IHRoaW5ncyBjYW4gYmUgZG9uZS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmV4dC5zdXBwb3J0c1xuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2tleV0gSWYgc3BlY2lmZWQsIGNoZWNrcyB0byBzZWUgaWYgdGhhdCBzcGVjaWZpYyBmZWF0dXJlIGhhcyBiZWVuIGVuYWJsZWRcbiAgICAgIEByZXR1cm4ge0Jvb2xlYW58T2JqZWN0fVxuICAgICAgICovXG4gICAgICBzdXBwb3J0cyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgY29uZiwgc3VwO1xuICAgICAgICBjb25mID0gcmVuZGVyX3BhcmFtcy5jb25mO1xuICAgICAgICBzdXAgPSAoY29uZiAmJiBjb25mLnN1cHBvcnRzKSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHN1cCkge1xuICAgICAgICAgIGtleSA9IF9jc3RyKGtleSk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgc3VwID0gc3VwW2tleV0gfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3VwID09PSBcIjBcIikge1xuICAgICAgICAgICAgICBzdXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwID0gbGFuZy5taXgoe30sIHN1cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXA7XG4gICAgICB9O1xuICAgICAgcmVuZGVyID0gZnVuY3Rpb24oc2hvd0FkLCBjYikge1xuICAgICAgICB2YXIgZXJyX2luZm87XG4gICAgICAgIGVycl9pbmZvID0ge307XG4gICAgICAgIGlmIChfY29uc3RydWN0aW9uKGVycl9pbmZvKSkge1xuICAgICAgICAgIGlmIChzaG93QWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVuZGVyKGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzaG93QWQgPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAoIWlzQWRTaG93bikge1xuICAgICAgICAgIHJldHVybiBfcmVuZGVyKGNiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGFkU2hvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzQWRTaG93bjtcbiAgICAgIH07XG4gICAgICBsYW5nLm1peChzZi5leHQsIHtcbiAgICAgICAgcmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICAgICAgICBleHBhbmQ6IGV4cGFuZCxcbiAgICAgICAgY29sbGFwc2U6IGNvbGxhcHNlLFxuICAgICAgICBnZW9tOiBnZW9tLFxuICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICBkZWxldGVNZXRhOiBkZWxldGVNZXRhLFxuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgc3VwcG9ydHM6IHN1cHBvcnRzLFxuICAgICAgICBjb29raWU6IGNvb2tpZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgaW5WaWV3UGVyY2VudGFnZTogaW5WaWV3UGVyY2VudGFnZSxcbiAgICAgICAgd2luSGFzRm9jdXM6IHdpbkhhc0ZvY3VzLFxuICAgICAgICBjbGljazogY2xpY2ssXG4gICAgICAgIHZpZXdlZDogdmlld2VkLFxuICAgICAgICB1bnZpZXdlZDogdW52aWV3ZWQsXG4gICAgICAgIHNob3dBZDogc2hvd0FkLFxuICAgICAgICBhZFNob3duOiBhZFNob3duLFxuICAgICAgICByZWxvYWQ6IHJlbG9hZFxuICAgICAgfSk7XG4gICAgICBpZiAoIWlzRXh0ZXJuYWwpIHtcbiAgICAgICAgd2luZG93LiRzZiA9IHNmO1xuICAgICAgICByZW5kZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy4kc2YgPSBzZjtcbiAgICAgICAgc2YuZXh0LnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZjtcbiAgICB9KSh3aW5kb3csIHNmKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSwgZW52LCBsYW5nLCBsb2dnZXI7XG5cbiAgbGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpO1xuXG4gIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxuICBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKGxhbmcsIGVudiwgZG9tLCBsb2dnZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyOiBcIjEtMS0wXCIsXG4gICAgICBzcGVjVmVyc2lvbjogXCIxLjFcIixcbiAgICAgIGxpYjoge1xuICAgICAgICBsYW5nOiBsYW5nLFxuICAgICAgICBkb206IGRvbSxcbiAgICAgICAgbG9nZ2VyOiBsb2dnZXJcbiAgICAgIH0sXG4gICAgICBlbnY6IGVudixcbiAgICAgIGhvc3Q6IHt9LFxuICAgICAgZXh0OiB7fSxcbiAgICAgIGluZm86IHtcbiAgICAgICAgZXJyczogW10sXG4gICAgICAgIGxpc3Q6IFtdXG4gICAgICB9XG4gICAgfTtcbiAgfSkobGFuZywgZW52LCBkb20sIGxvZ2dlcik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBlbnYsIGxhbmc7XG5cbiAgbGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpO1xuXG4gIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93LCBsYW5nLCBlbnYpIHtcbiAgICB2YXIgQkxBTktfVVJMLCBFVlRfQ05DTF9NRVRIT0RTLCBHQywgSUVfR0NfSU5URVJWQUwsIElGUkFNRSwgYXBwZW5kLCBhdHRhY2gsIGF0dHIsIGNsb25lX2lmcmFtZSwgY3NzLCBkZXRhY2gsIGRvYywgZG9tLCBkb21faXNfcmVhZHksIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUsIGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCwgZG9tX3JlYWR5X2Noa19tYXhfdHJpZXMsIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQsIGRvbV9yZWFkeV9jaGtfdHJpZXMsIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsLCBlbHQsIGV2dENuY2wsIGV2dFRndCwgZXZ0X3RndF9wcm9wX2EsIGV2dF90Z3RfcHJvcF9iLCBnYywgZ2NfdGltZXJfaWQsIGllX2F0dGFjaCwgaWVfZGV0YWNoLCBpZnJhbWVfY2JzX2F0dGFjaGVkLCBpZnJhbWVfbXNnX2hvc3RfbGliLCBpZnJhbWVfbmV4dF9pZCwgaWZyYW1lX3ZpZXcsIGlzSUUsIG1ha2VfZWxlbWVudCwgbWFrZV9pZnJhbWUsIHBhciwgcHVyZ2UsIHJlYWR5LCByZXBsYWNlX2lmcmFtZSwgdGFnTmFtZSwgdGFncywgdGhlRG9jdW1lbnQsIHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMsIHVzZV9hdHRhY2gsIHVzZV9kZXRhY2gsIHVzZV9pZV9vbGRfYXR0YWNoLCB2aWV3LCB3M2NfYXR0YWNoLCB3M2NfZGV0YWNoLCB3YWl0LCB3aW4sIF9iaW5kX2lmcmFtZV9vbmxvYWQsIF9ieUlELCBfY2FsbF94bXNnX2hvc3QsIF9jYWxsYWJsZSwgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrLCBfY2xvbmVfaWZyYW1lLCBfY3N0ciwgX2VudiwgX2hhbmRsZV9kb21fbG9hZF9ldnQsIF9sYW5nLCBfcmVhZHlfc3RhdGVfY2hlY2ssIF91bmJpbmRfaWZyYW1lX29ubG9hZDtcbiAgICBkb20gPSB7fTtcbiAgICBfbGFuZyA9IGxhbmc7XG4gICAgX2VudiA9IGVudjtcbiAgICB3aW4gPSB3aW5kb3c7XG4gICAgSUZSQU1FID0gXCJpZnJhbWVcIjtcbiAgICBHQyA9IFwiQ29sbGVjdEdhcmJhZ2VcIjtcbiAgICBpZV9hdHRhY2ggPSBcImF0dGFjaEV2ZW50XCI7XG4gICAgdzNjX2F0dGFjaCA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiO1xuICAgIGllX2RldGFjaCA9IFwiZGV0YWNoRXZlbnRcIjtcbiAgICB3M2NfZGV0YWNoID0gXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XG4gICAgdXNlX2F0dGFjaCA9IFwiXCI7XG4gICAgdXNlX2RldGFjaCA9IFwiXCI7XG4gICAgdXNlX2llX29sZF9hdHRhY2ggPSBmYWxzZTtcbiAgICBJRV9HQ19JTlRFUlZBTCA9IDMwMDA7XG4gICAgRVZUX0NOQ0xfTUVUSE9EUyA9IHtcbiAgICAgIFwicHJldmVudERlZmF1bHRcIjogMCxcbiAgICAgIFwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCI6IDAsXG4gICAgICBcInN0b3BQcm9wYWdhdGlvblwiOiAwLFxuICAgICAgXCJwcmV2ZW50QnViYmxlXCI6IDBcbiAgICB9O1xuICAgIGlzSUUgPSBlbnYuaXNJRTtcbiAgICB1c2VPbGRTdHlsZUF0dHJNZXRob2RzID0gZmFsc2U7XG4gICAgZ2NfdGltZXJfaWQgPSAwO1xuICAgIGRvbV9pc19yZWFkeSA9IG51bGw7XG4gICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gMDtcbiAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICBkb21fcmVhZHlfY2hrX21heF90cmllcyA9IDMwMDtcbiAgICBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCA9IDUwO1xuICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgPSAwO1xuICAgIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQgPSAwO1xuICAgIGlmcmFtZV9uZXh0X2lkID0gMDtcbiAgICBpZnJhbWVfY2JzX2F0dGFjaGVkID0ge307XG4gICAgZXZ0X3RndF9wcm9wX2EgPSBcIlwiO1xuICAgIGV2dF90Z3RfcHJvcF9iID0gXCJcIjtcbiAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gbnVsbDtcbiAgICB0aGVEb2N1bWVudCA9IHdpbi5kb2N1bWVudDtcbiAgICBCTEFOS19VUkwgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgX2NzdHIgPSBsYW5nLmNzdHI7XG4gICAgX2NhbGxhYmxlID0gbGFuZy5jYWxsYWJsZTtcblxuICAgIC8qXG4gICAgQ2xlYXIgb3V0IHRoZSB0aW1lciBmdW5jdGlvbiB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiByZWFkeSBzdGF0ZSBvZiB0aGUgRE9NXG4gICAgY2Fubm90IGJlIGRpcmVjdGx5IGRldGVjdGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9tX3JlYWR5X2Noa190aW1lcl9pZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZG9tX3JlYWR5X2Noa190aW1lcl9pZCk7XG4gICAgICAgIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgX2hhbmRsZV9kb21fbG9hZF9ldnQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGRldGFjaCh3aW4sIFwibG9hZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICBkZXRhY2god2luLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgdG8gc2VlIGlmIHRoZSBET00gaXMgcmVhZHkgdG8gYmUgbWFuaXB1bGF0ZWQsIHdpdGhvdXQgdGhlIG5lZWQgZm9yIGV2ZW50IGhvb2tpbmcuXG4gICAgT2Z0ZW4gdGltZXMgeW91J2xsIHNlZSBmb2xrcyB1c2UgdGhlIG9ubG9hZCBldmVudCBvciBET01Db250ZW50TG9hZGVkIGV2ZW50LiAgSG93ZXZlclxuICAgIHRoZSBwcm9ibGVtIHdpdGggdGhvc2UsIGlzIHRoYXQgeW91ciBKYXZhU2NyaXB0IGNvZGUgbWF5IGhhdmUgYmVlbiBsb2FkZWQgYXN5bmNocm9ub3VzbHksXG4gICAgYWZ0ZXIgZWl0aGVyIG9uZSBvZiB0aG9zZSBldmVudHMgaGF2ZSBmaXJlZCwgYW5kIGluIHdoaWNoIGNhc2UgeW91IHN0aWxsIGRvbid0IGtub3cgaWYgdGhlIERPTSBpcyByZWFsbHlcbiAgICByZWFkeS4gIE1vc3QgbW9kZXJuIGJyb3dzZXJzIChpbmNsdWRpbmcgSUUpLCBpbXBsZW1lbnQgYSBkb2N1bWVudC5yZWFkeVN0YXRlIHByb3BlcnR5IHRoYXQgd2UgY2FuXG4gICAgY2hlY2ssIGJ1dCBub3QgYWxsLiAgSW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBwcm9wZXJ0eSBpcyBub3QgaW1wbGVtZW50ZWQsIHdlIGRvIGEgc2VyaWVzIG9mIG5vZGVcbiAgICBjaGVja3MgYW5kIHRhZyBjb3VudHMgdmlhIHRpbWVycy4gIE9mIGNvdXJzZSB0aGlzIG1lYW5zIHRoYXQgb24gdGhlIHZlcnkgMXN0IGNhbGwsIHdlIHdpbGwgYWx3YXlzXG4gICAgYXBwZWFyIHRvIGJlIG5vdCByZWFkeSBldmVudGhvdWdoIHRoZSBET00gaXRzZWxmIG1heSBiZSBpbiBhIHJlYWR5IHN0YXRlLCBidXQgb3VyIHRpbWVvdXQgaW50ZXJ2YWxcbiAgICBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGlzIGlzIE9LLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLV9yZWFkeV9zdGF0ZV9jaGVja1xuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9yZWFkeV9zdGF0ZV9jaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGIsIGUsIGtpZHMsIGxzdCwgdGFnX2NudDtcbiAgICAgIF9jbGVhcl9yZWFkeV90aW1lcl9jaGVjaygpO1xuICAgICAgaWYgKGRvbV9yZWFkeV9jaGtfdHJpZXMgPj0gZG9tX3JlYWR5X2Noa19tYXhfdHJpZXMpIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZG9tX2lzX3JlYWR5ID09PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYiA9IHRoZURvY3VtZW50ICYmIHRoZURvY3VtZW50LmJvZHk7XG4gICAgICAgICAga2lkcyA9IGIgJiYgdGFncyhcIipcIiwgYik7XG4gICAgICAgICAgdGFnX2NudCA9IGtpZHMgJiYga2lkc1tMRU5dO1xuICAgICAgICAgIGxzdCA9IGIgJiYgYi5sYXN0Q2hpbGQ7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gMDtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ICYmIHRhZ19jbnQgPT09IGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCAmJiBsc3QgPT09IGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUpIHtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCA9IHRhZ19jbnQ7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IGxzdDtcbiAgICAgICAgICBkb21fcmVhZHlfY2hrX3RyaWVzICs9IDE7XG4gICAgICAgICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IHNldFRpbWVvdXQoX3JlYWR5X3N0YXRlX2NoZWNrLCBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIERldGFjaCBvbmxvYWQgaGFuZGxlcnMgb24gaWZyYW1lcyB0aGF0IHdlIGhhdmUgY3JlYXRlZFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX3VuYmluZF9pZnJhbWVfb25sb2FkXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIGlmcmFtZSBlbGVtZW50IHRvIHVuYmluZCBmcm9tXG4gICAgICovXG4gICAgX3VuYmluZF9pZnJhbWVfb25sb2FkID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBpZCwgb2xkQ0I7XG4gICAgICBpZCA9IGF0dHIoZWwsIFwiaWRcIik7XG4gICAgICBvbGRDQiA9IHZvaWQgMDtcbiAgICAgIG9sZENCID0gaWQgJiYgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF07XG4gICAgICBpZiAob2xkQ0IpIHtcbiAgICAgICAgZGV0YWNoKGVsLCBcImxvYWRcIiwgb2xkQ0IpO1xuICAgICAgICBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBBIGRlZmF1bHQgb25sb2FkIGV2ZW50IGhhbmRsZXIgZm9yIElGcmFtZXMuIFdlIGRvbid0XG4gICAgd2FudCB0byBhdHRhY2ggdG8gb25sb2FkIGV2ZW50cyBmb3IgSUZyYW1lcyB2aWEgYXR0cmlidXRlc1xuICAgIGIvYyB3ZSBkb24ndCB3YW50IG90aGVycyB0byBzZWUgd2hhdCBoYW5kbGVycyBhcmUgdGhlcmUuXG4gICAgSW4gdHVybiB3ZSBhbHNvIG1ha2Ugc3VyZSB0aGUgXCJ0aGlzXCIgcmVmZXJlbmNlIGZvciB0aGUgb3V0c2lkZVxuICAgIGhhbmRsZSBnZXRzIHNldCBwcm9wZXJseSwgYW5kIGl0IGFsbG93cyB1cyB0byBtYWtlIHN1cmVcbiAgICB0aGF0IHVuYmluZGluZyBvZiB0aGUgZXZlbnQgaGFuZGxlciBhbHNvIGdldHMgaGFuZGxlZCBhbHdheXNcbiAgICBzbyBhcyBub3QgdG8gY3JlYXRlIG1lbW9yeSBsZWFrIGlzc3Vlcy5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLV9iaW5kX2lmcmFtZV9vbmxvYWRcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgaWZyYW1lIGVsZW1lbnQgdG8gYmluZCB0b29cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgb25sb2FkIGhhbmRsZXIgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqL1xuICAgIF9iaW5kX2lmcmFtZV9vbmxvYWQgPSBmdW5jdGlvbihlbCwgY2IpIHtcbiAgICAgIHZhciBpZCwgbmV3Q0I7XG4gICAgICBuZXdDQiA9IHZvaWQgMDtcbiAgICAgIGlkID0gdm9pZCAwO1xuICAgICAgaWYgKF9jYWxsYWJsZShjYikpIHtcblxuICAgICAgICAvKlxuICAgICAgICBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICBuZXdDQiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHZhciBlLCB0Z3Q7XG4gICAgICAgICAgdGd0ID0gZXZ0VGd0KGV2dCk7XG4gICAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQodGd0KTtcbiAgICAgICAgICBpZiAodGd0ICYmIGNiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYi5jYWxsKHRndCwgZXZ0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICB9XG4gICAgICAgICAgdGd0ID0gZWwgPSBjYiA9IG5ld0NCID0gaWQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBpZCA9IGF0dHIoZWwsIFwiaWRcIik7XG4gICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZChlbCk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdID0gbmV3Q0I7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNoKGVsLCBcImxvYWRcIiwgbmV3Q0IpO1xuICAgICAgfVxuICAgICAgbmV3Q0IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgZWxlbWVudCByZWZlcmVuY2UgcGFzc2VkIGluLCBhbmQgaWYgaXRzIGEgc3RyaW5nIHZhbHVlIHBhc3NlZFxuICAgIGluIHVzZSB0aGF0IHRvIGxvb2t1cCB0aGUgZWxlbWVudCBieSBpZCBhdHRyaWJ1dGUuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX2J5SURcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gZWwgIHRoZSBlbGVtZW50IGlkIC8gZWxlbWVudCByZWZlcmVuY2VcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudHxlbH1cbiAgICAgKi9cbiAgICBfYnlJRCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBlbHQoZWwpIHx8IGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEEgcHJveHkgd3JhcHBlciBmb3IgY2FsbGluZyBpbnRvIHRoZSBjcm9zcy1kb21haW4gbWVzc2FnaW5nIGhvc3QgbGlicmFyeVxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX2NhbGxfeG1zZ19ob3N0XG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IG1ldGhOYW1lIFRoZSBtZXRob2QgbmFtZSBpbiB0aGUgbXNnIGhvc3QgbGlicmFyeSB0byBjYWxsXG4gICAgQHBhcmFtIHsqfSBhcmcxIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAxc3QgYXJnXG4gICAgQHBhcmFtIHsqfSBhcmcyIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAybmQgYXJnXG4gICAgQHBhcmFtIHsqfSBhcmczIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAzcmQgYXJnXG4gICAgQHJldHVybiB7Kn0gd2hhdGV2ZXIgY29tZXMgYmFjayBmcm9tIHRoZSBtZXRob2RcbiAgICAgKi9cbiAgICBfY2FsbF94bXNnX2hvc3QgPSBmdW5jdGlvbihtZXRoTmFtZSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIGU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpZnJhbWVfbXNnX2hvc3RfbGliKSB7XG4gICAgICAgICAgaWZyYW1lX21zZ19ob3N0X2xpYiA9IGRvbS5tc2dob3N0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgaWZyYW1lX21zZ19ob3N0X2xpYiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAod2luICE9PSB0b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhOYW1lICYmIGlmcmFtZV9tc2dfaG9zdF9saWIgJiYgaWZyYW1lX21zZ19ob3N0X2xpYlttZXRoTmFtZV0gJiYgaWZyYW1lX21zZ19ob3N0X2xpYlttZXRoTmFtZV0oYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgYSBkb2N1bWVudCBmb3IgYSBnaXZlbiBIVE1MIEVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBkb2MgYXMgJHNmLmxpYi5kb20uZG9jXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IGZvciB3aGljaCB5b3Ugd2lzaCB0byBmaW5kIGl0J3MgcGFyZW50IGRvY3VtZW50XG4gICAgQHJldHVybiB7RG9jdW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgZG9jID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBlLCBsb2NhbEQ7XG4gICAgICBsb2NhbEQgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxEID0gZWwuZG9jdW1lbnQgfHwgZWwub3duZXJEb2N1bWVudCB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGxvY2FsRCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxEO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIHRoZSBob3N0IHdpbmRvdyBvYmplY3QgZm9yIGEgZ2l2ZW4gSFRNTCBFbGVtZW50L2RvY3VtZW50LiBOb3RlIHRoYXQgdGhpcyBpcyBOT1QgdGhlIHNhbWUgYXMgJHNmLmxpYi5kb20uaWZyYW1lcy52aWV3LCB3aGljaFxuICAgIHJldHVybnMgdGhlIHdpbmRvdyByZWZlcmVuY2UgSU5TSURFIHRoZSBJRlJBTUUgZWxlbWVudC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyB2aWV3IGFzICRzZi5saWIuZG9tLnZpZXdcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTERvY3VtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50L2RvY3VtZW50IGZvciB3aGljaCB5b3Ugd2lzaCB0byBmaW5kIGl0J3MgcGFyZW50IHdpbmRvd1xuICAgIEByZXR1cm4ge0RvY3VtZW50fG51bGx9IG51bGwgaWYgbm90aGluZyBmb3VuZFxuICAgICAqL1xuICAgIHZpZXcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGxvY2FsRCwgcHJvcDEsIHByb3AyLCB3O1xuICAgICAgdyA9IG51bGw7XG4gICAgICBsb2NhbEQgPSB2b2lkIDA7XG4gICAgICBwcm9wMSA9IFwicGFyZW50V2luZG93XCI7XG4gICAgICBwcm9wMiA9IFwiZGVmYXVsdFZpZXdcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIHcgPSBlbFtwcm9wMV0gfHwgZWxbcHJvcDJdIHx8IG51bGw7XG4gICAgICAgICAgaWYgKCF3KSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBkb2MoZWwpO1xuICAgICAgICAgICAgdyA9IChsb2NhbEQgJiYgKGxvY2FsRFtwcm9wMV0gfHwgbG9jYWxEW3Byb3AyXSkpIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdztcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSBhbiBlbGVtZW50IGJ5IGl0cyBJRC4gLiBiYXNpY2FsbHkgYSBzaG9ydCBoYW5kIHdyYXBwZXIgYXJvdW5kIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGVsdCBhcyAkc2YubGliLmRvbS5lbHRcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBpZCAoUmVxdWlyZWQpIHRoZSBpZCBvZiB0aGUgSFRNTCBlbGVtZW50IHRvIGZpbmRcbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxXaW5kb3d8SFRNTERvY3VtZW50fSBbcGFyXSBUaGUgcGFyZW50IGVsZW1lbnQsZG9jdW1lbnQsd2luZG93IHRvIGxvb2sgZm9yIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgZWx0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBhcmdzLCBkYywgbGVuO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgZGMgPSB2b2lkIDA7XG4gICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICBkYyA9IGRvYyhhcmdzWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRjID0gdGhlRG9jdW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGRjICYmIGRjLmdldEVsZW1lbnRCeUlkKGlkKSkgfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIHdyYXBwZXIgYXJvdW5kIHJldHJpZXZpbmcgdGhlIHRhZ05hbWUgb2YgYW4gSFRNTCBlbGVtZW50IChub3JtYWxpemVzIHZhbHVlcyB0byBsb3dlciBjYXNlIHN0cmluZ3MpLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHRhZ05hbWUgYXMgJHNmLmxpYi5kb20udGFnTmFtZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIEhUTUwgZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSB0YWcgbmFtZS5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0YWcgbmFtZSBpbiBhbGwgbG93ZXIgY2FzZSBvZiBhbiBIVE1MIGVsZW1lbnQsIGlmIGl0IGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgcmV0cmlldmVkLCBhbHdhc3lzIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nICh3aGljaCB3aWxsIGV2YWx1YXRlIHRvIGZhbHNlKS5cbiAgICAgKi9cbiAgICB0YWdOYW1lID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBhcm91bmQgcmV0cmlldmluZyBhIGxpc3Qgb2YgdGFncyBieSBuYW1lLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHRhZ3MgYXMgJHNmLmxpYi5kb20udGFnc1xuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZ3MgdGhhdCB5b3Ugd2lzaCB0byBsb29rIGZvciwgbm90ZSB0aGF0IHlvdSBjYW4gcGFzcyBpbiBcIipcIiB0byBmaW5kIGFsbC5cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fERvY3VtZW50fSBbcGFyTm9kZV0gdGhlIHBhcmVudCBub2RlIHRoYXQgeW91IHdpc2ggdG8gbG9vayBpblxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50Q29sbGVjdGlvbn0gTGlzdCBvZiB0YWdzIGZvdW5kLiBOb3RlIHRoYXQgaXMgTk9UIGEgcmVhbCBKYXZhU2NyaXB0IEFycmF5XG4gICAgICovXG4gICAgdGFncyA9IGZ1bmN0aW9uKG5hbWUsIHBhck5vZGUpIHtcbiAgICAgIHZhciBlLCByZXQ7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGFyTm9kZSAmJiBwYXJOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG4gICAgICAgICAgcmV0ID0gcGFyTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSB8fCByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gdGhlRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSkgfHwgcmV0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpdmUgdGhlIHBhcmVudCBlbGVtZW50IG9mIGFuIEhUTUwgZWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHBhciBhcyAkc2YubGliLmRvbS5wYXJcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gY2hlY2tcbiAgICByZXR1cm4ge0hUTUxFbGVtZW50fSB0aGUgbmV3IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGVsZW1lbnQgb3IgbnVsbFxuICAgICAqL1xuICAgIHBhciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwgJiYgKGVsLnBhcmVudE5vZGUgfHwgZWwucGFyZW50RWxlbWVudCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUvU2V0L0RlbGV0ZSBhbiBlbGVtZW50J3MgYXR0cmlidXRlLiBOb3RlIHRoYXQgdGhpcyBoYW5kbGUnc1xuICAgIHNsaWdodCBkaWZmZXJlbmNlcyBpbiB0aGUgd2F5IEhUTUwgYXR0cmlidXRlcyBhcmUgaGFuZGxlZCBhY3Jvc3MgYnJvd3NlcnNcbiAgICBhcyB3ZWxsIGFzIGJlaW5nIHNob3J0aGFuZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGF0dHIgYXMgJHNmLmxpYi5kb20uYXR0clxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBtYW5pcHVsYXRlXG4gICAgQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIHRoZSBhdHRyaWJ1dGUgdG8gc2V0L2dldFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbYXR0clZhbF0sIGlmIHNwZWNpZmllZCB3aWxsIHNldCB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBmb3IgdGhpcyBlbGVtZW50LiAgUGFzc2luZyBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgY29tcGxldGVseVxuICAgIEByZXR1cm4ge1N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgbm9ybWFsaXplZCB0byBhIHN0cmluZyAobWF5IGJlIGVtcHR5KVxuICAgICAqL1xuICAgIGF0dHIgPSBmdW5jdGlvbihlbCwgYXR0ck5hbWUsIGF0dHJWYWwpIHtcbiAgICAgIHZhciBlO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgIGlmIChhdHRyVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGF0dHJWYWwpO1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBhdHRyVmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWwsIDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMpIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBfY3N0cihlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIDApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGF0dHJWYWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJWYWw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2V0L0dldCB0aGUgQ1NTIHRleHQgb2YgYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgY3NzIGFzICRzZi5saWIuZG9tLmNzc1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBtYW5pcHVsYXRlXG4gICAgQHBhcmFtIHtTdHJpbmd9IFt2YWxdIHRoZSBDU1Mgc3RyaW5nIHRvIHNldCBpZiBzcGVjaWZpZWQgKGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3Bvc2l0aW9uOmFic29sdXRlO3RvcDowcHg7bGVmdDowcHhcIikuXG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBub3JtYWxpemVkIHRvIGEgc3RyaW5nIChtYXkgYmUgZW1wdHkpXG4gICAgICovXG4gICAgY3NzID0gZnVuY3Rpb24oZWwsIHZhbCkge1xuICAgICAgdmFyIGUsIHN0O1xuICAgICAgc3QgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBzdCA9IGVsLnN0eWxlO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdC5jc3NUZXh0ID0gX2NzdHIodmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBzdC5jc3NUZXh0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWFrZSBhIG5ldyBlbGVtZW50XG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20ubWFrZVxuICAgIEBleHBvcnRzIG1ha2VfZWxlbWVudCBhcyAkc2YubGliLmRvbS5tYWtlXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZVxuICAgIEBwYXJhbSB7RG9jdW1lbnR8SFRNTEVsZW1lbnR8V2luZG93fSBbcGFyZW50XSBlbGVtZW50LCBkb2N1bWVudCwgb3Igd2luZG93IHRvIG1ha2UgdGhlIHRhZyBpbiwgb3B0aW9uYWwuXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgbWFrZV9lbGVtZW50ID0gZnVuY3Rpb24odGFnTmFtZSwgcGFyKSB7XG4gICAgICByZXR1cm4gKChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBkb2MocGFyKSkgfHwgdGhlRG9jdW1lbnQpLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQXBwZW5kIGFuZCBIVE1MRWxlbWVudCB0byBhbm90aGVyIEhUTUxFbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXBwZW5kIGFzICRzZi5saWIuZG9tLmFwcGVuZFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyTm9kZSB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZCAoUmVxdWlyZWQpIHRoZSBuZXcgSFRNTCBlbGVtZW50IHRvIGFkZCB0byB0aGUgcGFyZW50XG4gICAgcmV0dXJuIHtIVE1MRWxlbWVudHxCb29sZWFufSB0aGUgbmV3IHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgZWxlbWVudCB0aGF0IHdhcyBhcHBlbmRlZCwgb3IgZmFsc2UgaWYgZmFpbHVyZVxuICAgICAqL1xuICAgIGFwcGVuZCA9IGZ1bmN0aW9uKHBhck5vZGUsIGNoaWxkKSB7XG4gICAgICB2YXIgZSwgc3VjY2VzcztcbiAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGFyTm9kZSkge1xuICAgICAgICAgIHN1Y2Nlc3MgPSBwYXJOb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBtZXRob2QgZm9yIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gYSBkb2N1bWVudCByYXRoZXIgdGhhbiBjYWxsaW5nIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQgcmF3LlxuICAgIEhhcyBzcGVjaWFsIHByb2Nlc3NpbmcgdG8gZW5zdXJlIHRoYXQgY29udGVudHMgb2YgSUZSQU1FIHRhZ3MgZ2V0cyByZWxlYXNlZCBmcm9tIG1lbW9yeSBhcyB3ZWxsXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcHVyZ2UgYXMgJHNmLmxpYi5kb20ucHVyZ2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgVGhlIEhUTUwgZWxlbWVudCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGRvbVxuICAgIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIHB1cmdlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGUsIGlzSUZyYW1lLCBwYXJOb2RlLCBzdWNjZXNzO1xuICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgcGFyTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlzSUZyYW1lID0gdGFnTmFtZShub2RlKSA9PT0gSUZSQU1FO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGlmIChpc0lGcmFtZSkge1xuICAgICAgICBfY2FsbF94bXNnX2hvc3QoXCJkZXRhY2hcIiwgbm9kZSk7XG4gICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZChub2RlKTtcbiAgICAgICAgaWYgKCFpc0lFKSB7XG4gICAgICAgICAgYXR0cihub2RlLCBcInNyY1wiLCBCTEFOS19VUkwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBwYXJOb2RlID0gcGFyKG5vZGUpO1xuICAgICAgICBpZiAocGFyTm9kZSkge1xuICAgICAgICAgIHBhck5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzSUUgJiYgaXNJRnJhbWUpIHtcbiAgICAgICAgICAgIGdjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBub2RlID0gcGFyTm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuXG4gICAgLypcbiAgICBBdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0byBhbiBIVE1MRWxlbWVudC4gIE5vdGUgbm9ybWFsaXplIGV2ZW50IG5hbWVzIHRvIGxvd2VyIGNhc2UgLyB3M2Mgc3RhbmRhcmRzLlxuICAgIFNlZSBleGFtcGxlLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGF0dGFjaCBhcyAkc2YubGliLmRvbS5hdHRhY2hcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gYXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgdG9vXG4gICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b29cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgZnVuY3Rpb24gdXNlZCB0byBoYW5kbGUgdGhlIHBhcnRpY3VsYXIgZXZlbnRcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBlbCA9ICRzZi5saWIuZG9tLmVsdChcIm15X2VsZW1lbnRcIik7XG4gICAgZnVuY3Rpb24gaGFuZGxlX2NsaWNrKGV2dClcbiAgICB7XG4gICAgYWxlcnQoJ2kgd2FzIGNsaWNrZWQnKTtcbiAgICB9XG4gICAgXG4gICAgJHNmLmxpYi5kb20uYXR0YWNoKGVsLFwiY2xpY2tcIixoYW5kbGVfY2xpY2spO1xuICAgICAqL1xuICAgIGF0dGFjaCA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh1c2VfaWVfb2xkX2F0dGFjaCkge1xuICAgICAgICAgIG9ialt1c2VfYXR0YWNoXShcIm9uXCIgKyBuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW3VzZV9hdHRhY2hdKG5hbWUsIGNiLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIG9iaiA9IGNiID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBEZXRhY2ggYW4gZXZlbnQgaGFuZGxlciB0byBhbiBIVE1MRWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGRldGFjaCBhcyAkc2YubGliLmRvbS5kZXRhY2hcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gYXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgdG9vXG4gICAgQHBhcmFtIHtTdHJpbmd9IG5hbWV0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGhhbmRsZSB0aGUgcGFydGljdWxhciBldmVudFxuICAgICAqL1xuICAgIGRldGFjaCA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh1c2VfaWVfb2xkX2F0dGFjaCkge1xuICAgICAgICAgIG9iai5kZXRhY2hFdmVudChcIm9uXCIgKyBuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgb2JqID0gY2IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIERPTSBpcyByZWFkeSB0byBiZSBtYW5pcHVsYXRlZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHJlYWR5IGFzICRzZi5saWIuZG9tLnJlYWR5XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnM7XG4gICAgICBycyA9IHZvaWQgMDtcbiAgICAgIF9jbGVhcl9yZWFkeV90aW1lcl9jaGVjaygpO1xuICAgICAgaWYgKGRvbV9pc19yZWFkeSkge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBycyA9IHRoZURvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgICBpZiAocnMpIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChycyA9PT0gXCJsb2FkZWRcIiB8fCBycyA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICBkb21fcmVhZHlfY2hrX3RyaWVzID0gZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gMDtcbiAgICAgIF9yZWFkeV9zdGF0ZV9jaGVjaygpO1xuICAgICAgcmV0dXJuICEhZG9tX2lzX3JlYWR5O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEZpcmUgb2ZmIGEgcGFydGljdWxhciBmdW5jdGlvbiB3aGVuIGl0IGlzIGRldGVjdGVkIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgIFVzZWZ1bCB3aGVuIHlvdSBkb24ndCBrbm93IGZvciBzdXJlIGlmIHRoZSBET00gb2YgdGhlIGJyb3dzZXIgaXMgcmVhZHkgb3Igbm90LCBzbyB0aGlzIHdpbGwgZGV0ZWN0IGFuZCBmaXJlXG4gICAgeW91ciBmdW5jdGlvbiBmb3IgeW91LlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHdhaXQgYXMgJHNmLmxpYi5kb20ud2FpdFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgQSBmdW5jdGlvbiByZWZlcmVuY2UgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuICAgICAqL1xuICAgIHdhaXQgPSBmdW5jdGlvbihjYikge1xuICAgICAgdmFyIGUsIHJkeTtcbiAgICAgIHJkeSA9IHJlYWR5KCk7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgaWYgKHJkeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChsYW5nLmNhbGxhYmxlKGNiKSkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdhaXQoY2IpO1xuICAgICAgICBjYiA9IG51bGw7XG4gICAgICB9KSwgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwgKyAxKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDYW5jZWwgdGhlIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZXZ0Q25jbCBhcyAkc2YubGliLmRvbS5ldnRDbmNsXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0ICBUaGUgcmF3IEhUTUwgZXZlbnRcbiAgICAgKi9cbiAgICBldnRDbmNsID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgZSwgcHJvcDtcbiAgICAgIHByb3AgPSBcIlwiO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGV2dCA9IGV2dCB8fCB3aW4uZXZlbnQ7XG4gICAgICBpZiAoZXZ0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBmb3IgKHByb3AgaW4gRVZUX0NOQ0xfTUVUSE9EUykge1xuICAgICAgICAgIGlmIChFVlRfQ05DTF9NRVRIT0RTW3Byb3BdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBldnRbcHJvcF0oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIHRhcmdldC9zcmNFbGVtZW50IG9mIGFuIGV2ZW50IGZyb20gYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZXZ0VGd0IGFzICRzZi5saWIuZG9tLmV2dFRndFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IEhUTUwgZXZlbnRcbiAgICAgKi9cbiAgICBldnRUZ3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlLCB0Z3Q7XG4gICAgICB0Z3QgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXZ0ID0gZXZ0IHx8IHdpbi5ldmVudDtcbiAgICAgICAgdGd0ID0gKGV2dCA/IGV2dFtldnRfdGd0X3Byb3BfYV0gfHwgZXZ0W2V2dF90Z3RfcHJvcF9iXSA6IG51bGwpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHRndCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGd0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBuYW1lc3BhY2UgJHNmLmxpYi5kb20uaWZyYW1lcyBEZWZpbmVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgc3BlY2lmaWNhbGx5IHdpdGggSUZSQU1FIHRhZ3MsIHdoaWNoIGlzIGtleSB0byBTYWZlRnJhbWVzIHRlY2ggaW4gYSBicm93c2VyLlxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXNcbiAgICBAcmVxdWlyZXMgJHNmLmxpYi5sYW5nXG4gICAgICovXG5cbiAgICAvKlxuICAgIENsb25lcyBhbiBpZnJhbWUuIC4gLlxuICAgIFRoaXMgY29kZSBjcmVhdGVzIC8gY2xvbmVzIGlmcmFtZSB0YWdzIGluIGEgdmVyeSBzcGVjaWZpYyB3YXkgdG8gZW5zdXJlIGJvdGggb3B0aW1hbCBwZXJmb3JtYW5jZSBhbmQgc3RhYmlsaXR5LlxuICAgIFdlIHVzZSBzdHJpbmcgYnVmZmVycyB0byBidWlsZCBtYXJrdXAgaW50ZXJuYWxseSwgd2hpY2ggaXMgdHlwaWNhbGx5IGZhc3RlciB0aGFuIHVzaW5nIGFsbCBET00gQVBJcy4gIEFsc29cbiAgICB3ZSBhbGxvdyB0aGUgdXNhZ2Ugb2YgdGhlIFwibmFtZVwiIGF0dHJpYnV0ZSBhcyBhIGRhdGEgcGlwZWxpbmUsIHdoaWNoIGluIHR1cm4gYWxsb3dzIGZvciBzeW5jaHJvbm91cyBkb3dud2FyZFxuICAgIHgtZG9tYWluIG1lc3NhZ2luZy5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLmNsb25lXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50L1N0cmluZ30gZWwgIEFuIGlmcmFtZSBlbGVtZW50IG9yIGlkIG9mIGFuIGlmcmFtZSBlbGVtZW50IHRvIGNsb25lXG4gICAgQHBhcmFtIHtPYmplY3R9IFthdHRyc10gIEEgaGFzaCBtYXAgb2Ygb3RoZXIgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIGlmcmFtZS4gIERvIG5vdCBzZXQgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGZyYW1lIGhlcmUsIHNlZSB0aGUgbmV4dCBhcmd1bWVudCBmb3IgdGhhdC5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2Nzc1RleHRdICBUaGUgc3R5bGUgc3RyaW5nIChhcyBpbiB3aGF0IHlvdSB3b3VsZCB1c2UgaW4gSFRNTCBtYXJrdXAsIGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtib3JkZXI6c29saWQgM3B4IGJsdWU7XCIpLCB0byB1c2UgZm9yIHRoaXMgaWZyYW1lXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gc3BlY2lmeSBmb3Igd2hlbiB0aGUgaWZyYW1lIGxvYWRzLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFt4bXNnQ0JdIEFuIG9wdGlvbmFsIGNhbGwgYmFjayBmb3IgcmVjZWl2aW5nIG1lc3NhZ2VzIGZyb20gdGhlIGlmcmFtZVxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgdGhlIGlmcmFtZSBub2RlIGlmIHN1Y2Nlc2Z1bGx5IGNyZWF0ZWQgb3IgbnVsbC4gIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGluc2VydCB0aGUgaWZyYW1lIGludG8gdGhlIGRvY3VtZW50IGZvciB5b3UuIC4gLlxuICAgICAqL1xuICAgIGNsb25lX2lmcmFtZSA9IGZ1bmN0aW9uKGVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQikge1xuICAgICAgcmV0dXJuIF9jbG9uZV9pZnJhbWUoZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAaWdub3JlXG4gICAgICovXG4gICAgX2Nsb25lX2lmcmFtZSA9IGZ1bmN0aW9uKGVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQiwgaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgIHZhciBhdHRyU3RyLCBidWZmZXJIVE1MLCBjbCwgaHRtbCwgbmV3Q2wsIHByb3AsIHRlbXAsIHhtc2dQaXBlO1xuICAgICAgYnVmZmVySFRNTCA9IFtcIjxcIiwgSUZSQU1FLCBcIiBcIl07XG4gICAgICB4bXNnUGlwZSA9IFwiXCI7XG4gICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgdGVtcCA9IHZvaWQgMDtcbiAgICAgIGNsID0gdm9pZCAwO1xuICAgICAgbmV3Q2wgPSB2b2lkIDA7XG4gICAgICBodG1sID0gdm9pZCAwO1xuICAgICAgYXR0clN0ciA9IHZvaWQgMDtcbiAgICAgIGlmICghaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgICAgZWwgPSBfYnlJRChlbCk7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSAhPT0gSUZSQU1FKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2wgPSBlbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2wgPSBlbDtcbiAgICAgIH1cbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICBpZiAoXCJzcmNcIiBpbiBhdHRycykge1xuICAgICAgICBhdHRyKGNsLCBcInNyY1wiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLnNyYyA9IGF0dHIoZWwsIFwic3JjXCIpIHx8IEJMQU5LX1VSTDtcbiAgICAgIH1cbiAgICAgIGlmIChcIm5hbWVcIiBpbiBhdHRycykge1xuICAgICAgICBhdHRyKGNsLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRycy5uYW1lID0gYXR0cihlbCwgXCJuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRycy5zcmMpIHtcbiAgICAgICAgYXR0cnMuc3JjID0gQkxBTktfVVJMO1xuICAgICAgfVxuICAgICAgeG1zZ1BpcGUgPSB4bXNnQ0IgJiYgX2NhbGxfeG1zZ19ob3N0KFwicHJlcFwiLCBhdHRycyk7XG4gICAgICBpZiAoIWlmcmFtZV9za2lwX2Nsb25lKSB7XG4gICAgICAgIGF0dHIoY2wsIFwid2lkdGhcIiwgbnVsbCk7XG4gICAgICAgIGF0dHIoY2wsIFwiaGVpZ2h0XCIsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgdGVtcCA9IGNzcyhjbCk7XG4gICAgICAgIGlmICh0ZW1wICYmIHRlbXAuY2hhckF0KHRlbXAubGVuZ3RoIC0gMSkgIT09IFwiO1wiKSB7XG4gICAgICAgICAgdGVtcCArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBjc3MoY2wsIFt0ZW1wLCBfY3N0cihjc3NUZXh0KV0pO1xuICAgICAgfVxuICAgICAgdGVtcCA9IG1ha2VfZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGFwcGVuZCh0ZW1wLCBjbCk7XG4gICAgICBodG1sID0gdGVtcC5pbm5lckhUTUw7XG4gICAgICBhdHRyU3RyID0gaHRtbC5yZXBsYWNlKC88aWZyYW1lKC4qPyk+KC4qPyk8XFwvaWZyYW1lPi9nLCBcIiQxXCIpO1xuICAgICAgYnVmZmVySFRNTC5wdXNoKFwibmFtZT1cXFwiXCIsIGF0dHJzLm5hbWUsIFwiXFxcIiBcIiwgYXR0clN0ciwgXCI+PC9cIiwgSUZSQU1FLCBcIj5cIik7XG4gICAgICBkZWxldGUgYXR0cnMubmFtZTtcbiAgICAgIHRlbXAuaW5uZXJIVE1MID0gX2NzdHIoYnVmZmVySFRNTCk7XG4gICAgICBuZXdDbCA9IHRlbXAuZmlyc3RDaGlsZDtcbiAgICAgIGZvciAocHJvcCBpbiBhdHRycykge1xuICAgICAgICBhdHRyKG5ld0NsLCBwcm9wLCBhdHRyc1twcm9wXSk7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHIobmV3Q2wsIFwiaWRcIikpIHtcbiAgICAgICAgYXR0cihuZXdDbCwgXCJpZFwiLCBcInNmX1wiICsgSUZSQU1FICsgXCJfXCIgKyBpZnJhbWVfbmV4dF9pZCk7XG4gICAgICAgIGlmcmFtZV9uZXh0X2lkKys7XG4gICAgICB9XG4gICAgICBhdHRyKG5ld0NsLCBcIkZSQU1FQk9SREVSXCIsIFwibm9cIik7XG4gICAgICBhdHRyKG5ld0NsLCBcIlNDUk9MTElOR1wiLCBcIm5vXCIpO1xuICAgICAgYXR0cihuZXdDbCwgXCJBTExPV1RSQU5TUEFSRU5DWVwiLCB0cnVlKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiSElERUZPQ1VTXCIsIHRydWUpO1xuICAgICAgYXR0cihuZXdDbCwgXCJUQUJJTkRFWFwiLCAtMSk7XG4gICAgICBhdHRyKG5ld0NsLCBcIk1BUkdJTldJRFRIXCIsIDApO1xuICAgICAgYXR0cihuZXdDbCwgXCJNQVJHSU5IRUlHSFRcIiwgMCk7XG4gICAgICBfYmluZF9pZnJhbWVfb25sb2FkKG5ld0NsLCBjYik7XG4gICAgICBpZiAoeG1zZ1BpcGUpIHtcbiAgICAgICAgX2NhbGxfeG1zZ19ob3N0KFwiYXR0YWNoXCIsIG5ld0NsLCB4bXNnUGlwZSwgeG1zZ0NCKTtcbiAgICAgIH1cbiAgICAgIHhtc2dQaXBlID0geG1zZ0NCID0gY2wgPSBjYiA9IGVsID0gdGVtcCA9IG51bGw7XG4gICAgICByZXR1cm4gbmV3Q2w7XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWFrZSBhIG5ldyBpZnJhbWVcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLm1ha2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAgQSBoYXNoIG1hcCBvZiBvdGhlciBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgaWZyYW1lLiAgRG8gbm90IHNldCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZnJhbWUgaGVyZSwgc2VlIHRoZSBuZXh0IGFyZ3VtZW50IGZvciB0aGF0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbY3NzVGV4dF0gIFRoZSBzdHlsZSBzdHJpbmcgKGFzIGluIHdoYXQgeW91IHdvdWxkIHVzZSBpbiBIVE1MIG1hcmt1cCwgZS5nLiBcImJhY2tncm91bmQtY29sb3I6cmVkO2JvcmRlcjpzb2xpZCAzcHggYmx1ZTtcIiksIHRvIHVzZSBmb3IgdGhpcyBpZnJhbWVcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9ICB0aGUgaWZyYW1lIG5vZGUgaWYgc3VjY2VzZnVsbHkgY3JlYXRlZCBvciBudWxsLiAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgaW5zZXJ0IHRoZSBpZnJhbWUgaW50byB0aGUgZG9jdW1lbnQgZm9yIHlvdS4gLiAuXG4gICAgICovXG4gICAgbWFrZV9pZnJhbWUgPSBmdW5jdGlvbihhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQikge1xuICAgICAgcmV0dXJuIF9jbG9uZV9pZnJhbWUobWFrZV9lbGVtZW50KElGUkFNRSksIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIG1ldGhvZCB0byBpbnNlcnQgb3IgcmVwbGFjZSBhbiBIVE1MIHRhZyB3aXRoIGFuIElGUkFNRSB0YWcsIHdpdGggYSBuZXcgVVJMIGFuZCBhdHRyaWJ1dGVzLlxuICAgIFxuICAgIFVzZWQgZm9yIDMgcmVhc29uczpcbiAgICA8b2w+XG4gICAgPGxpPkl0IGF2b2lkcyBjbGljayBzb3VuZHMgb24gSUUuPC9saT5cbiAgICA8bGk+SXQgYWxsb3dzIGFsd2F5cyByZXNldHRpbmcgdGhlIHdpbmRvdy5uYW1lIHByb3BlcnR5IG9mIHRoZSBpZnJhbWVzIHVuZGVybHlpbmcgSFRNTFdpbmRvdyBvYmplY3QsIHVuZm9ydW5hdGVseSBJRSB3aWxsIG5vdCBsZXQgeW91IHNldCB0aGlzIGF0dHJpYnV0ZSBvbiBhIGNsb25lLjwvbGk+XG4gICAgPGxpPkl0IGVuc3VyZXMgdGhhdCBldmVudCBoYW5kbGVycyBpbiB0aGUgdW5kZXJseWluZyBkb2N1bWVudCBmb3IgdW5sb2FkaW5nIGFyZSBleGVjdXRlZC48L2xpPlxuICAgIDxsaT5DaGFuZ2luZyB0aGUgc3JjIGF0dHJpYnV0ZSBkaXJlY3RseSB3aWxsIHJlc3VsdCBpbiBhIGJyb3dzZXIgaGlzdG9yeSB1cGRhdGUsIHdoaWNoIHdlIGRvIG5vdCB3YW50LjwvbGk+XG4gICAgPC9vbD5cbiAgICBcbiAgICBXZSBjb3VsZCBqdXN0IGNoYW5nZSBsb2NhdGlvbi5ocmVmIHByb3BlcnR5IG9yIGNhbGwgbG9jYXRpb24ucmVwbGFjZSwgaG93ZXZlciB0aGF0IGlzIG5vdCBhbHdheXMgIHBvc3NpYmxlIHNpbmNlXG4gICAgdGhlIGZyYW1lIGNvdWxkIGJlIHgtZG9tYWluLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMucmVwbGFjZVxuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBIGhhc2ggbWFwIG9mIG90aGVyIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBpZnJhbWUuICBEbyBub3Qgc2V0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSBmcmFtZSBoZXJlLCBzZWUgdGhlIG5leHQgYXJndW1lbnQgZm9yIHRoYXQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjc3NUZXh0XSAgVGhlIHN0eWxlIHN0cmluZyAoYXMgaW4gd2hhdCB5b3Ugd291bGQgdXNlIGluIEhUTUwgbWFya3VwLCBlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7Ym9yZGVyOnNvbGlkIDNweCBibHVlO1wiKSwgdG8gdXNlIGZvciB0aGlzIGlmcmFtZVxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBbcGFyUmVmXSAgQW4gcGFyZW50IGVsZW1lbnQgb3IgcGFyZW50IGVsZW1lbnQgaWQsIHRvIGJlIHVzZWQgb25seSBpZiBhIG5ldyBpZnJhbWUgaXMgY3JlYXRlZCwgdGhlIGlmcmFtZSB3aWxsIGJlIGFwcGVuZCB0byB0aGF0IHBhcmVudCwgaWYgbm90IHNwZWNpZmllZCBkb2N1bWVudCBib2R5IGlzIHVzZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9IGEgcmVmZXJlbmNlIHRvIHRoZSBuZXdseSBjcmVhdGVkIGlmcmFtZSBlbGVtZW50IGlmIHN1Y2Nlc3NmdWxseSBpbnNlcnRlZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAgICovXG4gICAgcmVwbGFjZV9pZnJhbWUgPSBmdW5jdGlvbihhdHRycywgY3NzVGV4dCwgcGFyUmVmLCBjYiwgeG1zZ0NCKSB7XG4gICAgICB2YXIgY2wsIGUsIGVsLCBlbElELCBmcmFtZUVsLCBwYXJOb2RlLCB0Z247XG4gICAgICBjbCA9IHZvaWQgMDtcbiAgICAgIGVsID0gdm9pZCAwO1xuICAgICAgZnJhbWVFbCA9IHZvaWQgMDtcbiAgICAgIGVsSUQgPSB2b2lkIDA7XG4gICAgICB0Z24gPSB2b2lkIDA7XG4gICAgICBwYXJOb2RlID0gdm9pZCAwO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICBlbElEID0gYXR0cnMuaWQ7XG4gICAgICBlbCA9IGVsSUQgJiYgX2J5SUQoZWxJRCk7XG4gICAgICB0Z24gPSB0YWdOYW1lKGVsKTtcbiAgICAgIGVsID0gKHRnbiA/IGVsIDogbnVsbCk7XG4gICAgICBmcmFtZUVsID0gKHRnbiA9PT0gSUZSQU1FID8gZWwgOiBudWxsKTtcbiAgICAgIGlmIChmcmFtZUVsKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdChcImRldGFjaFwiLCBmcmFtZUVsKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKGZyYW1lRWwpO1xuICAgICAgICBwYXJOb2RlID0gcGFyKGZyYW1lRWwpO1xuICAgICAgICBjbCA9IGNsb25lX2lmcmFtZShmcmFtZUVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQik7XG4gICAgICAgIGF0dHIoY2wsIFwib25sb2FkXCIsIG51bGwpO1xuICAgICAgICBhdHRyKGNsLCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJSZWYpIHtcbiAgICAgICAgICBwYXJSZWYgPSBfYnlJRChwYXJSZWYpO1xuICAgICAgICAgIGlmICh0YWdOYW1lKHBhclJlZikpIHtcbiAgICAgICAgICAgIHBhck5vZGUgPSBwYXJSZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyTm9kZSAmJiBlbCkge1xuICAgICAgICAgIHBhck5vZGUgPSBwYXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGNzc1RleHQgPSBfY3N0cihjc3NUZXh0KSB8fCBjc3MoZWwpIHx8IFwiXCI7XG4gICAgICAgIGNsID0gbWFrZV9pZnJhbWUoYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFwYXJOb2RlKSB7XG4gICAgICAgICAgYXBwZW5kKHRoZURvY3VtZW50LmJvZHksIGNsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZnJhbWVFbCkge1xuICAgICAgICAgICAgcGFyTm9kZS5yZXBsYWNlQ2hpbGQoY2wsIGZyYW1lRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgcGFyTm9kZS5yZXBsYWNlQ2hpbGQoY2wsIGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGVuZChwYXJOb2RlLCBjbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBjbCA9IGVsID0gYXR0cnMgPSBmcmFtZUVsID0gcGFyTm9kZSA9IGNiID0gbnVsbDtcbiAgICAgIHJldHVybiBlbHQoZWxJRCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgdGhlIHdpbmRvdyByZWZlcmVuY2UgaW5zaWRlIG9mIGFuIElGUkFNRS4gTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggJHNmLmxpYi5kb20udmlldyB3aGljaFxuICAgIHJldHVybnMgdGhlIHBhcmVudCB3aW5kb3cgcmVmZXJlbmNlIG9mIGFuIGVsZW1lbnQuXG4gICAgXG4gICAgTm90ZSB0aGF0IGV2ZW4gaW4gY3Jvc3MtZG9tYWluIHNjZW5hcmlvcywgeW91IGFyZSBzdXBwb3NlZCB0byBhYmxlIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHdpbmRvdyByZWZlcmVuY2UuXG4gICAgSW4gYSBjcm9zcy1kb21haW4gc2NlbmFyaW8sIHlvdSB3b3VsZCBub3QgYmUgYWJsZSB0byB0aGVuIGFjZXNzcyBtb3N0IHByb3BlcnRpZXMgLyBtZXRob2RzIC8gb2JqZWN0cyBvZiB0aGF0XG4gICAgd2luZG93LCBidXQgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgYWxsb3dlZC5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLnZpZXdcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBpZnJhbWUgZWxlbWVudCB0byBzYWZlbHkgZ2V0IGJhY2sgdGhlIHdpbmRvd1xuICAgIEByZXR1cm4ge0hUTUxXaW5kb3d9IHRoZSB3aW5kb3cgcmVmZXJlbmNlIGluc2lkZSB0aGUgaWZyYW1lLlxuICAgICAqL1xuICAgIGlmcmFtZV92aWV3ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBlLCBlbERvYywgZWxXaW4sIGVyciwgZmUsIGZyYW1lLCBmcmFtZV9saXN0LCBpZHgsIGxvY2FsV2luO1xuICAgICAgbG9jYWxXaW4gPSB2b2lkIDA7XG4gICAgICBlbFdpbiA9IHZvaWQgMDtcbiAgICAgIGVsRG9jID0gdm9pZCAwO1xuICAgICAgZnJhbWVfbGlzdCA9IHZvaWQgMDtcbiAgICAgIGZyYW1lID0gdm9pZCAwO1xuICAgICAgZmUgPSB2b2lkIDA7XG4gICAgICBpZHggPSAwO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGVyciA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsV2luID0gZWwuY29udGVudFdpbmRvdyB8fCBudWxsO1xuICAgICAgICBpZiAoIXdpbikge1xuICAgICAgICAgIGVsRG9jID0gZG9jKGVsKTtcbiAgICAgICAgICBlbFdpbiA9IGVsRG9jICYmIHZpZXcoZWxEb2MpO1xuICAgICAgICAgIGZyYW1lX2xpc3QgPSAoZWxXaW4gJiYgZWxXaW4uZnJhbWVzKSB8fCBbXTtcbiAgICAgICAgICB3aGlsZSAoZnJhbWUgPSBmcmFtZV9saXN0W2lkeCsrXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmUgPSBmcmFtZS5mcmFtZUVsZW1lbnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgICAgICBmZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmUgJiYgZmUgPT09IGVsKSB7XG4gICAgICAgICAgICAgIGxvY2FsV2luID0gZnJhbWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGxvY2FsV2luID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NhbFdpbjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAaWdub3JlXG4gICAgICovXG4gICAgZ2MgPSBfbGFuZy5ub29wO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBBVFRSX05BTUUsIENSRUFURV9FVkVOVCwgRVZUX1RZUEUsIGVyciwgb2JqLCBwcm9wO1xuICAgICAgb2JqID0gdm9pZCAwO1xuICAgICAgQVRUUl9OQU1FID0gXCJTQ1JPTExJTkdcIjtcbiAgICAgIENSRUFURV9FVkVOVCA9IFwiY3JlYXRlRXZlbnRcIjtcbiAgICAgIEVWVF9UWVBFID0gXCJVSUV2ZW50XCI7XG4gICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgZXJyID0gdm9pZCAwO1xuICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2EgPSBcInNyY0VsZW1lbnRcIjtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2IgPSBcInRhcmdldFwiO1xuICAgICAgICBvYmogPSBtYWtlX2VsZW1lbnQoSUZSQU1FKTtcbiAgICAgICAgYXR0cihvYmosIEFUVFJfTkFNRSwgXCJub1wiKTtcbiAgICAgICAgdXNlT2xkU3R5bGVBdHRyTWV0aG9kcyA9IGF0dHIob2JqLCBBVFRSX05BTUUpICE9PSBcIm5vXCI7XG4gICAgICAgIGlmIChHQyBpbiB3aW4pIHtcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgQGlnbm9yZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGdjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZ2NfdGltZXJfaWQpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdjX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjX3RpbWVyX2lnKHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luW0dDXSgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgICB9LCBJRV9HQ19JTlRFUlZBTCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2MgPSBfbGFuZy5ub29wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldnRfdGd0X3Byb3BfYSA9IFwidGFyZ2V0XCI7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9iID0gXCJjdXJyZW50VGFyZ2V0XCI7XG4gICAgICB9XG4gICAgICBpZiAod2luW3czY19hdHRhY2hdICYmICFpc0lFKSB7XG4gICAgICAgIHVzZV9hdHRhY2ggPSB3M2NfYXR0YWNoO1xuICAgICAgICB1c2VfZGV0YWNoID0gdzNjX2RldGFjaDtcbiAgICAgIH0gZWxzZSBpZiAoaXNJRSkge1xuICAgICAgICB1c2VfaWVfb2xkX2F0dGFjaCA9IHRydWU7XG4gICAgICAgIHVzZV9hdHRhY2ggPSBpZV9hdHRhY2g7XG4gICAgICAgIHVzZV9kZXRhY2ggPSBpZV9kZXRhY2g7XG4gICAgICB9XG4gICAgICBvYmogPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqID0gdGhlRG9jdW1lbnRbQ1JFQVRFX0VWRU5UXShFVlRfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICBvYmogPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYmogPSB0aGVEb2N1bWVudFtDUkVBVEVfRVZFTlRdKEVWVF9UWVBFICsgXCJzXCIpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgb2JqID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iaikge1xuICAgICAgICBmb3IgKHByb3AgaW4gRVZUX0NOQ0xfTUVUSE9EUykge1xuICAgICAgICAgIGlmIChvYmpbcHJvcF0pIHtcbiAgICAgICAgICAgIEVWVF9DTkNMX01FVEhPRFNbcHJvcF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqID0gbnVsbDtcbiAgICAgIGF0dGFjaCh3aW4sIFwibG9hZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICByZXR1cm4gYXR0YWNoKHdpbiwgXCJET01Db250ZW50TG9hZGVkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBkb20gPSB7XG4gICAgICBkb2M6IGRvYyxcbiAgICAgIHZpZXc6IHZpZXcsXG4gICAgICBlbHQ6IGVsdCxcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICB0YWdzOiB0YWdzLFxuICAgICAgcGFyOiBwYXIsXG4gICAgICBtYWtlOiBtYWtlX2VsZW1lbnQsXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIGF0dHI6IGF0dHIsXG4gICAgICBnYzogZ2MsXG4gICAgICBhcHBlbmQ6IGFwcGVuZCxcbiAgICAgIHB1cmdlOiBwdXJnZSxcbiAgICAgIGF0dGFjaDogYXR0YWNoLFxuICAgICAgZGV0YWNoOiBkZXRhY2gsXG4gICAgICByZWFkeTogcmVhZHksXG4gICAgICB3YWl0OiB3YWl0LFxuICAgICAgZXZ0Q25jbDogZXZ0Q25jbCxcbiAgICAgIGV2dFRndDogZXZ0VGd0LFxuICAgICAgaWZyYW1lczoge1xuICAgICAgICBtYWtlOiBtYWtlX2lmcmFtZSxcbiAgICAgICAgY2xvbmU6IGNsb25lX2lmcmFtZSxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZV9pZnJhbWUsXG4gICAgICAgIHZpZXc6IGlmcmFtZV92aWV3XG4gICAgICB9XG4gICAgfTtcbiAgfSkod2luZG93LCBsYW5nLCBlbnYpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGxhbmcsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgbGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBjYWNoZWRfdWEsIGlzSUUsIGlzSUUxMSwgbmF2aWdhdG9yLCB0aGVEb2N1bWVudCwgdWEsIHVzZXJBZ2VudCwgd2luO1xuICAgIHdpbiA9IHdpbmRvdztcbiAgICBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuICAgIHRoZURvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHVzZXJBZ2VudCA9IChuYXZpZ2F0b3IgIT0gbnVsbCA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiB2b2lkIDApIHx8IFwiXCI7XG4gICAgaXNJRTExID0gIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmIF9faW5kZXhPZi5jYWxsKHdpbmRvdywgXCJBY3RpdmVYT2JqZWN0XCIpID49IDA7XG4gICAgaXNJRSA9ICFpc0lFMTEgJiYgKHdpbiAmJiAoX19pbmRleE9mLmNhbGwod2luLCBcIkFjdGl2ZVhPYmplY3RcIikgPj0gMCkpO1xuICAgIGNhY2hlZF91YSA9IG51bGw7XG4gICAgdWEgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgIC8qXG4gICAgICBDb252ZXJ0IGEgdmVyc2lvbiBzdHJpbmcgaW50byBhIG51bWVyaWMgdmFsdWVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS1fbnVtYmVyaWZ5XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gcyBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIHZlcnNpb24gbnVtYmVyIChlLmcuICdtYWpvci5taW5vci5yZXZpc2lvbicpXG4gICAgICBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB2YXIgcGFyc2VfdWEsIF9tYXRjaEl0LCBfbnVtYmVyaWZ5LCBfdGVzdEl0O1xuICAgICAgX251bWJlcmlmeSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIGMgPSAwO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnJlcGxhY2UoL1xcLi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYysrID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFdyYXBwZXIgbWV0aG9kIGZvciByZXR1cm5pbmcgdmFsdWVzIGZyb20gYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2ggc2FmZWx5LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLV9tYXRjaEl0XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgQHBhcmFtIHtSZWdFeHB9IHJlZ0V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdXNlIGZvciBtYXRjaGluZ1xuICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtpZHhdIFRoZSBpbmRleCBudW1iZXIgb2YgYSBtYXRjaCB0byBwdWxsIGZyb21cbiAgICAgIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIF9tYXRjaEl0ID0gZnVuY3Rpb24oc3RyLCByZWdFeCwgaWR4KSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICBtID0gc3RyICYmIHN0ci5tYXRjaChyZWdFeCk7XG4gICAgICAgIGlmICghKGlkeCAhPSBudWxsKSkge1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAobSAmJiBtW2lkeF0pIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBXcmFwcGVyIG1ldGhvZCBmb3IgdGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEtX3Rlc3RJdFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtSZWdFeHB9IHJlZ0V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdGVzdCB3aXRoXG4gICAgICBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICBAcGFyYW0ge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90ZXN0SXQgPSBmdW5jdGlvbihyZWdFeCwgc3RyKSB7XG4gICAgICAgIHJldHVybiByZWdFeC50ZXN0KHN0cik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUGFyc2UgYSB1c2VyLWFnZW50IHN0cmluZyBmcm9tIHRoZSBicm93c2VyIGFuZCBnYXRoZXIgcGVydGluZW50IGJyb3dzZXIsIGFuZCBPUyBpbmZvcm1hdGlvblxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnBhcnNlXG4gICAgICBAc3RhdGljXG4gICAgICBAcHVibGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbc3ViVUFdIEFuIGFsdGVybmF0ZSB1c2VyLWFnZW50IHN0cmluZyB0byBwYXJzZS4gSWYgbm8gdmFsaWQgc3RyaW5nIGlzIHBhc3NlZCBpbiwgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gb2JqZWN0IGJhc2VkIG9uIHRoZSBrbm93biB1c2VyLWFnZW50XG4gICAgICBAcmV0dXJucyB7T2JqZWN0fSA8Yj5wYXJzZWQ8L2I+IEJyb3dzZXIgYW5kIE9TIGluZm9ybWF0aW9uPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmllICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+Lm9wZXJhIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgT3BlcmEgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uZ2Vja28gVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBHZWNrbyAoRmlyZWZveCkgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ud2Via2l0IFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViS2l0IGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnNhZmFyaSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNhZmFyaSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5jaHJvbWUgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDaHJvbWUgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uYWlyIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQUlSIFNESyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaXBvZCBXaGV0aGVyIG9yIG5vdCBhbiBpUG9kIGRldmljZSBpcyBiZWluZyB1c2VkIDEgZm9yIHRydWUsIDAgZm9yIGZhbHNlLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pcGFkIFdoZXRoZXIgb3Igbm90IGFuIGlQYWQgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmlwaG9uZSBXaGV0aGVyIG9yIG5vdCBhbiBpUGhvbmUgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmFuZHJvaWQgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBbmRyb2lkIE9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi53ZWJvcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYk9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5zaWxrIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2lsayBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5ub2RlanMgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBOb2RlSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnBoYW50b21qcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFBoYW50b21KUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtTdHJpbmd9IDxiPnBhcnNlZDwvYj4ubW9iaWxlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIG9zIGlzIGEgbW9iaWxlIGRldmljZSAgYW5kIGl0J3MgdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSAnd2luZG93cycsICdhbmRyb2lkJywgJ3N5bWJvcycsICdsaW51eCcsICdtYWNpbnRvc2gnLCAncmhpbm8nLCAnZ2Vja28nLCAnQXBwbGUnLCAnY2hyb21lJy48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaW9zIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgaU9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge0Jvb2xlYW59IDxiPnBhcnNlZDwvYj4uYWNjZWwgV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBlbnZpcm9ubWVudCBpbiBxdWVzdGlvbiBpcyBoYXJkd2FyZSBhY2NlbGVyYXRlZC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uY2FqYVZlcnNpb24gVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDQUpBIGVudmlyb25tZW50IG9yIDAgaWYgbm90LlxuICAgICAgICovXG4gICAgICBwYXJzZV91YSA9IGZ1bmN0aW9uKHN1YlVBKSB7XG4gICAgICAgIHZhciBkYXRlLCBlLCBtYXRjaCwgcmV0O1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmICghc3ViVUEgJiYgY2FjaGVkX3VhKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZF91YTtcbiAgICAgICAgfVxuICAgICAgICByZXQuaWUgPSByZXQub3BlcmEgPSByZXQuZ2Vja28gPSByZXQud2Via2l0ID0gcmV0LnNhZmFyaSA9IHJldC5jaHJvbWUgPSByZXQuYWlyID0gcmV0Lmlwb2QgPSByZXQuaXBhZCA9IHJldC5pcGhvbmUgPSByZXQuYW5kcm9pZCA9IHJldC53ZWJvcyA9IHJldC5zaWxrID0gcmV0Lm5vZGVqcyA9IHJldC5waGFudG9tanMgPSAwO1xuICAgICAgICByZXQubW9iaWxlID0gcmV0LmlvcyA9IHJldC5vcyA9IG51bGw7XG4gICAgICAgIHJldC5hY2NlbCA9IGZhbHNlO1xuICAgICAgICByZXQuY2FqYSA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuY2FqYVZlcnNpb247XG4gICAgICAgIHJldC5ja3MgPSBmYWxzZTtcbiAgICAgICAgc3ViVUEgPSBzdWJVQSB8fCB1c2VyQWdlbnQgfHwgXCJcIjtcbiAgICAgICAgaWYgKHN1YlVBKSB7XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL3dpbmRvd3N8d2luMzIvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcIndpbmRvd3NcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL21hY2ludG9zaHxtYWNfcG93ZXJwYy9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwibWFjaW50b3NoXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9hbmRyb2lkL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJhbmRyb2lkXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9zeW1ib3MvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcInN5bWJvc1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvbGludXgvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcImxpbnV4XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfdGVzdEl0KC9yaGluby9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgcmV0Lm9zID0gXCJyaGlub1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvS0hUTUwvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC53ZWJraXQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvSUVNb2JpbGV8WEJMV1A3Lywgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQubW9iaWxlID0gXCJ3aW5kb3dzXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9GZW5uZWMvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcImdlY2tvXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BcHBsZVdlYktpdFxcLyhbXlxcc10qKS8sIDEpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0LndlYmtpdCA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgcmV0LnNhZmFyaSA9IHJldC53ZWJraXQ7XG4gICAgICAgICAgICBpZiAoX3Rlc3RJdCgvUGhhbnRvbUpTLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9QaGFudG9tSlNcXC8oW15cXHNdKikvLCAxKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0LnBoYW50b21qcyA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3Rlc3RJdChSZWdFeHAoXCIgTW9iaWxlXFxcXC9cIiksIHN1YlVBKSB8fCBfdGVzdEl0KC9pUGFkfGlQb2R8aVBob25lLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIkFwcGxlXCI7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9PUyAoW15cXHNdKikvLCAxKTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaCAmJiBfbnVtYmVyaWZ5KG1hdGNoLnJlcGxhY2UoXCJfXCIsIFwiLlwiKSk7XG4gICAgICAgICAgICAgIHJldC5pb3MgPSBtYXRjaDtcbiAgICAgICAgICAgICAgcmV0LmlwYWQgPSByZXQuaXBvZCA9IHJldC5pcGhvbmUgPSAwO1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvaVBhZHxpUG9kfGlQaG9uZS8sIDApO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXRbbWF0Y2gudG9Mb3dlckNhc2UoKV0gPSByZXQuaW9zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvTm9raWFOW15cXC9dKnxBbmRyb2lkIFxcZFxcLlxcZHx3ZWJPU1xcL1xcZFxcLlxcZC8sIDApO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gbWF0Y2g7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoL3dlYk9TLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiV2ViT1NcIjtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvd2ViT1NcXC8oW15cXHNdKik7LywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQud2Vib3MgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoUmVnRXhwKFwiIEFuZHJvaWRcIiksIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIkFuZHJvaWRcIjtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvQW5kcm9pZCAoW15cXHNdKik7LywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQuYW5kcm9pZCA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvU2lsay8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9TaWxrXFwvKFteXFxzXSopXFwpLywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQuc2lsayA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJldC5hbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICByZXQuYW5kcm9pZCA9IDIuMzQ7XG4gICAgICAgICAgICAgICAgICByZXQub3MgPSBcIkFuZHJvaWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoL0FjY2VsZXJhdGVkPXRydWUvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hY2NlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCA9IHN1YlVBLm1hdGNoKC8oQ2hyb21lfENyTW8pXFwvKFteXFxzXSopLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0gJiYgbWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgcmV0LmNocm9tZSA9IF9udW1iZXJpZnkobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICByZXQuc2FmYXJpID0gMDtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSBcIkNyTW9cIikge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcImNocm9tZVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvQWRvYmVBSVJcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0LmFpciA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmV0LndlYmtpdCkge1xuICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09wZXJhW1xcc1xcL10oW15cXHNdKikvLCAxKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICByZXQub3BlcmEgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09wZXJhIE1pbmlbXjtdKi8sIDApO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gbWF0Y2g7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9NU0lFXFxzKFteO10qKS8sIDEpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQuaWUgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvR2Vja29cXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5nZWNrbyA9IDE7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvcnY6KFteXFxzXFwpXSopLywgMSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmdlY2tvID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgMTAwMCk7XG4gICAgICAgICAgdGhlRG9jdW1lbnQuY29va2llID0gbGFuZy5jc3RyKFtcInNmX2NrX3RzdD10ZXN0OyBleHBpcmVzPVwiLCBkYXRlLnRvR01UU3RyaW5nKCksIFwiOyBwYXRoPS9cIl0pO1xuICAgICAgICAgIGlmICh0aGVEb2N1bWVudC5jb29raWUuaW5kZXhPZihcInNmX2NrX3RzdFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldC5ja3MgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICByZXQuY2tzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgICAgICAgICByZXQub3MgPSBwcm9jZXNzLnBsYXRmb3JtO1xuICAgICAgICAgICAgICByZXQubm9kZWpzID0gbnVtYmVyaWZ5KHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJldC5ub2RlanMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBJbnRlcm5ldCBFeHBsb3JlciBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmllXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE9wZXJhIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAbmFtZSAkc2YuZW52LnVhLm9wZXJhXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEdlY2tvIChGaXJlZm94KSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5nZWNrb1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJLaXQgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEud2Via2l0XG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNhZmFyaSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5zYWZhcmlcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ2hyb21lIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmNocm9tZVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBSVIgU0RLIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5haXJcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IGFuIGlQb2QgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcG9kXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCBhbiBpUGFkIGRldmljZSBpcyBiZWluZyB1c2VkLCAwIGZvciBmYWxzZSwgJmd0OyAwID09IHRydWVcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaXBhZFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgYW4gaVBob25lIGRldmljZSBpcyBiZWluZyB1c2VkLCAwIGZvciBmYWxzZSwgJmd0OyAwID09IHRydWVcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaXBob25lXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFuZHJvaWQgT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmFuZHJvaWRcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLndlYm9zXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNpbGsgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuc2lsa1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBOb2RlSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLm5vZGVqc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBQaGFudG9tSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnBoYW50b21qc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gb3MgaXMgYSBtb2JpbGUgZGV2aWNlICBhbmQgaXQncyB0eXBlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd3aW5kb3dzJywgJ2FuZHJvaWQnLCAnc3ltYm9zJywgJ2xpbnV4JywgJ21hY2ludG9zaCcsICdyaGlubycsICdnZWNrbycsICdBcHBsZScsICdjaHJvbWUnLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLm1vYmlsZVxuICAgICAgQHR5cGUge1N0cmluZ31cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBpT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlvc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBlbnZpcm9ubWVudCBpbiBxdWVzdGlvbiBpcyBoYXJkd2FyZSBhY2NlbGVyYXRlZC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuYWNjZWxcbiAgICAgIEB0eXBlIHtCb29sZWFufVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENBSkEgZW52aXJvbm1lbnQgb3IgMCBpZiBub3RcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuY2FqYVZlcnNpb25cbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cbiAgICAgIGNhY2hlZF91YSA9IHBhcnNlX3VhKCk7XG4gICAgICBjYWNoZWRfdWEucGFyc2UgPSBwYXJzZV91YTtcbiAgICAgIHJldHVybiBjYWNoZWRfdWE7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdWE6IHVhLFxuICAgICAgaXNJRTogaXNJRVxuICAgIH07XG4gIH0pKHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiOER3b2hSXCIpKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIFBhcmFtSGFzaCwgYmFja1NsYXNoLCBjYWxsYWJsZSwgY2Jvb2wsIGNudW0sIGNzdHIsIGRlZiwgZW50aXR5TWFwLCBlbnRpdHlSZWdleGVzLCBndWlkLCBpc0FycmF5LCBqc3NhZmVfaHRtbCwga2V5cywgbGFuZywgbWl4LCBuZXh0X2lkLCBub29wLCBucywgcHJvdG8sIHJhbmQsIHNjcmlwX3N0ciwgdGltZSwgdG9TdHJpbmcsIHRyaW0sIHdpbiwgd3JhcCwgX2VzLCBfdWU7XG4gICAgbmV4dF9pZCA9IDA7XG4gICAgd2luID0gd2luZG93O1xuICAgIGJhY2tTbGFzaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTIpO1xuICAgIHNjcmlwX3N0ciA9ICdzY3JcIitcImlwdCc7XG4gICAgX2VzID0gd2luLmVzY2FwZTtcbiAgICBfdWUgPSB3aW4udW5lc2NhcGU7XG5cbiAgICAvKlxuICAgIEEgZnVuY3Rpb24gcmVmZXJlbmNlIHRoYXQgZG9lcyBub3RoaW5nLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBub29wIGFzICRzZi5saWIubGFuZy5ub29wXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwdWJsaWNcbiAgICBAcmV0dXJuIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIG5vb3AgPSBmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBOb3RlIHRoYXQgXCJmYWxzeVwiIHZhbHVlcyBvciB2YWx1ZXMgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgIGFzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikuXG4gICAgICBcbiAgICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICAgIEBleHBvcnRzIGNzdHIgYXMgJHNmLmxpYi5sYW5nLmNzdHJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHsqfSBzdHIgIEFueSBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9ICBUaGUgbm9ybWFsaXplZCBzdHJpbmcgdmFsdWUuXG4gICAgICAgKi9cbiAgICB9O1xuICAgIGNzdHIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciB0eXA7XG4gICAgICB0eXAgPSB0eXBlb2Ygc3RyO1xuICAgICAgaWYgKHR5cCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJudW1iZXJcIiAmJiAhc3RyKSB7XG4gICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwib2JqZWN0XCIgJiYgc3RyICYmIHN0ci5qb2luKSB7XG4gICAgICAgIHJldHVybiBzdHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIGJvb2xlYW4uXG4gICAgXCJGYWxzeVwiIHZhbHVlcyBzdWNoIGFzIFwiXCIsIDAsIG51bGwsIGFuZCB1bmRlZmluZWQgYWxsIHJldHVybiBmYWxzZVxuICAgIFN0cmluZyB2YWx1ZXMgb2YgIFwiMFwiLCBcImZhbHNlXCIsIFwibm9cIiwgXCJ1bmRlZmluZWRcIiwgXCJudWxsXCIgYWxzbyByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY2Jvb2wgYXMgJHNmLmxpYi5sYW5nLmNib29sXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyp9IHZhbCBBbnkgSmF2YVNjcmlwdCByZWZlcmVuY2UgLyB2YWx1ZVxuICAgIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub3JtYWxpemVkIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBjYm9vbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKCF2YWwgfHwgdmFsID09PSBcIjBcIiB8fCB2YWwgPT09IFwiZmFsc2VcIiB8fCB2YWwgPT09IFwibm9cIiB8fCB2YWwgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBrLCBfdjtcbiAgICAgIHJldHVybiAodHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3Qua2V5cyhvYmopIDogdm9pZCAwKSB8fCAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICBfdiA9IG9ialtrXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBudW1iZXIuXG4gICAgVmFsdWVzIC8gb2JqZWN0cyB0aGF0IGNhbm5vdCBiZSBjb252ZXJ0ZWQsIHdpbGwgYmUgcmV0dXJuZWQgYXMgTmFOLCB1bmxlc3NcbiAgICBhIGRlZmF1bHQgdmFsdWUgaXMgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHVzZWQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGNudW0gYXMgJHNmLmxpYi5sYW5nLmNudW1cbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7Kn0gdmFsIEFueSBKYXZhU2NyaXB0IHJlZmVyZW5jZSAvIHZhbHVlXG4gICAgQHBhcmFtIHsqfSBbZGVmVmFsXSB1c2UgdGhpcyB2YWx1ZSBpZiBvcmlnaW5hbCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLCBvciBpZiB2YWx1ZSBpcyBsZXNzIHRoYW4gbWluIHZhbHVlLCBvciBpZiB2YWx1ZSBpcyBsZXNzIHRoYW4gbWF4IHZhbHVlLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbbWluVmFsXSBzcGVjaWZpZXMgdGhlIGxvd2VzdCBudW1lcmljYWwgdmFsdWUsIGlmIG9yaWdpbmFsIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLCB0aGUgZGVmVmFsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgQHBhcmFtIHtOdW1iZXJ9IFttYXhWYWxdIHNwZWNpZmllcyB0aGUgZ3JlYXRlc3QgbnVtZXJpY2FsIHZhbHVlLCBpZiBvcmlnaW5hbCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGRlZlZhbCB3aWxsIGJlIHJldHVybmVkLlxuICAgIEByZXR1cm4ge051bWJlcnxOYU58Kn0gdGhlIGNvbnZlcnRlZCB2YWx1ZSwgb3RoZXJ3aXNlIE5hTiBvciBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgY251bSA9IGZ1bmN0aW9uKHZhbCwgZGVmVmFsLCBtaW5WYWwsIG1heFZhbCkge1xuICAgICAgdmFyIGU7XG4gICAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHZhbCA9IE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXhWYWwgPT0gbnVsbCkge1xuICAgICAgICBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKG1pblZhbCA9PSBudWxsKSB7XG4gICAgICAgIG1pblZhbCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKChpc05hTih2YWwpIHx8IHZhbCA8IG1pblZhbCB8fCB2YWwgPiBtYXhWYWwpICYmIChkZWZWYWwgIT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZlZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIHRoYXQgYSBmdW5jdGlvbiByZWZlcmVuY2UgY2FuIGJlIGNhbGxlZCBzYWZlbHkuICBTb21ldGltZXMgZnVuY3Rpb24gcmVmZXJlbmNlcyBhcmUgcGFydFxuICAgIG9mIG9iamVjdHMgdGhhdCBtYXkgaGF2ZSBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkIChzdWNoIGFzIGEgZnVuY3Rpb24gcmVmZXJlbmNlIGZyb20gYW5vdGhlciB3aW5kb3cgb3IgZG9tIGVsZW1lbnQpLlxuICAgIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGUgcmVmZXJlbmNlIGJ5IG1ha2luZyBzdXJlIGl0IGhhcyBhIGNvbnN0cnVjdG9yIGFuZCB0b1N0cmluZyBwcm9wZXJ0aWVzLlxuICAgIFxuICAgIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBmdW5jdGlvbiBpdHNlbGYgd2hlbiBjYWxsZWQgKG9yIGl0cyBzdWJzcXVlbnQgY2FsbCBzdGFjayksIGNhbid0IHRocm93IGFuIGVycm9yLiAuIC5cbiAgICBzaW1wbHkgdGhhdCB5b3UgYXJlIGFibGUgdG8gY2FsbCBpdC4gLiAuXG4gICAgXG4gICAgdGhpcyBjYW4gcHJvYmxlbSBiZSByZW1vdmVkIGluIGxpZXUgb2YgZnVuYz8oKSBpbiBjc1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjYWxsYWJsZSBhcyAkc2YubGliLmxhbmcuY2FsbGFibGVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IEEgcmVmZXJlbmNlIHRvIGEgSmF2YVNjcmlwdCBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBzYWZlbHksIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBjYWxsYWJsZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHZhciBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiA9IChmICYmIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIgJiYgZi50b1N0cmluZygpICYmIChuZXcgZi5jb25zdHJ1Y3RvcigpKSA/IGYgOiBudWxsKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBmID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIWY7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2VuZXJhdGUgYSB1bmlxdWUgaWQgc3RyaW5nXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGd1aWQgYXMgJHNmLmxpYi5sYW5nLmd1aWRcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBhIHN1YnN0cmluZyB0byB1c2UgYSBwcmVmaXhcbiAgICBAcmV0dXJuIHtTdHJpbmd9IHVuaXF1ZSBpZCBzdHJpbmdcbiAgICAgKi9cbiAgICBndWlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICByZXR1cm4gY3N0cihbcHJlZml4IHx8IFwiXCIsIFwiX1wiLCB0aW1lKCksIFwiX1wiLCByYW5kKCksIFwiX1wiLCBuZXh0X2lkKytdKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNaXhlZCB0aGUgcHJvcGVydGllcyBvZiBvbmUgb2JqZWN0IGludG8gYW5vdGhlciBvYmplY3QuXG4gICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgcmVjdXJzaXZlXG4gICAgXG4gICAgXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG1peCBhcyAkc2YubGliLmxhbmcubWl4XG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge09iamVjdH0gIHIgIFRoZSBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGVydGllc1xuICAgIEBwYXJhbSB7T2JqZWN0fSAgcyAgVGhlIG9iamVjdCB0aGF0IHdpbGwgZGVsaWV2ZXIgcHJvcGVydGllc1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW293bmVkXSBXaGV0aGVyIG9yIG5vdCB0byBza2lwIG92ZXIgcHJvcGVydGllcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBvYmplY3QgcHJvdG90eXBlXG4gICAgQHBhcmFtIHtCb29sZWFufSBbc2tpcEZ1bmNzXSBXaGV0aGVyIG9yIG5vdCB0byBza2lwIG92ZXIgZnVuY3Rpb24gcmVmZXJlbmNlc1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW25vX292cl0gV2hldGhlciBvciBub3QgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgdGhhdCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gZmlsbGVkIG91dFxuICAgIEByZXR1cm4ge09iamVjdH0gVGhlIHJlY2VpdmVyIG9iamVjdCBwYXNzZWQgaW4gd2l0aCBwb3RlbnRpYWxseSBuZXcgcHJvcGVydGllcyBhZGRlZFxuICAgICAqL1xuICAgIG1peCA9IGZ1bmN0aW9uKHIsIHMsIG93bmVkLCBza2lwRnVuY3MsIG5vX292cikge1xuICAgICAgdmFyIGl0ZW0sIHAsIHR5cDtcbiAgICAgIGlmICghcyB8fCAhcikge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGZvciAocCBpbiBzKSB7XG4gICAgICAgIGl0ZW0gPSBzW3BdO1xuICAgICAgICB0eXAgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKG93bmVkICYmICFzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vX292ciAmJiAocCBpbiByKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwRnVuY3MgJiYgdHlwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwID09PSBcIm9iamVjdFwiICYmIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoaXRlbS5zbGljZSkge1xuICAgICAgICAgICAgaXRlbSA9IG1peChbXSwgaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtaXgoe30sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByW3BdID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcywgZnJvbSB0aGUgZXBvY2hcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgdGltZSBhcyAkc2YubGliLmxhbmcudGltZVxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHJldHVybiB7TnVtYmVyfSBjdXJyZW50IHRpbWVcbiAgICAgKi9cbiAgICB0aW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBhbnl3aGVyZSBmcm9tIDAgdG8gOTlcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgcmFuZCBhcyAkc2YubGliLmxhbmcucmFuZFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHJldHVybiB7TnVtYmVyfSByYW5kb20gbnVtYmVyXG4gICAgICovXG4gICAgcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVHJpbSB0aGUgYmVnaW5pbmcgYW5kIGVuZGluZyB3aGl0ZXNwYWNlIGZyb20gYSBzdHJpbmcuXG4gICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGFuIGFyZ3VtZW50IHRvIGEgc3RyaW5nIGZpcnN0XG4gICAgZm9yIHR5cGUgc2FmZXR5IHB1cnBvc2VzLiBJZiBzdHJpbmcgY2Fubm90IGJlIGNvbnZlcnRlZCwgYW5kIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyB0cmltIGFzICRzZi5saWIubGFuZy50cmltXG4gICAgQHJldHVybiB7U3RyaW5nfSB0cmltbWVkIHN0cmluZ1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgdHJpbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHJldDtcbiAgICAgIHJldCA9IGNzdHIoc3RyKTtcbiAgICAgIHJldHVybiByZXQgJiYgcmV0LnJlcGxhY2UoL15cXHNcXHMqLywgXCJcIikucmVwbGFjZSgvXFxzXFxzKiQvLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBEZWZpbmUgYSBKYXZhU2NyaXB0IE5hbWVzcGFjZSB3aXRoaW4gYSBnaXZlbiBjb250ZXh0XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGRlZiBhcyAkc2YubGliLmxhbmcuZGVmXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cl9ucyAgVGhlIG5hbWUgb2YgdGhlIG5hbWVzcGFjZSBpbiBkb3Qgbm90YXRpb24gYXMgYSBzdHJpbmcgKGUuZy4gXCJGb28uYmFyXCIpXG4gICAgQHBhcmFtIHtPYmplY3R9IFthdWddIGRlZmluZXMgdGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lc3BhY2UuICBJZiBuYW1lc3BhY2UgaXMgYWxyZWFkeSBzcGVjaWZpZWQsIGFuZCB0aGlzIG9iamVjdCBpcyBwcm92aWRlZCwgdGhlIG5hbWVzcGFjZSB3aWxsIGJlIGF1Z21lbnRlZCB3aXRoIHByb3BlcnRpZXMgZnJvbSB0aGlzIG9iamVjdC4gSWYgbm90aGluZyBpcyBwYXNzZWQgaW4sIGRlZmF1bHRzIHRvIHVzaW5nIGFuIGVtcHR5IG9iamVjdC5cbiAgICBAcGFyYW0ge09iamVjdH0gW3Jvb3RdIHRoZSByb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBuYW1lc3BhY2UgaXMgZGVmaW5lZC4gIElmIG5vdCBwYXNzZWQgaW4gZGVmYXVsdHMgdG8gdGhlIGdsb2JhbC93aW5kb3cgb2JqZWN0XG4gICAgQHBhcmFtIHtCb29sZWFufSBbbm9fb3ZyXSBpZiB0cnVlLCBwcm9wZXJ0aWVzIGFscmVhZHkgZGVmaW5lZCBvbiByb290IHdpdGggdGhlIHNhbWUgbmFtZSB3aWxsIGJlIGlnbm9yZWRcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBkZWYgPSBmdW5jdGlvbihzdHJfbnMsIGF1Zywgcm9vdCwgbm9fb3ZyKSB7XG4gICAgICB2YXIgYXIsIGlkeCwgaXRlbSwgb2JqLCBwZXIsIHJldDtcbiAgICAgIG9iaiA9IChyb290ICYmIHR5cGVvZiByb290ID09PSBcIm9iamVjdFwiID8gcm9vdCA6IHdpbik7XG4gICAgICBpZHggPSAwO1xuICAgICAgcGVyID0gXCIuXCI7XG4gICAgICByZXQgPSBudWxsO1xuICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICBzdHJfbnMgPSBjc3RyKHN0cl9ucyk7XG4gICAgICAgIGF1ZyA9IChhdWcgJiYgdHlwZW9mIGF1ZyA9PT0gXCJvYmplY3RcIiA/IGF1ZyA6IG51bGwpO1xuICAgICAgICBpZiAoc3RyX25zLmluZGV4T2YocGVyKSkge1xuICAgICAgICAgIGFyID0gc3RyX25zLnNwbGl0KHBlcik7XG4gICAgICAgICAgd2hpbGUgKGl0ZW0gPSBhcltpZHgrK10pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0cmltKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChvYmpbaXRlbV0gJiYgYXVnKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gbWl4KG9ialtpdGVtXSwgYXVnLCBmYWxzZSwgbnVsbCwgbm9fb3ZyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9fb3ZyICYmIChpdGVtIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gb2JqW2l0ZW1dIHx8IGF1ZyB8fCB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChub19vdnIgJiYgKGl0ZW0gaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV0gPSBvYmpbaXRlbV0gfHwge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9ialtpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9ialtzdHJfbnNdICYmIGF1Zykge1xuICAgICAgICAgICAgcmV0ID0gb2JqW3N0cl9uc10gPSBtaXgob2JqW3N0cl9uc10sIGF1ZywgZmFsc2UsIG51bGwsIG5vX292cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IG9ialtzdHJfbnNdID0gb2JqW3N0cl9uc10gfHwgYXVnIHx8IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBKYXZhU2NyaXB0IG5hbWVzcGFjZVxuICAgIGFzIG9wcG9zZWQgdG8gZGVmLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmaW5lIHRoZSBuYW1lc3BhY2VcbiAgICB3aXRoIGEgZ2l2ZW4gY29udGV4dC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgbnMgYXMgJHNmLmxpYi5sYW5nLm5zXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cl9ucyAgQSBzdHJpbmcgd2l0aCAuIG9yIFtdIG5vdGF0aW9uIG9mIGEgSmF2YVNjcmlwdCBuYW1lc2FjZSAoZS5nLiBcImZvby5iYXIuc2hvd1wiLCBvciBcImZvb1snYmFyJ11bJ3Nob3cnXVwiKS5cbiAgICBAcGFyYW0ge09iamVjdH0gW3Jvb3RdIHRoZSByb290IG9iamVjdCB0byBjaGVjayB3aXRoaW4uIC5kZWZhdWx0cyB0byBnbG9iYWwgLyB3aW5kb3dcbiAgICBAcmV0dXJuIHsqfSBUaGUgZW5kcG9pbnQgcmVmZXJlbmNlIG9mIHRoZSBuYW1lc3BhY2Ugb3IgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICBucyA9IGZ1bmN0aW9uKHN0cl9ucywgcm9vdCkge1xuICAgICAgdmFyIGV4aXN0cywgZXhwLCBleHAyLCBleHAzLCBleHA0LCBpZHgsIG1hdGNoZXMsIG9iaiwgcHJvcCwgcm9vdFN0cjtcbiAgICAgIGV4cCA9IC8oXFxbKC57MSx9KVxcXSl8KFxcLlxcdyspL2c7XG4gICAgICBleHAyID0gL1xcWygoJ3xcIik/KSgoXFxzfC4pKj8pKCgnfFwiKT8pXFxdL2c7XG4gICAgICBleHAzID0gLyhcXFsuKil8KFxcLi4qKS9nO1xuICAgICAgZXhwNCA9IC9cXC4vZztcbiAgICAgIGlkeCA9IDA7XG4gICAgICByb290U3RyID0gXCJcIjtcbiAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICBvYmogPSByb290ID0gcm9vdCB8fCB3aW47XG4gICAgICBpZiAoc3RyX25zKSB7XG4gICAgICAgIHN0cl9ucyA9IGNzdHIoc3RyX25zKTtcbiAgICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICAgIHN0cl9ucyA9IHRyaW0oc3RyX25zKTtcbiAgICAgICAgICBtYXRjaGVzID0gc3RyX25zLm1hdGNoKGV4cCk7XG4gICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJvb3RTdHIgPSBzdHJfbnMucmVwbGFjZShleHAzLCBcIlwiKTtcbiAgICAgICAgICAgIG1hdGNoZXMudW5zaGlmdChyb290U3RyKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9wID0gbWF0Y2hlc1tpZHgrK10pIHtcbiAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZShleHAyLCBcIiQzXCIpLnJlcGxhY2UoZXhwNCwgXCJcIik7XG4gICAgICAgICAgICAgIGlmICghb2JqW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wID0gc3RyX25zO1xuICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGV4aXN0cyAmJiBvYmopIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBmdW5jdGlvblxuICAgIFRlc3RzIHRvIHNlZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpcyBhbiBhcnJheVxuICAgICAqL1xuICAgIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKG9iai5sZW5ndGggIT0gbnVsbCkgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBKYXZhU2NyaXB0IG5hbWVzcGFjZVxuICAgIGFzIG9wcG9zZWQgdG8gZGVmLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmaW5lIHRoZSBuYW1lc3BhY2VcbiAgICB3aXRoIGEgZ2l2ZW4gY29udGV4dC4gICAgICAgICB2aWEgdW5kZXJzY29yZS5qc1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBucyBhcyAkc2YubGliLmxhbmcud3JhcFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIGZ1bmN0aW9uXG4gICAgQHJldHVybiB7RnVuY3Rpb259XG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICB3cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgYXJncyA9IFtmdW5jXTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdpdmVuIGEgc3RyaW5nIG9mIEhUTUwgZXNjYXBlIHF1b3RlIG1hcmtzIGFuZCBzZXBlcmF0ZSBzY3JpcHQgdGFncyBzbyB0aGF0IGJyb3dzZXJzIGRvbid0IGdldCB0cmlwcGVkIHVwXG4gICAgZHVyaW5nIHByb2Nlc3NpbmcuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGpzc2FmZV9odG1sIGFzICRzZi5saWIubGFuZy5qc3NhZmVfaHRtbFxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBzdHJpbmcgb2YgSFRNTCBtYXJrdXAgdG8gYmUgcHJvY2Vzc2VkXG4gICAgQHJldHVybiB7U3RyaW5nfVxuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgICovXG4gICAgZW50aXR5TWFwID0ge1xuICAgICAgZXNjYXBlOiB7XG4gICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgICB9XG4gICAgfTtcbiAgICBlbnRpdHlSZWdleGVzID0ge1xuICAgICAgZXNjYXBlOiBuZXcgUmVnRXhwKCdbJyArIGtleXMoZW50aXR5TWFwLmVzY2FwZSkuam9pbignJykgKyAnXScsICdnJylcbiAgICB9O1xuICAgIGpzc2FmZV9odG1sID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgnJyArIHN0cmluZykucmVwbGFjZShlbnRpdHlSZWdleGVzLmVzY2FwZSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcC5lc2NhcGVbbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQGNsYXNzIEludGFudGlhYmxlIGNsYXNzIHVzZWQgdG8gY29udmVydCBhIGRlbGltaXRlZCBzdHJpbmcgaW50byBhbiBvYmplY3QuPGJyIC8+XG4gICAgRm9yIGV4YW1wbGUgcXVlcnlzdHJpbmdzOiBcIm5hbWVfMT12YWx1ZV8xJm5hbWVfMj12YWx1ZV8yXCIgPT0+IHtuYW1lXzE6dmFsdWVfMSxuYW1lXzI6dmFsdWVfMn07PGJyLz48YnIgLz5cbiAgICBcbiAgICBOb3RlIHRoYXQgcHJvcGVydHkgdmFsdWVzIGNvdWxkIGFsc28gY29udGFpbiB0aGUgc2FtZSBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSBzdHJpbmdzLiAgUHJvcGVyIHN0cmluZyBlbmNvZGluZyBzaG91bGQgb2NjdXJcbiAgICB0byBub3QgdHJpcCB1cCB0aGUgcGFyc2luZyBvZiB0aGUgc3RyaW5nLiAgU2FpZCB2YWx1ZXMgbWF5IGJlIGFzY2lpIGVzY2FwZWQsIGFuZCBpbiB0dXJuLCBhbG9uZyB3aXRoIHRoZSA8aT48Yj5iUmVjdXJzZTwvYj48L2k+IGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzZXQgdG8gdHJ1ZSwgd2lsbCBjYXVzZSBuZXN0ZWQgUGFyYW1IYXNoIG9iamVjdHMgdG8gYmUgY3JlYXRlZC5cbiAgICBcbiAgICBAY29uc3RydWN0b3JcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgUGFyYW1IYXNoIGFzICRzZi5saWIubGFuZy5QYXJhbUhhc2hcbiAgICBAcGFyYW0ge1N0cmluZ30gW3NTdHJpbmddICBUaGUgZGVsaW1pdGVkIHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAgICBAcGFyYW0ge1N0cmluZ30gW3NQcm9wRGVsaW09XCImXCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlciB1c2VkIHRvIHNlcGVyYXRlIHByb3BlcnRpZXMuIERlZmF1bHQgaXMgXCImXCIuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzVmFsdWVEZWxpbT1cIj1cIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVkIHVzZWQgdG8gc2VwZXJhdGUgdmFsdWVzLiAgRGVmYXVsdCBpcyBcIj1cIi5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtiTm9PdmVyd3JpdGU9ZmFsc2VdICBJZiB0cnVlLCB3aGVuIGEgbmFtZSBpcyBlbmNvdW50ZXJlZCBtb3JlIHRoYW4gMSB0aW1lIGluIHRoZSBzdHJpbmcgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2JSZWN1cnNlPWZhbHNlXSAgSWYgdHJ1ZSwgd2hlbiBhIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCBpcyBwYXJzZWQgYWxzbyBoYXMgYm90aCB0aGUgc1Byb3BEZWxpbSBhbmQgc1ZhbHVlRGVsaW0gaW5zaWRlLCBjb252ZXJ0IHRoYXQgdmFsdWUgdG8gYW5vdGhlciBQYXJhbUhhc2ggb2JqZWN0IGF1dG9tYXRpY2FsbHlcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieD0xJnk9MSZ6PTFcIik7XG4gICAgYWxlcnQocGgueCk7IC8vID09IDFcbiAgICBhbGVydChwaC55KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnopOyAvLyA9PSAxXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng6MTt5OjI7ejozXCIsIFwiO1wiLCBcIjpcIik7XG4gICAgYWxlcnQocGgueCk7IC8vID09IDFcbiAgICBhbGVydChwaC55KTsgLy8gPT0gMlxuICAgIGFsZXJ0KHBoLnopOyAvLyA9PSAzXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng9MSZ5PTEmej0xJno9MlwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyAxXG4gICAgYWxlcnQocGgueik7IC8vTm90ZSB0aGF0IHogPT0gMiBiL2Mgb2YgMiBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4PTEmeT0xJno9MSZ6PTJcIixudWxsLG51bGwsdHJ1ZSk7IC8vbnVsbCBmb3Igc1Byb3BEZWxpbSBhbmQgc1ZhbHVlRGVsaW0gPT0gdXNlIGRlZmF1bHQgdmFsdWVzIG9mIFwiJlwiIGFuZCBcIj1cIiByZXNwZWN0aXZlbHlcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyAxXG4gICAgYWxlcnQocGgueik7IC8vTm90ZSB0aGF0IHogPT0gMSBiL2MgYk5vT3ZlcndyaXRlIHdhcyBzZXQgdG8gdHJ1ZVxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgLy9Zb3UgY2FuIGFsc28gZG8gcmVjdXJzaXZlIHByb2Nlc3NpbmcgaWYgbmVlZCBiZVxuICAgIHZhciBwb2ludHNcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKSxcbiAgICBwb2ludF8xXHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKCksXG4gICAgcG9pbnRfMlx0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpO1xuICAgIFxuICAgIHBvaW50XzEueCA9IDEwMDtcbiAgICBwb2ludF8xLnkgPSA3NTtcbiAgICBcbiAgICBwb2ludF8yLnggPSAyMDA7XG4gICAgcG9pbnRfMi55ID0gMTUwO1xuICAgIFxuICAgIHBvaW50cy5wb2ludF8xXHQ9IHBvaW50XzE7XG4gICAgcG9pbnRzLnBvaW50XzJcdD0gcG9pbnRfMjtcbiAgICBcbiAgICB2YXIgcG9pbnRfc3RyXHQ9IHBvaW50cy50b1N0cmluZygpOyAgLy8gPT0gXCJwb2ludF8xPXglM0QxMDAlMjZ5JTNENzUlMjYmcG9pbnRfMj14JTNEMjAwJTI2eSUzRDE1MCUyNiZcIjtcbiAgICB2YXIgcG9pbnRzX2NvcHlcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2gocG9pbnRfc3RyLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTsgLy9ub3RlIHBhc3NpbmcgdHJ1ZSwgYi9jIHdlIHdhbnQgdG8gcmVjdXJzZVxuICAgIFxuICAgIGFsZXJ0KHBvaW50c19jb3B5LnBvaW50XzEueCkgLy8gPT0gXCIxMDBcIjtcbiAgICAgKi9cbiAgICBQYXJhbUhhc2ggPSBmdW5jdGlvbihzU3RyaW5nLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSkge1xuICAgICAgdmFyIGFkZGVkLCBjbnQsIGRvQWRkLCBpZHgsIGlkeDIsIGlkeDMsIGlvLCBsZW4sIGxlbjIsIG1lLCBubSwgbnYsIG9iaiwgcGFpcnMsIHNUZW1wLCBzVGVtcDIsIHNUZW1wMywgc3M7XG4gICAgICBtZSA9IHRoaXM7XG4gICAgICBpbyA9IFwiaW5kZXhPZlwiO1xuICAgICAgc3MgPSBcInN1YnN0cmluZ1wiO1xuICAgICAgZG9BZGQgPSBmYWxzZTtcbiAgICAgIGlmICghKG1lIGluc3RhbmNlb2YgUGFyYW1IYXNoKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtSGFzaChzU3RyaW5nLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgfVxuICAgICAgaWYgKHNTdHJpbmcgJiYgdHlwZW9mIHNTdHJpbmcgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIG1peChuZXcgUGFyYW1IYXNoKFwiXCIsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKSwgc1N0cmluZyk7XG4gICAgICB9XG4gICAgICBzU3RyaW5nID0gY3N0cihzU3RyaW5nKTtcbiAgICAgIHNQcm9wRGVsaW0gPSBjc3RyKHNQcm9wRGVsaW0pIHx8IFwiJlwiO1xuICAgICAgc1ZhbHVlRGVsaW0gPSBjc3RyKHNWYWx1ZURlbGltKSB8fCBcIj1cIjtcbiAgICAgIGlmICghc1N0cmluZykge1xuICAgICAgICByZXR1cm4gbWU7XG4gICAgICB9XG4gICAgICBpZiAoc1Byb3BEZWxpbSAhPT0gXCI/XCIgJiYgc1ZhbHVlRGVsaW0gIT09IFwiP1wiICYmIHNTdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikge1xuICAgICAgICBzU3RyaW5nID0gc1N0cmluZ1tzc10oMSk7XG4gICAgICB9XG4gICAgICBpZHggPSBzU3RyaW5nW2lvXShcIj9cIik7XG4gICAgICBpZHgyID0gc1N0cmluZ1tpb10oc1ZhbHVlRGVsaW0pO1xuICAgICAgaWYgKGlkeCAhPT0gLTEgJiYgaWR4MiAhPT0gLTEgJiYgaWR4ID4gaWR4Mikge1xuICAgICAgICBzVGVtcCA9IF9lcyhzU3RyaW5nW3NzXShpZHgyICsgMSkpO1xuICAgICAgICBzVGVtcDIgPSBzU3RyaW5nLnN1YnN0cigwLCBpZHgyICsgMSk7XG4gICAgICAgIHNTdHJpbmcgPSBzVGVtcDIgKyBzVGVtcDtcbiAgICAgIH0gZWxzZSBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBzU3RyaW5nID0gc1N0cmluZ1tzc10oaWR4ICsgMSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1IYXNoKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNTdHJpbmcuY2hhckF0KDApID09PSBzUHJvcERlbGltKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXSgxKTtcbiAgICAgIH1cbiAgICAgIHBhaXJzID0gc1N0cmluZy5zcGxpdChzUHJvcERlbGltKTtcbiAgICAgIGNudCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGlkeCA9IDA7XG4gICAgICB3aGlsZSAoY250LS0pIHtcbiAgICAgICAgc1RlbXAgPSBwYWlyc1tpZHgrK107XG4gICAgICAgIGFkZGVkID0gZmFsc2U7XG4gICAgICAgIGRvQWRkID0gZmFsc2U7XG4gICAgICAgIGlmIChzVGVtcCkge1xuICAgICAgICAgIG52ID0gc1RlbXAuc3BsaXQoc1ZhbHVlRGVsaW0pO1xuICAgICAgICAgIGxlbiA9IG52Lmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgICAgbm0gPSBfdWUobnZbMF0pO1xuICAgICAgICAgICAgbnYuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChiUmVjdXJzZSkge1xuICAgICAgICAgICAgICBzVGVtcDIgPSBubSArIHNWYWx1ZURlbGltO1xuICAgICAgICAgICAgICBpZHgyID0gc1N0cmluZ1tpb10oc1RlbXAyKTtcbiAgICAgICAgICAgICAgbGVuID0gc1RlbXAyW0xFTl07XG4gICAgICAgICAgICAgIHNUZW1wMyA9IHNTdHJpbmdbc3NdKGlkeDIgKyBsZW4pO1xuICAgICAgICAgICAgICBzVGVtcDIgPSBzUHJvcERlbGltICsgc1Byb3BEZWxpbTtcbiAgICAgICAgICAgICAgbGVuMiA9IHNUZW1wMltMRU5dO1xuICAgICAgICAgICAgICBpZHgzID0gc1RlbXAzW2lvXShzVGVtcDIpO1xuICAgICAgICAgICAgICBpZiAoaWR4MyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzVGVtcDMgPSBzU3RyaW5nLnN1YnN0cihpZHgyICsgbGVuLCBpZHgzICsgbGVuMik7XG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IFBhcmFtSGFzaChzVGVtcDMsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgICAgICAgICAgICBzVGVtcDMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChzVGVtcDMgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlkeCArPSBsZW4gLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzVGVtcCA9IG9iajtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzVGVtcCA9IF91ZShudi5qb2luKHNWYWx1ZURlbGltKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNUZW1wID0gX3VlKG52LmpvaW4oc1ZhbHVlRGVsaW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvQWRkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgbm0gPSBfdWUobnZbMF0pO1xuICAgICAgICAgICAgc1RlbXAgPSBfdWUobnZbMV0pO1xuICAgICAgICAgICAgZG9BZGQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9BZGQpIHtcbiAgICAgICAgICAgIGlmIChiTm9PdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEobm0gaW4gbWUpKSB7XG4gICAgICAgICAgICAgICAgbWVbbm1dID0gc1RlbXA7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZVtubV0gPSBzVGVtcDtcbiAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJSZWN1cnNlICYmIGFkZGVkICYmIG5tICYmIHNUZW1wICYmIHR5cGVvZiBzVGVtcCAhPT0gXCJvYmplY3RcIiAmJiAoc1RlbXBbaW9dKHNQcm9wRGVsaW0pID49IDAgfHwgc1RlbXBbaW9dKHNWYWx1ZURlbGltKSA+PSAwKSkge1xuICAgICAgICAgICAgICBtZVtubV0gPSBuZXcgUGFyYW1IYXNoKHNUZW1wLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ29udmVydHMgYSBQYXJhbUhhc2ggb2JqZWN0IGJhY2sgaW50byBhIHN0cmluZyB1c2luZyB0aGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlbGltaXRlcnMgc3BlY2lmZWQgKGRlZmF1bHRzIHRvIFwiJlwiIGFuZCBcIj1cIikuXG4gICAgQWdhaW4gdGhpcyBtZXRob2Qgd29ya3MgcmVjdXJzaXZlbHkuICBJZiBhbiBvYmplY3QgaXMgZm91bmQgYXMgYSBwcm9wZXJ0eSwgaXQgd2lsbCBjb252ZXJ0IHRoYXQgb2JqZWN0IGludG8gYSBQYXJhbUhhc2ggc3RyaW5nXG4gICAgYW5kIHRoZW4gZXNjYXBlIGl0LiBOb3RlIGFsc28gdGhhdCB0aGlzIGNsYXNzJ3MgdmFsdWVPZiBtZXRob2QgaXMgZXF1YWwgdG8gdGhpcyBtZXRob2QuXG4gICAgXG4gICAgQG1ldGhvZE9mIFBhcmFtSGFzaCNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzUHJvcERlbGltPVwiJlwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZXIgdXNlZCB0byBzZXBlcmF0ZSBwcm9wZXJ0aWVzLiBEZWZhdWx0IGlzIFwiJlwiLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1ZhbHVlRGVsaW09XCI9XCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlZCB1c2VkIHRvIHNlcGVyYXRlIHZhbHVlcy4gIERlZmF1bHQgaXMgXCI9XCIuXG4gICAgQHBhcmFtIHtCb29sZWFufSBbZXNjYXBlUHJvcD1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gYXNjaWkgZXNjYXBlIHRoZSBuYW1lIG9mIGEgcHJvcGVydHlcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtkb250RXNjYXBlVmFsdWU9ZmFsc2VdIERvIG5vdCBlc2NhcGUgdmFsdWVzIG9yIHByb3BlcnRpZXMgYXV0b21hdGljYWxseVxuICAgIEByZXR1cm4ge1N0cmluZ30gdGhlIGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcgPSBmdW5jdGlvbihzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgZXNjYXBlUHJvcCwgZG9udEVzY2FwZVZhbHVlKSB7XG4gICAgICB2YXIgYnVmZmVyLCBpdGVtLCBpdGVtVHlwZSwgbWUsIHByb3A7XG4gICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgYnVmZmVyID0gW107XG4gICAgICBtZSA9IHRoaXM7XG4gICAgICBpdGVtVHlwZSA9IHZvaWQgMDtcbiAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICBzUHJvcERlbGltID0gc1Byb3BEZWxpbSB8fCBcIiZcIjtcbiAgICAgIHNWYWx1ZURlbGltID0gc1ZhbHVlRGVsaW0gfHwgXCI9XCI7XG4gICAgICBmb3IgKHByb3AgaW4gbWUpIHtcbiAgICAgICAgaXRlbSA9IG1lW3Byb3BdO1xuICAgICAgICBpdGVtVHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbVR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpdGVtID0gdG9TdHJpbmcuYXBwbHkoaXRlbSwgW3NQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBlc2NhcGVQcm9wLCBkb250RXNjYXBlVmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXNjYXBlUHJvcCkge1xuICAgICAgICAgIHByb3AgPSBfZXMocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb250RXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpdGVtID0gX2VzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHByb3AsIHNWYWx1ZURlbGltLCBpdGVtLCBzUHJvcERlbGltKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3RyKGJ1ZmZlcik7XG4gICAgfTtcbiAgICBwcm90byA9IFBhcmFtSGFzaC5wcm90b3R5cGU7XG4gICAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IHRyaW07XG4gICAgfVxuXG4gICAgLypcbiAgICBAaWdub3JlXG4gICAgICovXG4gICAgcHJvdG8udG9TdHJpbmcgPSBwcm90by52YWx1ZU9mID0gdG9TdHJpbmc7XG4gICAgbGFuZyA9IHtcbiAgICAgIFBhcmFtSGFzaDogUGFyYW1IYXNoLFxuICAgICAgY3N0cjogY3N0cixcbiAgICAgIGNudW06IGNudW0sXG4gICAgICBjYm9vbDogY2Jvb2wsXG4gICAgICBub29wOiBub29wLFxuICAgICAgdHJpbTogdHJpbSxcbiAgICAgIGNhbGxhYmxlOiBjYWxsYWJsZSxcbiAgICAgIGd1aWQ6IGd1aWQsXG4gICAgICBtaXg6IG1peCxcbiAgICAgIHRpbWU6IHRpbWUsXG4gICAgICByYW5kOiByYW5kLFxuICAgICAgZGVmOiBkZWYsXG4gICAgICBuczogbnMsXG4gICAgICBqc3NhZmVfaHRtbDoganNzYWZlX2h0bWwsXG4gICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgd3JhcDogd3JhcCxcbiAgICAgIGtleXM6IGtleXNcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBleHBvcnRzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5sYW5nID0gbGFuZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgbG9nRXJyb3IsIGxvZ0luZm8sIHdpbjtcbiAgICB3aW4gPSB3aW5kb3c7XG5cbiAgICAvKlxuICAgIFdyaXRlIGFuIGVudHJ5IHRvIHRoZSBjb25zb2xlIGxvZyBhbmQgZmlyZSBhbnkgbG9nIGxpc3RlbmVyc1xuICAgIFxuICAgIEBtZXNzYWdlICBUaGUgbG9nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBsb2dJbmZvID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgaWYgKHdpbi5jb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFdyaXRlIGFuIGVudHJ5IHRvIHRoZSBjb25zb2xlIGVycm9yIGxvZyBhbmQgZmlyZSBhbnkgbG9nIGxpc3RlbmVyc1xuICAgIFxuICAgIEBtZXNzYWdlICBUaGUgbG9nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBsb2dFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh3aW4uY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod2luLmNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZm86IGxvZ0luZm8sXG4gICAgICBlcnJvcjogbG9nRXJyb3JcbiAgICB9O1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGEpICYmIEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiB1dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCkgPyBzZWxmLmxlbmd0aCA6IE51bWJlcihlbmQpXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBoYXNoOiBoYXNoIH07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG52YXIgc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxudmFyIHNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMTogc2hhLFxuICBzaGEyNTY6IHNoYTI1NixcbiAgbWQ1OiBtZDVcbn1cblxudmFyIGJsb2Nrc2l6ZSA9IDY0XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKTsgemVyb0J1ZmZlci5maWxsKDApXG5mdW5jdGlvbiBobWFjKGZuLCBrZXksIGRhdGEpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSBrZXkgPSBuZXcgQnVmZmVyKGtleSlcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcblxuICBpZihrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gZm4oa2V5KVxuICB9IGVsc2UgaWYoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgemVyb0J1ZmZlcl0sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpLCBvcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHZhciBoYXNoID0gZm4oQnVmZmVyLmNvbmNhdChbaXBhZCwgZGF0YV0pKVxuICByZXR1cm4gZm4oQnVmZmVyLmNvbmNhdChbb3BhZCwgaGFzaF0pKVxufVxuXG5mdW5jdGlvbiBoYXNoKGFsZywga2V5KSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgdmFyIGZuID0gYWxnb3JpdGhtc1thbGddXG4gIHZhciBidWZzID0gW11cbiAgdmFyIGxlbmd0aCA9IDBcbiAgaWYoIWZuKSBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuICAgICAgICBcbiAgICAgIGJ1ZnMucHVzaChkYXRhKVxuICAgICAgbGVuZ3RoICs9IGRhdGEubGVuZ3RoXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZGlnZXN0OiBmdW5jdGlvbiAoZW5jKSB7XG4gICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZzKVxuICAgICAgdmFyIHIgPSBrZXkgPyBobWFjKGZuLCBrZXksIGJ1ZikgOiBmbihidWYpXG4gICAgICBidWZzID0gbnVsbFxuICAgICAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIChhbGcpIHsgcmV0dXJuIGhhc2goYWxnKSB9XG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBmdW5jdGlvbiAoYWxnLCBrZXkpIHsgcmV0dXJuIGhhc2goYWxnLCBrZXkpIH1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihzaXplLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbCkge1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgbmV3IEJ1ZmZlcihybmcoc2l6ZSkpKVxuICAgIH0gY2F0Y2ggKGVycikgeyBjYWxsYmFjayhlcnIpIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaChhLCBmKSB7XG4gIGZvcih2YXIgaSBpbiBhKVxuICAgIGYoYVtpXSwgaSlcbn1cblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG5lYWNoKFsnY3JlYXRlQ3JlZGVudGlhbHMnXG4sICdjcmVhdGVDaXBoZXInXG4sICdjcmVhdGVDaXBoZXJpdidcbiwgJ2NyZWF0ZURlY2lwaGVyJ1xuLCAnY3JlYXRlRGVjaXBoZXJpdidcbiwgJ2NyZWF0ZVNpZ24nXG4sICdjcmVhdGVWZXJpZnknXG4sICdjcmVhdGVEaWZmaWVIZWxsbWFuJ1xuLCAncGJrZGYyJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcbiIsIi8qXHJcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcclxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cclxuICogVmVyc2lvbiAyLjEgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDAyLlxyXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XHJcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxyXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxyXG4gKi9cclxuXHJcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XHJcblxyXG4vKlxyXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcclxuICovXHJcbmZ1bmN0aW9uIG1kNV92bV90ZXN0KClcclxue1xyXG4gIHJldHVybiBoZXhfbWQ1KFwiYWJjXCIpID09IFwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIjtcclxufVxyXG5cclxuLypcclxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxyXG57XHJcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cclxuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcclxuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XHJcblxyXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XHJcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xyXG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XHJcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xyXG5cclxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXHJcbiAge1xyXG4gICAgdmFyIG9sZGEgPSBhO1xyXG4gICAgdmFyIG9sZGIgPSBiO1xyXG4gICAgdmFyIG9sZGMgPSBjO1xyXG4gICAgdmFyIG9sZGQgPSBkO1xyXG5cclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xyXG5cclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcclxuXHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xyXG5cclxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcclxuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcclxuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcclxuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcclxuICB9XHJcbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xyXG5cclxufVxyXG5cclxuLypcclxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cclxuICovXHJcbmZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5cclxuLypcclxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxyXG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcclxue1xyXG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XHJcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xyXG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxyXG57XHJcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcclxuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9tZDUsIDE2KTtcclxufTtcclxuIiwiLy8gT3JpZ2luYWwgY29kZSBhZGFwdGVkIGZyb20gUm9iZXJ0IEtpZWZmZXIuXG4vLyBkZXRhaWxzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICB2YXIgbWF0aFJORywgd2hhdHdnUk5HO1xuXG4gIC8vIE5PVEU6IE1hdGgucmFuZG9tKCkgZG9lcyBub3QgZ3VhcmFudGVlIFwiY3J5cHRvZ3JhcGhpYyBxdWFsaXR5XCJcbiAgbWF0aFJORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIHI7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IHNpemU7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIGJ5dGVzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIGlmIChfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgd2hhdHdnUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IHdoYXR3Z1JORyB8fCBtYXRoUk5HO1xuXG59KCkpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhMShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfc2hhMSwgMjAsIHRydWUpO1xufTtcbiIsIlxuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbnZhciBzYWZlX2FkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn07XG5cbnZhciBTID0gZnVuY3Rpb24oWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpO1xufTtcblxudmFyIFIgPSBmdW5jdGlvbihYLCBuKSB7XG4gIHJldHVybiAoWCA+Pj4gbik7XG59O1xuXG52YXIgQ2ggPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xufTtcblxudmFyIE1haiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xufTtcblxudmFyIFNpZ21hMDI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDIpIF4gUyh4LCAxMykgXiBTKHgsIDIyKSk7XG59O1xuXG52YXIgU2lnbWExMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgNikgXiBTKHgsIDExKSBeIFMoeCwgMjUpKTtcbn07XG5cbnZhciBHYW1tYTAyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSk7XG59O1xuXG52YXIgR2FtbWExMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgMTcpIF4gUyh4LCAxOSkgXiBSKHgsIDEwKSk7XG59O1xuXG52YXIgY29yZV9zaGEyNTYgPSBmdW5jdGlvbihtLCBsKSB7XG4gIHZhciBLID0gbmV3IEFycmF5KDB4NDI4QTJGOTgsMHg3MTM3NDQ5MSwweEI1QzBGQkNGLDB4RTlCNURCQTUsMHgzOTU2QzI1QiwweDU5RjExMUYxLDB4OTIzRjgyQTQsMHhBQjFDNUVENSwweEQ4MDdBQTk4LDB4MTI4MzVCMDEsMHgyNDMxODVCRSwweDU1MEM3REMzLDB4NzJCRTVENzQsMHg4MERFQjFGRSwweDlCREMwNkE3LDB4QzE5QkYxNzQsMHhFNDlCNjlDMSwweEVGQkU0Nzg2LDB4RkMxOURDNiwweDI0MENBMUNDLDB4MkRFOTJDNkYsMHg0QTc0ODRBQSwweDVDQjBBOURDLDB4NzZGOTg4REEsMHg5ODNFNTE1MiwweEE4MzFDNjZELDB4QjAwMzI3QzgsMHhCRjU5N0ZDNywweEM2RTAwQkYzLDB4RDVBNzkxNDcsMHg2Q0E2MzUxLDB4MTQyOTI5NjcsMHgyN0I3MEE4NSwweDJFMUIyMTM4LDB4NEQyQzZERkMsMHg1MzM4MEQxMywweDY1MEE3MzU0LDB4NzY2QTBBQkIsMHg4MUMyQzkyRSwweDkyNzIyQzg1LDB4QTJCRkU4QTEsMHhBODFBNjY0QiwweEMyNEI4QjcwLDB4Qzc2QzUxQTMsMHhEMTkyRTgxOSwweEQ2OTkwNjI0LDB4RjQwRTM1ODUsMHgxMDZBQTA3MCwweDE5QTRDMTE2LDB4MUUzNzZDMDgsMHgyNzQ4Nzc0QywweDM0QjBCQ0I1LDB4MzkxQzBDQjMsMHg0RUQ4QUE0QSwweDVCOUNDQTRGLDB4NjgyRTZGRjMsMHg3NDhGODJFRSwweDc4QTU2MzZGLDB4ODRDODc4MTQsMHg4Q0M3MDIwOCwweDkwQkVGRkZBLDB4QTQ1MDZDRUIsMHhCRUY5QTNGNywweEM2NzE3OEYyKTtcbiAgdmFyIEhBU0ggPSBuZXcgQXJyYXkoMHg2QTA5RTY2NywgMHhCQjY3QUU4NSwgMHgzQzZFRjM3MiwgMHhBNTRGRjUzQSwgMHg1MTBFNTI3RiwgMHg5QjA1Njg4QywgMHgxRjgzRDlBQiwgMHg1QkUwQ0QxOSk7XG4gICAgdmFyIFcgPSBuZXcgQXJyYXkoNjQpO1xuICAgIHZhciBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqO1xuICAgIHZhciBUMSwgVDI7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIG1bbCA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGwgJSAzMik7XG4gIG1bKChsICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgYSA9IEhBU0hbMF07IGIgPSBIQVNIWzFdOyBjID0gSEFTSFsyXTsgZCA9IEhBU0hbM107IGUgPSBIQVNIWzRdOyBmID0gSEFTSFs1XTsgZyA9IEhBU0hbNl07IGggPSBIQVNIWzddO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgaWYgKGogPCAxNikge1xuICAgICAgICBXW2pdID0gbVtqICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBXW2pdID0gc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoR2FtbWExMjU2KFdbaiAtIDJdKSwgV1tqIC0gN10pLCBHYW1tYTAyNTYoV1tqIC0gMTVdKSksIFdbaiAtIDE2XSk7XG4gICAgICB9XG4gICAgICBUMSA9IHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKGgsIFNpZ21hMTI1NihlKSksIENoKGUsIGYsIGcpKSwgS1tqXSksIFdbal0pO1xuICAgICAgVDIgPSBzYWZlX2FkZChTaWdtYTAyNTYoYSksIE1haihhLCBiLCBjKSk7XG4gICAgICBoID0gZzsgZyA9IGY7IGYgPSBlOyBlID0gc2FmZV9hZGQoZCwgVDEpOyBkID0gYzsgYyA9IGI7IGIgPSBhOyBhID0gc2FmZV9hZGQoVDEsIFQyKTtcbiAgICB9XG4gICAgSEFTSFswXSA9IHNhZmVfYWRkKGEsIEhBU0hbMF0pOyBIQVNIWzFdID0gc2FmZV9hZGQoYiwgSEFTSFsxXSk7IEhBU0hbMl0gPSBzYWZlX2FkZChjLCBIQVNIWzJdKTsgSEFTSFszXSA9IHNhZmVfYWRkKGQsIEhBU0hbM10pO1xuICAgIEhBU0hbNF0gPSBzYWZlX2FkZChlLCBIQVNIWzRdKTsgSEFTSFs1XSA9IHNhZmVfYWRkKGYsIEhBU0hbNV0pOyBIQVNIWzZdID0gc2FmZV9hZGQoZywgSEFTSFs2XSk7IEhBU0hbN10gPSBzYWZlX2FkZChoLCBIQVNIWzddKTtcbiAgfVxuICByZXR1cm4gSEFTSDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhMjU2KGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9zaGEyNTYsIDMyLCB0cnVlKTtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiJdfQ==
