(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var AdJS, Session, config, engagement, sf, stream;

  sf = require('safeframe');

  engagement = require('./shared/engagement');

  Session = require('./shared/session');

  AdJS = require('./publisher/slot');

  stream = require('./shared/stream');

  config = require('./shared/config');

  (function(window) {
    var doRender, globalConfig, initSafeFrame, safeframeUrl, session, sfDom;
    session = new Session();
    stream.page(session);
    safeframeUrl = config.cdn_url;
    sfDom = $sf.lib.dom;
    globalConfig = {
      keys: [],
      safeframe_url: safeframeUrl
    };
    doRender = function() {
      var d, div, divs, sfPositions, _i, _len, _results;
      sfPositions = {};
      if (!sfDom.ready()) {
        sfDom.wait(function() {
          var args;
          doRender.apply(null, args);
          return args = null;
        });
      } else {
        divs = (function() {
          var _i, _len, _ref, _results;
          _ref = document.getElementsByTagName("div");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            div = _ref[_i];
            _results.push(div);
          }
          return _results;
        })();
        _results = [];
        for (_i = 0, _len = divs.length; _i < _len; _i++) {
          d = divs[_i];
          if (sfDom.attr(d, "data-adjs")) {
            _results.push((function(d) {
              return AdJS.create(d, session);
            })(d));
          }
        }
        return _results;
      }
    };
    initSafeFrame = function() {
      return $sf.host.Config({
        renderFile: globalConfig.safeframe_url,
        positions: {},
        onStartPosRender: function() {},
        onFailure: function() {},
        onAdLoad: function(id) {
          return AdJS(id).load();
        },
        onBeforePosMsg: function() {},
        onPosMsg: function(id, msg, content) {
          return AdJS(id).handleMessage(msg, content);
        }
      });
    };
    AdJS.view(function() {
      return session.incr("av");
    });
    AdJS.engage(function() {
      return session.incr("ae");
    });
    AdJS.load(function() {
      return session.incr("a");
    });
    AdJS.click(function() {
      return session.incr("ac");
    });
    AdJS.load(function() {
      return console.log("loaded");
    });
    session.change(function() {
      var ad, _, _ref, _results;
      console.log("wtf");
      _ref = AdJS.slots;
      _results = [];
      for (_ in _ref) {
        ad = _ref[_];
        _results.push(ad.notifyFrame("cookie-update", session.serializeCookie()));
      }
      return _results;
    });
    AdJS.render = function() {
      var adJsScript, s;
      adJsScript = ((function() {
        var _i, _len, _ref, _results;
        _ref = document.getElementsByTagName("script");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (sfDom.attr(s, "data-adjs")) {
            _results.push(s);
          }
        }
        return _results;
      })())[0];
      initSafeFrame();
      return doRender();
    };
    engagement.onEngagement(function() {
      var ad, _, _ref, _results;
      _ref = AdJS.slots;
      _results = [];
      for (_ in _ref) {
        ad = _ref[_];
        if (ad.currentlyInview() && !ad.engaged) {
          _results.push(ad.engage());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    (function() {
      return AdJS.render();
    })();
    AdJS.session = session;
    window.$ad = AdJS;
    return AdJS;
  })(window);

}).call(this);

},{"./publisher/slot":2,"./shared/config":4,"./shared/engagement":5,"./shared/session":7,"./shared/stream":9,"safeframe":15}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var events, sf, sfDom, sizes, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sf = require('safeframe');

  sizes = require('../shared/sizes');

  utils = require('../shared/utils');

  events = require('../shared/event')(["request", "click", "load", "view", "unload", "focus", "engage", "unfocus", "expand", "collapse", "refreshed", "cookie", "receive", "unview", "timeout"]);

  sfDom = sf.lib.dom;

  module.exports = (function() {
    var SCRIPT_REGEX, Slot, TIMEOUT_TIME, oldTrigger, slots;
    TIMEOUT_TIME = 5000;
    slots = {};
    SCRIPT_REGEX = /<!--([\s\S]*)-->/;
    Slot = (function() {
      function Slot(adId) {
        this.trigger = __bind(this.trigger, this);
        if (this instanceof Slot) {
          return this.init(adId);
        } else {
          return new Slot(adId);
        }
      }

      Slot.prototype.init = function(adId) {
        if (slots[adId]) {
          return slots[adId];
        }
        this.id = adId;
        this.count = 1;
        slots[adId] = this;
        return this.initEvents();
      };

      Slot.prototype.startAutoRefresh = function(delay, cb) {
        if (delay == null) {
          delay = 60;
        }
        if (!this._isAutoRefreshing) {
          this._isAutoRefreshing = true;
          this._refreshInterval = setTimeout((function(_this) {
            return function() {
              _this._isAutoRefreshing = false;
              if (_this.loadTime) {
                return _this.refresh(cb);
              }
            };
          })(this), delay * 1000);
        }
        return this;
      };

      Slot.prototype.stopAutoRefresh = function() {
        clearTimeout(this._refreshInterval);
        this._isAutoRefreshing = false;
        this._refreshInterval = null;
        return this;
      };

      Slot.prototype.refresh = function(cb) {
        this.remove();
        this.count++;
        this.posMeta.setValue("slot_count", "extended", this.count);
        sf.host.render(this.pos);
        this.frame = document.getElementById(this.posConfig.dest);
        if (typeof cb === "function") {
          cb(this);
        }
        this.refreshed();
        return this;
      };

      Slot.prototype.trigger = function(event) {
        var _ref;
        if (!((_ref = this.options) != null ? _ref.ignoreEvents : void 0)) {
          events.trigger.apply(this, arguments);
          Slot.trigger(event, this, arguments[1]);
        }
        return this;
      };

      Slot.prototype.handleMessage = function(msg, content) {
        switch (msg) {
          case "focus-change":
            if (content) {
              return this.focus();
            } else {
              return this.unfocus();
            }
            break;
          case "geom-update":
            return function() {};
          case "expand":
            return this.expand(content);
          case "collapse":
            return this.collapse(content);
          case "viewed":
            if (!this.viewed) {
              return this.view();
            }
            break;
          case "unviewed":
            if (!(this.unviewed && this.viewed)) {
              return this.unview();
            }
            break;
          case "clicked":
            if (!this.clicked) {
              return this.click();
            }
            break;
          case "requested":
            return this.request();
          case "cookie-write":
            return this.cookie({
              cookie: "write",
              content: content
            });
          case "cookie-read":
            return this.cookie({
              cookie: "read",
              content: content
            });
          case "reload":
            return this.reload();
          case "msg":
            return this.receive(decodeURIComponent(content));
          default:
            return null;
        }
      };

      Slot.prototype.initEvents = function() {
        this.request(function() {
          return this.requestTime = utils.now();
        });
        this.load(function() {
          this.frameCount = utils.countFrames(this.frame.contentWindow);
          return this.loadTime = utils.now();
        });
        this.view(function() {
          this.viewed = true;
          return this.viewTime = utils.now();
        });
        this.engage(function() {
          if (!this.engaged) {
            this.engaged = true;
            this.engageTime = utils.now();
            return this.notifyFrame("engaged");
          }
        });
        this.unview(function() {
          this.unviewed = true;
          return this.unviewTime = utils.now();
        });
        this.unload(function() {
          return this.unloadTime = utils.now();
        });
        return this.click(function() {
          return this.clicked = true;
        });
      };

      Slot.prototype.frameCount = 0;

      Slot.prototype.notifyFrame = function(cmd, data) {
        var msgObj;
        msgObj = sf.lib.lang.ParamHash();
        if (this.posConfig) {
          msgObj.pos = this.posConfig.id;
          msgObj.cmd = cmd;
          msgObj.value = escape(data);
          return sfDom.msghost.send(this.posConfig.dest, msgObj.toString());
        }
      };

      Slot.prototype.create = function(elem, html, options) {
        var height, s, supports, width, _i, _j, _len, _len1, _ref, _ref1;
        this.options = options != null ? options : {};
        width = this.options.width || elem.offsetWidth;
        height = this.options.height || elem.offsetHeight;
        supports = {};
        _ref = this.options.supports || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          supports[s] = true;
        }
        _ref1 = this.options.disables || [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          s = _ref1[_j];
          supports[s] = false;
        }
        if (this.elem) {
          return;
        }
        this.elem = elem;
        elem.id || (elem.id = sf.lib.lang.guid("pos"));
        this.posMeta = new sf.host.PosMeta(null, "extended", {
          inview: this.options.inview,
          session: this.options.session,
          host: document.location.hostname,
          referrer: this.options.referrer,
          location: document.location.href,
          slot_id: this.id,
          slot_count: this.count
        });
        this.posConfig = new sf.host.PosConfig({
          id: this.id,
          dest: elem.id,
          w: width,
          h: height,
          supports: supports
        });
        this.pos = new sf.host.Position(this.posConfig.id, html, this.posMeta);
        if (this.options.refresh_oov) {
          this.unview(function() {
            return setTimeout((function(_this) {
              return function() {
                return _this.refresh();
              };
            })(this), 1);
          });
        }
        if (this.options.refresh_time != null) {
          this.refreshTime = sf.lib.lang.cnum(this.options.refresh_time, 0);
          if (this.refreshTime > 0) {
            this.load(function() {
              return this.startAutoRefresh(this.refreshTime);
            });
            this.timeout(function() {
              this.stopAutoRefresh();
              return this.refresh();
            });
          }
        }
        sf.host.render(this.pos);
        this.frame = document.getElementById(elem.id);
        return this;
      };

      Slot.prototype.remove = function(dontFire) {
        if (!dontFire) {
          this.unload();
        }
        clearTimeout(this._refreshInterval);
        this.viewed = false;
        this.engaged = false;
        this.unviewed = false;
        this.frame = null;
        this.frameCount = 0;
        this.requestTime = null;
        this.loadTime = null;
        this.viewTime = null;
        this.engageTime = null;
        this.unviewTime = null;
        this.unloadTime = null;
        sf.host.nuke(this.id);
        return this;
      };

      Slot.prototype.destroy = function() {
        this.stopAutoRefresh();
        this.remove();
        delete this.events;
        return delete slots[this.id];
      };

      Slot.prototype.reload = function() {
        if (this.options.inview) {
          this.remove(true);
          sf.host.render(this.pos);
          return this.frame = document.getElementById(this.posConfig.dest);
        }
      };

      Slot.prototype.currentlyInview = function() {
        return sf.host.inViewPercentage(this.id) > 50 && this.viewed;
      };

      Slot.prototype.inviewPercentage = function() {
        return sf.host.inViewPercentage(this.id);
      };

      return Slot;

    })();
    Slot.destroy = function() {
      var ad, _, _results;
      _results = [];
      for (_ in slots) {
        ad = slots[_];
        _results.push(ad.destroy());
      }
      return _results;
    };
    Slot.events = {};
    oldTrigger = Slot.prototype.trigger;
    sf.lib.lang.mix(Slot.prototype, events);
    Slot.prototype.trigger = oldTrigger;
    sf.lib.lang.mix(Slot, events);
    Slot.create = function(d, session) {
      var adId, disables, div, height, posId, size, supports, template, width, _base, _base1, _ref;
      template = ((_ref = d.innerHTML.match(SCRIPT_REGEX)) != null ? _ref[1] : void 0) || d.innerHTML;
      posId = sf.lib.lang.guid("pos");
      adId = d.id || posId;
      div = document.createElement("div");
      div.id = posId;
      d.appendChild(div);
      supports = [];
      disables = [];
      if (size = sizes[sfDom.attr(d, "data-ad-type")]) {
        width = size[0], height = size[1];
      }
      Slot(adId).create(div, template, {
        width: width || sfDom.attr(d, "data-width"),
        height: height || sfDom.attr(d, "data-height"),
        supports: typeof (_base = sfDom.attr(d, "data-supports")).split === "function" ? _base.split(",") : void 0,
        disables: typeof (_base1 = sfDom.attr(d, "data-disables")).split === "function" ? _base1.split(",") : void 0,
        inview: sf.lib.lang.cbool(sfDom.attr(d, "data-inview")),
        refresh_time: sfDom.attr(d, "data-refresh-time"),
        refresh_oov: sf.lib.lang.cbool(sfDom.attr(d, "data-refresh-oov")),
        session: session != null ? session.serializeCookie() : void 0,
        referrer: sfDom.attr(d, "data-referrer"),
        ignoreEvents: sf.lib.lang.cbool(sfDom.attr(d, "data-ignore-events"))
      });
      return Slot(adId);
    };
    Slot.slots = slots;
    Slot.sizes = sizes;
    return Slot;
  })();

}).call(this);

},{"../shared/event":6,"../shared/sizes":8,"../shared/utils":10,"safeframe":15}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.attributes || (this.attributes = {});
        this._events = [];
      }

      Base.prototype.set = function(attrs, options) {
        var changed, changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        changed = false;
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
          }
          this.attributes[k] = v;
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      return Base;

    })();
  })();

}).call(this);

},{}],4:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html'
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//endpoint.adjs.io/1",
        cdn_url: process.env.CDN_URL
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html'
      };
    }
  })();

}).call(this);

}).call(this,require("8DwohR"))
},{"8DwohR":32}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils;

  utils = require('./utils');

  module.exports = (function(window, $sf) {
    var ENGAGEMENT_RESET, activityHandler, attach, disengageEvents, doc, engageEvents, engagement, engagementTimeout, lastEngaged, resetEngagement;
    attach = $sf.lib.dom.attach;
    engagement = {
      isEngaged: false
    };
    doc = window.document;
    engageEvents = [];
    disengageEvents = [];
    ENGAGEMENT_RESET = 3000;
    lastEngaged = void 0;
    engagement.onEngagement = function(f) {
      return engageEvents.push(f);
    };
    engagement.onDisengagement = function(f) {
      return disengageEvents.push(f);
    };
    activityHandler = function() {
      var f, _i, _len;
      engagement.isEngaged = true;
      engagement.lastEngaged = utils.now();
      for (_i = 0, _len = engageEvents.length; _i < _len; _i++) {
        f = engageEvents[_i];
        f();
      }
      resetEngagement();
      return true;
    };
    engagementTimeout = null;
    resetEngagement = function() {
      clearTimeout(engagementTimeout);
      return engagementTimeout = setTimeout(function() {
        var f, _i, _len;
        engagement.isEngaged = false;
        for (_i = 0, _len = disengageEvents.length; _i < _len; _i++) {
          f = disengageEvents[_i];
          f();
        }
        return disengageEvents = [];
      }, ENGAGEMENT_RESET);
    };
    attach(doc, 'click', activityHandler);
    attach(doc, 'mouseup', activityHandler);
    attach(doc, 'mousedown', activityHandler);
    attach(doc, 'mousemove', activityHandler);
    attach(doc, 'mousewheel', activityHandler);
    attach(doc, 'keypress', activityHandler);
    attach(doc, 'keydown', activityHandler);
    attach(doc, 'keyup', activityHandler);
    attach(window, 'DOMMouseScroll', activityHandler);
    attach(window, 'scroll', activityHandler);
    attach(window, 'resize', activityHandler);
    attach(window, 'focus', activityHandler);
    attach(window, 'blur', activityHandler);
    return engagement;
  })(window, $sf);

}).call(this);

},{"./utils":10}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(eventNames) {
    return (function() {
      var event, events, utils, _i, _len;
      utils = require('./utils');
      events = {
        on: function(event, cb) {
          var eventList;
          this.events || (this.events = {});
          eventList = this.events[event] || [];
          eventList.push(cb);
          this.events[event] = eventList;
          return this;
        },

        /*
          optionalData needs to be fixed
         */
        trigger: function(event, data, optionalData) {
          var e, ex, _i, _len, _ref;
          this.events || (this.events = {});
          _ref = this.events[event] || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            try {
              e.call(this, data, optionalData);
            } catch (_error) {
              ex = _error;
            }
          }
          this.notify(event, data || this);
          return this;
        },
        notify: function(event, data) {
          var endpoint, params, _i, _len, _ref, _ref1, _results;
          _ref1 = ((_ref = this.eventEndpoints) != null ? _ref[event] : void 0) || [];
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            endpoint = _ref1[_i];
            params = (data != null ? typeof data.getParams === "function" ? data.getParams() : void 0 : void 0) || {};
            params.event = event;
            _results.push(utils.sendRequest(endpoint, {
              data: params
            }));
          }
          return _results;
        }
      };
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        event = eventNames[_i];
        events[event] = (function(event) {
          var f;
          return f = function(data) {
            if (typeof data === "function") {
              return this.on(event, data);
            } else {
              return this.trigger(event, data);
            }
          };
        })(event);
        events["" + event + "RegisterEndpoint"] = (function(event) {
          var f;
          return f = function(endpoint) {
            var _base;
            this.eventEndpoints || (this.eventEndpoints = {});
            (_base = this.eventEndpoints)[event] || (_base[event] = []);
            return this.eventEndpoints[event].push(endpoint);
          };
        })(event);
      }
      return events;
    })();
  };

}).call(this);

},{"./utils":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, cookies, utils, uuid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  cookies = require('cookies-js');

  uuid = require('node-uuid');

  Base = require('./base');

  utils = require('./utils');

  module.exports = (function() {
    var COOKIE_KEY, Session, defaultAttributes, getUserId, now, parseCookie, updateVisitId;
    COOKIE_KEY = "_ajsk";
    now = utils.now();
    updateVisitId = function(options) {
      var nowTime;
      nowTime = utils.now() / 1000;
      this.lastVisitTime || (this.lastVisitTime = utils.toNumber(this.attributes.vts, 0));
      if ((nowTime - Session.VISITOR_EXPIRY) > this.lastVisitTime) {
        return this.set({
          v: utils.toNumber(this.attributes.v) + 1,
          vts0: this.attributes.vts,
          vts: nowTime,
          vid: uuid.v4(),
          vp: 0,
          va: 0,
          vav: 0,
          vae: 0,
          vac: 0
        }, options);
      } else {
        this.lastVisitTime = nowTime;
        return this.set({
          vts: nowTime
        }, {
          silent: true
        });
      }
    };
    parseCookie = function(cookie) {
      return utils.fromQuery(cookie);
    };
    getUserId = function() {
      return utils.sendRequest();
    };
    defaultAttributes = function() {
      return {
        id: uuid.v4(),
        vid: uuid.v4(),
        ts: now / 1000,
        p: 0,
        a: 0,
        av: 0,
        ac: 0,
        ae: 0,
        v: 1,
        vts: now / 1000,
        vts0: now / 1000,
        vp: 0,
        va: 0,
        vav: 0,
        vae: 0,
        vac: 0
      };
    };
    Session = (function(_super) {
      __extends(Session, _super);

      function Session(query) {
        var attrs, cookie, k, v, _base, _ref;
        Session.__super__.constructor.call(this);
        _ref = defaultAttributes();
        for (k in _ref) {
          v = _ref[k];
          (_base = this.attributes)[k] || (_base[k] = v);
        }
        if (query) {
          attrs = parseCookie(query);
          this.set(attrs, {
            silent: true
          });
        } else if (cookie = cookies.get(COOKIE_KEY)) {
          attrs = parseCookie(cookie);
          this.set(attrs, {
            silent: true
          });
          updateVisitId.call(this, {
            silent: true
          });
          this.serializeCookie();
        } else {
          this.serializeCookie();
        }
      }

      Session.prototype.serializeCookie = function() {
        var query;
        query = utils.toQuery(this.attributes);
        cookies.set(COOKIE_KEY, query, {
          expires: 31536000
        });
        return query;
      };

      Session.prototype.set = function(attrs, options) {
        if (options == null) {
          options = {};
        }
        Session.__super__.set.call(this, attrs, options);
        return this.serializeCookie();
      };

      Session.prototype.incr = function(key, options) {
        var updatedVals, vkey, _base;
        (_base = this.attributes)[key] || (_base[key] = 0);
        updatedVals = {};
        updatedVals[key] = utils.toNumber(this.attributes[key]) + 1;
        vkey = "v" + key;
        if (this.attributes[vkey] != null) {
          updatedVals[vkey] = utils.toNumber(this.attributes[vkey]) + 1;
        }
        return this.set(updatedVals, options);
      };

      return Session;

    })(Base);
    Session.VISITOR_EXPIRY = 20;
    if ((typeof _TEST !== "undefined" && _TEST !== null) && _TEST) {
      Session._updateVisitId = updateVisitId;
      Session._parseCookie = parseCookie;
      Session._getUser = getUserId;
      Session._COOKIE_KEY = COOKIE_KEY;
      Session.clearCookie = function() {
        return cookies.set(COOKIE_KEY, void 0);
      };
    }
    return Session;
  })();

}).call(this);

},{"./base":3,"./utils":10,"cookies-js":11,"node-uuid":13}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    return {
      leaderboard: [728, 90],
      "medium-rectangle": [300, 250]
    };
  })();

}).call(this);

},{}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var config, reqwest;

  reqwest = require('reqwest');

  config = require('./config');

  module.exports = (function() {
    var pendingRequests, prefix, send, sendingRequests;
    prefix = config.api;
    pendingRequests = {};
    sendingRequests = {};
    send = function(url, data, success, error) {
      return reqwest({
        url: url,
        type: 'jsonp',
        data: data,
        success: success,
        error: error
      });
    };
    return {
      page: function(session) {
        var error, success;
        success = function(resp) {
          return session.set(resp, {
            silent: true
          });
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        return send(prefix + '/page', session.attributes, success, error);
      },
      event: function(request, cb, isAttempt) {
        var error, success;
        success = function(resp) {
          request.set(resp, {
            silent: true
          });
          if (typeof cb === "function") {
            cb(resp);
          }
          return delete sendingRequests[request.id];
        };
        error = function(err) {
          return console.log("ERROR:" + err);
        };
        if (!sendingRequests[request.id]) {
          delete pendingRequests[request.id];
          sendingRequests[request.id] = true;
          return send(prefix + '/event', request.attributes, success, error);
        } else if (!pendingRequests[request.id] || isAttempt) {
          pendingRequests[request.id];
          return setTimeout((function(_this) {
            return function() {
              return event(request, cb, true);
            };
          })(this), 500);
        }
      }
    };
  })();

}).call(this);

},{"./config":4,"reqwest":14}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  window.reqwest || (window.reqwest = require('reqwest'));

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf, window) {
    var capitalizeString, countFrames, defineProperty, fromQuery, now, reqwest, sendRequest, toNumber, toQuery;
    reqwest = window.reqwest;
    sendRequest = function(url, options) {
      return reqwest({
        url: url,
        type: 'jsonp',
        success: options.success,
        error: options.error,
        data: options.data
      });
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        }
      } catch (_error) {
        e = _error;
        return console.log(e);
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    capitalizeString = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return {
      sendRequest: sendRequest,
      toQuery: toQuery,
      fromQuery: fromQuery,
      toNumber: toNumber,
      now: now,
      defineProperty: defineProperty,
      countFrames: countFrames,
      capitalizeString: capitalizeString
    };
  })($sf, window);

}).call(this);

},{"json":12,"reqwest":14}],11:[function(require,module,exports){
/*!
 * Cookies.js - 0.3.1
 * Wednesday, April 24 2013 @ 2:28 AM EST
 *
 * Copyright (c) 2013, Scott Hamper
 * Licensed under the MIT license,
 * http://www.opensource.org/licenses/MIT
 */
(function (undefined) {
    'use strict';

    var Cookies = function (key, value, options) {
        return arguments.length === 1 ?
            Cookies.get(key) : Cookies.set(key, value, options);
    };

    // Allows for setter injection in unit tests
    Cookies._document = document;
    Cookies._navigator = navigator;

    Cookies.defaults = {
        path: '/'
    };

    Cookies.get = function (key) {
        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
            Cookies._renewCache();
        }

        return Cookies._cache[key];
    };

    Cookies.set = function (key, value, options) {
        options = Cookies._getExtendedOptions(options);
        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

        return Cookies;
    };

    Cookies.expire = function (key, options) {
        return Cookies.set(key, undefined, options);
    };

    Cookies._getExtendedOptions = function (options) {
        return {
            path: options && options.path || Cookies.defaults.path,
            domain: options && options.domain || Cookies.defaults.domain,
            expires: options && options.expires || Cookies.defaults.expires,
            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
        };
    };

    Cookies._isValidDate = function (date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    };

    Cookies._getExpiresDate = function (expires, now) {
        now = now || new Date();
        switch (typeof expires) {
            case 'number': expires = new Date(now.getTime() + expires * 1000); break;
            case 'string': expires = new Date(expires); break;
        }

        if (expires && !Cookies._isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    };

    Cookies._generateCookieString = function (key, value, options) {
        key = encodeURIComponent(key);
        value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toGMTString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    };

    Cookies._getCookieObjectFromString = function (documentCookie) {
        var cookieObject = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieObject[cookieKvp.key] === undefined) {
                cookieObject[cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieObject;
    };

    Cookies._getKeyValuePairFromCookieString = function (cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        return {
            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
        };
    };

    Cookies._renewCache = function () {
        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);
        Cookies._cachedDocumentCookie = Cookies._document.cookie;
    };

    Cookies._areEnabled = function () {
        return Cookies._navigator.cookieEnabled ||
            Cookies.set('cookies.js', 1).get('cookies.js') === '1';
    };

    Cookies.enabled = Cookies._areEnabled();

    // AMD support
    if (typeof define === 'function' && define.amd) {
        define(function () { return Cookies; });
    // CommonJS and Node.js module support.
    } else if (typeof exports !== 'undefined') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Cookies;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = Cookies;
    } else {
        window.Cookies = Cookies;
    }
})();
},{}],12:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],13:[function(require,module,exports){
(function (Buffer){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

}).call(this,require("buffer").Buffer)
},{"buffer":23,"crypto":27}],14:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require("./host/host");

  (function(window, sf) {
    return window["$sf"] = sf;
  })(window, sf);

  module.exports = sf;

}).call(this);

},{"./host/host":17}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require('../shared/base');

  module.exports = (function(window, sf) {
    var AUTO_BOOT_MAX_RETRIES, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, SF_TAG_TYPE, boot, boot_retries, d, doing_auto_boot, dom, has_booted, inline_tags_processed, lang, lib, win, _attr, _auto_boot, _clean_up_booted_tags, _create_pos_markup, _cstr, _elt, _guid, _log, _par, _purge, _ready, _tags;
    win = window != null ? window : this;
    _log = function(msg, is_err) {
      var err_tag, head_el, lib;
      try {
        lib = sf.lib;
        if (lib && lib.logger && win === top) {
          if (is_err) {
            lib.logger.error(msg);
          } else {
            lib.logger.log(msg);
          }
        } else {
          head_el = d.getElementsByTagName("head")[0];
          err_tag = d.createElement("script");
          err_tag.type = "text/plain";
          err_tag.text = "<!-- SafeFrame " + (is_err ? "error" : "log") + ": " + (msg || "unknown") + " -->";
          head_el.appendChild(head_el, err_tag);
        }
      } catch (_error) {}
    };

    /*
    Create the HTML markup for a position if a src property was used
    
    @name $sf.host-_create_pos_markup
    @function
    @private
    @static
    @return {String}
     */
    _create_pos_markup = function(src) {
      return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
    };
    _auto_boot = function() {
      var config, do_auto, doing_auto_boot, e, head, host_file, scr_tag, sf_host;
      do_auto = true;
      config = void 0;
      sf_host = void 0;
      host_file = void 0;
      head = void 0;
      scr_tag = void 0;
      if (has_booted) {
        return;
      }
      sf_host = sf && sf.host;
      if (win === top) {
        if (sf_host && !sf_host.boot) {
          sf_host.boot = boot;
        }
        try {
          config = sf_host && sf_host.Config();
        } catch (_error) {
          e = _error;
          config = null;
        }
        if (!config) {
          try {
            config = sf_host && sf_host.conf;
          } catch (_error) {
            e = _error;
            config = null;
          }
        }
        if (config) {
          if (("auto" in config) && config.auto === false) {
            do_auto = false;
          }
          if (!sf_host.render || !sf_host.Config) {
            host_file = config.hostFile;
            if (host_file) {
              head = _tags("head")[0];
              scr_tag = dom.make("script");
              scr_tag.id = "sf_host_lib";
              scr_tag.type = "text/javascript";
              scr_tag.className = "sf_lib";
              scr_tag.src = host_file;
              if (win.ActiveXObject) {
                scr_tag.onreadystatechange = function() {
                  var doing_auto_boot, rs;
                  rs = scr_tag.readyState;
                  if (rs === "loaded" || rs === "complete") {
                    doing_auto_boot = false;
                    if (do_auto) {
                      boot();
                    }
                    scr_tag.onreadystatechange = null;
                    scr_tag = head = sf_host = config = null;
                  }
                };
              } else {
                scr_tag.onload = function() {
                  var doing_auto_boot;
                  doing_auto_boot = false;
                  if (do_auto) {
                    boot();
                  }
                  scr_tag.onload = null;
                  scr_tag = head = sf_host = config = null;
                };
              }
              doing_auto_boot = true;
              head.appendChild(scr_tag);
              return;
            }
          }
        }
        if (do_auto) {
          if (config) {
            doing_auto_boot = true;
            boot();
            doing_auto_boot = false;
          } else {
            if (boot_retries++ <= AUTO_BOOT_MAX_RETRIES) {
              setTimeout(_auto_boot, 50);
            }
          }
        }
      } else {
        boot();
      }
    };

    /*
    Go through and remove any inline script tags that are our data-islands , which have already been boostrapped
    
    @name $sf.host-_clean_up_booted_tags
    @private
    @function
    @static
     */
    _clean_up_booted_tags = function() {
      var script_tag, script_tag_id;
      script_tag_id = void 0;
      script_tag = void 0;
      if (dom) {
        for (script_tag_id in inline_tags_processed) {
          script_tag = _elt(script_tag_id);
          if (script_tag) {
            _purge(script_tag);
            delete inline_tags_processed[script_tag_id];
          }
        }
      }
    };

    /*
    Search for SafeFrames tags and render them. This function is called
    automatically whenever the SafeFrames publisher library is loaded. However a configuration
    can be applied to not have SafeFrames tags automatically be rendered, requiring a controlled
    call to this function.
    
    @name $sf.host.boot
    @public
    @function
    @static
     */
    boot = function() {
      var boot_positions, data, e, err, errMsg, has_booted, html, idx, lib, meta_key, pos_conf, pos_dest_el, pos_meta, pos_meta_item, pos_obj, prv_meta, prv_meta_key, ret, script_tag, script_tag_id, script_tag_par, script_tags, sf_conf, sf_host, sf_inline_conf, sf_ocnf, shared_meta, typ;
      script_tags = (_tags && _tags("script")) || [];
      boot_positions = [];
      idx = 0;
      ret = false;
      errMsg = void 0;
      sf_host = sf && sf.host;
      sf_inline_conf = sf_host && sf_host.conf;
      script_tag = void 0;
      script_tag_par = void 0;
      script_tag_id = void 0;
      data = void 0;
      html = void 0;
      pos_obj = void 0;
      pos_conf = void 0;
      pos_dest_el = void 0;
      pos_meta = void 0;
      pos_meta_item = void 0;
      typ = void 0;
      shared_meta = void 0;
      prv_meta = void 0;
      prv_meta_key = void 0;
      meta_key = void 0;
      sf_ocnf = void 0;
      err = void 0;
      if (!sf || !lang || !dom) {
        _log("SafeFrame base library not found", true);
        return ret;
      }
      if (!lib) {
        lib = sf && sf.lib;
      }
      if (doing_auto_boot && has_booted) {
        _log("Automatic boot already invoked");
        return ret;
      }
      if (win === top) {
        try {
          sf_conf = sf_host.Config();
        } catch (_error) {
          err = _error;
          sf_conf = null;
        }
        if (sf_inline_conf && !sf_conf) {
          try {
            sf_conf = sf_host.Config(sf_inline_conf);
          } catch (_error) {
            e = _error;
            sf_conf = null;
          }
        }
        if (!sf_conf) {
          _log("No configuration found");
          return ret;
        }
      }
      while (script_tag = script_tags[idx++]) {
        if (script_tag.className === SF_DATATAG_CLASS || _attr(script_tag, "type") === SF_TAG_TYPE) {
          has_booted = true;
          script_tag_id = _attr(script_tag, "id");
          if (!script_tag_id) {
            script_tag_id = _guid("sf_data_element");
            _attr(script_tag, "id", script_tag_id);
          }
          if (inline_tags_processed[script_tag_id]) {
            continue;
          }
          data = script_tag.text || script_tag.innerHTML || script_tag.innerText;
          try {
            data = lang.trim(data);
            data = new Function("return " + data);
            data = data();
          } catch (_error) {
            err = _error;
            data = null;
            errMsg = "Error parsing tag configuration " + (err && err.message || "");
            _log(errMsg, true);
            continue;
          }
          if (data && data.id && (data.html || data.src)) {
            if (win !== top) {
              html = data.html || "";
              html = html || _create_pos_markup(data.src);
              if (!_ready()) {
                d.write(html);
              } else {
                _log("cannot write html content into already loaded document");
              }
            } else {
              script_tag_par = _par(script_tag);
              if (!script_tag_par) {
                _log("can't find parent element for script tag", true);
                continue;
              }
              pos_conf = sf_conf && sf_conf.positions[data.id];
              if (!pos_conf) {
                pos_conf = data.conf;
                pos_conf.id = data.id;
                if (pos_conf) {
                  pos_conf = new sf_host.PosConfig(pos_conf);
                }
              }
              if (!pos_conf) {
                _log("no position conf found pre-defined or inline for position " + data.id, true);
                continue;
              }
              if (!pos_conf.dest) {
                pos_conf = new sf_host.PosConfig(pos_conf, _guid(SF_POSELEM_WRAPPER_CLASS));
              }
              if (data.meta) {
                pos_meta = data.meta;
                meta_key = "";
                shared_meta = {};
                for (meta_key in pos_meta) {
                  pos_meta_item = pos_meta[meta_key];
                  typ = typeof pos_meta_item;
                  if (!prv_meta && typ === "object" && pos_meta_item) {
                    prv_meta = pos_meta_item;
                    prv_meta_key = meta_key;
                  }
                  if (typ !== "object" && typ !== "function") {
                    shared_meta[meta_key] = pos_meta_item;
                  }
                }
                pos_meta = new sf_host.PosMeta(shared_meta, prv_meta_key || "", (prv_meta_key && prv_meta ? prv_meta : null));
              }
              pos_obj = new sf_host.Position(data, null, pos_meta, pos_conf);
              inline_tags_processed[script_tag_id] = script_tag_id;
              pos_dest_el = _elt(pos_conf.dest);
              if (!pos_dest_el) {
                if (_ready()) {
                  pos_dest_el = dom.make("div");
                  _attr(pos_dest_el, "id", pos_conf.dest);
                  try {
                    script_tag_par.insertBefore(pos_dest_el);
                  } catch (_error) {
                    err = _error;
                    _log("failed auto-adding destination element " + err.message, true);
                    continue;
                  }
                } else {
                  d.write("<div id='", pos_conf.dest, "'></div>");
                }
              }
              boot_positions.push(pos_obj);
            }
          } else {
            _log("no content or id property found in the inline position object", true);
          }
        }
      }
      if (boot_positions.length) {
        try {
          sf_host.render(boot_positions);
        } catch (_error) {
          e = _error;
          _log("failed during rendering " + e.message);
        }
      } else {
        _log("no positions to boot");
      }
      dom.wait(_clean_up_booted_tags);
    };
    SF_DATATAG_CLASS = "sf_data";
    SF_TAG_TYPE = "text/x-safeframe";
    AUTO_BOOT_MAX_RETRIES = 100;
    SF_POSELEM_WRAPPER_CLASS = "sf_position";
    d = win && win.document;
    lib = sf.lib;
    lang = lib.lang;
    dom = lib.dom;
    _cstr = lang.cstr;
    _guid = lang.guid;
    _elt = dom.elt;
    _par = dom.par;
    _tags = dom.tags;
    _attr = dom.attr;
    _purge = dom.purge;
    _ready = dom.ready;
    inline_tags_processed = {};
    boot_retries = 0;
    has_booted = false;
    doing_auto_boot = false;
    setTimeout(_auto_boot, 50);
    return sf;
  })(window, sf);

}).call(this);

},{"../shared/base":18}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@namespace $sf.host Defines the Publisher side api, and helper functions
@name $sf.host
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.2
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require('./boot');

  module.exports = (function(window, sf) {
    var ATTACH, AUTO, AUTO_BOOT_MAX_RETRIES, BF_POS_MSG, CLIP, COLLAPSE_COMMAND, COMPARE_DOC_POS, COMPAT_MODE, CONTAINS, Config, DEFAULT_RENDER_TIMEOUT, DEFAULT_ZINDEX, DETACH, DOC, DOC_EL, EL_FROM_PT, ERROR_COMMAND, EXPAND_COMMAND, FLASH_MIME, GEOM_UPDATE_INTRVAL, GUID, HEIGHT, HIDDEN, IE_BORDER_ADJ, INTERSECT_FACTOR, LEN, M, MSG, NODE_TYPE, NOTIFY_COLLAPSE, NOTIFY_EXPAND, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, OBJ, ONSCROLL, OVER, PMSG, POS_ID_AUTO_PREFIX, POS_MSG, POS_REL_BOX_ID_PREFIX, PX, ParamHash, PosConfig, PosMeta, Position, SCROLL, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, ST, STR, SUPPORTS_FEATURES, TFXD, VERSION, WIDTH, XCOM_RESP_DELAY, attach_iframe_msging, bounds, canUseHTML5, complete_ifrs, config, contains, currentStyle, current_status, dc, detach_iframe_msging, docRect, dom, env, flashActiveXVersions, flash_ver, focus_update_timer, geckVer, geom_update_timer, get, html5Bound, ieVer, ifr_dest_id_map, iframes, inViewPercentage, initID, isIE, lang, lib, loc, locHost, mgr_bounds_details, msg_pipes, msghostfb, nuke, operaVer, overlaps, pending_ifrs, prep_iframe_msging, render, rendered_ifrs, scroll_parents_attached, send_msg_to_child_iframe, status, ua, usingHTML5, wbVer, win, winRect, win_events_attached, _attr, _build_geom, _calcBorders, _call_xmsg_host_fb, _callable, _cbool, _check_html5_init, _clear_focus_update_timer, _clear_geom_update_timer, _cnum, _collapse_safeframe, _cookieHash, _cookies_enabled_test, _create_pos_markup, _cstr, _doc, _docNode, _elt, _es, _expand_safeframe, _fire_pub_callback, _getClip, _getGeom, _getRectIE, _getRectNonIE, _get_doc_scroll, _get_flash_version, _guid, _handle_frame_load, _handle_msg_evt, _handle_msg_from_outside, _handle_node_scroll, _handle_render_timeout, _handle_unload, _handle_win_blur, _handle_win_focus, _handle_win_geom_resize, _handle_win_geom_scroll, _has_pending_renders, _ifr_view, _isPX, _max, _min, _mix, _noop, _par, _purge, _read_cookie, _ready, _record_error, _rect, _round, _send_generic_response, _send_response, _set_focus_update_timer, _set_geom_update_timer, _shim_frame, _strippedEncodedLocation, _tagName, _tags, _update_focus, _update_geom, _update_geom_win_resize, _update_geom_win_scroll, _view, _write_cookie;
    win = window;
    DEFAULT_RENDER_TIMEOUT = 60000;
    POS_ID_AUTO_PREFIX = "sf_pos";
    POS_REL_BOX_ID_PREFIX = "sf_pos_rel_el";
    SF_DATATAG_CLASS = "sf_data";
    SF_POSELEM_WRAPPER_CLASS = "sf_position";
    AUTO_BOOT_MAX_RETRIES = 100;
    GEOM_UPDATE_INTRVAL = 100;
    XCOM_RESP_DELAY = 1;
    IE_BORDER_ADJ = 2;
    INTERSECT_FACTOR = 10;
    BF_POS_MSG = "onBeforePosMsg";
    POS_MSG = "onPosMsg";
    SUPPORTS_FEATURES = {
      "exp-ovr": 1,
      "exp-push": 0,
      bg: 0,
      pin: 0,
      "read-cookie": 0,
      "write-cookie": 0
    };
    EXPAND_COMMAND = "exp-ovr";
    COLLAPSE_COMMAND = "collapse";
    ERROR_COMMAND = "error";
    NOTIFY_EXPAND = "expand";
    NOTIFY_GEOM_UPDATE = "geom-update";
    NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
    NOTIFY_FOCUS_CHANGE = "focus-change";
    DEFAULT_ZINDEX = 3000;
    OBJ = "object";
    STR = "string";
    ST = "style";
    LEN = "length";
    WIDTH = "width";
    HEIGHT = "height";
    PX = "PX";
    CLIP = "clip";
    SCROLL = "scroll";
    ONSCROLL = "onscroll";
    COMPAT_MODE = "compatMode";
    DOC_EL = "documentElement";
    DOC = "document";
    NODE_TYPE = "nodeType";
    CONTAINS = "contains";
    COMPARE_DOC_POS = "compareDocumentPosition";
    EL_FROM_PT = "elementFromPoint";
    AUTO = "auto";
    HIDDEN = "hidden";
    OVER = "overflow";
    TFXD = "toFixed";
    ATTACH = "attach";
    DETACH = "detach";
    MSG = "message";
    PMSG = "postMessage";
    GUID = "guid";
    FLASH_MIME = "application/x-shockwave-flash";
    VERSION = sf.ver;
    env = sf.env;
    ua = env.ua;
    lib = sf.lib;
    lang = lib.lang;
    dom = lib.dom;
    iframes = dom.iframes;
    _cbool = lang.cbool;
    _cnum = lang.cnum;
    _cstr = lang.cstr;
    _callable = lang.callable;
    _noop = lang.noop;
    _guid = lang[GUID];
    _mix = lang.mix;
    _elt = dom.elt;
    _par = dom.par;
    _tags = dom.tags;
    _attr = dom.attr;
    _doc = dom.doc;
    _tagName = dom.tagName;
    _view = dom.view;
    _ifr_view = iframes.view;
    _purge = dom.purge;
    _ready = dom.ready;
    _es = win && win.escape;
    M = win && win.Math;
    _max = M.max;
    _min = M.min;
    _round = M.round;
    _rect = null;
    ParamHash = lang && lang.ParamHash;
    dc = win && win[DOC];
    isIE = env && env.isIE;
    ieVer = (ua && ua.ie) || 0;
    wbVer = (ua && ua.webkit) || 0;
    geckVer = (ua && ua.gecko) || 0;
    operaVer = (ua && ua.opera) || 0;
    loc = win.location;
    locHost = loc && ((loc.protocol + "//" + (loc.host || loc.hostname)) || "");
    rendered_ifrs = {};
    msg_pipes = {};
    ifr_dest_id_map = {};
    pending_ifrs = {};
    complete_ifrs = {};
    scroll_parents_attached = {};
    mgr_bounds_details = false;
    canUseHTML5 = false;
    html5Bound = false;
    win_events_attached = false;
    geom_update_timer = 0;
    focus_update_timer = 0;
    current_status = null;
    msghostfb = null;
    flash_ver = null;
    config = null;
    flashActiveXVersions = ["ShockwaveFlash.ShockwaveFlash.11", "ShockwaveFlash.ShockwaveFlash.8", "ShockwaveFlash.ShockwaveFlash.7", "ShockwaveFlash.ShockwaveFlash.6", "ShockwaveFlash.ShockwaveFlash"];
    initID = void 0;

    /*
    Configure the base-level settings for the SafeFrames library
    Note that only one configuration can be active at a given time.
    Therefore you cannot change the configuration by creating a new $sf.host.Config while
    the SafeFrames library is busy (however you can add new position configurations).
    Instatiating a new config, when the library is not busy will destroy / remove all currently
    managed positions and there configurations.
    
    @name $sf.host.Config
    @constructor
    @public
    @param {Object} conf An object containing properties for configuration
    @param {Boolean} [conf.auto] Whether or not to have SafeFrames automatically boostrap an render any SafeFrames tags within the page
    @param {String} conf.cdn The protocol,host name, and port parts of a URI, that is a 2ndary origin, used with SafeFrames to render content. For example JS files would be loaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/[filename]"
    @param {Boolean} [conf.debug] Whether or not debug mode is on or off
    @param {String} conf.root The root path part of the URI that is a 2ndary origin, used with SafeFrames to render content. For example the HTML file for rendering content into would beloaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/"+conf.renderFile
    @param {String} conf.renderFile The filename (may also include path info), for which to render content into via a SafeFrame.
    @param {String} [conf.msgFile] The filename (may also include path info), for which to use as a proxy for x-domain messaging whenever HTML5 messaging is not available. Only required if supporting older browsers.
    @param {Number} [conf.to] The maximum amount of time in milliseconds to wait for a SafeFrame to finish rendering, defaults to 60 seconds.
    @param {Function} [conf.onBeforePosMsg] A callback function that gets fired before any cancellable action is requested to be peformed from a a SafeFrame, such as expansion, etc.  Return true out of this callback function to cancel/disallow the action in question.
    @param {Function} [conf.onPosMsg] A callback function that gets fired when an action requested by a SafeFrame is performed
    @param {Function} [conf.onStartPosRender] A callback function that gets fired when a SafeFrame starts to render 3rd party content.
    @param {Function} [conf.onEndPosRender] A callback function that gets fired when a SafeFrame finishes rendering 3rd party content.
    @param {Object} [conf.positions] A map of positions to automatically configure, where each key equals the id of the $sf.host.PosConfig object, and the value is an object containing said object's settings.
     */
    Config = function(conf) {
      var boot_up, conf_pos_map, me, posID, pos_conf, pos_id, pos_map;
      me = this;
      if (!arguments.length) {
        return (config ? _mix({}, config) : null);
      }
      if (!(me instanceof Config)) {
        return new Config(conf);
      }
      if (!conf) {
        config = null;
        return null;
      }
      boot_up = !!config;
      me.auto = ("auto" in conf ? _cbool(conf.auto) : true);
      me.cdn = _cstr(conf.cdn);
      me.debug = _cbool(conf.debug);
      me.root = _cstr(conf.root);
      me.renderFile = _cstr(conf.renderFile);
      me.msgFile = _cstr(conf.msgFile);
      me.to = _cnum(conf.to, DEFAULT_RENDER_TIMEOUT);
      me.ver = _cstr(conf.ver) || VERSION;
      me.onBeforePosMsg = (_callable(conf.onBeforePosMsg) ? conf.onBeforePosMsg : _noop);
      me.onPosMsg = (_callable(conf.onPosMsg) ? conf.onPosMsg : _noop);
      me.onStartPosRender = (_callable(conf.onStartPosRender) ? conf.onStartPosRender : _noop);
      me.onEndPosRender = (_callable(conf.onEndPosRender) ? conf.onEndPosRender : _noop);
      me.onFailure = (_callable(conf.onFailure) ? conf.onFailure : _noop);
      me.onAdLoad = (_callable(conf.onAdLoad) ? conf.onAdLoad : _noop);
      me.onReadCookie = (_callable(conf.onReadCookie) ? conf.onReadCookie : _noop);
      me.onWriteCookie = (_callable(conf.onWriteCookie) ? conf.onWriteCookie : _noop);
      conf_pos_map = conf.positions;
      me.positions = pos_map = {};
      if (conf_pos_map) {
        for (posID in conf_pos_map) {
          pos_conf = conf_pos_map[posID];
          if (pos_conf && typeof pos_conf === OBJ) {
            pos_id = posID || pos_conf.id || _guid(POS_ID_AUTO_PREFIX);
            pos_map[pos_id] = new PosConfig(pos_conf);
          }
        }
      }
      config = me;
      boot_up = !!(boot_up && me.auto && (sf.host.boot != null));
      try {
        if (boot_up) {
          sf.host.boot();
        }
      } catch (_error) {}
      return _mix({}, config);
    };

    /*
    Configure a particualar position for rendering a SafeFrame
    Each $sf.host.PosConfig object has an id property that should be unique.  Creating a new $sf.host.PosConfig with an id, that has already been
    used results in changing the old $sf.host.PosConfig settings, and can only be done if the SafeFrames library is not busy.
    Automatically ads to the position map of the $sf.host.Config object if said config has already been created.
    
    @name $sf.host.PosConfig
    @public
    @constructor
    @param {Object|String} posIDorObj The id of the $sf.host.PosConfig instance, or an object containing all settings that are to be used for the instance.
    @param {String} [posIDorObj.id] The id of the $sf.host.PosConfig instance, if not specified one will be generated automatically.
    @param {String} [posIDorObj.dest] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
    @param {String} [posIDorObj.bg] The color of the background to be used inside the SafeFrame. Default equals "transparent".
    @param {String} [posIDorObj.tgt] The name of the target window where hyperlinks inside a SafeFrame will navigate too...Note that "_self" is not allowed and always converted to "_top". Allowed values are any string value not prefixed with "_", or "_top" or "_blank".
    @param {String} [posIDorObj.css] A string of CSS rules, or a URL that points to a CSS style sheet to be used inside the SafeFrame
    @param {Number} [posIDorObj.w] The width of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
    @param {Number} [posIDorObj.h] The height of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
    @param {String} [posIDorObj.size] A string formated as "widthXheight", that defines the width and height of the SafeFrame. The delimiter character "X" is can be specified as lower or upper case.
    @param {String} [posIDorObj.z] The z-index of the SafeFrame.
    @param {Object} [posIDorObj.supports] An object containing key/value pairs for what features/actions are supported by the SafeFrame, and its corresponding value represents a boolean detereming whether that feature can be used.  Currently supported keys are "exp-ovr" == SafeFrame can expand in overlay mode, "exp-push" == SafeFrame can expand in push mode, and "bg" == SafeFrame can change the background of the publisher / host.
    @param {String} [destID] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
    @param {Object} [baseConf] An object representing a $sf.host.Config object to automatically use / create for the SafeFrames library. Note that baseConf can only be used one time, otherwise you have to use the $sf.host.Config object directly.
     */
    PosConfig = function(posIDorObj, destID, baseConf) {
      var me, sz, sz_split, typ;
      me = this;
      typ = (posIDorObj && typeof posIDorObj) || "";
      if (!(me instanceof PosConfig)) {
        return new PosConfig(posIDorObj, destID, baseConf);
      }
      if (typ === OBJ) {
        me.id = _cstr(posIDorObj.id);
        me.dest = _cstr(posIDorObj.dest || destID);
        me.bg = _cstr(posIDorObj.bg) || "transparent";
        me.tgt = _cstr(posIDorObj.tgt) || "_top";
        me.css = _cstr(posIDorObj.css);
        me.w = _cnum(posIDorObj.w, 0);
        me.h = _cnum(posIDorObj.h, 0);
        me.z = _cnum(posIDorObj.z, 0);
        me.supports = _mix({}, posIDorObj.supports || SUPPORTS_FEATURES, true, true, true);
        if (!me.w || !me.h) {
          sz = _cstr(posIDorObj.size);
          if (sz) {
            sz_split = sz.split(/x/g);
            me.w = _cnum(sz_split[0], 0);
            me.h = _cnum(sz_split[1], 0);
            me.size = sz;
          } else {
            me.size = "";
          }
        } else {
          me.size = me.w + "x" + me.h;
        }
      } else if (typ === "string") {
        me.id = _cstr(posIDorObj);
        me.dest = _cstr(destID);
      } else {
        me.dest = "";
        me.bg = "transparent";
        me.tgt = "_top";
        me.css = "";
        me.w = 0;
        me.h = 0;
        me.size = "";
        me.z = 0;
        me.supports = {};
      }
      me.id = me.id || _guid(POS_ID_AUTO_PREFIX);
      if (!config && baseConf) {
        Config(baseConf);
      }
      if (config) {
        config.positions[me.id] = me;
      }
      return _mix({}, me);
    };

    /*
    Construct a set of dynamic key/value pairs that can be shared as meta-data with the 3rd party content inside a SafeFrame.
    All data is treated as protected, and can only be specfied during construction of this object.
    
    @exports PosMeta as $sf.host.PosMeta#
    @public
    @constructor
    @class
    @param {Object} shared_object An object containing keys and values to be shared as meta-data inside the SafeFrame
    @param {String} [owner_key] A key name to be used to hold pseudo private keys / values of meta data.
    @param {Object} [owned_obj] An object containing psuedo private keys and values to be shared as meta-data inside the SafeFrame.
    @example
    var shared_data 		 = {content_id:8978098,partner_id:99},
    private_data_key	 = "rmx",
    private_data      = {section_id:2342,site_id:23904},
    meta_data		 = new $sf.host.PosMeta(shared_data, private_data_key, private_data);
    
    //show section id on host side
    alert(meta_data.value("rmx", "site_id")); //== 23904
    
    @example
    //now retrieve this information inside the safe frame
    
    var content_id = $sf.vend.meta("content_id"); //== 8978098
    
    var rmx_section_id = $sf.vend.meta("rmx", "section_id") //== 2342, but note that vendor side code must know the "owner_key" upfront.
     */
    PosMeta = function(shared_obj, owner_key, owned_obj) {

      /*
      A method retrieves a meta data value from this object.
      
      @exports get_value as $sf.host.PosMeta#value
      @param {String} propKey The name of the value to retrieve
      @param {String} [owner_key] The name of the owner key of the meta data value. By default, it is assumed to be shared, so nothing needs to be passed in unless looking for a specific proprietary value
      @return {String|Number|Boolean}
      @default {String} ""
      @public
      @function
       */
      var get_value, me, non_shared, old, posConf, serialize, set_value, shared;
      get_value = function(propKey, owner_key) {
        var ret;
        ret = "";
        if (!propKey || typeof propKey !== STR) {
          return ret;
        }
        if (!owner_key || typeof owner_key !== STR) {
          owner_key = "shared";
        }
        if (owner_key === "shared") {
          ret = shared[propKey] || "";
        } else {
          ret = (propKey in non_shared ? non_shared[prop_key] || "" : "");
        }
        return ret;
      };

      /*
      Return a serialized string representation (in url query string format) of the meta data object
      
      @exports serialize as $sf.host.PosMeta#toString
      @function
      @public
       */
      serialize = function() {
        var obj;
        obj = new ParamHash();
        obj.shared = shared;
        obj.non_shared = non_shared;
        return obj.toString();
      };
      set_value = function(propKey, ownerKey, value) {
        non_shared[ownerKey] || (non_shared[ownerKey] = {});
        return non_shared[ownerKey][propKey] = value;
      };
      me = this;
      shared = void 0;
      non_shared = void 0;
      old = void 0;
      posConf = void 0;
      if (!(me instanceof PosMeta)) {
        return new PosMeta(key, owned_obj, pos, shared_obj);
      }
      shared = {};
      non_shared = {};
      if (!owner_key || typeof owner_key !== STR) {
        return me;
      }
      if (shared_obj && typeof shared_obj === OBJ) {
        shared = _mix(shared, shared_obj);
      }
      if (owned_obj && typeof owned_obj === OBJ) {
        non_shared[owner_key] = owned_obj;
      }
      me.toString = serialize;
      me.value = get_value;
      me.setValue = set_value;
    };

    /*
    Create the HTML markup for a position if a src property was used
    
    @name $sf.host-_create_pos_markup
    @function
    @private
    @static
    @return {String}
     */
    _create_pos_markup = function(src) {
      var ckVal, fVer;
      if (src) {
        if (src.indexOf("${sf_ver}") > -1) {
          src = src.replace(/\${sf_ver}/g, $sf.ver);
        }
        if (src.indexOf("${ck_on}") > -1) {
          ckVal = (_cookies_enabled_test() ? "1" : "0");
          src = src.replace(/\${ck_on}/g, ckVal);
        }
        if (src.indexOf("${flash_ver}") > -1) {
          fVer = _get_flash_version();
          src = src.replace(/\${flash_ver}/g, fVer);
        }
      }
      return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
    };

    /*
    Get the falsh version number
     */
    _get_flash_version = function() {
      var err, getActiveXVersion, i, mimeTypes, obj, p, tmpVer;
      if (flash_ver !== null) {
        return flash_ver;
      }
      if (navigator.plugins && navigator.plugins.length > 0) {
        mimeTypes = navigator.mimeTypes;
        if (mimeTypes && mimeTypes[FLASH_MIME] && mimeTypes[FLASH_MIME].enabledPlugin && mimeTypes[FLASH_MIME].enabledPlugin.description) {
          flash_ver = mimeTypes[FLASH_MIME].enabledPlugin.version;
        }
      } else if (sf.env.isIE) {
        i = 0;
        while (i < flashActiveXVersions.length) {
          try {
            obj = new ActiveXObject(flashActiveXVersions[i]);
            tmpVer = obj.GetVariable("$version");
            p = tmpVer.indexOf(" ");
            if (p > -1) {
              flash_ver = tmpVer.substr(p + 1).replace(/,/g, ".");
            } else {
              flash_ver = tmpVer.replace(/,/g, ".");
            }
            break;
          } catch (_error) {
            err = _error;
            obj = null;
            flash_ver = 0;
            continue;
          }
          i++;
        }
      } else {
        flash_ver = 0;
      }
      return flash_ver;
      getActiveXVersion = function(activeXObj) {
        var version;
        version = -1;
        try {
          version = activeXObj.GetVariable("$version");
        } catch (_error) {}
        return version;
      };
    };

    /*
    Test to see if cookies are enabled
     */
    _cookies_enabled_test = function() {
      var cookieEnabled;
      cookieEnabled = (navigator.cookieEnabled ? true : false);
      if (typeof navigator.cookieEnabled === "undefined" && !cookieEnabled) {
        document.cookie = "testcookie";
        cookieEnabled = (document.cookie.indexOf("testcookie") !== -1 ? true : false);
        if (navigator) {
          navigator.cookieEnabled = cookieEnabled;
        }
      }
      return cookieEnabled;
    };

    /*
    Construction a postion content object that contains HTML, optionally meta-data, and optionally a position configuration to use.
    The id specified must match an id for a $sf.host.PosConfig (although said config could be specfied directly here via arguments).
    
    @name $sf.host.Position
    @constructor
    @public
    @param {Object|String} posIDorObj The id of the position which maps to its configuration, or an object represeting the various values of an $sf.host.Position instance.
    @param {String} [posIDorObj.id] The id of the position which maps to its configuration.
    @param {String} [posIDorObj.html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
    @param {String} [posIDorObj.src] An optional URL to be used for redering inside the SafeFrame which will automatically generate a SCRIPT tag with the specified URL.
    @param {$sf.host.PosMeta} [posIDorObj.meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
    @param {Object} [posIDorObj.conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
    @param {String} [html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
    @param {$sf.host.PosMeta} [meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
    @param {Object} [conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
     */
    Position = function(posIDorObj, html, meta, conf) {
      var id, me, msg, origHtml, typ;
      me = this;
      typ = posIDorObj && typeof posIDorObj;
      origHtml = html;
      if (!(me instanceof Position)) {
        return new Position(posIDorObj, html, meta, conf);
      }
      if (config == null) {
        msg = "Publisher Config not initialized - abort";
        sf.lib.logger.error(msg);
        sf.info.errs.push(msg);
        return;
      }
      if (typ === OBJ) {
        _mix(me, posIDorObj);
      } else {
        id = me.id = _cstr(posIDorObj) || _guid(POS_ID_AUTO_PREFIX);
      }
      if (!html) {
        if (me.src) {
          me.html = _create_pos_markup(me.src);
        } else {
          me.html = me.html || "";
          me.src = "";
        }
      } else {
        me.html = html;
        me.src = "";
      }
      if (!me.html) {
        me.html = "";
      }
      me.meta = meta || me.meta || {};
      me.conf = conf || me.conf || {};
      if (id) {
        if (config && config.positions[id]) {
          me.conf = config.positions[id];
        } else {
          if (conf) {
            conf.id = id;
            me.conf = new PosConfig(conf);
          }
        }
      }
    };

    /*
    @namespace $sf.lib.dom.msghost Contains functionality to reside in the top level page for sending and receiving x-domain messages to SafeFrame containers
    @name $sf.lib.dom.msghost
     */

    /*
    Returns the root document HTMLElement / node
    @name $sf.lib.dom-_docNode
    @private
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as a reference for finding the root document element.
    @returns {HTMLElement}
     */
    _docNode = function(el) {
      var compatMode, d, root;
      d = (el && _doc(el)) || dc;
      compatMode = d[COMPAT_MODE];
      root = d[DOC_EL];
      if (compatMode && !operaVer && compatMode !== "CSS1Compat") {
        root = d.body;
      }
      return root;
    };

    /*
    Returns whether or not a value is specified in pixels
    @name $sf.lib.dom-_isPX
    @private
    @static
    @function
    @param {String} val A css value of size
    @returns {Boolean}
     */
    _isPX = function(val) {
      val = _cstr(val);
      if (val && val.search(/\D+/g) === -1) {
        return true;
      }
      if (val && val.search(/px/g) !== -1) {
        return true;
      }
    };

    /*
    Return an array of values of clipping region information. Array represents top, right, bottom, left values respectively.
    If values are not specified in pixels, or no clip region is defined for that element, -1 is returned for each value.
    
    @name $sf.lib.dom-_getClip
    @private
    @function
    @static
    @param {HTMLStyleObject} curSt The current style object of an HTMLElement
    @return {Array}
     */
    _getClip = function(curSt) {
      var clipVal, idx, len, prop, props, ret, val;
      ret = [-1, -1, -1, -1];
      props = [CLIP + "Top", CLIP + "Right", CLIP + "Bottom", CLIP + "Left"];
      idx = 0;
      clipVal = void 0;
      prop = void 0;
      val = void 0;
      len = void 0;
      if (!curSt) {
        return ret;
      }
      if (ieVer) {
        while (prop = props[idx]) {
          clipVal = curSt[prop];
          if (_isPX(clipVal)) {
            clipVal = _cnum(clipVal, -1);
            if (clipVal >= 0) {
              ret[idx] = clipVal;
            }
          }
          idx++;
        }
      } else {
        clipVal = curSt[CLIP];
        if (clipVal && clipVal.search(/\d+/g) !== -1) {
          clipVal = clipVal.replace(/\w+\(([^\)]*?)\)/g, "$1");
          ret = clipVal.split(" ");
          ret = (ret[LEN] <= 1 ? ret.split(",") : ret);
          len = ret[LEN];
          idx = 0;
          while (len--) {
            val = ret[idx];
            if (!_isPX(val)) {
              ret[idx] = -1;
            } else {
              ret[idx] = _cnum(val, -1);
            }
            idx++;
          }
        }
      }
      return ret;
    };

    /*
    Returns border values in pixels if possible to help calculate geometry of an element
    
    @name $sf.lib.dom-_calcBorders
    @private
    @static
    @function
    @param {HTMLElement} el The HTMLElement for which to look at. . .
    @param {Object} rect The rect object generated for the HTMLElement in question to be adjusted
    @returns {Object} rect
     */
    _calcBorders = function(el, rect) {
      var l, re, st, t;
      t = 0;
      l = 0;
      st = void 0;
      re = /^t(?:able|d|h|r|head|foot)$/i;
      st = currentStyle(el);
      if (st) {
        t = st["borderTopWidth"];
        l = st["borderLeftWidth"];
        t = (_isPX(t) ? _cnum(t, 0) : 0);
        l = (_isPX(l) ? _cnum(l, 0) : 0);
        if (geckVer && re.test(_tagName(el))) {
          t = l = 0;
        }
      }
      rect = rect || {
        t: 0,
        l: 0
      };
      rect.t += t;
      rect.l += l;
      return rect;
    };

    /*
    Retrieve scroll values of a document
    
    @name $sf.lib.dom-_get_doc_scroll
    @private
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as a reference document rather than the default main document
    @return {Object} Contains x, y, w, h properties for scrolling
     */
    _get_doc_scroll = function(el) {
      var d, db, de, def, dv, offsetX, offsetY, pos;
      pos = {
        x: 0,
        y: 0,
        w: 0,
        h: 0
      };
      def = {
        scrollLeft: 0,
        scrollTop: 0,
        scrollWidth: 0,
        scrollHeight: 0
      };
      d = void 0;
      de = void 0;
      dv = void 0;
      db = void 0;
      offsetX = 0;
      offsetY = 0;
      d = _doc(el) || dc;
      de = d[DOC_EL] || def;
      db = d.body || def;
      dv = d.defaultView;
      if (dv) {
        offsetX = _cnum(dv.pageXOffset, 0);
        offsetY = _cnum(dv.pageYOffset, 0);
      }
      pos.x = _max(de.scrollLeft, db.scrollLeft, offsetX);
      pos.y = _max(de.scrollTop, db.scrollTop, offsetY);
      pos.w = _max(de.scrollWidth, db.scrollWidth, 0);
      pos.h = _max(de.scrollHeight, db.scrollHeight, 0);
      return pos;
    };

    /*
    Calculate a geometric rectangle for a given element. Note that for IE browsers
    we can use the "getBoundingClientRect" function which saves us some time / increases
    peformance. . however it really can only be called if the DOM is completely loaded,
    and if that is the case we fallback to the brute-force / non-IE method.
    
    @name $sf.lib.dom-_getRectIE
    @private
    @static
    @function
    @param {HTMLElement} el  The element for which to derive a rectangle object
    @returns {Object} An object representing the rectangle for the given HTMLElement
     */
    _getRectIE = function(el) {
      var adjustX, adjustY, bLeft, bTop, box, compatMode, d, de, e, rect, scroll, st, _back;
      rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        w: 0,
        h: 0,
        z: 0
      };
      _back = "BackCompat";
      scroll = void 0;
      box = void 0;
      d = void 0;
      de = void 0;
      compatMode = void 0;
      st = void 0;
      adjustX = void 0;
      adjustY = void 0;
      bLeft = void 0;
      bTop = void 0;
      if (el && el[NODE_TYPE] === 1) {
        try {
          d = _doc(el) || dc;
          if (!dom.ready()) {
            return _getRectNonIE(el);
          }
          scroll = _get_doc_scroll(el);
          box = el.getBoundingClientRect();
          rect.t = box.top;
          rect.l = box.left;
          adjustX = adjustY = IE_BORDER_ADJ;
          compatMode = d[COMPAT_MODE];
          de = d[DOC_EL];
          st = currentStyle(de);
          bLeft = st["borderLeftWidth"];
          bTop = st["borderTopWidth"];
          if (ieVer === 6) {
            if (compatMode !== _back) {
              adjustX = adjustY = 0;
            }
          }
          if (compatMode === _back) {
            bLeft = (_isPX(bLeft) ? _cnum(bLeft, 0) : 0);
            adjustX = bLeft;
            bTop = (_isPX(bTop) ? _cnum(bTop, 0) : 0);
            adjustY = bTop;
            rect.t -= adjustX;
            rect.l -= adjustY;
          }
          rect.t += scroll.y;
          rect.l += scroll.x;
          rect.b = rect.t + el.offsetHeight;
          rect.r = rect.l + el.offsetWidth;
          rect.w = _max(rect.r - rect.l, 0);
          rect.h = _max(rect.b - rect.t, 0);
          rect.z = currentStyle(el, "zIndex");
        } catch (_error) {
          e = _error;
          rect = {
            t: 0,
            l: 0,
            r: 0,
            b: 0,
            w: 0,
            h: 0,
            z: 0
          };
        }
      }
      return rect;
    };

    /*
    Calculate a geometric rectangle for a given element. For non-IE browsers, we must use
    brute-force and walk up the offsetParent tree. Also takes in consideration for some
    other slight variations in browsers.
    
    @name $sf.lib.dom-_getRectNonIE
    @private
    @static
    @function
    @param {HTMLElement} el  The element for which to derive a rectangle object
    @returns {Object} An object representing the rectangle for the given HTMLElement
     */
    _getRectNonIE = function(el) {
      var bCheck, e, h, parentNode, rect, root, scroll, scrollLeft, scrollTop, w;
      rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        w: 0,
        h: 0,
        z: 0
      };
      scrollTop = 0;
      scrollLeft = 0;
      bCheck = false;
      root = _docNode(el);
      scroll = _get_doc_scroll(el);
      parentNode = void 0;
      w = void 0;
      h = void 0;
      if (el && el[NODE_TYPE] === 1) {
        try {
          rect.l = el.offsetLeft || 0;
          rect.t = el.offsetTop || 0;
          parentNode = el;
          bCheck = geckVer || wbVer > 519;
          while (parentNode = parentNode.offsetParent) {
            rect.t += parentNode.offsetTop || 0;
            rect.l += parentNode.offsetLeft || 0;
            if (bCheck) {
              _calcBorders(parentNode, rect);
            }
            if (parentNode === root) {
              break;
            }
          }
          parentNode = el;
          if (currentStyle(parentNode, "position") !== "fixed") {
            parentNode = el;
            while (parentNode = _par(parentNode)) {
              if (parentNode[NODE_TYPE] === 1) {
                scrollTop = parentNode.scrollTop || 0;
                scrollLeft = parentNode.scrollLeft || 0;
                if (geckVer && currentStyle(parentNode, OVER) !== "visible") {
                  _calcBorders(parentNode, rect);
                }
                rect.l -= scrollLeft;
                rect.t -= scrollTop;
              }
              if (parentNode === root) {
                break;
              }
            }
            rect.t += scroll.y;
            rect.l += scroll.x;
          } else {
            rect.t += scroll.y;
            rect.l += scroll.x;
          }
          if (!ieVer && el === _docNode(el)) {
            h = el.clientHeight;
            w = el.clientWidth;
          } else {
            h = el.offsetHeight;
            w = el.offsetWidth;
          }
          rect.b = rect.t + h;
          rect.r = rect.l + w;
          rect.w = _max(rect.r - rect.l, 0);
          rect.h = _max(rect.b - rect.t, 0);
          rect.z = currentStyle(el, "zIndex");
        } catch (_error) {
          e = _error;
          rect = {
            t: 0,
            l: 0,
            r: 0,
            b: 0,
            w: 0,
            h: 0,
            z: 0
          };
        }
      }
      return rect;
    };

    /*
    Returns an object that represents a rectangle with the geometric information of an HTMLDocument
    (includes scroll width / height)
    
    @name $sf.lib.dom.docRect
    @public
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as the reference for an HTMLDocument
    @returns {Object}
     */
    docRect = function(el) {
      var h, root, w;
      root = _docNode(el);
      w = 0;
      h = 0;
      if (root) {
        w = root.scrollWidth || 0;
        h = root.scrollHeight || 0;
      }
      return {
        t: 0,
        l: 0,
        b: h,
        r: w,
        w: w,
        h: h
      };
    };

    /*
    Returns an object that represents a rectangle with the geometric information of an HTMLWindow
    (does not include scroll width / height)
    
    @name $sf.lib.dom.winRect
    @public
    @static
    @function
    @param {HTMLElement} [el] An HTMLElement to use as the references for an HTMLWindow
    @returns {Object}
     */
    winRect = function(el) {
      var b, h, l, r, root, t, w, wi;
      wi = (el && _view(el)) || win;
      h = wi.innerHeight || 0;
      w = wi.innerWidth || 0;
      t = wi.screenY || wi.screenTop || 0;
      b = h + t;
      l = wi.screenX || wi.screenLeft || 0;
      r = w + l;
      root = _docNode(el);
      if (!h && !w && root) {
        h = root.clientHeight || 0;
        w = root.clientWidth || 0;
        r = l + w;
        b = t + h;
      }
      return {
        t: t,
        l: l,
        b: b,
        r: r,
        w: w,
        h: h
      };
    };

    /*
    Returns whether or not an HTMLElement is contained within another HTMLElement
    
    @name $sf.lib.dom.contains
    @public
    @static
    @function
    @param {HTMLElement} element The HTMLElement reference to search within
    @param {HTMLElement} needle The HTMLElement for which you want to check if its contained by the 1st parameter
    @returns {Boolean}
     */
    contains = function(element, needle) {
      var el_node_type, needle_node_type, ret;
      ret = false;
      el_node_type = (element && element[NODE_TYPE]) || -1;
      needle_node_type = (needle && needle[NODE_TYPE]) || -1;
      if (el_node_type === 1 && needle_node_type !== -1) {
        if (element[CONTAINS]) {
          if (operaVer || needle_node_type === 1) {
            ret = element[CONTAINS](needle);
          } else {
            while (needle) {
              if (element === needle) {
                ret = true;
                break;
              }
              needle = needle.parentNode;
            }
          }
        } else {
          if (element[COMPARE_DOC_POS]) {
            ret = element === needle || !!(element[COMPARE_DOC_POS](needle) & 16);
          }
        }
      }
      return ret;
    };

    /*
    Returns the current value of a style attribute, or the current style object in its entirety depending on whether an attribute parameter is specified
    
    @name $sf.lib.dom.currentStyle
    @public
    @static
    @function
    @param {HTMLElement} el The HTMLElement for which to retrieve style information
    @param {String} [attr] The style attribute (in JavaScript notation, e.g. 'backgroundColor' rather than 'background-color') to fetch.
    @return {HTMLStyleObject} An HTMLStyleObject containing all current style attribute values
    @return {String} The value of an style attribute (only if attr parameter is specified).
     */
    currentStyle = function(el, attr) {
      var comp, e, hasAttr, val;
      val = "";
      hasAttr = !!(arguments.length && attr);
      comp = "getComputedStyle";
      e = void 0;
      if (hasAttr) {
        if (ieVer) {
          try {
            val = el.currentStyle[attr];
          } catch (_error) {
            e = _error;
            val = "";
          }
        } else {
          try {
            val = _view(el)[comp](el, null)[attr];
          } catch (_error) {
            e = _error;
            val = "";
          }
        }
      } else {
        if (ieVer) {
          try {
            val = el.currentStyle;
          } catch (_error) {
            e = _error;
            val = null;
          }
        } else {
          try {
            val = _view(el)[comp](el, null);
          } catch (_error) {
            e = _error;
            val = null;
          }
        }
      }
      return val;
    };

    /*
    Calculate the surrounding boundaries of an HTMLElement, and whether or not the HTMLElement is "in-view" of the user
    
    @name $sf.lib.dom.bounds
    @public
    @static
    @function
    @param {HTMLElement} el The element for which to calculate information
    @param {Object} [details] An object reference used as an output parameter in which further details about the boundaries of the element are specified
    @param {Boolean} [check_3D] Check the element within 3 dimensional space such that any elements covering said element are also take into consideration
    @returns {Object} info An object containing information about the element boundaries
     */
    bounds = function(el, details, check_3D) {
      var b, client_height, client_width, clip, clip_rect, cur_st, doc_rect, el_rect, exp_rect, h, is_scroll_node, is_using_doc_root_b, is_using_doc_root_r, l, offset_height, offset_width, over_x_val, over_y_val, par, r, ref_node, root, root_rect, root_scroll, scroll_height, scroll_left, scroll_top, scroll_width, t, temp_rect, w, x_hidden, xsb_h, y_hidden, ysb_w;
      par = el && _par(el);
      root = _docNode(el);
      el_rect = _rect(el);
      root_rect = _rect(root);
      root_scroll = _get_doc_scroll(root);
      doc_rect = docRect(el);
      clip_rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        w: 0,
        h: 0
      };
      exp_rect = {
        t: 0,
        l: 0,
        r: 0,
        b: 0,
        xs: 0,
        ys: 0,
        xiv: 0,
        yiv: 0,
        iv: 0,
        w: 0,
        h: 0
      };
      xsb_h = 0;
      ysb_w = 0;
      is_scroll_node = false;
      is_using_doc_root_r = false;
      is_using_doc_root_b = false;
      cur_st = void 0;
      w = void 0;
      h = void 0;
      t = void 0;
      l = void 0;
      r = void 0;
      b = void 0;
      scroll_width = void 0;
      offset_width = void 0;
      client_width = void 0;
      scroll_height = void 0;
      offset_height = void 0;
      client_height = void 0;
      over_x_val = void 0;
      scroll_left = void 0;
      scroll_top = void 0;
      over_y_val = void 0;
      clip = void 0;
      x_hidden = void 0;
      y_hidden = void 0;
      ref_node = void 0;
      temp_rect = void 0;
      is_scroll_node = false;
      details = (details && typeof details === OBJ ? details : {});
      if (par) {
        while (cur_st = currentStyle(par)) {
          if (cur_st["display"] === "block" || cur_st["position"] === "absolute" || cur_st["float"] !== "none" || cur_st["clear"] !== "none") {
            over_x_val = cur_st[OVER + "X"];
            over_y_val = cur_st[OVER + "Y"];
            clip = _getClip(cur_st);
            if (par === root) {
              scroll_width = root_scroll.w;
              scroll_height = root_scroll.h;
            } else {
              scroll_width = par.scrollWidth;
              scroll_height = par.scrollHeight;
            }
            offset_width = par.offsetWidth;
            offset_height = par.offsetHeight;
            client_width = par.clientWidth;
            client_height = par.clientHeight;
            if (over_x_val === HIDDEN || clip[1] > 0 || clip[3] > 0) {
              if (!ref_node) {
                x_hidden = 1;
                ref_node = par;
              }
            }
            if (over_y_val === HIDDEN || clip[0] > 0 || clip[2] > 0) {
              if (!ref_node) {
                y_hidden = 1;
                ref_node = par;
              }
            }
            if (over_x_val === SCROLL) {
              ref_node = par;
              xsb_h = offset_height - client_height;
              is_scroll_node = true;
            }
            if (over_y_val === SCROLL) {
              if (!ref_node) {
                ref_node = par;
              }
              ysb_w = offset_width - client_width;
              is_scroll_node = true;
            }
            if (over_x_val === AUTO) {
              if (!ref_node) {
                ref_node = par;
              }
              if (scroll_width > client_width) {
                xsb_h = offset_height - client_height;
              }
              is_scroll_node = true;
            }
            if (over_y_val === AUTO) {
              if (!ref_node) {
                ref_node = par;
              }
              if (scroll_height > client_height) {
                ysb_w = offset_width - client_width;
              }
              is_scroll_node = true;
            }
            if (ref_node) {
              break;
            }
          }
          if (par === root) {
            if (scroll_width > client_width) {
              h = (win.innerHeight || 0) || offset_height;
              xsb_h = h - client_height;
            }
            if (scroll_height > client_height) {
              w = (win.innerWidth || 0) || offset_width;
              ysb_w = w - client_width;
            }
            is_scroll_node = true;
          }
          par = _par(par);
          if (!par || par[NODE_TYPE] !== 1) {
            break;
          }
        }
      }
      if (el_rect.w && el_rect.h) {
        if (!ref_node || ref_node === root) {
          exp_rect.t = _max(el_rect.t, 0);
          exp_rect.l = _max(el_rect.l, 0);
          if (ieVer && dc[COMPAT_MODE] === "BackCompat" && _attr(root, SCROLL) === "no") {
            y_hidden = x_hidden = 1;
          } else {
            cur_st = currentStyle(root);
            if (cur_st) {
              x_hidden = cur_st[OVER + "X"] === HIDDEN;
              y_hidden = cur_st[OVER + "Y"] === HIDDEN;
            }
          }
          if (root_scroll.h > root.clientHeight) {
            if (y_hidden) {
              exp_rect.b = 0;
            } else {
              is_using_doc_root_b = true;
              exp_rect.b = _max(((doc_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
            }
          } else {
            exp_rect.b = _max(((root_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
          }
          if (root_scroll.w > root.clientWidth) {
            if (x_hidden) {
              exp_rect.r = 0;
            } else {
              is_using_doc_root_r = true;
              exp_rect.r = _max(((doc_rect.w - el_rect.w) - ysb_w) - el_rect.l, 0);
            }
          } else {
            exp_rect.r = _max(((root_rect.r - el_rect.w) - ysb_w) - el_rect.l, 0);
          }
        } else {
          cur_st = currentStyle(ref_node);
          if (_tagName(ref_node) === "body") {
            ref_node = root;
            t = el_rect.t;
            l = el_rect.l;
          } else {
            t = l = 0;
          }
          clip_rect = _rect(ref_node);
          if (clip[1] > 0) {
            clip_rect.w = clip[1];
            clip_rect.r = clip_rect.l + clip_rect.w;
          }
          if (clip[3] > 0) {
            clip_rect.l = clip_rect.l + clip[3];
            clip_rect.w = clip_rect.w - clip[3];
          }
          if (clip[2] > 0) {
            clip_rect.h = clip[2];
            clip_rect.b = clip_rect.t + clip_rect.h;
          }
          if (clip[0] > 0) {
            clip_rect.t = clip_rect.t + clip[0];
            clip_rect.h = clip_rect.h - clip[0];
          }
          if (el_rect.t > clip_rect.t && clip_rect.t > 0) {
            t = el_rect.t - clip_rect.t;
          }
          if (el_rect.l > clip_rect.l && clip_rect.l > 0) {
            l = el_rect.l - clip_rect.l;
          }
          scroll_top = ref_node.scrollTop;
          scroll_left = ref_node.scrollLeft;
          scroll_height = ref_node.scrollHeight;
          scroll_width = ref_node.scrollWidth;
          exp_rect.t = _max(t, 0);
          exp_rect.l = _max(l, 0);
          if (cur_st) {
            x_hidden = cur_st[OVER + "X"] === HIDDEN || clip[1] > 0 || clip[3] > 0;
            y_hidden = cur_st[OVER + "Y"] === HIDDEN || clip[0] > 0 || clip[2] > 0;
          }
          if (el_rect.t >= clip_rect.b) {
            exp_rect.b = 0;
          } else {
            if (!y_hidden && el_rect.t >= clip_rect.b) {
              y_hidden = 1;
            }
            if (scroll_height > ref_node.clientHeight) {
              if (y_hidden) {
                exp_rect.b = 0;
              } else {
                exp_rect.b = _max(((scroll_height - el_rect.h) - xsb_h) - t, 0);
              }
            } else {
              exp_rect.b = _max(((clip_rect.h - el_rect.h) - xsb_h) - t, 0);
            }
          }
          if (el_rect.l >= clip_rect.r) {
            exp_rect.r = 0;
          } else {
            if (!x_hidden && el_rect.l >= clip_rect.r) {
              x_hidden = 1;
            }
            if (scroll_width > ref_node.clientWidth) {
              if (x_hidden) {
                exp_rect.r = 0;
              } else {
                exp_rect.r = _max(((scroll_width - el_rect.w) - ysb_w) - l, 0);
              }
            } else {
              exp_rect.r = _max(((clip_rect.w - el_rect.w) - ysb_w) - l, 0);
            }
          }
        }
        exp_rect.xs = (xsb_h ? 1 : 0);
        exp_rect.ys = (ysb_w ? 1 : 0);
        exp_rect.w = exp_rect.r + exp_rect.l;
        exp_rect.h = exp_rect.t + exp_rect.b;
        if (!ref_node || ref_node === root) {
          temp_rect = root_rect;
          ref_node = root;
        } else {
          temp_rect = clip_rect;
        }
        l = _max(el_rect.l, temp_rect.l);
        r = _min(el_rect.r, (is_using_doc_root_r ? _min(doc_rect.r, temp_rect.r) : temp_rect.r));
        w = _max(r - l, 0);
        t = _max(el_rect.t, temp_rect.t);
        b = _min(el_rect.b, (is_using_doc_root_b ? _min(doc_rect.b, temp_rect.b) : temp_rect.b));
        h = _max(b - t, 0);
        exp_rect.xiv = _cnum((w / el_rect.w)[TFXD](2));
        exp_rect.yiv = _cnum((h / el_rect.h)[TFXD](2));
        exp_rect.iv = _cnum(((w * h) / (el_rect.w * el_rect.h))[TFXD](2));
      }
      details.refNode = ref_node || root;
      details.isRoot = ref_node === root;
      details.canScroll = is_scroll_node;
      details.refRect = (!ref_node || ref_node === root ? root_rect : clip_rect);
      details.expRect = exp_rect;
      details.rect = el_rect;
      if (check_3D) {
        (function() {
          var arOvrlaps, el_area, el_h, el_w, idx, len, new_iv, new_xiv, new_yiv, ovr_area, ovr_node, ovr_node_rect;
          idx = 0;
          len = 0;
          arOvrlaps = void 0;
          el_w = void 0;
          el_h = void 0;
          el_area = void 0;
          ovr_node = void 0;
          ovr_node_rect = void 0;
          t = void 0;
          b = void 0;
          l = void 0;
          r = void 0;
          h = void 0;
          w = void 0;
          ovr_area = void 0;
          new_iv = void 0;
          new_xiv = void 0;
          new_yiv = void 0;
          if (exp_rect.iv > .5) {
            mgr_bounds_details = details;
            arOvrlaps = overlaps(el, _cnum(check_3D, 1, 1));
            mgr_bounds_details = null;
            len = arOvrlaps[LEN];
            el_w = el_rect.w;
            el_h = el_rect.h;
            el_area = el_w * el_h;
            if (len) {
              while (ovr_node = arOvrlaps[idx++]) {
                ovr_node_rect = _rect(ovr_node);
                l = _max(el_rect.l, ovr_node_rect.l);
                r = _min(el_rect.r, ovr_node_rect.r);
                t = _max(el_rect.t, ovr_node_rect.t);
                b = _min(el_rect.b, ovr_node_rect.b);
                w = r - l;
                h = b - t;
                ovr_area = w * h;
                new_xiv = (1 - (w / el_w))[TFXD](2);
                new_yiv = (1 - (h / el_h))[TFXD](2);
                new_iv = (1 - (ovr_area / el_area))[TFXD](2);
                if ((new_xiv > 0 && new_xiv < exp_rect.xiv) || (new_yiv > 0 && new_yiv < exp_rect.yiv)) {
                  exp_rect.xiv = new_xiv;
                  exp_rect.yiv = new_yiv;
                  exp_rect.iv = new_iv;
                }
              }
            }
          }
        })();
      }
      return exp_rect;
    };

    /*
    Find any HTMLElements that are covering a given HTMLElement.
    
    @name $sf.lib.dom.overlaps
    @public
    @static
    @function
    @param {HTMLElement} el The HTMLElement for which to find any other elements that may be covering it.
    @param {Number} [limit] The maximum number of covering elements to return
    @returns {Array} An array of elements that are covering the given element
     */
    overlaps = function(el, limit) {
      var baseH, baseW, checkEl, curH, curW, doc, factor, h, id, idx, l, maxX, maxY, par_details, points, pt, rect, ref_par_node, ref_par_rect, ret, root, seen, t, w, x, y;
      rect = _rect(el);
      doc = _doc(el);
      root = _docNode(doc);
      t = rect.t;
      l = rect.l;
      w = rect.r - rect.l;
      h = rect.b - rect.t;
      factor = INTERSECT_FACTOR;
      ret = [];
      baseW = _round(w / factor);
      baseH = _round(h / factor);
      curW = baseW;
      curH = baseH;
      seen = {};
      par_details = {};
      points = [];
      idx = 0;
      x = void 0;
      y = void 0;
      pt = void 0;
      id = void 0;
      checkEl = void 0;
      ref_par_node = void 0;
      ref_par_rect = void 0;
      maxX = void 0;
      maxY = void 0;
      if (mgr_bounds_details) {
        par_details = mgr_bounds_details;
      } else {
        bounds(el, par_details, true);
      }
      ref_par_node = par_details.refNode;
      ref_par_rect = par_details.refRect;
      if (ref_par_rect && ref_par_node && ref_par_node !== root) {
        maxX = ref_par_rect.r;
        maxY = ref_par_rect.b;
      } else {
        maxX = l + w;
        maxY = t + h;
      }
      if (doc && root && doc[EL_FROM_PT]) {
        while (curW < w) {
          curH = baseH;
          while (curH < h) {
            x = l + curW;
            y = t + curH;
            if (x < maxX && y < maxY) {
              points.push([x, y]);
            }
            curH += baseH;
          }
          curW += baseW;
        }
        limit = _cnum(limit, points[LEN]);
        while (pt = points[idx++]) {
          checkEl = doc[EL_FROM_PT](pt[0], pt[1]);
          try {
            if (checkEl && checkEl.nodeType === 1 && checkEl !== root && checkEl !== el && !contains(el, checkEl)) {
              id = _attr(checkEl, "id");
              if (!id) {
                id = lang.guid("geom_inter");
                _attr(checkEl, "id", id);
              }
              if (!seen[id] && ret[LEN] < limit) {
                seen[id] = 1;
                ret.push(checkEl);
              }
            }
          } catch (_error) {}
        }
      }
      id = "";
      for (id in seen) {
        if (id.indexOf("geom_inter") === 0) {
          checkEl = _elt(id);
          if (checkEl) {
            _attr(checkEl, "id", null);
          }
        }
      }
      return ret;
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host fall back library
    Looks for namespace will be $sf.lib.dom.msghost_fb
    Said library is used in cases where there is not HTML5 style messaging (i.e. no postMessage method available).
    
    @name $sf.lib.dom.msghost-_call_xmsg_host_fb
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @returns {*} whatever comes back from the method
     */
    _call_xmsg_host_fb = function(methName, arg1, arg2, arg3) {
      if (!msghostfb) {
        msghostfb = dom.msghost_fb;
      }
      return methName && msghostfb && msghostfb[methName] && msghostfb[methName](arg1, arg2, arg3);
    };

    /*
    Listen for an initial HTML5 postMessage event, to validate that HTML5 style
    messaging can be used
    
    @name $sf.lib.dom.msghost-_check_html5_init
    @private
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
     */
    _check_html5_init = function(evt) {
      if (!canUseHTML5 && evt && evt.data === initID) {
        canUseHTML5 = true;
        dom.evtCncl(evt);
        dom[DETACH](win, MSG, _check_html5_init);
      }
    };

    /*
    Listen for onmessage events in the main window. Validate that message is for us, and if so
    pass it through to the rest of the code and cancel further handling.
    
    @name $sf.lib.dom.msghost-_handle_msg_from_outside
    @private
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
     */
    _handle_msg_from_outside = function(evt) {
      var cb, data, dataGUID, e, fr_win, ifr, msg_win, params, pipe, pipeGUID, ret, tgtID;
      data = evt && evt.data;
      msg_win = evt && evt.source;
      params = data && (data.indexOf(GUID) !== -1) && ParamHash(data);
      tgtID = params && params.id;
      ifr = tgtID && _elt(tgtID);
      fr_win = ifr && _ifr_view(ifr);
      pipe = tgtID && msg_pipes[tgtID];
      dataGUID = params && params[GUID];
      pipeGUID = pipe && pipe[GUID];
      cb = pipe && pipe._xmsgcb;
      ret = false;
      if (pipeGUID && dataGUID && dataGUID === pipeGUID && msg_win && fr_win && fr_win === msg_win) {
        try {
          ret = cb(params.msg);
        } catch (_error) {
          e = _error;
          ret = false;
        }
      }
      if (ret) {
        dom.evtCncl(evt);
      }
      return ret;
    };

    /*
    Send a message to a child iframe.
    
    @name $sf.lib.dom.msghost.send
    @public
    @static
    @function
    @param {String} tgtID The HTML id attribute of the iframe element for which to send a message
    @param {String} data The string of data to send to the given iframe
    @returns {Boolean} Whether or not message was send succesfully (note that this does not mean message was handled / recevied, only that sending was ok).
     */
    send_msg_to_child_iframe = function(tgtID, data) {
      var e, el, msgObj, pipe, success, w;
      pipe = tgtID && msg_pipes[tgtID];
      success = false;
      msgObj = void 0;
      w = void 0;
      el = void 0;
      e = void 0;
      if (!pipe) {
        success = _call_xmsg_host_fb("send", tgtID, data);
      } else {
        if (pipe) {
          msgObj = ParamHash();
          msgObj.msg = data;
          msgObj.guid = pipe.guid;
          if (usingHTML5()) {
            el = _elt(tgtID);
            w = _ifr_view(el);
            try {
              w[PMSG](_cstr(msgObj), pipe.srcHost || "*");
              success = true;
            } catch (_error) {
              e = _error;
              success = false;
            }
          } else {
            success = _call_xmsg_host_fb("send", tgtID, data);
          }
        }
      }
      msgObj = w = el = null;
      return success;
    };

    /*
    Get whether or not HTML5 style messaging can be used
    
    @name $sf.lib.dom.msghost.usingHTML5
    @public
    @static
    @function
    @returns {Boolean}
     */
    usingHTML5 = function() {
      return canUseHTML5;
    };

    /*
    Gets a location of the hosting page, stripped of the search hash,
    but leaving query parameters, port, host, path, etc.
     */
    _strippedEncodedLocation = function() {
      var cleaned, pos;
      cleaned = void 0;
      pos = loc.href.indexOf("#");
      if (pos > -1) {
        cleaned = loc.href.substr(0, pos);
      } else {
        cleaned = loc.href;
      }
      pos = cleaned.indexOf("?");
      if (pos > -1) {
        cleaned = cleaned.substr(0, pos);
      }
      return escape(cleaned);
    };

    /*
    Prepare an iframe in the top level window to be able to send / receive cross-domain messages
    Generally this method is called from $sf.lib.iframes.  The attrs object in question should
    represent key/value pairs of HTML attributes for the iframe. Note that the attrs object passed
    in will be modified with a new "name" property, to send information into the iframe and setup
    messaging.
    
    @name $sf.lib.dom.msghost.prep
    @public
    @static
    @function
    @param {Object} attrs Information required to set up the cross-domain messaging channel
    @param {String} attrs.id The IFRAME HTML id attribute
    @param {String} attrs.src The URL / src attribute of the IFRAME
    @param {String} [attrs.guid] The guid / signature to use to validate that messages sent/ received can be accepted. If not specified, one will be created automatically.
    @param {String} [attrs.name] The IFRAME HTML name attribute which will be used to send an intial message to the HTML document inside the IFRAME.
    @returns {Object} An object with various properties detailing the messaging pipe-line.
     */
    prep_iframe_msging = function(attrs) {
      var iframeName, locStripped, nameParams, newPipe, pipe, src, srcHost;
      pipe = null;
      iframeName = void 0;
      nameParams = void 0;
      src = void 0;
      srcHost = void 0;
      newPipe = void 0;
      locStripped = _strippedEncodedLocation();
      if (attrs) {
        iframeName = attrs.name;
        nameParams = ParamHash(iframeName);
        src = _cstr(attrs.src);
        srcHost = src && src.substring(0, src.indexOf("/", 9));
        srcHost = (srcHost.search(/http/g) !== 0 ? "" : srcHost);
        pipe = ParamHash(nameParams);
        pipe.id = attrs.id || ("iframe_" + _guid());
        pipe.src = src;
        pipe.srcHost = srcHost;
        pipe[GUID] = pipe[GUID] || _guid();
        pipe.host = locHost;
        pipe.loc = locStripped;
        pipe.proxyID = "";
        if (usingHTML5()) {
          pipe.html5 = 1;
          pipe.proxyPath = "";
        } else {
          newPipe = _call_xmsg_host_fb("prep", pipe);
          if (newPipe) {
            pipe = newPipe;
          }
        }
        attrs.name = pipe;
      }
      return pipe;
    };

    /*
    Listen for messages from an IFRAME. Note that on the host / publisher side
    this library only allows for one message handler to be attached to a given
    IFRAME.
    
    @name $sf.lib.dom.msghost.attach
    @public
    @static
    @function
    @param {HTMLElement} el The IFRAME reference to attach a listener callback too. .
    @param {Object} pipe The message pipe object created from $sf.lib.dom.msghost.prep
    @param {Function} cb The callback function to fire when a message is received
     */
    attach_iframe_msging = function(el, pipe, cb) {
      var tgtID;
      tgtID = void 0;
      if (_tagName(el) === "iframe") {
        tgtID = _attr(el, "id");
        if (tgtID && pipe && (pipe instanceof ParamHash) && tgtID === pipe.id) {
          if (usingHTML5()) {
            msg_pipes[tgtID] = pipe;
            pipe._xmsgcb = cb;
            if (!html5Bound) {
              dom[ATTACH](win, MSG, _handle_msg_from_outside);
              html5Bound = true;
            }
          } else {
            _call_xmsg_host_fb(ATTACH, el, pipe, cb);
          }
        }
      }
    };

    /*
    Detach listening for messages from an IFRAME
    
    @name $sf.lib.dom.msghost.detach
    @public
    @static
    @function
    @param {HTMLElement} el The IFRAME reference to detach a listener
     */
    detach_iframe_msging = function(el) {
      var empty, id, pipe, w;
      id = _attr(el, "id");
      pipe = id && msg_pipes[id];
      w = null;
      empty = true;
      if (!pipe) {
        _call_xmsg_host_fb(DETACH, el);
        return;
      }
      if (pipe) {
        pipe._xmsgcb = msg_pipes[id] = null;
        pipe = null;
        delete msg_pipes[id];
      }
      id = "";
      for (id in msg_pipes) {
        pipe = msg_pipes[id];
        if (pipe && pipe[GUID]) {
          empty = false;
          break;
        }
      }
      if (empty && usingHTML5() && html5Bound) {
        html5Bound = false;
        dom[DETACH](win, MSG, _handle_msg_from_outside);
      }
      el = w = pipe = null;
    };

    /*
    Fire the specifed callback out to the publisher. Note that other arguments beyond the 1st argument are passed throug to the callback.
    
    @name $sf.host-_fire_pub_callback
    @static
    @private
    @function
    @param {String} cb_name The callback name to fire
     */
    _fire_pub_callback = function(cb_name) {
      var a, args, cb_args, e, f, idx, len, ret;
      cb_args = [];
      args = arguments;
      len = args[LEN];
      idx = 0;
      f = void 0;
      ret = false;
      e = void 0;
      a = void 0;
      if (config) {
        f = config[cb_name];
        if (f) {
          while (len--) {
            a = args[idx++];
            if (a !== cb_name) {
              cb_args.push(a);
            }
          }
          try {
            ret = f.apply(null, cb_args);
          } catch (_error) {
            e = _error;
            ret = false;
          }
        }
      }
      return ret;
    };

    /*
    Nuke the position an report that said position took too long to render
    
    @name $sf.host-_handle_render_timeout
    @static
    @private
    @function
    @param {String} pos_id The position id that has taken too long
     */
    _handle_render_timeout = function(pos_id) {
      var pend;
      pend = pos_id && pending_ifrs[pos_id];
      if (pend) {
        clearTimeout(pend);
        nuke(pos_id);
        _fire_pub_callback(POS_MSG, "render-timeout", pos_id);
      }
      if (!_has_pending_renders()) {
        current_status = "";
      }
    };

    /*
    Clear the timer that fires every so often to update the geometry in side
    of SafeFrames
    
    @name $sf.host-_clear_geom_update_timer
    @static
    @private
    @function
     */
    _clear_geom_update_timer = function() {
      if (geom_update_timer) {
        clearTimeout(geom_update_timer);
        geom_update_timer = 0;
      }
    };

    /*
    +	 * Clear the timer that fires every so often to update the geometry in side
    +	 * of SafeFrames
    +	 *
    +	 * @name $sf.host-_clear_geom_update_timer
    +	 * @static
    +	 * @private
    +	 * @function
    +	 *
    +
     */
    _clear_focus_update_timer = function() {
      if (focus_update_timer) {
        clearTimeout(focus_update_timer);
        focus_update_timer = 0;
      }
    };
    _set_focus_update_timer = function(in_focus) {
      _clear_focus_update_timer();
      focus_update_timer = setTimeout(function() {
        _update_focus(in_focus);
      }, 2);
    };

    /*
    Set up the timer function that updates each SafeFrame with up to date geometric information
    
    @name $sf.host-_set_geom_update_timer
    @static
    @private
    @function
     */
    _set_geom_update_timer = function(is_win_scroll) {
      _clear_geom_update_timer();
      if (is_win_scroll) {
        geom_update_timer = setTimeout(_update_geom_win_scroll, GEOM_UPDATE_INTRVAL);
      } else {
        geom_update_timer = setTimeout(_update_geom_win_resize, GEOM_UPDATE_INTRVAL);
      }
    };

    /*
    Update all SafeFrames with updated geometric information
    
    @name $sf.host-_update_geom
    @static
    @private
    @function
    @param {Boolean} is_win_scroll Whether or not we are updating due to the main window being scrolled
     */
    _update_geom = function(is_win_scroll) {
      var g, id, ifr, msgObj, params, posID;
      posID = void 0;
      params = void 0;
      msgObj = void 0;
      id = void 0;
      ifr = void 0;
      g = void 0;
      for (posID in rendered_ifrs) {
        if (is_win_scroll && (posID in scroll_parents_attached)) {
          continue;
        }
        params = rendered_ifrs[posID];
        id = params && params.dest;
        ifr = id && _elt(id);
        if (ifr && params) {
          g = _build_geom(posID, ifr, true);
          msgObj = ParamHash();
          msgObj.pos = posID;
          msgObj.cmd = NOTIFY_GEOM_UPDATE;
          msgObj.geom = _es(g);
          _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
          _send_response(params, msgObj);
        }
      }
      _clear_geom_update_timer();
    };

    /*
    Update all SafeFrames with updated geometric information due to a window resize
    event.
    
    @name $sf.host-_update_geom_win_resize
    @static
    @private
    @function
     */
    _update_geom_win_resize = function() {
      _update_geom();
    };

    /*
    Update all SafeFrames with updated geometric information due to a window scroll event
    
    @name $sf.host-_update_geom_win_scroll
    @static
    @private
    @function
     */
    _update_geom_win_scroll = function() {
      _update_geom(true);
    };

    /*
    Update a SafeFrame that has new geometric information due to its parent HTML element
    scrolling.
    
    @name $sf.host-_handle_node_scroll
    @static
    @private
    @function
     */
    _handle_node_scroll = function(evt, posID, node) {
      var g, scr_handle;
      scr_handle = scroll_parents_attached[posID];
      g = void 0;
      if (scr_handle) {
        if (scr_handle.tID) {
          clearTimeout(scr_handle.tID);
          delete scr_handle.tID;
        }
        scr_handle.tID = setTimeout(function() {
          var id, ifr, msgObj, params;
          params = rendered_ifrs[posID];
          id = params && params.dest;
          ifr = id && _elt(id);
          g = void 0;
          msgObj = void 0;
          if (ifr && params) {
            g = _build_geom(posID, ifr, true);
            msgObj = ParamHash();
            msgObj.pos = posID;
            msgObj.cmd = NOTIFY_GEOM_UPDATE;
            msgObj.geom = _es(g);
            _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
            _send_response(params, msgObj);
          }
          delete scr_handle.tID;
        }, GEOM_UPDATE_INTRVAL);
      }
    };

    /*
    Handle the window onscroll event, eventually leading to a geometric update
    
    @name $sf.host-_handle_win_geom_scroll
    @static
    @private
    @function
    @param {HTMLEvent} evt The raw event object
     */
    _handle_win_geom_scroll = function(evt) {
      _set_geom_update_timer(1);
    };

    /*
    Handle the window onresize event, eventually leading to a geometric update
    once the window events are slowed down
    
    @name $sf.host-_handle_win_geom_resize
    @static
    @private
    @function
    @param {HTMLEvent} evt The raw event object
     */
    _handle_win_geom_resize = function(evt) {
      _set_geom_update_timer();
    };

    /*
    Update all SafeFrames with updated focus information
    
    @name $sf.host-_update_focus
    @static
    @private
    @function
    @param {Boolean} in_focus True when the window has gained focus
     */
    _update_focus = function(in_focus) {
      var data, id, ifr, msgObj, params, posID;
      posID = void 0;
      params = void 0;
      msgObj = void 0;
      id = void 0;
      ifr = void 0;
      for (posID in rendered_ifrs) {
        params = rendered_ifrs[posID];
        id = params && params.dest;
        ifr = id && _elt(id);
        if (ifr && params) {
          msgObj = ParamHash();
          data = ParamHash();
          msgObj.pos = posID;
          msgObj.cmd = data.cmd = NOTIFY_FOCUS_CHANGE;
          msgObj.value = in_focus;
          _fire_pub_callback(POS_MSG, posID, NOTIFY_FOCUS_CHANGE, in_focus);
          _send_response(params, msgObj);
        }
      }
      _clear_focus_update_timer();
    };

    /*
    Handle the window focus event, which notifies ads of the change
     */
    _handle_win_focus = function(evt) {
      _set_focus_update_timer(true);
    };

    /*
    Handle the window blur event, which notifies ads of the change
     */
    _handle_win_blur = function(evt) {
      _set_focus_update_timer(false);
    };

    /*
    Handle the window unload event, clearing up our state
    
    @name $sf.host-_handle_unload
    @static
    @private
    @function
    @param {HTMLEvent} evt The raw event object
     */
    _handle_unload = function(evt) {
      var e, prop, scr_handle;
      prop = void 0;
      scr_handle = void 0;
      e = void 0;
      _clear_geom_update_timer();
      try {
        dom.detach(win, SCROLL, _handle_win_geom_scroll);
        dom.detach(win, "resize", _handle_win_geom_resize);
        dom.detach(win, "unload", _handle_unload);
        dom.detach(win, "focus", _handle_win_focus);
        dom.detach(win, "blur", _handle_win_blur);
        for (prop in scroll_parents_attached) {
          scr_handle = scroll_parents_attached[prop];
          if (scr_handle) {
            if (scr_handle.tID) {
              clearTimeout(scr_handle.tID);
            }
            dom.detach(scroll_parents_attached[prop], SCROLL, scr_handle[ONSCROLL]);
            scr_handle[ONSCROLL] = scr_handle.node = null;
          }
          scroll_parents_attached[prop] = null;
          delete scroll_parents_attached[prop];
        }
        win_events_attached = false;
      } catch (_error) {}
    };

    /*
    Handle the window message event, passed from raw event handling of the msghost code.
    Pass through the data to our format handling functions for expand, etc.
    
    @name $sf.host-_handle_msg_evt
    @static
    @private
    @function
    @param {String|Object} data the message to be handled
    @return {Boolean} return whether or not the message was handled
     */
    _handle_msg_evt = function(data) {
      var canRead, canWrite, info, msgObj, ret;
      msgObj = void 0;
      ret = false;
      info = void 0;
      msgObj = ParamHash(data, null, null, true, true);
      if (msgObj && msgObj.pos) {
        info = rendered_ifrs[msgObj.pos];
        if (info) {
          ret = (function() {
            switch (msgObj.cmd) {
              case "exp-push":
                _expand_safeframe(msgObj, true);
                return true;
              case "exp-ovr":
                _expand_safeframe(msgObj);
                return true;
              case "collapse":
                _collapse_safeframe(msgObj);
                return true;
              case "msg":
              case "clicked":
              case "viewed":
              case "requested":
              case "unviewed":
              case "reload":
                _fire_pub_callback(POS_MSG, msgObj.pos, msgObj.cmd, msgObj.msg);
                _send_generic_response(msgObj.pos, msgObj.cmd);
                return true;
              case "loaded":
                _fire_pub_callback("onAdLoad", msgObj.pos, msgObj);
                _send_generic_response(msgObj.pos, msgObj.cmd);
                return true;
              case ERROR_COMMAND:
                _record_error(msgObj);
                return true;
              case NOTIFY_GEOM_UPDATE:
                sf.lib.logger.log("Geom update complete: " + msgObj.pos);
                return true;
              case "read-cookie":
                canRead = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                if (canRead) {
                  _read_cookie(msgObj);
                  _fire_pub_callback("onCookieRead", msgObj.pos, msgObj.cookie);
                  return true;
                } else {
                  return false;
                }
                break;
              case "write-cookie":
                canWrite = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                if (canWrite) {
                  _write_cookie(msgObj);
                  _fire_pub_callback("onCookieWrite", msgObj.pos, msgObj.cookie);
                  return true;
                } else {
                  return false;
                }
            }
          })();
        }
      }
      return ret;
    };

    /*
    Check whether or not there are any SafeFrames being rendered
    
    @name $sf.host-_has_pending_renders
    @static
    @private
    @function
     */
    _has_pending_renders = function() {
      var all_renders_done, pos_id;
      all_renders_done = true;
      pos_id = void 0;
      for (pos_id in pending_ifrs) {
        all_renders_done = false;
        break;
      }
      return all_renders_done;
    };

    /*
    Send a response back down to the SafeFrame after a message was handled
    
    @name $sf.host-_send_response
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} params The parameters object stored for a rendered SafeFrame holding state information
    @param {$sf.lib.lang.ParamHash} msgObj The message to send back down into the SafeFrame
     */
    _send_response = function(params, msgObj) {

      /*
      @ignore
       */
      current_status = "sending-msg-down-" + msgObj.cmd;
      setTimeout((function() {
        var id;
        id = params && params.dest;
        if (id && msgObj) {
          send_msg_to_child_iframe(id, msgObj.toString());
        }
        current_status = "";
        msgObj = id = params = null;
      }), XCOM_RESP_DELAY);
    };

    /*
    Handle the onload event from the IFRAME tag created for a SafeFrame.
    Note that b/c we used our own library to create the IFRAME ($sf.lib.dom.iframes),
    the "this" keyword will now properly point to the IFRAME in question.
    
    @name $sf.host-_handle_frame_load
    @private
    @static
    @function
     */
    _handle_frame_load = function() {
      var all_renders_done, el, pos_id;
      el = this;
      pos_id = dom.attr(el, "_pos_id");
      all_renders_done = true;
      if (pending_ifrs[pos_id]) {
        clearTimeout(pending_ifrs[pos_id]);
        delete pending_ifrs[pos_id];
        complete_ifrs[pos_id] = pos_id;
        dom.attr(el, "_pos_id", null);
        dom.attr(el, "name", null);
        el[ST].visibility = "inherit";
        el[ST].display = "block";
        _fire_pub_callback("onEndPosRender", pos_id);
      }
      if (!_has_pending_renders()) {
        current_status = "";
      }
    };

    /*
    Build an extra IFRAME to put behind any iframe that is expanding, to protect
    against painting issues in IE with window'd mode flash.
    
    @name $sf.host-_shim_frame
    @private
    @static
    @function
     */
    _shim_frame = function(id, showIt, w, h, z) {
      var ifr, shmFrm, shmID;
      if (!isIE) {
        return;
      }
      ifr = _elt(id);
      shmID = "shm_" + id;
      shmFrm = _elt(shmID);
      if (showIt) {
        if (shmFrm) {
          shmFrm[ST].visibility = "visible";
          return;
        }
        shmFrm = iframes.clone(ifr, {
          id: shmID,
          src: "",
          name: shmID
        }, [WIDTH, ":", w, PX, ";position:absolute;", HEIGHT, ":", h, PX, ";z-index:", z - 1, ";filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0)"]);
        dom.append(_par(ifr), shmFrm);
      } else {
        if (!showIt && shmFrm) {
          shmFrm[ST].visibility = "hidden";
        }
      }
    };

    /*
    Build a geometry info object for a particular SafeFrame position, and also
    may attach an onscroll event listener to a parent HTML element if said parent element
    is scrollable but not the root document node / body
    
    @name $sf.host-_build_geom
    @private
    @static
    @function
    @return {Object} With information about the geometry around a given SafeFrame
     */
    _build_geom = function(posID, dest, dont_attach_scroll_evt) {
      var details, e, ex, info, new_ref_node, node, s, scr_handle;
      bounds = void 0;
      info = ParamHash();
      details = {};
      scr_handle = void 0;
      node = void 0;
      new_ref_node = void 0;
      ex = void 0;
      s = void 0;
      e = void 0;
      try {
        bounds = dom.bounds(dest, details, true);
        if (!dont_attach_scroll_evt && !details.isRoot && details.canScroll) {
          ex = details.expRect;
          if (ex.xs || ex.ys) {
            scr_handle = scroll_parents_attached[posID];
            new_ref_node = details.refNode;
            if (scr_handle && scr_handle.node !== new_ref_node) {
              if (scr_handle.tID) {
                clearTimeout(scr_handle.tID);
              }
              dom.detach(node, SCROLL, scr_handle[ONSCROLL]);
              scr_handle.node = scr_handle[ONSCROLL] = null;
              scroll_parents_attached[posID] = null;
              delete scroll_parents_attached[posID];
            }
            if (!scroll_parents_attached[posID]) {
              scr_handle = {};
              scr_handle.node = new_ref_node;

              /*
              @ignore
               */
              scr_handle[ONSCROLL] = function(evt) {
                _handle_node_scroll(evt, posID);
              };
              scroll_parents_attached[posID] = scr_handle;
              dom.attach(new_ref_node, SCROLL, scr_handle[ONSCROLL]);
            }
          }
        }
      } catch (_error) {
        e = _error;
        info = null;
      }
      try {
        if (info) {
          info.win = ParamHash(dom.winRect());
          info.par = ParamHash(details.refRect);
          ex = ParamHash(details.expRect);
          s = ParamHash(details.rect);
          s.iv = ex.iv;
          s.xiv = ex.xiv;
          s.yiv = ex.yiv;
          delete ex.iv;
          delete ex.xiv;
          delete ex.yiv;
          info.exp = ex;
          info.self = s;
        }
      } catch (_error) {
        e = _error;
        info = null;
      }
      return info;
    };

    /*
    Expands a given SafeFrame based on a command from the 3rd party content
    
    @name $sf.host-_expand_safeframe
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj Details about how to do the expansion
    
    TODO, handle omni-directional and push
     */
    _expand_safeframe = function(msgObj, push) {
      var b, delta, dx, dy, exp, id, ifr, ifrSt, l, nHt, nWd, orHt, orWd, par, parSt, params, params_conf, posID, r, scr_handle, t, xn, yn, z;
      xn = false;
      yn = false;
      posID = msgObj && msgObj.pos;
      params = void 0;
      params_conf = void 0;
      ifr = void 0;
      par = void 0;
      ifrSt = void 0;
      parSt = void 0;
      orWd = void 0;
      orHt = void 0;
      dx = void 0;
      dy = void 0;
      nWd = void 0;
      nHt = void 0;
      id = void 0;
      t = void 0;
      l = void 0;
      r = void 0;
      b = void 0;
      exp = void 0;
      z = void 0;
      delta = void 0;
      scr_handle = void 0;
      if (!posID) {
        return;
      }
      params = rendered_ifrs[posID];
      params_conf = params && params.conf;
      if (!params || !params_conf) {
        return;
      }
      id = params.dest;
      ifr = _elt(id);
      par = _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
      if (!ifr || !par) {
        return;
      }
      ifrSt = ifr[ST];
      parSt = par[ST];
      if (!ifrSt) {
        return;
      }
      scr_handle = scroll_parents_attached[posID];
      if (scr_handle && scr_handle.tID) {
        clearTimeout(scr_handle.tID);
      }
      _clear_geom_update_timer();
      exp = msgObj.exp_obj;
      orWd = params_conf.w;
      orHt = params_conf.h;
      if (!exp) {
        dx = params.dx = _cnum(msgObj.dx);
        dy = params.dy = _cnum(msgObj.dy);
        xn = dx < 0;
        yn = dy < 0;
        nWd = (xn ? orWd + (dx * -1) : orWd + dx);
        nHt = (yn ? orHt + (dy * -1) : orHt + dy);
      } else {
        t = _cnum(exp.t, 0, 0);
        l = _cnum(exp.l, 0, 0);
        r = _cnum(exp.r, 0, 0);
        b = _cnum(exp.b, 0, 0);
        nWd = _cnum(orWd + l + r, 0, 0);
        nHt = _cnum(orHt + t + b, 0, 0);
        if (t) {
          dy = t * -1;
          yn = true;
        } else {
          dy = 0;
        }
        if (l) {
          dx = l * -1;
          xn = true;
        } else {
          dx = 0;
        }
      }
      if (nWd <= orWd && nHt <= orHt) {
        return;
      }
      if (_fire_pub_callback(BF_POS_MSG, posID, EXPAND_COMMAND, dx, dy)) {
        return;
      }
      ifrSt[WIDTH] = nWd + PX;
      ifrSt[HEIGHT] = nHt + PX;
      if (xn) {
        ifrSt.left = dx + PX;
      }
      if (yn) {
        ifrSt.top = dy + PX;
      }
      z = _cnum(params.z, 0);
      if (!z) {
        z = DEFAULT_ZINDEX;
      }
      ifrSt.zIndex = z;
      _shim_frame(id, true, nWd, nHt, z - 1);
      if (push) {
        parSt[WIDTH] = nWd + PX;
        parSt[HEIGHT] = nHt + PX;
      } else {
        parSt[WIDTH] = orWd + PX;
        parSt[HEIGHT] = orHt + PX;
      }
      params.expanded = true;
      msgObj.dx = dx;
      msgObj.dy = dy;
      msgObj.w = nWd;
      msgObj.h = nHt;
      msgObj.cmd = "expand";
      msgObj.geom = _es(_build_geom(posID, ifr, true));
      _fire_pub_callback(POS_MSG, posID, EXPAND_COMMAND, dx, dy);
      _send_response(params, msgObj);
      ifrSt = par = ifr = params = msgObj = null;
    };

    /*
    Collapse a SafeFrame after it has been expanded
    
    @name $sf.host-_collapse_safeframe
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame to collapse
    @param {Boolean} [isOutside] Whether or not the collapse command came from the publisher
    @param {Boolean} [noMsging] Whether or not to send a message of response back to the SafeFrame being collapsed
     */
    _collapse_safeframe = function(msgObj, isOutside, noMsging) {
      var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
      ifrSt = ifr && ifr[ST];
      parSt = par && par[ST];
      scr_handle = void 0;
      if (!posID || !params || !ifr || !par) {
        return;
      }
      if (!params.expanded) {
        return;
      }
      scr_handle = scroll_parents_attached[posID];
      if (scr_handle && scr_handle.tID) {
        clearTimeout(scr_handle.tID);
      }
      _clear_geom_update_timer();
      if (!noMsging) {
        if (_fire_pub_callback(BF_POS_MSG, posID, COLLAPSE_COMMAND, 0, 0)) {
          return;
        }
      }
      ifrSt.left = ifrSt.top = "0px";
      parSt[WIDTH] = ifrSt[WIDTH] = params_conf.w + PX;
      parSt[HEIGHT] = ifrSt[HEIGHT] = params_conf.h + PX;
      ifrSt.zIndex = params.dx = params.dy = 0;
      _shim_frame(id);
      if (!noMsging) {
        _fire_pub_callback(POS_MSG, posID, COLLAPSE_COMMAND, 0, 0);
        msgObj.cmd = (isOutside ? "collapsed" : "collapse");
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        _send_response(params, msgObj);
      }
      ifr = ifrSt = par = parSt = params = msgObj = null;
    };

    /*
    Records a reported error message to $sf.info.errors and fires any listeners
    
    @name $sf.host-_record_error
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame having an error
     */
    _record_error = function(msgObj) {
      var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
      ifrSt = ifr && ifr[ST];
      parSt = par && par[ST];
      scr_handle = void 0;
      if (sf && sf.info && sf.info.errs) {
        sf.info.errs.push(msgObj);
      }
      _fire_pub_callback(POS_MSG, posID, ERROR_COMMAND, msgObj);
    };

    /*
    Returns the current document cookies as a hash
    @name $sf.lib._cookieHash
    @private
    @static
    @function
    @returns {Object}
     */
    _cookieHash = function() {
      var c, cookies, cooks, i, key;
      cooks = void 0;
      key = void 0;
      i = void 0;
      cookies = {};
      c = void 0;
      cooks = document.cookie.split("; ");
      i = cooks.length - 1;
      while (i >= 0) {
        c = cooks[i].split("=");
        cookies[c[0]] = c[1];
        i--;
      }
      return cookies;
    };

    /*
    Read a host domain cookie
    
    @name $sf.host-_read_cookie
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
    @param {Boolean} [isOutside] Whether or not the read-cookie command came from the publisher
     */
    _read_cookie = function(msgObj, isOutside) {
      var canRead, command, cookies, id, ifr, key, params, params_conf, posID;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      key = void 0;
      cookies = void 0;
      command = "read-cookie";
      canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
      if (!canRead) {
        return;
      }
      if (!posID || !params || !ifr) {
        return;
      }
      key = msgObj.cookie;
      if (!key) {
        return;
      }
      cookies = _cookieHash();
      _fire_pub_callback(POS_MSG, command, posID, 0, 0);
      msgObj.cmd = command;
      msgObj.geom = _es(_build_geom(posID, ifr, true));
      msgObj.value = cookies[key];
      _send_response(params, msgObj);
      ifr = params = msgObj = null;
    };

    /*
    Write a host domain cookie
    
    @name $sf.host-_write_cookie
    @private
    @static
    @function
    @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
    @param {Boolean} [isOutside] Whether or not the write-cookie command came from the publisher
     */
    _write_cookie = function(msgObj, isOutside) {
      var c_value, canRead, command, cookies, exdate, id, ifr, key, newCookies, newValue, params, params_conf, posID;
      posID = msgObj && msgObj.pos;
      params = posID && rendered_ifrs[posID];
      params_conf = params && params.conf;
      id = params_conf && params_conf.dest;
      ifr = id && _elt(id);
      key = void 0;
      newValue = void 0;
      cookies = void 0;
      newCookies = void 0;
      command = "write-cookie";
      canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
      if (!canRead) {
        return;
      }
      if (!posID || !params || !ifr) {
        return;
      }
      key = msgObj.cookie;
      if (!key) {
        return;
      }
      newValue = escape(msgObj.value);
      exdate = new Date();
      exdate.setDate(exdate.getDate() + 1);
      c_value = newValue + "; expires=" + exdate.toUTCString();
      document.cookie = key + "=" + c_value;
      _fire_pub_callback(POS_MSG, command, posID, 0, 0);
      msgObj.cmd = command;
      msgObj.geom = _es(_build_geom(posID, ifr, true));
      msgObj.info = newValue;
      msgObj.value = "";
      _send_response(params, msgObj);
      ifr = params = msgObj = null;
    };

    /*
    Remove / destroy one or more SafeFrames from the publisher page
    
    @name $sf.host.nuke
    @static
    @function
    @public
    @param {String} pos_id* One or more position ids to remove from the page. If no arguments are specifed, all positions currently rendered are removed.
     */
    nuke = function() {
      var args, el, el_id, empty, idx, par, pos, pos_id, sb_rel;
      idx = 0;
      empty = true;
      args = arguments;
      pos_id = void 0;
      pos = void 0;
      el_id = void 0;
      el = void 0;
      sb_rel = void 0;
      par = void 0;
      if (!args[LEN] || args[idx] === "*") {
        args = [];
        for (pos_id in rendered_ifrs) {
          args.push(pos_id);
        }
      }
      while (pos_id = args[idx++]) {
        pos = rendered_ifrs[pos_id];
        if (pos) {
          if (pos_id in pending_ifrs) {
            clearTimeout(pending_ifrs[pos_id]);
            delete pending_ifrs[pos_id];
          }
          if (pos_id in complete_ifrs) {
            delete complete_ifrs[pos_id];
          }
          el_id = pos.dest;
          el = el_id && _elt(el_id);
          par = el && _par(el);
          if (dom.attr(par, "id").indexOf(POS_REL_BOX_ID_PREFIX) !== -1) {
            sb_rel = par;
            par = _par(sb_rel);
          }
          dom.purge(el);
          if (sb_rel) {
            dom.purge(sb_rel);
          }
          rendered_ifrs[pos_id] = null;
          delete rendered_ifrs[pos_id];
          el = dom.make("div");
          dom.attr(el, "id", el_id);
          dom.append(par, el);
        }
      }
      pos_id = "";
      for (pos_id in rendered_ifrs) {
        empty = false;
        break;
      }
      if (empty) {
        current_status = "";
        _handle_unload();
      }
    };

    /*
    Render one or more $sf.host.Position objects into the page
    
    @name $sf.host.render
    @public
    @static
    @function
    @param {$sf.host.Position} pos* An instance of an $sf.host.Position object to render. Note that said object must have a corresponding $sf.host.PosConfig, as well as $sf.host.Config must have been set
     */
    render = function() {
      var args, css_txt, dest_el, dest_id, dest_rel_id, e, finalCSSEnd, finalCSSPos, firstCSSPos, h, idx, name_params, new_dest_el, par_el, pend, pos, pos_conf, pos_id, rel_el, st, w;
      idx = 0;
      args = arguments;
      firstCSSPos = "relative";
      finalCSSPos = "absolute";
      finalCSSEnd = "top:0px;left:0px;visibility:hidden;display:none;";
      pos = void 0;
      pos_id = void 0;
      pos_conf = void 0;
      dest_el = void 0;
      new_dest_el = void 0;
      rel_el = void 0;
      par_el = void 0;
      name_params = void 0;
      dest_id = void 0;
      dest_rel_id = void 0;
      css_txt = void 0;
      w = void 0;
      h = void 0;
      st = void 0;
      e = void 0;
      pend = void 0;
      if (!config) {
        return false;
      }
      if (!dom.ready()) {
        dom.wait(function() {
          render.apply(null, args);
          args = null;
        });
        return null;
      }
      if ((args[0] instanceof Array) && args[LEN] === 1) {
        args = args[0];
      }
      while (pos = args[idx++]) {
        pos_id = pos.id;
        pos_conf = (pos_id ? config.positions[pos_id] : null);
        if (pos_conf) {
          dest_id = pos_conf.dest;
          dest_el = dest_id && _elt(dest_id);
          if (dest_el) {
            w = pos_conf.w;
            h = pos_conf.h;
            if (!w) {
              try {
                w = dest_el.offsetWidth;
              } catch (_error) {
                e = _error;
                w = 0;
              }
              if (w) {
                pos_conf.w = w;
              }
            }
            if (!h) {
              try {
                h = dest_el.offsetHeight;
              } catch (_error) {
                e = _error;
                h = 0;
              }
              if (h) {
                pos_conf.h = h;
              }
            }
            if (w && h) {
              name_params = new ParamHash();
              dest_rel_id = POS_REL_BOX_ID_PREFIX + "_" + pos_id;
              rel_el = _elt(dest_rel_id);
              par_el = _par(dest_el);
              if (rel_el && par_el === rel_el) {
                par_el = _par(rel_el);
              }
              _shim_frame(dest_id);

              /*
              @ignore
               */
              pend = pending_ifrs[pos_id];
              if (pend) {
                clearTimeout(pend);
              }
              pend = complete_ifrs[pos_id];
              if (pend) {
                delete complete_ifrs[pos_id];
              }
              pending_ifrs[pos_id] = setTimeout(function() {
                _handle_render_timeout(pos_id);
              }, config.to);
              current_status = "rendering";
              _fire_pub_callback("onStartPosRender", pos_id, pos_conf, pos);
              css_txt = ["position:", "", ";z-index:0;", WIDTH, ":", w, PX, ";", HEIGHT, ":", h, PX, ";", "visibility:inherit;"];
              if (!rel_el) {
                css_txt[1] = firstCSSPos;
                rel_el = dom.make("div");
                rel_el.id = dest_rel_id;
                rel_el.className = "iab_sf";
                new_dest_el = dest_el.cloneNode(false);
                dom.css(new_dest_el, css_txt);
                rel_el.appendChild(new_dest_el);
                dom.css(rel_el, css_txt);
                par_el.replaceChild(rel_el, dest_el);
                dest_el = _elt(dest_id);
              } else {
                st = rel_el[ST];
                st.width = w + PX;
                st.height = h + PX;
                st = dest_el && dest_el[ST];
                st.width = w + PX;
                st.height = h + PX;
              }
              name_params.id = pos_id;
              name_params.dest = dest_id;
              name_params.conf = ParamHash(pos_conf);
              name_params.meta = pos.meta.toString();
              name_params.html = _es(pos.html);
              name_params.geom = _es(_build_geom(pos_id, dest_el));
              name_params.src = config.renderFile;
              name_params.has_focus = lang.cstr(document.hasFocus());
              css_txt[1] = finalCSSPos;
              css_txt[13] = finalCSSEnd;
              if (!win_events_attached) {
                dom.attach(win, SCROLL, _handle_win_geom_scroll);
                dom.attach(win, "resize", _handle_win_geom_resize);
                dom.attach(win, "unload", _handle_unload);
                dom.attach(win, "focus", _handle_win_focus);
                dom.attach(win, "blur", _handle_win_blur);
                win_events_attached = true;
              }
              iframes.replace({
                id: dest_id,
                name: name_params,
                src: config.renderFile,
                _pos_id: pos_id
              }, css_txt, rel_el, _handle_frame_load, _handle_msg_evt);
              rendered_ifrs[pos_id] = name_params;
            }
          }
        }
      }
    };

    /*
    Gets a copy of the Position configuration, content, and meta data for a given SafeFrame
    
    @name $sf.host.get
    @public
    @function
    @static
    @return {Object}
     */
    get = function(positionId) {
      var obj;
      obj = rendered_ifrs[positionId];
      if (!obj) {
        return null;
      }
      return _mix({}, obj);
    };

    /*
    Returns a string as to whether or not the library is busy, empty string is returned on idle
    
    @name $sf.host.status
    @public
    @function
    @static
    @return {String}
     */
    status = function() {
      return current_status;
    };
    _send_generic_response = function(posID, command) {
      var msgObj, params;
      msgObj = new ParamHash();
      params = posID && rendered_ifrs[posID];
      msgObj.cmd = command;
      msgObj.pos = posID;
      return _send_response(params, msgObj);
    };
    _getGeom = function(posID) {
      var g, id, ifr, params;
      params = rendered_ifrs[posID];
      id = params && params.dest;
      ifr = id && _elt(id);
      g = _build_geom(posID, ifr, true);
      return g;
    };
    inViewPercentage = function(posID) {
      var geom_info, iv, tv, _ref;
      geom_info = _getGeom(posID);
      iv = _cnum(geom_info != null ? (_ref = geom_info.self) != null ? _ref.iv : void 0 : void 0, -1, 0);
      if (iv >= 0) {
        tv = Math.floor(iv * 100);
      }
      return tv;
    };
    if (lang) {
      if (win === top) {
        _rect = (ieVer ? _getRectIE : _getRectNonIE);
        _mix(dom, {
          rect: _rect,
          currentStyle: currentStyle,
          contains: contains,
          docRect: docRect,
          winRect: winRect,
          bounds: bounds,
          overlaps: overlaps
        });

        /*
        @ignore
         */
        (function() {
          var e;
          e = void 0;
          dom.msghost = {
            prep: prep_iframe_msging,
            attach: attach_iframe_msging,
            detach: detach_iframe_msging,
            usingHTML5: usingHTML5,
            send: send_msg_to_child_iframe
          };
          dom[ATTACH](win, MSG, _check_html5_init);
          initID = "xdm-html5-init-" + _guid();
          locHost = (locHost.indexOf("file") === 0 ? locHost = "file" : locHost);
          try {
            win[PMSG](initID, (locHost === "file" ? "*" : locHost));
          } catch (_error) {
            e = _error;
            dom[DETACH](win, MSG, _check_html5_init);
          }
        })();
        _mix(sf.host, {
          Config: Config,
          PosConfig: PosConfig,
          PosMeta: PosMeta,
          Position: Position,
          nuke: nuke,
          get: get,
          render: render,
          status: status,
          inViewPercentage: inViewPercentage
        });
      }
    }
    return sf;
  })(window, sf);

}).call(this);

},{"./boot":16}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":19,"./env":20,"./lang":21,"./logger":22}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":20,"./lang":21}],20:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./lang":21,"8DwohR":32}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, wrap, _es, _keys, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    _keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + _keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray,
      wrap: wrap
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],23:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":24,"ieee754":25}],24:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],25:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],26:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":23}],27:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":28,"./rng":29,"./sha":30,"./sha256":31,"buffer":23}],28:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":26}],29:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],30:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":26}],31:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":26}],32:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3B1Ymxpc2hlci5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3B1Ymxpc2hlci9zbG90LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9saWIvc2hhcmVkL2Jhc2UuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL2xpYi9zaGFyZWQvY29uZmlnLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9saWIvc2hhcmVkL2VuZ2FnZW1lbnQuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL2xpYi9zaGFyZWQvZXZlbnQuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL2xpYi9zaGFyZWQvc2Vzc2lvbi5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3NoYXJlZC9zaXplcy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbGliL3NoYXJlZC9zdHJlYW0uanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL2xpYi9zaGFyZWQvdXRpbHMuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9jb29raWVzLWpzL3NyYy9jb29raWVzLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvanNvbi9qc29uMi5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbm9kZV9tb2R1bGVzL25vZGUtdXVpZC91dWlkLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvcmVxd2VzdC9yZXF3ZXN0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9ob3N0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9ob3N0L2Jvb3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL2hvc3QvaG9zdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2NvcmUvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2Jhc2UuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9kb20uanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9lbnYuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9jb3JlL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9sYW5nLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvY29yZS9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvbG9nZ2VyLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L21kNS5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3NoYTI1Ni5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBBZEpTLCBTZXNzaW9uLCBjb25maWcsIGVuZ2FnZW1lbnQsIHNmLCBzdHJlYW07XG5cbiAgc2YgPSByZXF1aXJlKCdzYWZlZnJhbWUnKTtcblxuICBlbmdhZ2VtZW50ID0gcmVxdWlyZSgnLi9zaGFyZWQvZW5nYWdlbWVudCcpO1xuXG4gIFNlc3Npb24gPSByZXF1aXJlKCcuL3NoYXJlZC9zZXNzaW9uJyk7XG5cbiAgQWRKUyA9IHJlcXVpcmUoJy4vcHVibGlzaGVyL3Nsb3QnKTtcblxuICBzdHJlYW0gPSByZXF1aXJlKCcuL3NoYXJlZC9zdHJlYW0nKTtcblxuICBjb25maWcgPSByZXF1aXJlKCcuL3NoYXJlZC9jb25maWcnKTtcblxuICAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGRvUmVuZGVyLCBnbG9iYWxDb25maWcsIGluaXRTYWZlRnJhbWUsIHNhZmVmcmFtZVVybCwgc2Vzc2lvbiwgc2ZEb207XG4gICAgc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKCk7XG4gICAgc3RyZWFtLnBhZ2Uoc2Vzc2lvbik7XG4gICAgc2FmZWZyYW1lVXJsID0gY29uZmlnLmNkbl91cmw7XG4gICAgc2ZEb20gPSAkc2YubGliLmRvbTtcbiAgICBnbG9iYWxDb25maWcgPSB7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHNhZmVmcmFtZV91cmw6IHNhZmVmcmFtZVVybFxuICAgIH07XG4gICAgZG9SZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkLCBkaXYsIGRpdnMsIHNmUG9zaXRpb25zLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBzZlBvc2l0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFzZkRvbS5yZWFkeSgpKSB7XG4gICAgICAgIHNmRG9tLndhaXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgICAgZG9SZW5kZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGFyZ3MgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIik7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGRpdiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkaXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGl2cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGQgPSBkaXZzW19pXTtcbiAgICAgICAgICBpZiAoc2ZEb20uYXR0cihkLCBcImRhdGEtYWRqc1wiKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gQWRKUy5jcmVhdGUoZCwgc2Vzc2lvbik7XG4gICAgICAgICAgICB9KShkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXRTYWZlRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAkc2YuaG9zdC5Db25maWcoe1xuICAgICAgICByZW5kZXJGaWxlOiBnbG9iYWxDb25maWcuc2FmZWZyYW1lX3VybCxcbiAgICAgICAgcG9zaXRpb25zOiB7fSxcbiAgICAgICAgb25TdGFydFBvc1JlbmRlcjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb25GYWlsdXJlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBvbkFkTG9hZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICByZXR1cm4gQWRKUyhpZCkubG9hZCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZVBvc01zZzogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb25Qb3NNc2c6IGZ1bmN0aW9uKGlkLCBtc2csIGNvbnRlbnQpIHtcbiAgICAgICAgICByZXR1cm4gQWRKUyhpZCkuaGFuZGxlTWVzc2FnZShtc2csIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIEFkSlMudmlldyhmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXNzaW9uLmluY3IoXCJhdlwiKTtcbiAgICB9KTtcbiAgICBBZEpTLmVuZ2FnZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXNzaW9uLmluY3IoXCJhZVwiKTtcbiAgICB9KTtcbiAgICBBZEpTLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2Vzc2lvbi5pbmNyKFwiYVwiKTtcbiAgICB9KTtcbiAgICBBZEpTLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlc3Npb24uaW5jcihcImFjXCIpO1xuICAgIH0pO1xuICAgIEFkSlMubG9hZChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcImxvYWRlZFwiKTtcbiAgICB9KTtcbiAgICBzZXNzaW9uLmNoYW5nZShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhZCwgXywgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBjb25zb2xlLmxvZyhcInd0ZlwiKTtcbiAgICAgIF9yZWYgPSBBZEpTLnNsb3RzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoXyBpbiBfcmVmKSB7XG4gICAgICAgIGFkID0gX3JlZltfXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChhZC5ub3RpZnlGcmFtZShcImNvb2tpZS11cGRhdGVcIiwgc2Vzc2lvbi5zZXJpYWxpemVDb29raWUoKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pO1xuICAgIEFkSlMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWRKc1NjcmlwdCwgcztcbiAgICAgIGFkSnNTY3JpcHQgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHMgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoc2ZEb20uYXR0cihzLCBcImRhdGEtYWRqc1wiKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSlbMF07XG4gICAgICBpbml0U2FmZUZyYW1lKCk7XG4gICAgICByZXR1cm4gZG9SZW5kZXIoKTtcbiAgICB9O1xuICAgIGVuZ2FnZW1lbnQub25FbmdhZ2VtZW50KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFkLCBfLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSBBZEpTLnNsb3RzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoXyBpbiBfcmVmKSB7XG4gICAgICAgIGFkID0gX3JlZltfXTtcbiAgICAgICAgaWYgKGFkLmN1cnJlbnRseUludmlldygpICYmICFhZC5lbmdhZ2VkKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChhZC5lbmdhZ2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSk7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFkSlMucmVuZGVyKCk7XG4gICAgfSkoKTtcbiAgICBBZEpTLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHdpbmRvdy4kYWQgPSBBZEpTO1xuICAgIHJldHVybiBBZEpTO1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnRzLCBzZiwgc2ZEb20sIHNpemVzLCB1dGlscyxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIHNmID0gcmVxdWlyZSgnc2FmZWZyYW1lJyk7XG5cbiAgc2l6ZXMgPSByZXF1aXJlKCcuLi9zaGFyZWQvc2l6ZXMnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4uL3NoYXJlZC91dGlscycpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4uL3NoYXJlZC9ldmVudCcpKFtcInJlcXVlc3RcIiwgXCJjbGlja1wiLCBcImxvYWRcIiwgXCJ2aWV3XCIsIFwidW5sb2FkXCIsIFwiZm9jdXNcIiwgXCJlbmdhZ2VcIiwgXCJ1bmZvY3VzXCIsIFwiZXhwYW5kXCIsIFwiY29sbGFwc2VcIiwgXCJyZWZyZXNoZWRcIiwgXCJjb29raWVcIiwgXCJyZWNlaXZlXCIsIFwidW52aWV3XCIsIFwidGltZW91dFwiXSk7XG5cbiAgc2ZEb20gPSBzZi5saWIuZG9tO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBTQ1JJUFRfUkVHRVgsIFNsb3QsIFRJTUVPVVRfVElNRSwgb2xkVHJpZ2dlciwgc2xvdHM7XG4gICAgVElNRU9VVF9USU1FID0gNTAwMDtcbiAgICBzbG90cyA9IHt9O1xuICAgIFNDUklQVF9SRUdFWCA9IC88IS0tKFtcXHNcXFNdKiktLT4vO1xuICAgIFNsb3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBTbG90KGFkSWQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyID0gX19iaW5kKHRoaXMudHJpZ2dlciwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU2xvdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXQoYWRJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTbG90KGFkSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihhZElkKSB7XG4gICAgICAgIGlmIChzbG90c1thZElkXSkge1xuICAgICAgICAgIHJldHVybiBzbG90c1thZElkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gYWRJZDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIHNsb3RzW2FkSWRdID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdEV2ZW50cygpO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuc3RhcnRBdXRvUmVmcmVzaCA9IGZ1bmN0aW9uKGRlbGF5LCBjYikge1xuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgIGRlbGF5ID0gNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG9SZWZyZXNoaW5nKSB7XG4gICAgICAgICAgdGhpcy5faXNBdXRvUmVmcmVzaGluZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaEludGVydmFsID0gc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2lzQXV0b1JlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLmxvYWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlZnJlc2goY2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKHRoaXMpLCBkZWxheSAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuc3RvcEF1dG9SZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pc0F1dG9SZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgdGhpcy5wb3NNZXRhLnNldFZhbHVlKFwic2xvdF9jb3VudFwiLCBcImV4dGVuZGVkXCIsIHRoaXMuY291bnQpO1xuICAgICAgICBzZi5ob3N0LnJlbmRlcih0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnBvc0NvbmZpZy5kZXN0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY2IodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgIGlmICghKChfcmVmID0gdGhpcy5vcHRpb25zKSAhPSBudWxsID8gX3JlZi5pZ25vcmVFdmVudHMgOiB2b2lkIDApKSB7XG4gICAgICAgICAgZXZlbnRzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBTbG90LnRyaWdnZXIoZXZlbnQsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24obXNnLCBjb250ZW50KSB7XG4gICAgICAgIHN3aXRjaCAobXNnKSB7XG4gICAgICAgICAgY2FzZSBcImZvY3VzLWNoYW5nZVwiOlxuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJnZW9tLXVwZGF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgY2FzZSBcImV4cGFuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kKGNvbnRlbnQpO1xuICAgICAgICAgIGNhc2UgXCJjb2xsYXBzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2UoY29udGVudCk7XG4gICAgICAgICAgY2FzZSBcInZpZXdlZFwiOlxuICAgICAgICAgICAgaWYgKCF0aGlzLnZpZXdlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidW52aWV3ZWRcIjpcbiAgICAgICAgICAgIGlmICghKHRoaXMudW52aWV3ZWQgJiYgdGhpcy52aWV3ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnVudmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNsaWNrZWRcIjpcbiAgICAgICAgICAgIGlmICghdGhpcy5jbGlja2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVxdWVzdGVkXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KCk7XG4gICAgICAgICAgY2FzZSBcImNvb2tpZS13cml0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29va2llKHtcbiAgICAgICAgICAgICAgY29va2llOiBcIndyaXRlXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJjb29raWUtcmVhZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29va2llKHtcbiAgICAgICAgICAgICAgY29va2llOiBcInJlYWRcIixcbiAgICAgICAgICAgICAgY29udGVudDogY29udGVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcInJlbG9hZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgY2FzZSBcIm1zZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZShkZWNvZGVVUklDb21wb25lbnQoY29udGVudCkpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuaW5pdEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubG9hZChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSB1dGlscy5jb3VudEZyYW1lcyh0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy52aWV3ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVuZ2FnZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZW5nYWdlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmdhZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW5nYWdlVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5RnJhbWUoXCJlbmdhZ2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudW52aWV3ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnVudmlld1RpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVubG9hZFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmZyYW1lQ291bnQgPSAwO1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5ub3RpZnlGcmFtZSA9IGZ1bmN0aW9uKGNtZCwgZGF0YSkge1xuICAgICAgICB2YXIgbXNnT2JqO1xuICAgICAgICBtc2dPYmogPSBzZi5saWIubGFuZy5QYXJhbUhhc2goKTtcbiAgICAgICAgaWYgKHRoaXMucG9zQ29uZmlnKSB7XG4gICAgICAgICAgbXNnT2JqLnBvcyA9IHRoaXMucG9zQ29uZmlnLmlkO1xuICAgICAgICAgIG1zZ09iai5jbWQgPSBjbWQ7XG4gICAgICAgICAgbXNnT2JqLnZhbHVlID0gZXNjYXBlKGRhdGEpO1xuICAgICAgICAgIHJldHVybiBzZkRvbS5tc2dob3N0LnNlbmQodGhpcy5wb3NDb25maWcuZGVzdCwgbXNnT2JqLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtLCBodG1sLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHMsIHN1cHBvcnRzLCB3aWR0aCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZiwgX3JlZjE7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgZWxlbS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLmhlaWdodCB8fCBlbGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgc3VwcG9ydHMgPSB7fTtcbiAgICAgICAgX3JlZiA9IHRoaXMub3B0aW9ucy5zdXBwb3J0cyB8fCBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcyA9IF9yZWZbX2ldO1xuICAgICAgICAgIHN1cHBvcnRzW3NdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfcmVmMSA9IHRoaXMub3B0aW9ucy5kaXNhYmxlcyB8fCBbXTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgcyA9IF9yZWYxW19qXTtcbiAgICAgICAgICBzdXBwb3J0c1tzXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgZWxlbS5pZCB8fCAoZWxlbS5pZCA9IHNmLmxpYi5sYW5nLmd1aWQoXCJwb3NcIikpO1xuICAgICAgICB0aGlzLnBvc01ldGEgPSBuZXcgc2YuaG9zdC5Qb3NNZXRhKG51bGwsIFwiZXh0ZW5kZWRcIiwge1xuICAgICAgICAgIGludmlldzogdGhpcy5vcHRpb25zLmludmlldyxcbiAgICAgICAgICBzZXNzaW9uOiB0aGlzLm9wdGlvbnMuc2Vzc2lvbixcbiAgICAgICAgICBob3N0OiBkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICByZWZlcnJlcjogdGhpcy5vcHRpb25zLnJlZmVycmVyLFxuICAgICAgICAgIGxvY2F0aW9uOiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgIHNsb3RfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgc2xvdF9jb3VudDogdGhpcy5jb3VudFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3NDb25maWcgPSBuZXcgc2YuaG9zdC5Qb3NDb25maWcoe1xuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgIGRlc3Q6IGVsZW0uaWQsXG4gICAgICAgICAgdzogd2lkdGgsXG4gICAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICAgIHN1cHBvcnRzOiBzdXBwb3J0c1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3MgPSBuZXcgc2YuaG9zdC5Qb3NpdGlvbih0aGlzLnBvc0NvbmZpZy5pZCwgaHRtbCwgdGhpcy5wb3NNZXRhKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZyZXNoX29vdikge1xuICAgICAgICAgIHRoaXMudW52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcyksIDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmcmVzaF90aW1lICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lID0gc2YubGliLmxhbmcuY251bSh0aGlzLm9wdGlvbnMucmVmcmVzaF90aW1lLCAwKTtcbiAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoVGltZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9hZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRBdXRvUmVmcmVzaCh0aGlzLnJlZnJlc2hUaW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGlzLnN0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2YuaG9zdC5yZW5kZXIodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbS5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZG9udEZpcmUpIHtcbiAgICAgICAgaWYgKCFkb250RmlyZSkge1xuICAgICAgICAgIHRoaXMudW5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMudmlld2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5nYWdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVudmlld2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld1RpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVuZ2FnZVRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnVudmlld1RpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnVubG9hZFRpbWUgPSBudWxsO1xuICAgICAgICBzZi5ob3N0Lm51a2UodGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5ldmVudHM7XG4gICAgICAgIHJldHVybiBkZWxldGUgc2xvdHNbdGhpcy5pZF07XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnZpZXcpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSh0cnVlKTtcbiAgICAgICAgICBzZi5ob3N0LnJlbmRlcih0aGlzLnBvcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnBvc0NvbmZpZy5kZXN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuY3VycmVudGx5SW52aWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZi5ob3N0LmluVmlld1BlcmNlbnRhZ2UodGhpcy5pZCkgPiA1MCAmJiB0aGlzLnZpZXdlZDtcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmludmlld1BlcmNlbnRhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNmLmhvc3QuaW5WaWV3UGVyY2VudGFnZSh0aGlzLmlkKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTbG90O1xuXG4gICAgfSkoKTtcbiAgICBTbG90LmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhZCwgXywgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfIGluIHNsb3RzKSB7XG4gICAgICAgIGFkID0gc2xvdHNbX107XG4gICAgICAgIF9yZXN1bHRzLnB1c2goYWQuZGVzdHJveSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICAgIFNsb3QuZXZlbnRzID0ge307XG4gICAgb2xkVHJpZ2dlciA9IFNsb3QucHJvdG90eXBlLnRyaWdnZXI7XG4gICAgc2YubGliLmxhbmcubWl4KFNsb3QucHJvdG90eXBlLCBldmVudHMpO1xuICAgIFNsb3QucHJvdG90eXBlLnRyaWdnZXIgPSBvbGRUcmlnZ2VyO1xuICAgIHNmLmxpYi5sYW5nLm1peChTbG90LCBldmVudHMpO1xuICAgIFNsb3QuY3JlYXRlID0gZnVuY3Rpb24oZCwgc2Vzc2lvbikge1xuICAgICAgdmFyIGFkSWQsIGRpc2FibGVzLCBkaXYsIGhlaWdodCwgcG9zSWQsIHNpemUsIHN1cHBvcnRzLCB0ZW1wbGF0ZSwgd2lkdGgsIF9iYXNlLCBfYmFzZTEsIF9yZWY7XG4gICAgICB0ZW1wbGF0ZSA9ICgoX3JlZiA9IGQuaW5uZXJIVE1MLm1hdGNoKFNDUklQVF9SRUdFWCkpICE9IG51bGwgPyBfcmVmWzFdIDogdm9pZCAwKSB8fCBkLmlubmVySFRNTDtcbiAgICAgIHBvc0lkID0gc2YubGliLmxhbmcuZ3VpZChcInBvc1wiKTtcbiAgICAgIGFkSWQgPSBkLmlkIHx8IHBvc0lkO1xuICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5pZCA9IHBvc0lkO1xuICAgICAgZC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgc3VwcG9ydHMgPSBbXTtcbiAgICAgIGRpc2FibGVzID0gW107XG4gICAgICBpZiAoc2l6ZSA9IHNpemVzW3NmRG9tLmF0dHIoZCwgXCJkYXRhLWFkLXR5cGVcIildKSB7XG4gICAgICAgIHdpZHRoID0gc2l6ZVswXSwgaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICAgIH1cbiAgICAgIFNsb3QoYWRJZCkuY3JlYXRlKGRpdiwgdGVtcGxhdGUsIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoIHx8IHNmRG9tLmF0dHIoZCwgXCJkYXRhLXdpZHRoXCIpLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCBzZkRvbS5hdHRyKGQsIFwiZGF0YS1oZWlnaHRcIiksXG4gICAgICAgIHN1cHBvcnRzOiB0eXBlb2YgKF9iYXNlID0gc2ZEb20uYXR0cihkLCBcImRhdGEtc3VwcG9ydHNcIikpLnNwbGl0ID09PSBcImZ1bmN0aW9uXCIgPyBfYmFzZS5zcGxpdChcIixcIikgOiB2b2lkIDAsXG4gICAgICAgIGRpc2FibGVzOiB0eXBlb2YgKF9iYXNlMSA9IHNmRG9tLmF0dHIoZCwgXCJkYXRhLWRpc2FibGVzXCIpKS5zcGxpdCA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2UxLnNwbGl0KFwiLFwiKSA6IHZvaWQgMCxcbiAgICAgICAgaW52aWV3OiBzZi5saWIubGFuZy5jYm9vbChzZkRvbS5hdHRyKGQsIFwiZGF0YS1pbnZpZXdcIikpLFxuICAgICAgICByZWZyZXNoX3RpbWU6IHNmRG9tLmF0dHIoZCwgXCJkYXRhLXJlZnJlc2gtdGltZVwiKSxcbiAgICAgICAgcmVmcmVzaF9vb3Y6IHNmLmxpYi5sYW5nLmNib29sKHNmRG9tLmF0dHIoZCwgXCJkYXRhLXJlZnJlc2gtb292XCIpKSxcbiAgICAgICAgc2Vzc2lvbjogc2Vzc2lvbiAhPSBudWxsID8gc2Vzc2lvbi5zZXJpYWxpemVDb29raWUoKSA6IHZvaWQgMCxcbiAgICAgICAgcmVmZXJyZXI6IHNmRG9tLmF0dHIoZCwgXCJkYXRhLXJlZmVycmVyXCIpLFxuICAgICAgICBpZ25vcmVFdmVudHM6IHNmLmxpYi5sYW5nLmNib29sKHNmRG9tLmF0dHIoZCwgXCJkYXRhLWlnbm9yZS1ldmVudHNcIikpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTbG90KGFkSWQpO1xuICAgIH07XG4gICAgU2xvdC5zbG90cyA9IHNsb3RzO1xuICAgIFNsb3Quc2l6ZXMgPSBzaXplcztcbiAgICByZXR1cm4gU2xvdDtcbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJhc2U7XG4gICAgcmV0dXJuIEJhc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCYXNlKCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgfHwgKHRoaXMuYXR0cmlidXRlcyA9IHt9KTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICB9XG5cbiAgICAgIEJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkLCBjaGFuZ2VkQXR0cmlidXRlcywgZiwgaywgdiwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIGF0dHJzKSB7XG4gICAgICAgICAgdiA9IGF0dHJzW2tdO1xuICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXNba10gIT09IHYpIHtcbiAgICAgICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiBjaGFuZ2VkQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmLmFwcGx5KHRoaXMsIFt0aGlzLCBjaGFuZ2VkQXR0cmlidXRlc10pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBCYXNlLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIGlmIChmICYmIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWYpIHtcbiAgICAgICAgICBfcmVmID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmID0gX3JlZltfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEJhc2U7XG5cbiAgICB9KSgpO1xuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJ2Jhc2UvbGliL2h0bWwvYWRqc2ZyYW1lLmh0bWwnXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBpOiBcIi8vZW5kcG9pbnQuYWRqcy5pby8xXCIsXG4gICAgICAgIGNkbl91cmw6IHByb2Nlc3MuZW52LkNETl9VUkxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJy4uL2xpYi9odG1sL2FkanNmcmFtZS5odG1sJ1xuICAgICAgfTtcbiAgICB9XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiOER3b2hSXCIpKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIHV0aWxzO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdywgJHNmKSB7XG4gICAgdmFyIEVOR0FHRU1FTlRfUkVTRVQsIGFjdGl2aXR5SGFuZGxlciwgYXR0YWNoLCBkaXNlbmdhZ2VFdmVudHMsIGRvYywgZW5nYWdlRXZlbnRzLCBlbmdhZ2VtZW50LCBlbmdhZ2VtZW50VGltZW91dCwgbGFzdEVuZ2FnZWQsIHJlc2V0RW5nYWdlbWVudDtcbiAgICBhdHRhY2ggPSAkc2YubGliLmRvbS5hdHRhY2g7XG4gICAgZW5nYWdlbWVudCA9IHtcbiAgICAgIGlzRW5nYWdlZDogZmFsc2VcbiAgICB9O1xuICAgIGRvYyA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICBlbmdhZ2VFdmVudHMgPSBbXTtcbiAgICBkaXNlbmdhZ2VFdmVudHMgPSBbXTtcbiAgICBFTkdBR0VNRU5UX1JFU0VUID0gMzAwMDtcbiAgICBsYXN0RW5nYWdlZCA9IHZvaWQgMDtcbiAgICBlbmdhZ2VtZW50Lm9uRW5nYWdlbWVudCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlbmdhZ2VFdmVudHMucHVzaChmKTtcbiAgICB9O1xuICAgIGVuZ2FnZW1lbnQub25EaXNlbmdhZ2VtZW50ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGRpc2VuZ2FnZUV2ZW50cy5wdXNoKGYpO1xuICAgIH07XG4gICAgYWN0aXZpdHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZiwgX2ksIF9sZW47XG4gICAgICBlbmdhZ2VtZW50LmlzRW5nYWdlZCA9IHRydWU7XG4gICAgICBlbmdhZ2VtZW50Lmxhc3RFbmdhZ2VkID0gdXRpbHMubm93KCk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGVuZ2FnZUV2ZW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBmID0gZW5nYWdlRXZlbnRzW19pXTtcbiAgICAgICAgZigpO1xuICAgICAgfVxuICAgICAgcmVzZXRFbmdhZ2VtZW50KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGVuZ2FnZW1lbnRUaW1lb3V0ID0gbnVsbDtcbiAgICByZXNldEVuZ2FnZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dChlbmdhZ2VtZW50VGltZW91dCk7XG4gICAgICByZXR1cm4gZW5nYWdlbWVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZiwgX2ksIF9sZW47XG4gICAgICAgIGVuZ2FnZW1lbnQuaXNFbmdhZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGlzZW5nYWdlRXZlbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgZiA9IGRpc2VuZ2FnZUV2ZW50c1tfaV07XG4gICAgICAgICAgZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNlbmdhZ2VFdmVudHMgPSBbXTtcbiAgICAgIH0sIEVOR0FHRU1FTlRfUkVTRVQpO1xuICAgIH07XG4gICAgYXR0YWNoKGRvYywgJ2NsaWNrJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2goZG9jLCAnbW91c2V1cCcsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ21vdXNlZG93bicsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ21vdXNlbW92ZScsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ21vdXNld2hlZWwnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaChkb2MsICdrZXlwcmVzcycsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ2tleWRvd24nLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaChkb2MsICdrZXl1cCcsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKHdpbmRvdywgJ0RPTU1vdXNlU2Nyb2xsJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAnc2Nyb2xsJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAncmVzaXplJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAnZm9jdXMnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaCh3aW5kb3csICdibHVyJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICByZXR1cm4gZW5nYWdlbWVudDtcbiAgfSkod2luZG93LCAkc2YpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCBldmVudHMsIHV0aWxzLCBfaSwgX2xlbjtcbiAgICAgIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgICAgZXZlbnRzID0ge1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdDtcbiAgICAgICAgICB0aGlzLmV2ZW50cyB8fCAodGhpcy5ldmVudHMgPSB7fSk7XG4gICAgICAgICAgZXZlbnRMaXN0ID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKGNiKTtcbiAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBldmVudExpc3Q7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICBvcHRpb25hbERhdGEgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhLCBvcHRpb25hbERhdGEpIHtcbiAgICAgICAgICB2YXIgZSwgZXgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICAgIHRoaXMuZXZlbnRzIHx8ICh0aGlzLmV2ZW50cyA9IHt9KTtcbiAgICAgICAgICBfcmVmID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZSA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZS5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbmFsRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXggPSBfZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubm90aWZ5KGV2ZW50LCBkYXRhIHx8IHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBub3RpZnk6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZHBvaW50LCBwYXJhbXMsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjEgPSAoKF9yZWYgPSB0aGlzLmV2ZW50RW5kcG9pbnRzKSAhPSBudWxsID8gX3JlZltldmVudF0gOiB2b2lkIDApIHx8IFtdO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICBwYXJhbXMgPSAoZGF0YSAhPSBudWxsID8gdHlwZW9mIGRhdGEuZ2V0UGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBkYXRhLmdldFBhcmFtcygpIDogdm9pZCAwIDogdm9pZCAwKSB8fCB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh1dGlscy5zZW5kUmVxdWVzdChlbmRwb2ludCwge1xuICAgICAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBldmVudE5hbWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnROYW1lc1tfaV07XG4gICAgICAgIGV2ZW50c1tldmVudF0gPSAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICByZXR1cm4gZiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgZXZlbnRzW1wiXCIgKyBldmVudCArIFwiUmVnaXN0ZXJFbmRwb2ludFwiXSA9IChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIHJldHVybiBmID0gZnVuY3Rpb24oZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBfYmFzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbmRwb2ludHMgfHwgKHRoaXMuZXZlbnRFbmRwb2ludHMgPSB7fSk7XG4gICAgICAgICAgICAoX2Jhc2UgPSB0aGlzLmV2ZW50RW5kcG9pbnRzKVtldmVudF0gfHwgKF9iYXNlW2V2ZW50XSA9IFtdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50RW5kcG9pbnRzW2V2ZW50XS5wdXNoKGVuZHBvaW50KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KShldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH0pKCk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBCYXNlLCBjb29raWVzLCB1dGlscywgdXVpZCxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBjb29raWVzID0gcmVxdWlyZSgnY29va2llcy1qcycpO1xuXG4gIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKTtcblxuICBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbiAgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIENPT0tJRV9LRVksIFNlc3Npb24sIGRlZmF1bHRBdHRyaWJ1dGVzLCBnZXRVc2VySWQsIG5vdywgcGFyc2VDb29raWUsIHVwZGF0ZVZpc2l0SWQ7XG4gICAgQ09PS0lFX0tFWSA9IFwiX2Fqc2tcIjtcbiAgICBub3cgPSB1dGlscy5ub3coKTtcbiAgICB1cGRhdGVWaXNpdElkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG5vd1RpbWU7XG4gICAgICBub3dUaW1lID0gdXRpbHMubm93KCkgLyAxMDAwO1xuICAgICAgdGhpcy5sYXN0VmlzaXRUaW1lIHx8ICh0aGlzLmxhc3RWaXNpdFRpbWUgPSB1dGlscy50b051bWJlcih0aGlzLmF0dHJpYnV0ZXMudnRzLCAwKSk7XG4gICAgICBpZiAoKG5vd1RpbWUgLSBTZXNzaW9uLlZJU0lUT1JfRVhQSVJZKSA+IHRoaXMubGFzdFZpc2l0VGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgIHY6IHV0aWxzLnRvTnVtYmVyKHRoaXMuYXR0cmlidXRlcy52KSArIDEsXG4gICAgICAgICAgdnRzMDogdGhpcy5hdHRyaWJ1dGVzLnZ0cyxcbiAgICAgICAgICB2dHM6IG5vd1RpbWUsXG4gICAgICAgICAgdmlkOiB1dWlkLnY0KCksXG4gICAgICAgICAgdnA6IDAsXG4gICAgICAgICAgdmE6IDAsXG4gICAgICAgICAgdmF2OiAwLFxuICAgICAgICAgIHZhZTogMCxcbiAgICAgICAgICB2YWM6IDBcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RWaXNpdFRpbWUgPSBub3dUaW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgIHZ0czogbm93VGltZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VDb29raWUgPSBmdW5jdGlvbihjb29raWUpIHtcbiAgICAgIHJldHVybiB1dGlscy5mcm9tUXVlcnkoY29va2llKTtcbiAgICB9O1xuICAgIGdldFVzZXJJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWxzLnNlbmRSZXF1ZXN0KCk7XG4gICAgfTtcbiAgICBkZWZhdWx0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHV1aWQudjQoKSxcbiAgICAgICAgdmlkOiB1dWlkLnY0KCksXG4gICAgICAgIHRzOiBub3cgLyAxMDAwLFxuICAgICAgICBwOiAwLFxuICAgICAgICBhOiAwLFxuICAgICAgICBhdjogMCxcbiAgICAgICAgYWM6IDAsXG4gICAgICAgIGFlOiAwLFxuICAgICAgICB2OiAxLFxuICAgICAgICB2dHM6IG5vdyAvIDEwMDAsXG4gICAgICAgIHZ0czA6IG5vdyAvIDEwMDAsXG4gICAgICAgIHZwOiAwLFxuICAgICAgICB2YTogMCxcbiAgICAgICAgdmF2OiAwLFxuICAgICAgICB2YWU6IDAsXG4gICAgICAgIHZhYzogMFxuICAgICAgfTtcbiAgICB9O1xuICAgIFNlc3Npb24gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMoU2Vzc2lvbiwgX3N1cGVyKTtcblxuICAgICAgZnVuY3Rpb24gU2Vzc2lvbihxdWVyeSkge1xuICAgICAgICB2YXIgYXR0cnMsIGNvb2tpZSwgaywgdiwgX2Jhc2UsIF9yZWY7XG4gICAgICAgIFNlc3Npb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgICAgIF9yZWYgPSBkZWZhdWx0QXR0cmlidXRlcygpO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICAgIChfYmFzZSA9IHRoaXMuYXR0cmlidXRlcylba10gfHwgKF9iYXNlW2tdID0gdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgYXR0cnMgPSBwYXJzZUNvb2tpZShxdWVyeSk7XG4gICAgICAgICAgdGhpcy5zZXQoYXR0cnMsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNvb2tpZSA9IGNvb2tpZXMuZ2V0KENPT0tJRV9LRVkpKSB7XG4gICAgICAgICAgYXR0cnMgPSBwYXJzZUNvb2tpZShjb29raWUpO1xuICAgICAgICAgIHRoaXMuc2V0KGF0dHJzLCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1cGRhdGVWaXNpdElkLmNhbGwodGhpcywge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zZXJpYWxpemVDb29raWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUNvb2tpZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFNlc3Npb24ucHJvdG90eXBlLnNlcmlhbGl6ZUNvb2tpZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcXVlcnk7XG4gICAgICAgIHF1ZXJ5ID0gdXRpbHMudG9RdWVyeSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICBjb29raWVzLnNldChDT09LSUVfS0VZLCBxdWVyeSwge1xuICAgICAgICAgIGV4cGlyZXM6IDMxNTM2MDAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICB9O1xuXG4gICAgICBTZXNzaW9uLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIFNlc3Npb24uX19zdXBlcl9fLnNldC5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplQ29va2llKCk7XG4gICAgICB9O1xuXG4gICAgICBTZXNzaW9uLnByb3RvdHlwZS5pbmNyID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cGRhdGVkVmFscywgdmtleSwgX2Jhc2U7XG4gICAgICAgIChfYmFzZSA9IHRoaXMuYXR0cmlidXRlcylba2V5XSB8fCAoX2Jhc2Vba2V5XSA9IDApO1xuICAgICAgICB1cGRhdGVkVmFscyA9IHt9O1xuICAgICAgICB1cGRhdGVkVmFsc1trZXldID0gdXRpbHMudG9OdW1iZXIodGhpcy5hdHRyaWJ1dGVzW2tleV0pICsgMTtcbiAgICAgICAgdmtleSA9IFwidlwiICsga2V5O1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW3ZrZXldICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVkVmFsc1t2a2V5XSA9IHV0aWxzLnRvTnVtYmVyKHRoaXMuYXR0cmlidXRlc1t2a2V5XSkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNldCh1cGRhdGVkVmFscywgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU2Vzc2lvbjtcblxuICAgIH0pKEJhc2UpO1xuICAgIFNlc3Npb24uVklTSVRPUl9FWFBJUlkgPSAyMDtcbiAgICBpZiAoKHR5cGVvZiBfVEVTVCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfVEVTVCAhPT0gbnVsbCkgJiYgX1RFU1QpIHtcbiAgICAgIFNlc3Npb24uX3VwZGF0ZVZpc2l0SWQgPSB1cGRhdGVWaXNpdElkO1xuICAgICAgU2Vzc2lvbi5fcGFyc2VDb29raWUgPSBwYXJzZUNvb2tpZTtcbiAgICAgIFNlc3Npb24uX2dldFVzZXIgPSBnZXRVc2VySWQ7XG4gICAgICBTZXNzaW9uLl9DT09LSUVfS0VZID0gQ09PS0lFX0tFWTtcbiAgICAgIFNlc3Npb24uY2xlYXJDb29raWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvb2tpZXMuc2V0KENPT0tJRV9LRVksIHZvaWQgMCk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gU2Vzc2lvbjtcbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlYWRlcmJvYXJkOiBbNzI4LCA5MF0sXG4gICAgICBcIm1lZGl1bS1yZWN0YW5nbGVcIjogWzMwMCwgMjUwXVxuICAgIH07XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBjb25maWcsIHJlcXdlc3Q7XG5cbiAgcmVxd2VzdCA9IHJlcXVpcmUoJ3JlcXdlc3QnKTtcblxuICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nUmVxdWVzdHMsIHByZWZpeCwgc2VuZCwgc2VuZGluZ1JlcXVlc3RzO1xuICAgIHByZWZpeCA9IGNvbmZpZy5hcGk7XG4gICAgcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgIHJldHVybiByZXF3ZXN0KHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHR5cGU6ICdqc29ucCcsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZTogZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB2YXIgZXJyb3IsIHN1Y2Nlc3M7XG4gICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgcmV0dXJuIHNlc3Npb24uc2V0KHJlc3AsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVSUk9SOlwiICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbmQocHJlZml4ICsgJy9wYWdlJywgc2Vzc2lvbi5hdHRyaWJ1dGVzLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICB9LFxuICAgICAgZXZlbnQ6IGZ1bmN0aW9uKHJlcXVlc3QsIGNiLCBpc0F0dGVtcHQpIHtcbiAgICAgICAgdmFyIGVycm9yLCBzdWNjZXNzO1xuICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHJlcXVlc3Quc2V0KHJlc3AsIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2IocmVzcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWxldGUgc2VuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICB9O1xuICAgICAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIkVSUk9SOlwiICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF0pIHtcbiAgICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICAgIHNlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHNlbmQocHJlZml4ICsgJy9ldmVudCcsIHJlcXVlc3QuYXR0cmlidXRlcywgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFwZW5kaW5nUmVxdWVzdHNbcmVxdWVzdC5pZF0gfHwgaXNBdHRlbXB0KSB7XG4gICAgICAgICAgcGVuZGluZ1JlcXVlc3RzW3JlcXVlc3QuaWRdO1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXZlbnQocmVxdWVzdCwgY2IsIHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSh0aGlzKSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5yZXF3ZXN0IHx8ICh3aW5kb3cucmVxd2VzdCA9IHJlcXVpcmUoJ3JlcXdlc3QnKSk7XG5cbiAgd2luZG93LkpTT04gfHwgKHdpbmRvdy5KU09OID0gcmVxdWlyZSgnanNvbicpKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigkc2YsIHdpbmRvdykge1xuICAgIHZhciBjYXBpdGFsaXplU3RyaW5nLCBjb3VudEZyYW1lcywgZGVmaW5lUHJvcGVydHksIGZyb21RdWVyeSwgbm93LCByZXF3ZXN0LCBzZW5kUmVxdWVzdCwgdG9OdW1iZXIsIHRvUXVlcnk7XG4gICAgcmVxd2VzdCA9IHdpbmRvdy5yZXF3ZXN0O1xuICAgIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxd2VzdCh7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICB0eXBlOiAnanNvbnAnLFxuICAgICAgICBzdWNjZXNzOiBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBvcHRpb25zLmVycm9yLFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnJvbVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnksIGRlbGltKSB7XG4gICAgICB2YXIgaXRlbSwga2V5LCBwYXJhbXMsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAocXVlcnkgPT0gbnVsbCkge1xuICAgICAgICBxdWVyeSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoZGVsaW0gPT0gbnVsbCkge1xuICAgICAgICBkZWxpbSA9IFwiJlwiO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0ge307XG4gICAgICBfcmVmID0gcXVlcnkuc3BsaXQoZGVsaW0pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBfcmVmW19pXTtcbiAgICAgICAgX3JlZjEgPSBpdGVtLnNwbGl0KFwiPVwiKSwga2V5ID0gX3JlZjFbMF0sIHZhbHVlID0gX3JlZjFbMV07XG4gICAgICAgIHBhcmFtc1trZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgICB0b1F1ZXJ5ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIHJlcXdlc3QudG9RdWVyeVN0cmluZyhhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIHRvTnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJHNmICE9IG51bGwgPyAkc2YubGliLmxhbmcuY251bSh2YWwsIDApIDogdm9pZCAwO1xuICAgIH07XG4gICAgbm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcImRlZmluZVByb3BlcnR5XCIgaW4gT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiX19kZWZpbmVHZXR0ZXJfX1wiIGluIG9iaikge1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLndyaXRhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbFtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKHByb3AsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmouX19kZWZpbmVTZXR0ZXJfXyhwcm9wLCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY291bnRGcmFtZXMgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgIHZhciBjb3VudCwgZnJhbWUsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgY291bnQgPSB3aW4uZnJhbWVzLmxlbmd0aDtcbiAgICAgIF9yZWYgPSB3aW4uZnJhbWVzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGZyYW1lID0gX3JlZltfaV07XG4gICAgICAgIGlmIChmcmFtZSAhPT0gd2luKSB7XG4gICAgICAgICAgY291bnQgKz0gY291bnRGcmFtZXMoZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICBjYXBpdGFsaXplU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbmRSZXF1ZXN0OiBzZW5kUmVxdWVzdCxcbiAgICAgIHRvUXVlcnk6IHRvUXVlcnksXG4gICAgICBmcm9tUXVlcnk6IGZyb21RdWVyeSxcbiAgICAgIHRvTnVtYmVyOiB0b051bWJlcixcbiAgICAgIG5vdzogbm93LFxuICAgICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZVByb3BlcnR5LFxuICAgICAgY291bnRGcmFtZXM6IGNvdW50RnJhbWVzLFxuICAgICAgY2FwaXRhbGl6ZVN0cmluZzogY2FwaXRhbGl6ZVN0cmluZ1xuICAgIH07XG4gIH0pKCRzZiwgd2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIVxyXG4gKiBDb29raWVzLmpzIC0gMC4zLjFcclxuICogV2VkbmVzZGF5LCBBcHJpbCAyNCAyMDEzIEAgMjoyOCBBTSBFU1RcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBTY290dCBIYW1wZXJcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLFxyXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4gKi9cclxuKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgQ29va2llcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xyXG4gICAgICAgICAgICBDb29raWVzLmdldChrZXkpIDogQ29va2llcy5zZXQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFsbG93cyBmb3Igc2V0dGVyIGluamVjdGlvbiBpbiB1bml0IHRlc3RzXHJcbiAgICBDb29raWVzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgQ29va2llcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xyXG5cclxuICAgIENvb2tpZXMuZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgcGF0aDogJy8nXHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChDb29raWVzLl9jYWNoZWREb2N1bWVudENvb2tpZSAhPT0gQ29va2llcy5fZG9jdW1lbnQuY29va2llKSB7XHJcbiAgICAgICAgICAgIENvb2tpZXMuX3JlbmV3Q2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDb29raWVzLl9jYWNoZVtrZXldO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IENvb2tpZXMuX2dldEV4dGVuZGVkT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICBvcHRpb25zLmV4cGlyZXMgPSBDb29raWVzLl9nZXRFeHBpcmVzRGF0ZSh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gLTEgOiBvcHRpb25zLmV4cGlyZXMpO1xyXG5cclxuICAgICAgICBDb29raWVzLl9kb2N1bWVudC5jb29raWUgPSBDb29raWVzLl9nZW5lcmF0ZUNvb2tpZVN0cmluZyhrZXksIHZhbHVlLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIENvb2tpZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuZXhwaXJlID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBDb29raWVzLnNldChrZXksIHVuZGVmaW5lZCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dldEV4dGVuZGVkT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcGF0aDogb3B0aW9ucyAmJiBvcHRpb25zLnBhdGggfHwgQ29va2llcy5kZWZhdWx0cy5wYXRoLFxyXG4gICAgICAgICAgICBkb21haW46IG9wdGlvbnMgJiYgb3B0aW9ucy5kb21haW4gfHwgQ29va2llcy5kZWZhdWx0cy5kb21haW4sXHJcbiAgICAgICAgICAgIGV4cGlyZXM6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHBpcmVzIHx8IENvb2tpZXMuZGVmYXVsdHMuZXhwaXJlcyxcclxuICAgICAgICAgICAgc2VjdXJlOiBvcHRpb25zICYmIG9wdGlvbnMuc2VjdXJlICE9PSB1bmRlZmluZWQgPyAgb3B0aW9ucy5zZWN1cmUgOiBDb29raWVzLmRlZmF1bHRzLnNlY3VyZVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2lzVmFsaWREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09PSAnW29iamVjdCBEYXRlXScgJiYgIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5fZ2V0RXhwaXJlc0RhdGUgPSBmdW5jdGlvbiAoZXhwaXJlcywgbm93KSB7XHJcbiAgICAgICAgbm93ID0gbm93IHx8IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgZXhwaXJlcykge1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOiBleHBpcmVzID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIGV4cGlyZXMgKiAxMDAwKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IGV4cGlyZXMgPSBuZXcgRGF0ZShleHBpcmVzKTsgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXhwaXJlcyAmJiAhQ29va2llcy5faXNWYWxpZERhdGUoZXhwaXJlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZXhwaXJlc2AgcGFyYW1ldGVyIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSB2YWxpZCBEYXRlIGluc3RhbmNlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXhwaXJlcztcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5fZ2VuZXJhdGVDb29raWVTdHJpbmcgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGtleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlICsgJycpLnJlcGxhY2UoL1teISMkJi0rXFwtLTo8LVxcW1xcXS1+XS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICB2YXIgY29va2llU3RyaW5nID0ga2V5ICsgJz0nICsgdmFsdWU7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMucGF0aCA/ICc7cGF0aD0nICsgb3B0aW9ucy5wYXRoIDogJyc7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMuZG9tYWluID8gJztkb21haW49JyArIG9wdGlvbnMuZG9tYWluIDogJyc7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMuZXhwaXJlcyA/ICc7ZXhwaXJlcz0nICsgb3B0aW9ucy5leHBpcmVzLnRvR01UU3RyaW5nKCkgOiAnJztcclxuICAgICAgICBjb29raWVTdHJpbmcgKz0gb3B0aW9ucy5zZWN1cmUgPyAnO3NlY3VyZScgOiAnJztcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvb2tpZVN0cmluZztcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5fZ2V0Q29va2llT2JqZWN0RnJvbVN0cmluZyA9IGZ1bmN0aW9uIChkb2N1bWVudENvb2tpZSkge1xyXG4gICAgICAgIHZhciBjb29raWVPYmplY3QgPSB7fTtcclxuICAgICAgICB2YXIgY29va2llc0FycmF5ID0gZG9jdW1lbnRDb29raWUgPyBkb2N1bWVudENvb2tpZS5zcGxpdCgnOyAnKSA6IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29va2llS3ZwID0gQ29va2llcy5fZ2V0S2V5VmFsdWVQYWlyRnJvbUNvb2tpZVN0cmluZyhjb29raWVzQXJyYXlbaV0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvb2tpZU9iamVjdFtjb29raWVLdnAua2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb29raWVPYmplY3RbY29va2llS3ZwLmtleV0gPSBjb29raWVLdnAudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb29raWVPYmplY3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dldEtleVZhbHVlUGFpckZyb21Db29raWVTdHJpbmcgPSBmdW5jdGlvbiAoY29va2llU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gXCI9XCIgaXMgYSB2YWxpZCBjaGFyYWN0ZXIgaW4gYSBjb29raWUgdmFsdWUgYWNjb3JkaW5nIHRvIFJGQzYyNjUsIHNvIGNhbm5vdCBgc3BsaXQoJz0nKWBcclxuICAgICAgICB2YXIgc2VwYXJhdG9ySW5kZXggPSBjb29raWVTdHJpbmcuaW5kZXhPZignPScpO1xyXG5cclxuICAgICAgICAvLyBJRSBvbWl0cyB0aGUgXCI9XCIgd2hlbiB0aGUgY29va2llIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgIHNlcGFyYXRvckluZGV4ID0gc2VwYXJhdG9ySW5kZXggPCAwID8gY29va2llU3RyaW5nLmxlbmd0aCA6IHNlcGFyYXRvckluZGV4O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXk6IGRlY29kZVVSSUNvbXBvbmVudChjb29raWVTdHJpbmcuc3Vic3RyKDAsIHNlcGFyYXRvckluZGV4KSksXHJcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQoY29va2llU3RyaW5nLnN1YnN0cihzZXBhcmF0b3JJbmRleCArIDEpKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX3JlbmV3Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgQ29va2llcy5fY2FjaGUgPSBDb29raWVzLl9nZXRDb29raWVPYmplY3RGcm9tU3RyaW5nKENvb2tpZXMuX2RvY3VtZW50LmNvb2tpZSk7XHJcbiAgICAgICAgQ29va2llcy5fY2FjaGVkRG9jdW1lbnRDb29raWUgPSBDb29raWVzLl9kb2N1bWVudC5jb29raWU7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2FyZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvb2tpZXMuX25hdmlnYXRvci5jb29raWVFbmFibGVkIHx8XHJcbiAgICAgICAgICAgIENvb2tpZXMuc2V0KCdjb29raWVzLmpzJywgMSkuZ2V0KCdjb29raWVzLmpzJykgPT09ICcxJztcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5lbmFibGVkID0gQ29va2llcy5fYXJlRW5hYmxlZCgpO1xyXG5cclxuICAgIC8vIEFNRCBzdXBwb3J0XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvb2tpZXM7IH0pO1xyXG4gICAgLy8gQ29tbW9uSlMgYW5kIE5vZGUuanMgbW9kdWxlIHN1cHBvcnQuXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFN1cHBvcnQgTm9kZS5qcyBzcGVjaWZpYyBgbW9kdWxlLmV4cG9ydHNgICh3aGljaCBjYW4gYmUgYSBmdW5jdGlvbilcclxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29va2llcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnV0IGFsd2F5cyBzdXBwb3J0IENvbW1vbkpTIG1vZHVsZSAxLjEuMSBzcGVjIChgZXhwb3J0c2AgY2Fubm90IGJlIGEgZnVuY3Rpb24pXHJcbiAgICAgICAgZXhwb3J0cy5Db29raWVzID0gQ29va2llcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2luZG93LkNvb2tpZXMgPSBDb29raWVzO1xyXG4gICAgfVxyXG59KSgpOyIsIi8qXG4gICAgaHR0cDovL3d3dy5KU09OLm9yZy9qc29uMi5qc1xuICAgIDIwMTEtMDItMjNcblxuICAgIFB1YmxpYyBEb21haW4uXG5cbiAgICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG5cbiAgICBTZWUgaHR0cDovL3d3dy5KU09OLm9yZy9qcy5odG1sXG5cblxuICAgIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4gICAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4gICAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbiAgICBOT1QgQ09OVFJPTC5cblxuXG4gICAgVGhpcyBmaWxlIGNyZWF0ZXMgYSBnbG9iYWwgSlNPTiBvYmplY3QgY29udGFpbmluZyB0d28gbWV0aG9kczogc3RyaW5naWZ5XG4gICAgYW5kIHBhcnNlLlxuXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG5cbiAgICAgICAgICAgIHJlcGxhY2VyICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRldGVybWluZXMgaG93IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFyZSBzdHJpbmdpZmllZCBmb3Igb2JqZWN0cy4gSXQgY2FuIGJlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG5cbiAgICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzICdcXHQnIG9yICcmbmJzcDsnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHByb2R1Y2VzIGEgSlNPTiB0ZXh0IGZyb20gYSBKYXZhU2NyaXB0IHZhbHVlLlxuXG4gICAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuICAgICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbiAgICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuICAgICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4gICAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWVcblxuICAgICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWic7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4gICAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4gICAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbiAgICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbiAgICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4gICAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4gICAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuICAgICAgICAgICAgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuICAgICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbiAgICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuICAgICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuICAgICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbiAgICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbiAgICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4gICAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXFxuXFx0XCJlXCIsXFxuXFx0e1xcblxcdFxcdFwicGx1cmlidXNcIjogXCJ1bnVtXCJcXG5cXHR9XFxuXSdcblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtuZXcgRGF0ZSgpXSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgICAgICAgICAgICAgICdEYXRlKCcgKyB0aGlzW2tleV0gKyAnKScgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG5cbiAgICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuICAgICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4gICAgICAgICAgICB0cmFuc2Zvcm0gdGhlIHJlc3VsdHMuIEl0IHJlY2VpdmVzIGVhY2ggb2YgdGhlIGtleXMgYW5kIHZhbHVlcyxcbiAgICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHVuZGVmaW5lZCB0aGVuIHRoZSBtZW1iZXIgaXMgZGVsZXRlZC5cblxuICAgICAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIGNvbnZlcnRlZCB0byBEYXRlIG9iamVjdHMuXG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhID1cbi9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgNSkgPT09ICdEYXRlKCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4gICAgcmVkaXN0cmlidXRlLlxuKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgcmVnZXhwOiBmYWxzZSAqL1xuXG4vKm1lbWJlcnMgXCJcIiwgXCJcXGJcIiwgXCJcXHRcIiwgXCJcXG5cIiwgXCJcXGZcIiwgXCJcXHJcIiwgXCJcXFwiXCIsIEpTT04sIFwiXFxcXFwiLCBhcHBseSxcbiAgICBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxudmFyIEpTT047XG5pZiAoIUpTT04pIHtcbiAgICBKU09OID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICAgICAgLCBKU09OID0gZ2xvYmFsLkpTT05cbiAgICAgIDtcblxuICAgIGlmICghSlNPTikge1xuICAgICAgSlNPTiA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICAgKyAnLScgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWicgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUudG9KU09OICAgICAgPVxuICAgICAgICAgICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gID1cbiAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBnYXAsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbi8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgICAgICBwYXJ0aWFsLFxuICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICB9XG5cbi8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4vLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcblxuLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4vLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuLy8gbnVsbC5cblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbi8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gJyc7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbi8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICAgICAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgSlNPTi5wYXJzZSA9IGZ1bmN0aW9uICh0ZXh0LCByZXZpdmVyKSB7XG5cbi8vIFRoZSBwYXJzZSBtZXRob2QgdGFrZXMgYSB0ZXh0IGFuZCBhbiBvcHRpb25hbCByZXZpdmVyIGZ1bmN0aW9uLCBhbmQgcmV0dXJuc1xuLy8gYSBKYXZhU2NyaXB0IHZhbHVlIGlmIHRoZSB0ZXh0IGlzIGEgdmFsaWQgSlNPTiB0ZXh0LlxuXG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuXG4vLyBUaGUgd2FsayBtZXRob2QgaXMgdXNlZCB0byByZWN1cnNpdmVseSB3YWxrIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlIHNvXG4vLyB0aGF0IG1vZGlmaWNhdGlvbnMgY2FuIGJlIG1hZGUuXG5cbiAgICAgICAgICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGN4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGN4LCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCAnKCknIGFuZCAnbmV3J1xuLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgJz0nIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoICdAJyAoYSBub24tSlNPTiBjaGFyYWN0ZXIpLiBTZWNvbmQsIHdlXG4vLyByZXBsYWNlIGFsbCBzaW1wbGUgdmFsdWUgdG9rZW5zIHdpdGggJ10nIGNoYXJhY3RlcnMuIFRoaXJkLCB3ZSBkZWxldGUgYWxsXG4vLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbi8vIHdlIGxvb2sgdG8gc2VlIHRoYXQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFyZSBvbmx5IHdoaXRlc3BhY2Ugb3IgJ10nIG9yXG4vLyAnLCcgb3IgJzonIG9yICd7JyBvciAnfScuIElmIHRoYXQgaXMgc28sIHRoZW4gdGhlIHRleHQgaXMgc2FmZSBmb3IgZXZhbC5cblxuICAgICAgICAgICAgaWYgKC9eW1xcXSw6e31cXHNdKiQvXG4gICAgICAgICAgICAgICAgICAgIC50ZXN0KHRleHQucmVwbGFjZSgvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csICddJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZywgJycpKSkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlICd7JyBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuLy8gaW4gSmF2YVNjcmlwdDogaXQgY2FuIGJlZ2luIGEgYmxvY2sgb3IgYW4gb2JqZWN0IGxpdGVyYWwuIFdlIHdyYXAgdGhlIHRleHRcbi8vIGluIHBhcmVucyB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eS5cblxuICAgICAgICAgICAgICAgIGogPSBldmFsKCcoJyArIHRleHQgKyAnKScpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgd2Fsayh7Jyc6IGp9LCAnJykgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSlNPTi5wYXJzZScpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdsb2JhbC5KU09OID0gSlNPTjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEpTT047XG59KCkpO1xuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuLy8gICAgIHV1aWQuanNcbi8vXG4vLyAgICAgQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZSAtIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcbiAgdmFyIF9ybmc7XG5cbiAgLy8gTm9kZS5qcyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL25vZGVqcy5vcmcvZG9jcy92MC42LjIvYXBpL2NyeXB0by5odG1sXG4gIC8vXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIGlmICh0eXBlb2YocmVxdWlyZSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3JiID0gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgICBfcm5nID0gX3JiICYmIGZ1bmN0aW9uKCkge3JldHVybiBfcmIoMTYpO307XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKCFfcm5nICYmIF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgICAvL1xuICAgIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gICAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgICAgcmV0dXJuIF9ybmRzODtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFfcm5nKSB7XG4gICAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAgIC8vXG4gICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgICAvLyBxdWFsaXR5LlxuICAgIHZhciAgX3JuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgICAgX3JuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcm5kcztcbiAgICB9O1xuICB9XG5cbiAgLy8gQnVmZmVyIGNsYXNzIHRvIHVzZVxuICB2YXIgQnVmZmVyQ2xhc3MgPSB0eXBlb2YoQnVmZmVyKSA9PSAnZnVuY3Rpb24nID8gQnVmZmVyIDogQXJyYXk7XG5cbiAgLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbiAgdmFyIF9ieXRlVG9IZXggPSBbXTtcbiAgdmFyIF9oZXhUb0J5dGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIF9ieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICAgIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xuICB9XG5cbiAgLy8gKipgcGFyc2UoKWAgLSBQYXJzZSBhIFVVSUQgaW50byBpdCdzIGNvbXBvbmVudCBieXRlcyoqXG4gIGZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAoYnVmICYmIG9mZnNldCkgfHwgMCwgaWkgPSAwO1xuXG4gICAgYnVmID0gYnVmIHx8IFtdO1xuICAgIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbihvY3QpIHtcbiAgICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgICB3aGlsZSAoaWkgPCAxNikge1xuICAgICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIC8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuICBmdW5jdGlvbiB1bnBhcnNlKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgICByZXR1cm4gIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xuICB9XG5cbiAgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuICAvL1xuICAvLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuICAvLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG4gIC8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG4gIHZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4gIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICB2YXIgX25vZGVJZCA9IFtcbiAgICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXG4gIF07XG5cbiAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgdmFyIF9jbG9ja3NlcSA9IChfc2VlZEJ5dGVzWzZdIDw8IDggfCBfc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcblxuICAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbiAgdmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT0gbnVsbCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAgIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gICAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gICAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9IG51bGwgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gICAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9IG51bGwgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gICAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAgIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgICAvLyB0aW1lIGludGVydmFsXG4gICAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09IG51bGwpIHtcbiAgICAgIG5zZWNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gICAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgICB9XG5cbiAgICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gICAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gICAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gICAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgICAvLyBgdGltZV9sb3dgXG4gICAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICAgIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfbWlkYFxuICAgIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAgIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICAgIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAgIC8vIGBjbG9ja19zZXFfbG93YFxuICAgIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAgIC8vIGBub2RlYFxuICAgIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbiAgfVxuXG4gIC8vICoqYHY0KClgIC0gR2VuZXJhdGUgcmFuZG9tIFVVSUQqKlxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICAvLyBEZXByZWNhdGVkIC0gJ2Zvcm1hdCcgYXJndW1lbnQsIGFzIHN1cHBvcnRlZCBpbiB2MS4yXG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEJ1ZmZlckNsYXNzKDE2KSA6IG51bGw7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gICAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICAgIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgICBpZiAoYnVmKSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmIHx8IHVucGFyc2Uocm5kcyk7XG4gIH1cblxuICAvLyBFeHBvcnQgcHVibGljIEFQSVxuICB2YXIgdXVpZCA9IHY0O1xuICB1dWlkLnYxID0gdjE7XG4gIHV1aWQudjQgPSB2NDtcbiAgdXVpZC5wYXJzZSA9IHBhcnNlO1xuICB1dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuICB1dWlkLkJ1ZmZlckNsYXNzID0gQnVmZmVyQ2xhc3M7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFB1Ymxpc2ggYXMgQU1EIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gdXVpZDt9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YobW9kdWxlKSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIFB1Ymxpc2ggYXMgbm9kZS5qcyBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVibGlzaCBhcyBnbG9iYWwgKGluIGJyb3dzZXJzKVxuICAgIHZhciBfcHJldmlvdXNSb290ID0gX2dsb2JhbC51dWlkO1xuXG4gICAgLy8gKipgbm9Db25mbGljdCgpYCAtIChicm93c2VyIG9ubHkpIHRvIHJlc2V0IGdsb2JhbCAndXVpZCcgdmFyKipcbiAgICB1dWlkLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9nbG9iYWwudXVpZCA9IF9wcmV2aW91c1Jvb3Q7XG4gICAgICByZXR1cm4gdXVpZDtcbiAgICB9O1xuXG4gICAgX2dsb2JhbC51dWlkID0gdXVpZDtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIi8qIVxuICAqIFJlcXdlc3QhIEEgZ2VuZXJhbCBwdXJwb3NlIFhIUiBjb25uZWN0aW9uIG1hbmFnZXJcbiAgKiBsaWNlbnNlIE1JVCAoYykgRHVzdGluIERpYXogMjAxNFxuICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvcmVxd2VzdFxuICAqL1xuXG4hZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSBjb250ZXh0W25hbWVdID0gZGVmaW5pdGlvbigpXG59KCdyZXF3ZXN0JywgdGhpcywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciB3aW4gPSB3aW5kb3dcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCB0d29IdW5kbyA9IC9eKDIwXFxkfDEyMjMpJC9cbiAgICAsIGJ5VGFnID0gJ2dldEVsZW1lbnRzQnlUYWdOYW1lJ1xuICAgICwgcmVhZHlTdGF0ZSA9ICdyZWFkeVN0YXRlJ1xuICAgICwgY29udGVudFR5cGUgPSAnQ29udGVudC1UeXBlJ1xuICAgICwgcmVxdWVzdGVkV2l0aCA9ICdYLVJlcXVlc3RlZC1XaXRoJ1xuICAgICwgaGVhZCA9IGRvY1tieVRhZ10oJ2hlYWQnKVswXVxuICAgICwgdW5pcWlkID0gMFxuICAgICwgY2FsbGJhY2tQcmVmaXggPSAncmVxd2VzdF8nICsgKCtuZXcgRGF0ZSgpKVxuICAgICwgbGFzdFZhbHVlIC8vIGRhdGEgc3RvcmVkIGJ5IHRoZSBtb3N0IHJlY2VudCBKU09OUCBjYWxsYmFja1xuICAgICwgeG1sSHR0cFJlcXVlc3QgPSAnWE1MSHR0cFJlcXVlc3QnXG4gICAgLCB4RG9tYWluUmVxdWVzdCA9ICdYRG9tYWluUmVxdWVzdCdcbiAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4gICAgLCBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IEFycmF5LmlzQXJyYXlcbiAgICAgICAgOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgIH1cblxuICAgICwgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgICAgJ2NvbnRlbnRUeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgICAgICAgLCAncmVxdWVzdGVkV2l0aCc6IHhtbEh0dHBSZXF1ZXN0XG4gICAgICAgICwgJ2FjY2VwdCc6IHtcbiAgICAgICAgICAgICAgJyonOiAgJ3RleHQvamF2YXNjcmlwdCwgdGV4dC9odG1sLCBhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sLCAqLyonXG4gICAgICAgICAgICAsICd4bWwnOiAgJ2FwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwnXG4gICAgICAgICAgICAsICdodG1sJzogJ3RleHQvaHRtbCdcbiAgICAgICAgICAgICwgJ3RleHQnOiAndGV4dC9wbGFpbidcbiAgICAgICAgICAgICwgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgLCAnanMnOiAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLCB4aHIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIC8vIGlzIGl0IHgtZG9tYWluXG4gICAgICAgIGlmIChvWydjcm9zc09yaWdpbiddID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHhociA9IHdpblt4bWxIdHRwUmVxdWVzdF0gPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG51bGxcbiAgICAgICAgICBpZiAoeGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgcmV0dXJuIHhoclxuICAgICAgICAgIH0gZWxzZSBpZiAod2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGNyb3NzLW9yaWdpbiByZXF1ZXN0cycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdpblt4bWxIdHRwUmVxdWVzdF0pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICwgZ2xvYmFsU2V0dXBPcHRpb25zID0ge1xuICAgICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgIH1cbiAgICAgIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZWFkeVN0YXRlKHIsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHVzZSBfYWJvcnRlZCB0byBtaXRpZ2F0ZSBhZ2FpbnN0IElFIGVyciBjMDBjMDIzZlxuICAgICAgLy8gKGNhbid0IHJlYWQgcHJvcHMgb24gYWJvcnRlZCByZXF1ZXN0IG9iamVjdHMpXG4gICAgICBpZiAoci5fYWJvcnRlZCkgcmV0dXJuIGVycm9yKHIucmVxdWVzdClcbiAgICAgIGlmIChyLnJlcXVlc3QgJiYgci5yZXF1ZXN0W3JlYWR5U3RhdGVdID09IDQpIHtcbiAgICAgICAgci5yZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG5vb3BcbiAgICAgICAgaWYgKHR3b0h1bmRvLnRlc3Qoci5yZXF1ZXN0LnN0YXR1cykpIHN1Y2Nlc3Moci5yZXF1ZXN0KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZXJyb3Ioci5yZXF1ZXN0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEhlYWRlcnMoaHR0cCwgbykge1xuICAgIHZhciBoZWFkZXJzID0gb1snaGVhZGVycyddIHx8IHt9XG4gICAgICAsIGhcblxuICAgIGhlYWRlcnNbJ0FjY2VwdCddID0gaGVhZGVyc1snQWNjZXB0J11cbiAgICAgIHx8IGRlZmF1bHRIZWFkZXJzWydhY2NlcHQnXVtvWyd0eXBlJ11dXG4gICAgICB8fCBkZWZhdWx0SGVhZGVyc1snYWNjZXB0J11bJyonXVxuXG4gICAgLy8gYnJlYWtzIGNyb3NzLW9yaWdpbiByZXF1ZXN0cyB3aXRoIGxlZ2FjeSBicm93c2Vyc1xuICAgIGlmICghb1snY3Jvc3NPcmlnaW4nXSAmJiAhaGVhZGVyc1tyZXF1ZXN0ZWRXaXRoXSkgaGVhZGVyc1tyZXF1ZXN0ZWRXaXRoXSA9IGRlZmF1bHRIZWFkZXJzWydyZXF1ZXN0ZWRXaXRoJ11cbiAgICBpZiAoIWhlYWRlcnNbY29udGVudFR5cGVdKSBoZWFkZXJzW2NvbnRlbnRUeXBlXSA9IG9bJ2NvbnRlbnRUeXBlJ10gfHwgZGVmYXVsdEhlYWRlcnNbJ2NvbnRlbnRUeXBlJ11cbiAgICBmb3IgKGggaW4gaGVhZGVycylcbiAgICAgIGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaCkgJiYgJ3NldFJlcXVlc3RIZWFkZXInIGluIGh0dHAgJiYgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDcmVkZW50aWFscyhodHRwLCBvKSB7XG4gICAgaWYgKHR5cGVvZiBvWyd3aXRoQ3JlZGVudGlhbHMnXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGh0dHAud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaHR0cC53aXRoQ3JlZGVudGlhbHMgPSAhIW9bJ3dpdGhDcmVkZW50aWFscyddXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhbENhbGxiYWNrKGRhdGEpIHtcbiAgICBsYXN0VmFsdWUgPSBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiB1cmxhcHBlbmQgKHVybCwgcykge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybCkge1xuICAgIHZhciByZXFJZCA9IHVuaXFpZCsrXG4gICAgICAsIGNia2V5ID0gb1snanNvbnBDYWxsYmFjayddIHx8ICdjYWxsYmFjaycgLy8gdGhlICdjYWxsYmFjaycga2V5XG4gICAgICAsIGNidmFsID0gb1snanNvbnBDYWxsYmFja05hbWUnXSB8fCByZXF3ZXN0LmdldGNhbGxiYWNrUHJlZml4KHJlcUlkKVxuICAgICAgLCBjYnJlZyA9IG5ldyBSZWdFeHAoJygoXnxcXFxcP3wmKScgKyBjYmtleSArICcpPShbXiZdKyknKVxuICAgICAgLCBtYXRjaCA9IHVybC5tYXRjaChjYnJlZylcbiAgICAgICwgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAsIGxvYWRlZCA9IDBcbiAgICAgICwgaXNJRTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFIDEwLjAnKSAhPT0gLTFcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgaWYgKG1hdGNoWzNdID09PSAnPycpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoY2JyZWcsICckMT0nICsgY2J2YWwpIC8vIHdpbGRjYXJkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2J2YWwgPSBtYXRjaFszXSAvLyBwcm92aWRlZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgY2JrZXkgKyAnPScgKyBjYnZhbCkgLy8gbm8gY2FsbGJhY2sgZGV0YWlscywgYWRkICdlbVxuICAgIH1cblxuICAgIHdpbltjYnZhbF0gPSBnZW5lcmFsQ2FsbGJhY2tcblxuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBzY3JpcHQuc3JjID0gdXJsXG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZVxuICAgIGlmICh0eXBlb2Ygc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSUUxMCkge1xuICAgICAgLy8gbmVlZCB0aGlzIGZvciBJRSBkdWUgdG8gb3V0LW9mLW9yZGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSgpLCBiaW5kaW5nIHNjcmlwdFxuICAgICAgLy8gZXhlY3V0aW9uIHRvIGFuIGV2ZW50IGxpc3RlbmVyIGdpdmVzIHVzIGNvbnRyb2wgb3ZlciB3aGVuIHRoZSBzY3JpcHRcbiAgICAgIC8vIGlzIGV4ZWN1dGVkLiBTZWUgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZCA9ICdfcmVxd2VzdF8nICsgcmVxSWRcbiAgICB9XG5cbiAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgoc2NyaXB0W3JlYWR5U3RhdGVdICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2NvbXBsZXRlJyAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdsb2FkZWQnKSB8fCBsb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgIHNjcmlwdC5vbmNsaWNrICYmIHNjcmlwdC5vbmNsaWNrKClcbiAgICAgIC8vIENhbGwgdGhlIHVzZXIgY2FsbGJhY2sgd2l0aCB0aGUgbGFzdCB2YWx1ZSBzdG9yZWQgYW5kIGNsZWFuIHVwIHZhbHVlcyBhbmQgc2NyaXB0cy5cbiAgICAgIGZuKGxhc3RWYWx1ZSlcbiAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgICBsb2FkZWQgPSAxXG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBzY3JpcHQgdG8gdGhlIERPTSBoZWFkXG4gICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cbiAgICAvLyBFbmFibGUgSlNPTlAgdGltZW91dFxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgICAgZXJyKHt9LCAnUmVxdWVzdCBpcyBhYm9ydGVkOiB0aW1lb3V0Jywge30pXG4gICAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICAgICAgbG9hZGVkID0gMVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlcXVlc3QoZm4sIGVycikge1xuICAgIHZhciBvID0gdGhpcy5vXG4gICAgICAsIG1ldGhvZCA9IChvWydtZXRob2QnXSB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuICAgICAgLCB1cmwgPSB0eXBlb2YgbyA9PT0gJ3N0cmluZycgPyBvIDogb1sndXJsJ11cbiAgICAgIC8vIGNvbnZlcnQgbm9uLXN0cmluZyBvYmplY3RzIHRvIHF1ZXJ5LXN0cmluZyBmb3JtIHVubGVzcyBvWydwcm9jZXNzRGF0YSddIGlzIGZhbHNlXG4gICAgICAsIGRhdGEgPSAob1sncHJvY2Vzc0RhdGEnXSAhPT0gZmFsc2UgJiYgb1snZGF0YSddICYmIHR5cGVvZiBvWydkYXRhJ10gIT09ICdzdHJpbmcnKVxuICAgICAgICA/IHJlcXdlc3QudG9RdWVyeVN0cmluZyhvWydkYXRhJ10pXG4gICAgICAgIDogKG9bJ2RhdGEnXSB8fCBudWxsKVxuICAgICAgLCBodHRwXG4gICAgICAsIHNlbmRXYWl0ID0gZmFsc2VcblxuICAgIC8vIGlmIHdlJ3JlIHdvcmtpbmcgb24gYSBHRVQgcmVxdWVzdCBhbmQgd2UgaGF2ZSBkYXRhIHRoZW4gd2Ugc2hvdWxkIGFwcGVuZFxuICAgIC8vIHF1ZXJ5IHN0cmluZyB0byBlbmQgb2YgVVJMIGFuZCBub3QgcG9zdCBkYXRhXG4gICAgaWYgKChvWyd0eXBlJ10gPT0gJ2pzb25wJyB8fCBtZXRob2QgPT0gJ0dFVCcpICYmIGRhdGEpIHtcbiAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGRhdGEpXG4gICAgICBkYXRhID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChvWyd0eXBlJ10gPT0gJ2pzb25wJykgcmV0dXJuIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybClcblxuICAgIC8vIGdldCB0aGUgeGhyIGZyb20gdGhlIGZhY3RvcnkgaWYgcGFzc2VkXG4gICAgLy8gaWYgdGhlIGZhY3RvcnkgcmV0dXJucyBudWxsLCBmYWxsLWJhY2sgdG8gb3Vyc1xuICAgIGh0dHAgPSAoby54aHIgJiYgby54aHIobykpIHx8IHhocihvKVxuXG4gICAgaHR0cC5vcGVuKG1ldGhvZCwgdXJsLCBvWydhc3luYyddID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSlcbiAgICBzZXRIZWFkZXJzKGh0dHAsIG8pXG4gICAgc2V0Q3JlZGVudGlhbHMoaHR0cCwgbylcbiAgICBpZiAod2luW3hEb21haW5SZXF1ZXN0XSAmJiBodHRwIGluc3RhbmNlb2Ygd2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICBodHRwLm9ubG9hZCA9IGZuXG4gICAgICAgIGh0dHAub25lcnJvciA9IGVyclxuICAgICAgICAvLyBOT1RFOiBzZWVcbiAgICAgICAgLy8gaHR0cDovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL2lld2ViZGV2ZWxvcG1lbnQvdGhyZWFkLzMwZWYzYWRkLTc2N2MtNDQzNi1iOGE5LWYxY2ExOWI0ODEyZVxuICAgICAgICBodHRwLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9XG4gICAgICAgIHNlbmRXYWl0ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZVJlYWR5U3RhdGUodGhpcywgZm4sIGVycilcbiAgICB9XG4gICAgb1snYmVmb3JlJ10gJiYgb1snYmVmb3JlJ10oaHR0cClcbiAgICBpZiAoc2VuZFdhaXQpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICAgIH0sIDIwMClcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cC5zZW5kKGRhdGEpXG4gICAgfVxuICAgIHJldHVybiBodHRwXG4gIH1cblxuICBmdW5jdGlvbiBSZXF3ZXN0KG8sIGZuKSB7XG4gICAgdGhpcy5vID0gb1xuICAgIHRoaXMuZm4gPSBmblxuXG4gICAgaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUeXBlKGhlYWRlcikge1xuICAgIC8vIGpzb24sIGphdmFzY3JpcHQsIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgeG1sXG4gICAgaWYgKGhlYWRlci5tYXRjaCgnanNvbicpKSByZXR1cm4gJ2pzb24nXG4gICAgaWYgKGhlYWRlci5tYXRjaCgnamF2YXNjcmlwdCcpKSByZXR1cm4gJ2pzJ1xuICAgIGlmIChoZWFkZXIubWF0Y2goJ3RleHQnKSkgcmV0dXJuICdodG1sJ1xuICAgIGlmIChoZWFkZXIubWF0Y2goJ3htbCcpKSByZXR1cm4gJ3htbCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQobywgZm4pIHtcblxuICAgIHRoaXMudXJsID0gdHlwZW9mIG8gPT0gJ3N0cmluZycgPyBvIDogb1sndXJsJ11cbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG5cbiAgICAvLyB3aGV0aGVyIHJlcXVlc3QgaGFzIGJlZW4gZnVsZmlsbGVkIGZvciBwdXJwb3NlXG4gICAgLy8gb2YgdHJhY2tpbmcgdGhlIFByb21pc2VzXG4gICAgdGhpcy5fZnVsZmlsbGVkID0gZmFsc2VcbiAgICAvLyBzdWNjZXNzIGhhbmRsZXJzXG4gICAgdGhpcy5fc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbigpe31cbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJzID0gW11cbiAgICAvLyBlcnJvciBoYW5kbGVyc1xuICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMgPSBbXVxuICAgIC8vIGNvbXBsZXRlIChib3RoIHN1Y2Nlc3MgYW5kIGZhaWwpIGhhbmRsZXJzXG4gICAgdGhpcy5fY29tcGxldGVIYW5kbGVycyA9IFtdXG4gICAgdGhpcy5fZXJyZWQgPSBmYWxzZVxuICAgIHRoaXMuX3Jlc3BvbnNlQXJncyA9IHt9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIGZuID0gZm4gfHwgZnVuY3Rpb24gKCkge31cblxuICAgIGlmIChvWyd0aW1lb3V0J10pIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmFib3J0KClcbiAgICAgIH0sIG9bJ3RpbWVvdXQnXSlcbiAgICB9XG5cbiAgICBpZiAob1snc3VjY2VzcyddKSB7XG4gICAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snc3VjY2VzcyddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob1snZXJyb3InXSkge1xuICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snZXJyb3InXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvWydjb21wbGV0ZSddKSB7XG4gICAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydjb21wbGV0ZSddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUgKHJlc3ApIHtcbiAgICAgIG9bJ3RpbWVvdXQnXSAmJiBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KVxuICAgICAgc2VsZi50aW1lb3V0ID0gbnVsbFxuICAgICAgd2hpbGUgKHNlbGYuX2NvbXBsZXRlSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9jb21wbGV0ZUhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWNjZXNzIChyZXNwKSB7XG4gICAgICB2YXIgdHlwZSA9IG9bJ3R5cGUnXSB8fCBzZXRUeXBlKHJlc3AuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKVxuICAgICAgcmVzcCA9ICh0eXBlICE9PSAnanNvbnAnKSA/IHNlbGYucmVxdWVzdCA6IHJlc3BcbiAgICAgIC8vIHVzZSBnbG9iYWwgZGF0YSBmaWx0ZXIgb24gcmVzcG9uc2UgdGV4dFxuICAgICAgdmFyIGZpbHRlcmVkUmVzcG9uc2UgPSBnbG9iYWxTZXR1cE9wdGlvbnMuZGF0YUZpbHRlcihyZXNwLnJlc3BvbnNlVGV4dCwgdHlwZSlcbiAgICAgICAgLCByID0gZmlsdGVyZWRSZXNwb25zZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcC5yZXNwb25zZVRleHQgPSByXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGNhbid0IGFzc2lnbiB0aGlzIGluIElFPD04LCBqdXN0IGlnbm9yZVxuICAgICAgfVxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwID0gd2luLkpTT04gPyB3aW4uSlNPTi5wYXJzZShyKSA6IGV2YWwoJygnICsgciArICcpJylcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihyZXNwLCAnQ291bGQgbm90IHBhcnNlIEpTT04gaW4gcmVzcG9uc2UnLCBlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2pzJzpcbiAgICAgICAgICByZXNwID0gZXZhbChyKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgIHJlc3AgPSByXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICByZXNwID0gcmVzcC5yZXNwb25zZVhNTFxuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IgLy8gSUUgdHJvbG9sb1xuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IuZXJyb3JDb2RlXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5yZWFzb25cbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiByZXNwLnJlc3BvbnNlWE1MXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3BcbiAgICAgIHNlbGYuX2Z1bGZpbGxlZCA9IHRydWVcbiAgICAgIGZuKHJlc3ApXG4gICAgICBzZWxmLl9zdWNjZXNzSGFuZGxlcihyZXNwKVxuICAgICAgd2hpbGUgKHNlbGYuX2Z1bGZpbGxtZW50SGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXNwID0gc2VsZi5fZnVsZmlsbG1lbnRIYW5kbGVycy5zaGlmdCgpKHJlc3ApXG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlKHJlc3ApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IocmVzcCwgbXNnLCB0KSB7XG4gICAgICByZXNwID0gc2VsZi5yZXF1ZXN0XG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3BcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5tc2cgPSBtc2dcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy50ID0gdFxuICAgICAgc2VsZi5fZXJyZWQgPSB0cnVlXG4gICAgICB3aGlsZSAoc2VsZi5fZXJyb3JIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuX2Vycm9ySGFuZGxlcnMuc2hpZnQoKShyZXNwLCBtc2csIHQpXG4gICAgICB9XG4gICAgICBjb21wbGV0ZShyZXNwKVxuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdCA9IGdldFJlcXVlc3QuY2FsbCh0aGlzLCBzdWNjZXNzLCBlcnJvcilcbiAgfVxuXG4gIFJlcXdlc3QucHJvdG90eXBlID0ge1xuICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZVxuICAgICAgdGhpcy5yZXF1ZXN0LmFib3J0KClcbiAgICB9XG5cbiAgLCByZXRyeTogZnVuY3Rpb24gKCkge1xuICAgICAgaW5pdC5jYWxsKHRoaXMsIHRoaXMubywgdGhpcy5mbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbWFsbCBkZXZpYXRpb24gZnJvbSB0aGUgUHJvbWlzZXMgQSBDb21tb25KcyBzcGVjaWZpY2F0aW9uXG4gICAgICogaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvUHJvbWlzZXMvQVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogYHRoZW5gIHdpbGwgZXhlY3V0ZSB1cG9uIHN1Y2Nlc3NmdWwgcmVxdWVzdHNcbiAgICAgKi9cbiAgLCB0aGVuOiBmdW5jdGlvbiAoc3VjY2VzcywgZmFpbCkge1xuICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgfHwgZnVuY3Rpb24gKCkge31cbiAgICAgIGZhaWwgPSBmYWlsIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgICBpZiAodGhpcy5fZnVsZmlsbGVkKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwID0gc3VjY2Vzcyh0aGlzLl9yZXNwb25zZUFyZ3MucmVzcClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZmFpbCh0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCwgdGhpcy5fcmVzcG9uc2VBcmdzLm1zZywgdGhpcy5fcmVzcG9uc2VBcmdzLnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJzLnB1c2goc3VjY2VzcylcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZhaWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBhbHdheXNgIHdpbGwgZXhlY3V0ZSB3aGV0aGVyIHRoZSByZXF1ZXN0IHN1Y2NlZWRzIG9yIGZhaWxzXG4gICAgICovXG4gICwgYWx3YXlzOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLl9mdWxmaWxsZWQgfHwgdGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZm4odGhpcy5fcmVzcG9uc2VBcmdzLnJlc3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzLnB1c2goZm4pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBmYWlsYCB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgcmVxdWVzdCBmYWlsc1xuICAgICAqL1xuICAsIGZhaWw6IGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZuKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwLCB0aGlzLl9yZXNwb25zZUFyZ3MubXNnLCB0aGlzLl9yZXNwb25zZUFyZ3MudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVxd2VzdChvLCBmbikge1xuICAgIHJldHVybiBuZXcgUmVxd2VzdChvLCBmbilcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBuZXdsaW5lIHZhcmlhbnRzIGFjY29yZGluZyB0byBzcGVjIC0+IENSTEZcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHMpIHtcbiAgICByZXR1cm4gcyA/IHMucmVwbGFjZSgvXFxyP1xcbi9nLCAnXFxyXFxuJykgOiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gc2VyaWFsKGVsLCBjYikge1xuICAgIHZhciBuID0gZWwubmFtZVxuICAgICAgLCB0ID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG9wdENiID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAvLyBJRSBnaXZlcyB2YWx1ZT1cIlwiIGV2ZW4gd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUgYXR0cmlidXRlXG4gICAgICAgICAgLy8gJ3NwZWNpZmllZCcgcmVmOiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2NvcmUuaHRtbCNJRC04NjI1MjkyNzNcbiAgICAgICAgICBpZiAobyAmJiAhb1snZGlzYWJsZWQnXSlcbiAgICAgICAgICAgIGNiKG4sIG5vcm1hbGl6ZShvWydhdHRyaWJ1dGVzJ11bJ3ZhbHVlJ10gJiYgb1snYXR0cmlidXRlcyddWyd2YWx1ZSddWydzcGVjaWZpZWQnXSA/IG9bJ3ZhbHVlJ10gOiBvWyd0ZXh0J10pKVxuICAgICAgICB9XG4gICAgICAsIGNoLCByYSwgdmFsLCBpXG5cbiAgICAvLyBkb24ndCBzZXJpYWxpemUgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWJsZWQgb3Igd2l0aG91dCBhIG5hbWVcbiAgICBpZiAoZWwuZGlzYWJsZWQgfHwgIW4pIHJldHVyblxuXG4gICAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaWYgKCEvcmVzZXR8YnV0dG9ufGltYWdlfGZpbGUvaS50ZXN0KGVsLnR5cGUpKSB7XG4gICAgICAgIGNoID0gL2NoZWNrYm94L2kudGVzdChlbC50eXBlKVxuICAgICAgICByYSA9IC9yYWRpby9pLnRlc3QoZWwudHlwZSlcbiAgICAgICAgdmFsID0gZWwudmFsdWVcbiAgICAgICAgLy8gV2ViS2l0IGdpdmVzIHVzIFwiXCIgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSBjaGVja2JveCBoYXMgbm8gdmFsdWUsIHNvIGNvcnJlY3QgaXQgaGVyZVxuICAgICAgICA7KCEoY2ggfHwgcmEpIHx8IGVsLmNoZWNrZWQpICYmIGNiKG4sIG5vcm1hbGl6ZShjaCAmJiB2YWwgPT09ICcnID8gJ29uJyA6IHZhbCkpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGNiKG4sIG5vcm1hbGl6ZShlbC52YWx1ZSkpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpZiAoZWwudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0LW9uZScpIHtcbiAgICAgICAgb3B0Q2IoZWwuc2VsZWN0ZWRJbmRleCA+PSAwID8gZWwub3B0aW9uc1tlbC5zZWxlY3RlZEluZGV4XSA6IG51bGwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBlbC5sZW5ndGggJiYgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWwub3B0aW9uc1tpXS5zZWxlY3RlZCAmJiBvcHRDYihlbC5vcHRpb25zW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbGxlY3QgdXAgYWxsIGZvcm0gZWxlbWVudHMgZm91bmQgZnJvbSB0aGUgcGFzc2VkIGFyZ3VtZW50IGVsZW1lbnRzIGFsbFxuICAvLyB0aGUgd2F5IGRvd24gdG8gY2hpbGQgZWxlbWVudHM7IHBhc3MgYSAnPGZvcm0+JyBvciBmb3JtIGZpZWxkcy5cbiAgLy8gY2FsbGVkIHdpdGggJ3RoaXMnPWNhbGxiYWNrIHRvIHVzZSBmb3Igc2VyaWFsKCkgb24gZWFjaCBlbGVtZW50XG4gIGZ1bmN0aW9uIGVhY2hGb3JtRWxlbWVudCgpIHtcbiAgICB2YXIgY2IgPSB0aGlzXG4gICAgICAsIGUsIGlcbiAgICAgICwgc2VyaWFsaXplU3VidGFncyA9IGZ1bmN0aW9uIChlLCB0YWdzKSB7XG4gICAgICAgICAgdmFyIGksIGosIGZhXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZhID0gZVtieVRhZ10odGFnc1tpXSlcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmYS5sZW5ndGg7IGorKykgc2VyaWFsKGZhW2pdLCBjYilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGUgPSBhcmd1bWVudHNbaV1cbiAgICAgIGlmICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhL2kudGVzdChlLnRhZ05hbWUpKSBzZXJpYWwoZSwgY2IpXG4gICAgICBzZXJpYWxpemVTdWJ0YWdzKGUsIFsgJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScgXSlcbiAgICB9XG4gIH1cblxuICAvLyBzdGFuZGFyZCBxdWVyeSBzdHJpbmcgc3R5bGUgc2VyaWFsaXphdGlvblxuICBmdW5jdGlvbiBzZXJpYWxpemVRdWVyeVN0cmluZygpIHtcbiAgICByZXR1cm4gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKHJlcXdlc3Quc2VyaWFsaXplQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSlcbiAgfVxuXG4gIC8vIHsgJ25hbWUnOiAndmFsdWUnLCAuLi4gfSBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUhhc2goKSB7XG4gICAgdmFyIGhhc2ggPSB7fVxuICAgIGVhY2hGb3JtRWxlbWVudC5hcHBseShmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lIGluIGhhc2gpIHtcbiAgICAgICAgaGFzaFtuYW1lXSAmJiAhaXNBcnJheShoYXNoW25hbWVdKSAmJiAoaGFzaFtuYW1lXSA9IFtoYXNoW25hbWVdXSlcbiAgICAgICAgaGFzaFtuYW1lXS5wdXNoKHZhbHVlKVxuICAgICAgfSBlbHNlIGhhc2hbbmFtZV0gPSB2YWx1ZVxuICAgIH0sIGFyZ3VtZW50cylcbiAgICByZXR1cm4gaGFzaFxuICB9XG5cbiAgLy8gWyB7IG5hbWU6ICduYW1lJywgdmFsdWU6ICd2YWx1ZScgfSwgLi4uIF0gc3R5bGUgc2VyaWFsaXphdGlvblxuICByZXF3ZXN0LnNlcmlhbGl6ZUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnIgPSBbXVxuICAgIGVhY2hGb3JtRWxlbWVudC5hcHBseShmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGFyci5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KVxuICAgIH0sIGFyZ3VtZW50cylcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICByZXF3ZXN0LnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gICAgdmFyIG9wdCwgZm5cbiAgICAgICwgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcblxuICAgIG9wdCA9IGFyZ3MucG9wKClcbiAgICBvcHQgJiYgb3B0Lm5vZGVUeXBlICYmIGFyZ3MucHVzaChvcHQpICYmIChvcHQgPSBudWxsKVxuICAgIG9wdCAmJiAob3B0ID0gb3B0LnR5cGUpXG5cbiAgICBpZiAob3B0ID09ICdtYXAnKSBmbiA9IHNlcmlhbGl6ZUhhc2hcbiAgICBlbHNlIGlmIChvcHQgPT0gJ2FycmF5JykgZm4gPSByZXF3ZXN0LnNlcmlhbGl6ZUFycmF5XG4gICAgZWxzZSBmbiA9IHNlcmlhbGl6ZVF1ZXJ5U3RyaW5nXG5cbiAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncylcbiAgfVxuXG4gIHJlcXdlc3QudG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChvLCB0cmFkKSB7XG4gICAgdmFyIHByZWZpeCwgaVxuICAgICAgLCB0cmFkaXRpb25hbCA9IHRyYWQgfHwgZmFsc2VcbiAgICAgICwgcyA9IFtdXG4gICAgICAsIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudFxuICAgICAgLCBhZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuICAgICAgICAgIHZhbHVlID0gKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZSkgPyB2YWx1ZSgpIDogKHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKVxuICAgICAgICAgIHNbcy5sZW5ndGhdID0gZW5jKGtleSkgKyAnPScgKyBlbmModmFsdWUpXG4gICAgICAgIH1cbiAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgIGlmIChpc0FycmF5KG8pKSB7XG4gICAgICBmb3IgKGkgPSAwOyBvICYmIGkgPCBvLmxlbmd0aDsgaSsrKSBhZGQob1tpXVsnbmFtZSddLCBvW2ldWyd2YWx1ZSddKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICBmb3IgKHByZWZpeCBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KHByZWZpeCkpIGJ1aWxkUGFyYW1zKHByZWZpeCwgb1twcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNwYWNlcyBzaG91bGQgYmUgKyBhY2NvcmRpbmcgdG8gc3BlY1xuICAgIHJldHVybiBzLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRQYXJhbXMocHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQpIHtcbiAgICB2YXIgbmFtZSwgaSwgdlxuICAgICAgLCByYnJhY2tldCA9IC9cXFtcXF0kL1xuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICBmb3IgKGkgPSAwOyBvYmogJiYgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ID0gb2JqW2ldXG4gICAgICAgIGlmICh0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgYWRkKHByZWZpeCwgdilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyAodHlwZW9mIHYgPT09ICdvYmplY3QnID8gaSA6ICcnKSArICddJywgdiwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmIG9iai50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyBuYW1lICsgJ10nLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgYWRkKHByZWZpeCwgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXdlc3QuZ2V0Y2FsbGJhY2tQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrUHJlZml4XG4gIH1cblxuICAvLyBqUXVlcnkgYW5kIFplcHRvIGNvbXBhdGliaWxpdHksIGRpZmZlcmVuY2VzIGNhbiBiZSByZW1hcHBlZCBoZXJlIHNvIHlvdSBjYW4gY2FsbFxuICAvLyAuYWpheC5jb21wYXQob3B0aW9ucywgY2FsbGJhY2spXG4gIHJlcXdlc3QuY29tcGF0ID0gZnVuY3Rpb24gKG8sIGZuKSB7XG4gICAgaWYgKG8pIHtcbiAgICAgIG9bJ3R5cGUnXSAmJiAob1snbWV0aG9kJ10gPSBvWyd0eXBlJ10pICYmIGRlbGV0ZSBvWyd0eXBlJ11cbiAgICAgIG9bJ2RhdGFUeXBlJ10gJiYgKG9bJ3R5cGUnXSA9IG9bJ2RhdGFUeXBlJ10pXG4gICAgICBvWydqc29ucENhbGxiYWNrJ10gJiYgKG9bJ2pzb25wQ2FsbGJhY2tOYW1lJ10gPSBvWydqc29ucENhbGxiYWNrJ10pICYmIGRlbGV0ZSBvWydqc29ucENhbGxiYWNrJ11cbiAgICAgIG9bJ2pzb25wJ10gJiYgKG9bJ2pzb25wQ2FsbGJhY2snXSA9IG9bJ2pzb25wJ10pXG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVxd2VzdChvLCBmbilcbiAgfVxuXG4gIHJlcXdlc3QuYWpheFNldHVwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zW2tdID0gb3B0aW9uc1trXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF3ZXN0XG59KTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIHNmO1xuXG4gIHNmID0gcmVxdWlyZShcIi4vaG9zdC9ob3N0XCIpO1xuXG4gIChmdW5jdGlvbih3aW5kb3csIHNmKSB7XG4gICAgcmV0dXJuIHdpbmRvd1tcIiRzZlwiXSA9IHNmO1xuICB9KSh3aW5kb3csIHNmKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHNmO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKCcuLi9zaGFyZWQvYmFzZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdywgc2YpIHtcbiAgICB2YXIgQVVUT19CT09UX01BWF9SRVRSSUVTLCBTRl9EQVRBVEFHX0NMQVNTLCBTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MsIFNGX1RBR19UWVBFLCBib290LCBib290X3JldHJpZXMsIGQsIGRvaW5nX2F1dG9fYm9vdCwgZG9tLCBoYXNfYm9vdGVkLCBpbmxpbmVfdGFnc19wcm9jZXNzZWQsIGxhbmcsIGxpYiwgd2luLCBfYXR0ciwgX2F1dG9fYm9vdCwgX2NsZWFuX3VwX2Jvb3RlZF90YWdzLCBfY3JlYXRlX3Bvc19tYXJrdXAsIF9jc3RyLCBfZWx0LCBfZ3VpZCwgX2xvZywgX3BhciwgX3B1cmdlLCBfcmVhZHksIF90YWdzO1xuICAgIHdpbiA9IHdpbmRvdyAhPSBudWxsID8gd2luZG93IDogdGhpcztcbiAgICBfbG9nID0gZnVuY3Rpb24obXNnLCBpc19lcnIpIHtcbiAgICAgIHZhciBlcnJfdGFnLCBoZWFkX2VsLCBsaWI7XG4gICAgICB0cnkge1xuICAgICAgICBsaWIgPSBzZi5saWI7XG4gICAgICAgIGlmIChsaWIgJiYgbGliLmxvZ2dlciAmJiB3aW4gPT09IHRvcCkge1xuICAgICAgICAgIGlmIChpc19lcnIpIHtcbiAgICAgICAgICAgIGxpYi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliLmxvZ2dlci5sb2cobXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZF9lbCA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICAgIGVycl90YWcgPSBkLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgZXJyX3RhZy50eXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgICAgZXJyX3RhZy50ZXh0ID0gXCI8IS0tIFNhZmVGcmFtZSBcIiArIChpc19lcnIgPyBcImVycm9yXCIgOiBcImxvZ1wiKSArIFwiOiBcIiArIChtc2cgfHwgXCJ1bmtub3duXCIpICsgXCIgLS0+XCI7XG4gICAgICAgICAgaGVhZF9lbC5hcHBlbmRDaGlsZChoZWFkX2VsLCBlcnJfdGFnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgIH07XG5cbiAgICAvKlxuICAgIENyZWF0ZSB0aGUgSFRNTCBtYXJrdXAgZm9yIGEgcG9zaXRpb24gaWYgYSBzcmMgcHJvcGVydHkgd2FzIHVzZWRcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1fY3JlYXRlX3Bvc19tYXJrdXBcbiAgICBAZnVuY3Rpb25cbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgX2NyZWF0ZV9wb3NfbWFya3VwID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgICByZXR1cm4gX2NzdHIoW1wiPHNjclwiLCBcImlwdCB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnLCBzcmM9J1wiLCBzcmMsIFwiJz48L3NjclwiLCBcImlwdD5cIl0pO1xuICAgIH07XG4gICAgX2F1dG9fYm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbmZpZywgZG9fYXV0bywgZG9pbmdfYXV0b19ib290LCBlLCBoZWFkLCBob3N0X2ZpbGUsIHNjcl90YWcsIHNmX2hvc3Q7XG4gICAgICBkb19hdXRvID0gdHJ1ZTtcbiAgICAgIGNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHNmX2hvc3QgPSB2b2lkIDA7XG4gICAgICBob3N0X2ZpbGUgPSB2b2lkIDA7XG4gICAgICBoZWFkID0gdm9pZCAwO1xuICAgICAgc2NyX3RhZyA9IHZvaWQgMDtcbiAgICAgIGlmIChoYXNfYm9vdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNmX2hvc3QgPSBzZiAmJiBzZi5ob3N0O1xuICAgICAgaWYgKHdpbiA9PT0gdG9wKSB7XG4gICAgICAgIGlmIChzZl9ob3N0ICYmICFzZl9ob3N0LmJvb3QpIHtcbiAgICAgICAgICBzZl9ob3N0LmJvb3QgPSBib290O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uZmlnID0gc2ZfaG9zdCAmJiBzZl9ob3N0LkNvbmZpZygpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGNvbmZpZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uZmlnID0gc2ZfaG9zdCAmJiBzZl9ob3N0LmNvbmY7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgY29uZmlnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgIGlmICgoXCJhdXRvXCIgaW4gY29uZmlnKSAmJiBjb25maWcuYXV0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRvX2F1dG8gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZl9ob3N0LnJlbmRlciB8fCAhc2ZfaG9zdC5Db25maWcpIHtcbiAgICAgICAgICAgIGhvc3RfZmlsZSA9IGNvbmZpZy5ob3N0RmlsZTtcbiAgICAgICAgICAgIGlmIChob3N0X2ZpbGUpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IF90YWdzKFwiaGVhZFwiKVswXTtcbiAgICAgICAgICAgICAgc2NyX3RhZyA9IGRvbS5tYWtlKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICBzY3JfdGFnLmlkID0gXCJzZl9ob3N0X2xpYlwiO1xuICAgICAgICAgICAgICBzY3JfdGFnLnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICAgICAgICAgICAgICBzY3JfdGFnLmNsYXNzTmFtZSA9IFwic2ZfbGliXCI7XG4gICAgICAgICAgICAgIHNjcl90YWcuc3JjID0gaG9zdF9maWxlO1xuICAgICAgICAgICAgICBpZiAod2luLkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBzY3JfdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRvaW5nX2F1dG9fYm9vdCwgcnM7XG4gICAgICAgICAgICAgICAgICBycyA9IHNjcl90YWcucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChycyA9PT0gXCJsb2FkZWRcIiB8fCBycyA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9fYXV0bykge1xuICAgICAgICAgICAgICAgICAgICAgIGJvb3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY3JfdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNjcl90YWcgPSBoZWFkID0gc2ZfaG9zdCA9IGNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JfdGFnLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRvaW5nX2F1dG9fYm9vdDtcbiAgICAgICAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGRvX2F1dG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYm9vdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2NyX3RhZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgc2NyX3RhZyA9IGhlYWQgPSBzZl9ob3N0ID0gY29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IHRydWU7XG4gICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyX3RhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvX2F1dG8pIHtcbiAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBkb2luZ19hdXRvX2Jvb3QgPSB0cnVlO1xuICAgICAgICAgICAgYm9vdCgpO1xuICAgICAgICAgICAgZG9pbmdfYXV0b19ib290ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChib290X3JldHJpZXMrKyA8PSBBVVRPX0JPT1RfTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChfYXV0b19ib290LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib290KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgR28gdGhyb3VnaCBhbmQgcmVtb3ZlIGFueSBpbmxpbmUgc2NyaXB0IHRhZ3MgdGhhdCBhcmUgb3VyIGRhdGEtaXNsYW5kcyAsIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGJvb3N0cmFwcGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2NsZWFuX3VwX2Jvb3RlZF90YWdzXG4gICAgQHByaXZhdGVcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgX2NsZWFuX3VwX2Jvb3RlZF90YWdzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NyaXB0X3RhZywgc2NyaXB0X3RhZ19pZDtcbiAgICAgIHNjcmlwdF90YWdfaWQgPSB2b2lkIDA7XG4gICAgICBzY3JpcHRfdGFnID0gdm9pZCAwO1xuICAgICAgaWYgKGRvbSkge1xuICAgICAgICBmb3IgKHNjcmlwdF90YWdfaWQgaW4gaW5saW5lX3RhZ3NfcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgc2NyaXB0X3RhZyA9IF9lbHQoc2NyaXB0X3RhZ19pZCk7XG4gICAgICAgICAgaWYgKHNjcmlwdF90YWcpIHtcbiAgICAgICAgICAgIF9wdXJnZShzY3JpcHRfdGFnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbmxpbmVfdGFnc19wcm9jZXNzZWRbc2NyaXB0X3RhZ19pZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VhcmNoIGZvciBTYWZlRnJhbWVzIHRhZ3MgYW5kIHJlbmRlciB0aGVtLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgIGF1dG9tYXRpY2FsbHkgd2hlbmV2ZXIgdGhlIFNhZmVGcmFtZXMgcHVibGlzaGVyIGxpYnJhcnkgaXMgbG9hZGVkLiBIb3dldmVyIGEgY29uZmlndXJhdGlvblxuICAgIGNhbiBiZSBhcHBsaWVkIHRvIG5vdCBoYXZlIFNhZmVGcmFtZXMgdGFncyBhdXRvbWF0aWNhbGx5IGJlIHJlbmRlcmVkLCByZXF1aXJpbmcgYSBjb250cm9sbGVkXG4gICAgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LmJvb3RcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgICAqL1xuICAgIGJvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBib290X3Bvc2l0aW9ucywgZGF0YSwgZSwgZXJyLCBlcnJNc2csIGhhc19ib290ZWQsIGh0bWwsIGlkeCwgbGliLCBtZXRhX2tleSwgcG9zX2NvbmYsIHBvc19kZXN0X2VsLCBwb3NfbWV0YSwgcG9zX21ldGFfaXRlbSwgcG9zX29iaiwgcHJ2X21ldGEsIHBydl9tZXRhX2tleSwgcmV0LCBzY3JpcHRfdGFnLCBzY3JpcHRfdGFnX2lkLCBzY3JpcHRfdGFnX3Bhciwgc2NyaXB0X3RhZ3MsIHNmX2NvbmYsIHNmX2hvc3QsIHNmX2lubGluZV9jb25mLCBzZl9vY25mLCBzaGFyZWRfbWV0YSwgdHlwO1xuICAgICAgc2NyaXB0X3RhZ3MgPSAoX3RhZ3MgJiYgX3RhZ3MoXCJzY3JpcHRcIikpIHx8IFtdO1xuICAgICAgYm9vdF9wb3NpdGlvbnMgPSBbXTtcbiAgICAgIGlkeCA9IDA7XG4gICAgICByZXQgPSBmYWxzZTtcbiAgICAgIGVyck1zZyA9IHZvaWQgMDtcbiAgICAgIHNmX2hvc3QgPSBzZiAmJiBzZi5ob3N0O1xuICAgICAgc2ZfaW5saW5lX2NvbmYgPSBzZl9ob3N0ICYmIHNmX2hvc3QuY29uZjtcbiAgICAgIHNjcmlwdF90YWcgPSB2b2lkIDA7XG4gICAgICBzY3JpcHRfdGFnX3BhciA9IHZvaWQgMDtcbiAgICAgIHNjcmlwdF90YWdfaWQgPSB2b2lkIDA7XG4gICAgICBkYXRhID0gdm9pZCAwO1xuICAgICAgaHRtbCA9IHZvaWQgMDtcbiAgICAgIHBvc19vYmogPSB2b2lkIDA7XG4gICAgICBwb3NfY29uZiA9IHZvaWQgMDtcbiAgICAgIHBvc19kZXN0X2VsID0gdm9pZCAwO1xuICAgICAgcG9zX21ldGEgPSB2b2lkIDA7XG4gICAgICBwb3NfbWV0YV9pdGVtID0gdm9pZCAwO1xuICAgICAgdHlwID0gdm9pZCAwO1xuICAgICAgc2hhcmVkX21ldGEgPSB2b2lkIDA7XG4gICAgICBwcnZfbWV0YSA9IHZvaWQgMDtcbiAgICAgIHBydl9tZXRhX2tleSA9IHZvaWQgMDtcbiAgICAgIG1ldGFfa2V5ID0gdm9pZCAwO1xuICAgICAgc2Zfb2NuZiA9IHZvaWQgMDtcbiAgICAgIGVyciA9IHZvaWQgMDtcbiAgICAgIGlmICghc2YgfHwgIWxhbmcgfHwgIWRvbSkge1xuICAgICAgICBfbG9nKFwiU2FmZUZyYW1lIGJhc2UgbGlicmFyeSBub3QgZm91bmRcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBpZiAoIWxpYikge1xuICAgICAgICBsaWIgPSBzZiAmJiBzZi5saWI7XG4gICAgICB9XG4gICAgICBpZiAoZG9pbmdfYXV0b19ib290ICYmIGhhc19ib290ZWQpIHtcbiAgICAgICAgX2xvZyhcIkF1dG9tYXRpYyBib290IGFscmVhZHkgaW52b2tlZFwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW4gPT09IHRvcCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNmX2NvbmYgPSBzZl9ob3N0LkNvbmZpZygpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgc2ZfY29uZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNmX2lubGluZV9jb25mICYmICFzZl9jb25mKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNmX2NvbmYgPSBzZl9ob3N0LkNvbmZpZyhzZl9pbmxpbmVfY29uZik7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgc2ZfY29uZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2ZfY29uZikge1xuICAgICAgICAgIF9sb2coXCJObyBjb25maWd1cmF0aW9uIGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzY3JpcHRfdGFnID0gc2NyaXB0X3RhZ3NbaWR4KytdKSB7XG4gICAgICAgIGlmIChzY3JpcHRfdGFnLmNsYXNzTmFtZSA9PT0gU0ZfREFUQVRBR19DTEFTUyB8fCBfYXR0cihzY3JpcHRfdGFnLCBcInR5cGVcIikgPT09IFNGX1RBR19UWVBFKSB7XG4gICAgICAgICAgaGFzX2Jvb3RlZCA9IHRydWU7XG4gICAgICAgICAgc2NyaXB0X3RhZ19pZCA9IF9hdHRyKHNjcmlwdF90YWcsIFwiaWRcIik7XG4gICAgICAgICAgaWYgKCFzY3JpcHRfdGFnX2lkKSB7XG4gICAgICAgICAgICBzY3JpcHRfdGFnX2lkID0gX2d1aWQoXCJzZl9kYXRhX2VsZW1lbnRcIik7XG4gICAgICAgICAgICBfYXR0cihzY3JpcHRfdGFnLCBcImlkXCIsIHNjcmlwdF90YWdfaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5saW5lX3RhZ3NfcHJvY2Vzc2VkW3NjcmlwdF90YWdfaWRdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YSA9IHNjcmlwdF90YWcudGV4dCB8fCBzY3JpcHRfdGFnLmlubmVySFRNTCB8fCBzY3JpcHRfdGFnLmlubmVyVGV4dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IGxhbmcudHJpbShkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGVyck1zZyA9IFwiRXJyb3IgcGFyc2luZyB0YWcgY29uZmlndXJhdGlvbiBcIiArIChlcnIgJiYgZXJyLm1lc3NhZ2UgfHwgXCJcIik7XG4gICAgICAgICAgICBfbG9nKGVyck1zZywgdHJ1ZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5pZCAmJiAoZGF0YS5odG1sIHx8IGRhdGEuc3JjKSkge1xuICAgICAgICAgICAgaWYgKHdpbiAhPT0gdG9wKSB7XG4gICAgICAgICAgICAgIGh0bWwgPSBkYXRhLmh0bWwgfHwgXCJcIjtcbiAgICAgICAgICAgICAgaHRtbCA9IGh0bWwgfHwgX2NyZWF0ZV9wb3NfbWFya3VwKGRhdGEuc3JjKTtcbiAgICAgICAgICAgICAgaWYgKCFfcmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIGQud3JpdGUoaHRtbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2xvZyhcImNhbm5vdCB3cml0ZSBodG1sIGNvbnRlbnQgaW50byBhbHJlYWR5IGxvYWRlZCBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2NyaXB0X3RhZ19wYXIgPSBfcGFyKHNjcmlwdF90YWcpO1xuICAgICAgICAgICAgICBpZiAoIXNjcmlwdF90YWdfcGFyKSB7XG4gICAgICAgICAgICAgICAgX2xvZyhcImNhbid0IGZpbmQgcGFyZW50IGVsZW1lbnQgZm9yIHNjcmlwdCB0YWdcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zX2NvbmYgPSBzZl9jb25mICYmIHNmX2NvbmYucG9zaXRpb25zW2RhdGEuaWRdO1xuICAgICAgICAgICAgICBpZiAoIXBvc19jb25mKSB7XG4gICAgICAgICAgICAgICAgcG9zX2NvbmYgPSBkYXRhLmNvbmY7XG4gICAgICAgICAgICAgICAgcG9zX2NvbmYuaWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgICAgIGlmIChwb3NfY29uZikge1xuICAgICAgICAgICAgICAgICAgcG9zX2NvbmYgPSBuZXcgc2ZfaG9zdC5Qb3NDb25maWcocG9zX2NvbmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBvc19jb25mKSB7XG4gICAgICAgICAgICAgICAgX2xvZyhcIm5vIHBvc2l0aW9uIGNvbmYgZm91bmQgcHJlLWRlZmluZWQgb3IgaW5saW5lIGZvciBwb3NpdGlvbiBcIiArIGRhdGEuaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcG9zX2NvbmYuZGVzdCkge1xuICAgICAgICAgICAgICAgIHBvc19jb25mID0gbmV3IHNmX2hvc3QuUG9zQ29uZmlnKHBvc19jb25mLCBfZ3VpZChTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGF0YS5tZXRhKSB7XG4gICAgICAgICAgICAgICAgcG9zX21ldGEgPSBkYXRhLm1ldGE7XG4gICAgICAgICAgICAgICAgbWV0YV9rZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNoYXJlZF9tZXRhID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChtZXRhX2tleSBpbiBwb3NfbWV0YSkge1xuICAgICAgICAgICAgICAgICAgcG9zX21ldGFfaXRlbSA9IHBvc19tZXRhW21ldGFfa2V5XTtcbiAgICAgICAgICAgICAgICAgIHR5cCA9IHR5cGVvZiBwb3NfbWV0YV9pdGVtO1xuICAgICAgICAgICAgICAgICAgaWYgKCFwcnZfbWV0YSAmJiB0eXAgPT09IFwib2JqZWN0XCIgJiYgcG9zX21ldGFfaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBwcnZfbWV0YSA9IHBvc19tZXRhX2l0ZW07XG4gICAgICAgICAgICAgICAgICAgIHBydl9tZXRhX2tleSA9IG1ldGFfa2V5O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cCAhPT0gXCJvYmplY3RcIiAmJiB0eXAgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBzaGFyZWRfbWV0YVttZXRhX2tleV0gPSBwb3NfbWV0YV9pdGVtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NfbWV0YSA9IG5ldyBzZl9ob3N0LlBvc01ldGEoc2hhcmVkX21ldGEsIHBydl9tZXRhX2tleSB8fCBcIlwiLCAocHJ2X21ldGFfa2V5ICYmIHBydl9tZXRhID8gcHJ2X21ldGEgOiBudWxsKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zX29iaiA9IG5ldyBzZl9ob3N0LlBvc2l0aW9uKGRhdGEsIG51bGwsIHBvc19tZXRhLCBwb3NfY29uZik7XG4gICAgICAgICAgICAgIGlubGluZV90YWdzX3Byb2Nlc3NlZFtzY3JpcHRfdGFnX2lkXSA9IHNjcmlwdF90YWdfaWQ7XG4gICAgICAgICAgICAgIHBvc19kZXN0X2VsID0gX2VsdChwb3NfY29uZi5kZXN0KTtcbiAgICAgICAgICAgICAgaWYgKCFwb3NfZGVzdF9lbCkge1xuICAgICAgICAgICAgICAgIGlmIChfcmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgcG9zX2Rlc3RfZWwgPSBkb20ubWFrZShcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgIF9hdHRyKHBvc19kZXN0X2VsLCBcImlkXCIsIHBvc19jb25mLmRlc3QpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0X3RhZ19wYXIuaW5zZXJ0QmVmb3JlKHBvc19kZXN0X2VsKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9sb2coXCJmYWlsZWQgYXV0by1hZGRpbmcgZGVzdGluYXRpb24gZWxlbWVudCBcIiArIGVyci5tZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGQud3JpdGUoXCI8ZGl2IGlkPSdcIiwgcG9zX2NvbmYuZGVzdCwgXCInPjwvZGl2PlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYm9vdF9wb3NpdGlvbnMucHVzaChwb3Nfb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2xvZyhcIm5vIGNvbnRlbnQgb3IgaWQgcHJvcGVydHkgZm91bmQgaW4gdGhlIGlubGluZSBwb3NpdGlvbiBvYmplY3RcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYm9vdF9wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2ZfaG9zdC5yZW5kZXIoYm9vdF9wb3NpdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIF9sb2coXCJmYWlsZWQgZHVyaW5nIHJlbmRlcmluZyBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2coXCJubyBwb3NpdGlvbnMgdG8gYm9vdFwiKTtcbiAgICAgIH1cbiAgICAgIGRvbS53YWl0KF9jbGVhbl91cF9ib290ZWRfdGFncyk7XG4gICAgfTtcbiAgICBTRl9EQVRBVEFHX0NMQVNTID0gXCJzZl9kYXRhXCI7XG4gICAgU0ZfVEFHX1RZUEUgPSBcInRleHQveC1zYWZlZnJhbWVcIjtcbiAgICBBVVRPX0JPT1RfTUFYX1JFVFJJRVMgPSAxMDA7XG4gICAgU0ZfUE9TRUxFTV9XUkFQUEVSX0NMQVNTID0gXCJzZl9wb3NpdGlvblwiO1xuICAgIGQgPSB3aW4gJiYgd2luLmRvY3VtZW50O1xuICAgIGxpYiA9IHNmLmxpYjtcbiAgICBsYW5nID0gbGliLmxhbmc7XG4gICAgZG9tID0gbGliLmRvbTtcbiAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICBfZ3VpZCA9IGxhbmcuZ3VpZDtcbiAgICBfZWx0ID0gZG9tLmVsdDtcbiAgICBfcGFyID0gZG9tLnBhcjtcbiAgICBfdGFncyA9IGRvbS50YWdzO1xuICAgIF9hdHRyID0gZG9tLmF0dHI7XG4gICAgX3B1cmdlID0gZG9tLnB1cmdlO1xuICAgIF9yZWFkeSA9IGRvbS5yZWFkeTtcbiAgICBpbmxpbmVfdGFnc19wcm9jZXNzZWQgPSB7fTtcbiAgICBib290X3JldHJpZXMgPSAwO1xuICAgIGhhc19ib290ZWQgPSBmYWxzZTtcbiAgICBkb2luZ19hdXRvX2Jvb3QgPSBmYWxzZTtcbiAgICBzZXRUaW1lb3V0KF9hdXRvX2Jvb3QsIDUwKTtcbiAgICByZXR1cm4gc2Y7XG4gIH0pKHdpbmRvdywgc2YpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuXG4vKlxuQG5hbWVzcGFjZSAkc2YuaG9zdCBEZWZpbmVzIHRoZSBQdWJsaXNoZXIgc2lkZSBhcGksIGFuZCBoZWxwZXIgZnVuY3Rpb25zXG5AbmFtZSAkc2YuaG9zdFxuQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOnNzbmlkZXJAeWFob28taW5jLmNvbVwiPlNlYW4gU25pZGVyPC9hPlxuQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmNjb2xlW0FUXWVtaW5hdGlvbi5jb21cIj5DaHJpcyBDb2xlPC9hPlxuQHZlcnNpb24gMS4wLjJcbiAqL1xuXG5cbi8qXG5AaWdub3JlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKCcuL2Jvb3QnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3csIHNmKSB7XG4gICAgdmFyIEFUVEFDSCwgQVVUTywgQVVUT19CT09UX01BWF9SRVRSSUVTLCBCRl9QT1NfTVNHLCBDTElQLCBDT0xMQVBTRV9DT01NQU5ELCBDT01QQVJFX0RPQ19QT1MsIENPTVBBVF9NT0RFLCBDT05UQUlOUywgQ29uZmlnLCBERUZBVUxUX1JFTkRFUl9USU1FT1VULCBERUZBVUxUX1pJTkRFWCwgREVUQUNILCBET0MsIERPQ19FTCwgRUxfRlJPTV9QVCwgRVJST1JfQ09NTUFORCwgRVhQQU5EX0NPTU1BTkQsIEZMQVNIX01JTUUsIEdFT01fVVBEQVRFX0lOVFJWQUwsIEdVSUQsIEhFSUdIVCwgSElEREVOLCBJRV9CT1JERVJfQURKLCBJTlRFUlNFQ1RfRkFDVE9SLCBMRU4sIE0sIE1TRywgTk9ERV9UWVBFLCBOT1RJRllfQ09MTEFQU0UsIE5PVElGWV9FWFBBTkQsIE5PVElGWV9GT0NVU19DSEFOR0UsIE5PVElGWV9HRU9NX1VQREFURSwgT0JKLCBPTlNDUk9MTCwgT1ZFUiwgUE1TRywgUE9TX0lEX0FVVE9fUFJFRklYLCBQT1NfTVNHLCBQT1NfUkVMX0JPWF9JRF9QUkVGSVgsIFBYLCBQYXJhbUhhc2gsIFBvc0NvbmZpZywgUG9zTWV0YSwgUG9zaXRpb24sIFNDUk9MTCwgU0ZfREFUQVRBR19DTEFTUywgU0ZfUE9TRUxFTV9XUkFQUEVSX0NMQVNTLCBTVCwgU1RSLCBTVVBQT1JUU19GRUFUVVJFUywgVEZYRCwgVkVSU0lPTiwgV0lEVEgsIFhDT01fUkVTUF9ERUxBWSwgYXR0YWNoX2lmcmFtZV9tc2dpbmcsIGJvdW5kcywgY2FuVXNlSFRNTDUsIGNvbXBsZXRlX2lmcnMsIGNvbmZpZywgY29udGFpbnMsIGN1cnJlbnRTdHlsZSwgY3VycmVudF9zdGF0dXMsIGRjLCBkZXRhY2hfaWZyYW1lX21zZ2luZywgZG9jUmVjdCwgZG9tLCBlbnYsIGZsYXNoQWN0aXZlWFZlcnNpb25zLCBmbGFzaF92ZXIsIGZvY3VzX3VwZGF0ZV90aW1lciwgZ2Vja1ZlciwgZ2VvbV91cGRhdGVfdGltZXIsIGdldCwgaHRtbDVCb3VuZCwgaWVWZXIsIGlmcl9kZXN0X2lkX21hcCwgaWZyYW1lcywgaW5WaWV3UGVyY2VudGFnZSwgaW5pdElELCBpc0lFLCBsYW5nLCBsaWIsIGxvYywgbG9jSG9zdCwgbWdyX2JvdW5kc19kZXRhaWxzLCBtc2dfcGlwZXMsIG1zZ2hvc3RmYiwgbnVrZSwgb3BlcmFWZXIsIG92ZXJsYXBzLCBwZW5kaW5nX2lmcnMsIHByZXBfaWZyYW1lX21zZ2luZywgcmVuZGVyLCByZW5kZXJlZF9pZnJzLCBzY3JvbGxfcGFyZW50c19hdHRhY2hlZCwgc2VuZF9tc2dfdG9fY2hpbGRfaWZyYW1lLCBzdGF0dXMsIHVhLCB1c2luZ0hUTUw1LCB3YlZlciwgd2luLCB3aW5SZWN0LCB3aW5fZXZlbnRzX2F0dGFjaGVkLCBfYXR0ciwgX2J1aWxkX2dlb20sIF9jYWxjQm9yZGVycywgX2NhbGxfeG1zZ19ob3N0X2ZiLCBfY2FsbGFibGUsIF9jYm9vbCwgX2NoZWNrX2h0bWw1X2luaXQsIF9jbGVhcl9mb2N1c191cGRhdGVfdGltZXIsIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lciwgX2NudW0sIF9jb2xsYXBzZV9zYWZlZnJhbWUsIF9jb29raWVIYXNoLCBfY29va2llc19lbmFibGVkX3Rlc3QsIF9jcmVhdGVfcG9zX21hcmt1cCwgX2NzdHIsIF9kb2MsIF9kb2NOb2RlLCBfZWx0LCBfZXMsIF9leHBhbmRfc2FmZWZyYW1lLCBfZmlyZV9wdWJfY2FsbGJhY2ssIF9nZXRDbGlwLCBfZ2V0R2VvbSwgX2dldFJlY3RJRSwgX2dldFJlY3ROb25JRSwgX2dldF9kb2Nfc2Nyb2xsLCBfZ2V0X2ZsYXNoX3ZlcnNpb24sIF9ndWlkLCBfaGFuZGxlX2ZyYW1lX2xvYWQsIF9oYW5kbGVfbXNnX2V2dCwgX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlLCBfaGFuZGxlX25vZGVfc2Nyb2xsLCBfaGFuZGxlX3JlbmRlcl90aW1lb3V0LCBfaGFuZGxlX3VubG9hZCwgX2hhbmRsZV93aW5fYmx1ciwgX2hhbmRsZV93aW5fZm9jdXMsIF9oYW5kbGVfd2luX2dlb21fcmVzaXplLCBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCwgX2hhc19wZW5kaW5nX3JlbmRlcnMsIF9pZnJfdmlldywgX2lzUFgsIF9tYXgsIF9taW4sIF9taXgsIF9ub29wLCBfcGFyLCBfcHVyZ2UsIF9yZWFkX2Nvb2tpZSwgX3JlYWR5LCBfcmVjb3JkX2Vycm9yLCBfcmVjdCwgX3JvdW5kLCBfc2VuZF9nZW5lcmljX3Jlc3BvbnNlLCBfc2VuZF9yZXNwb25zZSwgX3NldF9mb2N1c191cGRhdGVfdGltZXIsIF9zZXRfZ2VvbV91cGRhdGVfdGltZXIsIF9zaGltX2ZyYW1lLCBfc3RyaXBwZWRFbmNvZGVkTG9jYXRpb24sIF90YWdOYW1lLCBfdGFncywgX3VwZGF0ZV9mb2N1cywgX3VwZGF0ZV9nZW9tLCBfdXBkYXRlX2dlb21fd2luX3Jlc2l6ZSwgX3VwZGF0ZV9nZW9tX3dpbl9zY3JvbGwsIF92aWV3LCBfd3JpdGVfY29va2llO1xuICAgIHdpbiA9IHdpbmRvdztcbiAgICBERUZBVUxUX1JFTkRFUl9USU1FT1VUID0gNjAwMDA7XG4gICAgUE9TX0lEX0FVVE9fUFJFRklYID0gXCJzZl9wb3NcIjtcbiAgICBQT1NfUkVMX0JPWF9JRF9QUkVGSVggPSBcInNmX3Bvc19yZWxfZWxcIjtcbiAgICBTRl9EQVRBVEFHX0NMQVNTID0gXCJzZl9kYXRhXCI7XG4gICAgU0ZfUE9TRUxFTV9XUkFQUEVSX0NMQVNTID0gXCJzZl9wb3NpdGlvblwiO1xuICAgIEFVVE9fQk9PVF9NQVhfUkVUUklFUyA9IDEwMDtcbiAgICBHRU9NX1VQREFURV9JTlRSVkFMID0gMTAwO1xuICAgIFhDT01fUkVTUF9ERUxBWSA9IDE7XG4gICAgSUVfQk9SREVSX0FESiA9IDI7XG4gICAgSU5URVJTRUNUX0ZBQ1RPUiA9IDEwO1xuICAgIEJGX1BPU19NU0cgPSBcIm9uQmVmb3JlUG9zTXNnXCI7XG4gICAgUE9TX01TRyA9IFwib25Qb3NNc2dcIjtcbiAgICBTVVBQT1JUU19GRUFUVVJFUyA9IHtcbiAgICAgIFwiZXhwLW92clwiOiAxLFxuICAgICAgXCJleHAtcHVzaFwiOiAwLFxuICAgICAgYmc6IDAsXG4gICAgICBwaW46IDAsXG4gICAgICBcInJlYWQtY29va2llXCI6IDAsXG4gICAgICBcIndyaXRlLWNvb2tpZVwiOiAwXG4gICAgfTtcbiAgICBFWFBBTkRfQ09NTUFORCA9IFwiZXhwLW92clwiO1xuICAgIENPTExBUFNFX0NPTU1BTkQgPSBcImNvbGxhcHNlXCI7XG4gICAgRVJST1JfQ09NTUFORCA9IFwiZXJyb3JcIjtcbiAgICBOT1RJRllfRVhQQU5EID0gXCJleHBhbmRcIjtcbiAgICBOT1RJRllfR0VPTV9VUERBVEUgPSBcImdlb20tdXBkYXRlXCI7XG4gICAgTk9USUZZX0NPTExBUFNFID0gQ09MTEFQU0VfQ09NTUFORDtcbiAgICBOT1RJRllfRk9DVVNfQ0hBTkdFID0gXCJmb2N1cy1jaGFuZ2VcIjtcbiAgICBERUZBVUxUX1pJTkRFWCA9IDMwMDA7XG4gICAgT0JKID0gXCJvYmplY3RcIjtcbiAgICBTVFIgPSBcInN0cmluZ1wiO1xuICAgIFNUID0gXCJzdHlsZVwiO1xuICAgIExFTiA9IFwibGVuZ3RoXCI7XG4gICAgV0lEVEggPSBcIndpZHRoXCI7XG4gICAgSEVJR0hUID0gXCJoZWlnaHRcIjtcbiAgICBQWCA9IFwiUFhcIjtcbiAgICBDTElQID0gXCJjbGlwXCI7XG4gICAgU0NST0xMID0gXCJzY3JvbGxcIjtcbiAgICBPTlNDUk9MTCA9IFwib25zY3JvbGxcIjtcbiAgICBDT01QQVRfTU9ERSA9IFwiY29tcGF0TW9kZVwiO1xuICAgIERPQ19FTCA9IFwiZG9jdW1lbnRFbGVtZW50XCI7XG4gICAgRE9DID0gXCJkb2N1bWVudFwiO1xuICAgIE5PREVfVFlQRSA9IFwibm9kZVR5cGVcIjtcbiAgICBDT05UQUlOUyA9IFwiY29udGFpbnNcIjtcbiAgICBDT01QQVJFX0RPQ19QT1MgPSBcImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXCI7XG4gICAgRUxfRlJPTV9QVCA9IFwiZWxlbWVudEZyb21Qb2ludFwiO1xuICAgIEFVVE8gPSBcImF1dG9cIjtcbiAgICBISURERU4gPSBcImhpZGRlblwiO1xuICAgIE9WRVIgPSBcIm92ZXJmbG93XCI7XG4gICAgVEZYRCA9IFwidG9GaXhlZFwiO1xuICAgIEFUVEFDSCA9IFwiYXR0YWNoXCI7XG4gICAgREVUQUNIID0gXCJkZXRhY2hcIjtcbiAgICBNU0cgPSBcIm1lc3NhZ2VcIjtcbiAgICBQTVNHID0gXCJwb3N0TWVzc2FnZVwiO1xuICAgIEdVSUQgPSBcImd1aWRcIjtcbiAgICBGTEFTSF9NSU1FID0gXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiO1xuICAgIFZFUlNJT04gPSBzZi52ZXI7XG4gICAgZW52ID0gc2YuZW52O1xuICAgIHVhID0gZW52LnVhO1xuICAgIGxpYiA9IHNmLmxpYjtcbiAgICBsYW5nID0gbGliLmxhbmc7XG4gICAgZG9tID0gbGliLmRvbTtcbiAgICBpZnJhbWVzID0gZG9tLmlmcmFtZXM7XG4gICAgX2Nib29sID0gbGFuZy5jYm9vbDtcbiAgICBfY251bSA9IGxhbmcuY251bTtcbiAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICBfY2FsbGFibGUgPSBsYW5nLmNhbGxhYmxlO1xuICAgIF9ub29wID0gbGFuZy5ub29wO1xuICAgIF9ndWlkID0gbGFuZ1tHVUlEXTtcbiAgICBfbWl4ID0gbGFuZy5taXg7XG4gICAgX2VsdCA9IGRvbS5lbHQ7XG4gICAgX3BhciA9IGRvbS5wYXI7XG4gICAgX3RhZ3MgPSBkb20udGFncztcbiAgICBfYXR0ciA9IGRvbS5hdHRyO1xuICAgIF9kb2MgPSBkb20uZG9jO1xuICAgIF90YWdOYW1lID0gZG9tLnRhZ05hbWU7XG4gICAgX3ZpZXcgPSBkb20udmlldztcbiAgICBfaWZyX3ZpZXcgPSBpZnJhbWVzLnZpZXc7XG4gICAgX3B1cmdlID0gZG9tLnB1cmdlO1xuICAgIF9yZWFkeSA9IGRvbS5yZWFkeTtcbiAgICBfZXMgPSB3aW4gJiYgd2luLmVzY2FwZTtcbiAgICBNID0gd2luICYmIHdpbi5NYXRoO1xuICAgIF9tYXggPSBNLm1heDtcbiAgICBfbWluID0gTS5taW47XG4gICAgX3JvdW5kID0gTS5yb3VuZDtcbiAgICBfcmVjdCA9IG51bGw7XG4gICAgUGFyYW1IYXNoID0gbGFuZyAmJiBsYW5nLlBhcmFtSGFzaDtcbiAgICBkYyA9IHdpbiAmJiB3aW5bRE9DXTtcbiAgICBpc0lFID0gZW52ICYmIGVudi5pc0lFO1xuICAgIGllVmVyID0gKHVhICYmIHVhLmllKSB8fCAwO1xuICAgIHdiVmVyID0gKHVhICYmIHVhLndlYmtpdCkgfHwgMDtcbiAgICBnZWNrVmVyID0gKHVhICYmIHVhLmdlY2tvKSB8fCAwO1xuICAgIG9wZXJhVmVyID0gKHVhICYmIHVhLm9wZXJhKSB8fCAwO1xuICAgIGxvYyA9IHdpbi5sb2NhdGlvbjtcbiAgICBsb2NIb3N0ID0gbG9jICYmICgobG9jLnByb3RvY29sICsgXCIvL1wiICsgKGxvYy5ob3N0IHx8IGxvYy5ob3N0bmFtZSkpIHx8IFwiXCIpO1xuICAgIHJlbmRlcmVkX2lmcnMgPSB7fTtcbiAgICBtc2dfcGlwZXMgPSB7fTtcbiAgICBpZnJfZGVzdF9pZF9tYXAgPSB7fTtcbiAgICBwZW5kaW5nX2lmcnMgPSB7fTtcbiAgICBjb21wbGV0ZV9pZnJzID0ge307XG4gICAgc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWQgPSB7fTtcbiAgICBtZ3JfYm91bmRzX2RldGFpbHMgPSBmYWxzZTtcbiAgICBjYW5Vc2VIVE1MNSA9IGZhbHNlO1xuICAgIGh0bWw1Qm91bmQgPSBmYWxzZTtcbiAgICB3aW5fZXZlbnRzX2F0dGFjaGVkID0gZmFsc2U7XG4gICAgZ2VvbV91cGRhdGVfdGltZXIgPSAwO1xuICAgIGZvY3VzX3VwZGF0ZV90aW1lciA9IDA7XG4gICAgY3VycmVudF9zdGF0dXMgPSBudWxsO1xuICAgIG1zZ2hvc3RmYiA9IG51bGw7XG4gICAgZmxhc2hfdmVyID0gbnVsbDtcbiAgICBjb25maWcgPSBudWxsO1xuICAgIGZsYXNoQWN0aXZlWFZlcnNpb25zID0gW1wiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2guMTFcIiwgXCJTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaC44XCIsIFwiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2guN1wiLCBcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoLjZcIiwgXCJTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaFwiXTtcbiAgICBpbml0SUQgPSB2b2lkIDA7XG5cbiAgICAvKlxuICAgIENvbmZpZ3VyZSB0aGUgYmFzZS1sZXZlbCBzZXR0aW5ncyBmb3IgdGhlIFNhZmVGcmFtZXMgbGlicmFyeVxuICAgIE5vdGUgdGhhdCBvbmx5IG9uZSBjb25maWd1cmF0aW9uIGNhbiBiZSBhY3RpdmUgYXQgYSBnaXZlbiB0aW1lLlxuICAgIFRoZXJlZm9yZSB5b3UgY2Fubm90IGNoYW5nZSB0aGUgY29uZmlndXJhdGlvbiBieSBjcmVhdGluZyBhIG5ldyAkc2YuaG9zdC5Db25maWcgd2hpbGVcbiAgICB0aGUgU2FmZUZyYW1lcyBsaWJyYXJ5IGlzIGJ1c3kgKGhvd2V2ZXIgeW91IGNhbiBhZGQgbmV3IHBvc2l0aW9uIGNvbmZpZ3VyYXRpb25zKS5cbiAgICBJbnN0YXRpYXRpbmcgYSBuZXcgY29uZmlnLCB3aGVuIHRoZSBsaWJyYXJ5IGlzIG5vdCBidXN5IHdpbGwgZGVzdHJveSAvIHJlbW92ZSBhbGwgY3VycmVudGx5XG4gICAgbWFuYWdlZCBwb3NpdGlvbnMgYW5kIHRoZXJlIGNvbmZpZ3VyYXRpb25zLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LkNvbmZpZ1xuICAgIEBjb25zdHJ1Y3RvclxuICAgIEBwdWJsaWNcbiAgICBAcGFyYW0ge09iamVjdH0gY29uZiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGZvciBjb25maWd1cmF0aW9uXG4gICAgQHBhcmFtIHtCb29sZWFufSBbY29uZi5hdXRvXSBXaGV0aGVyIG9yIG5vdCB0byBoYXZlIFNhZmVGcmFtZXMgYXV0b21hdGljYWxseSBib29zdHJhcCBhbiByZW5kZXIgYW55IFNhZmVGcmFtZXMgdGFncyB3aXRoaW4gdGhlIHBhZ2VcbiAgICBAcGFyYW0ge1N0cmluZ30gY29uZi5jZG4gVGhlIHByb3RvY29sLGhvc3QgbmFtZSwgYW5kIHBvcnQgcGFydHMgb2YgYSBVUkksIHRoYXQgaXMgYSAybmRhcnkgb3JpZ2luLCB1c2VkIHdpdGggU2FmZUZyYW1lcyB0byByZW5kZXIgY29udGVudC4gRm9yIGV4YW1wbGUgSlMgZmlsZXMgd291bGQgYmUgbG9hZGVkIGZyb20gY29uZi5jZG4rXCIvXCIrY29uZi5yb290K1wiL1wiK2NvbmYudmVyc2lvbitcIi9bZmlsZW5hbWVdXCJcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtjb25mLmRlYnVnXSBXaGV0aGVyIG9yIG5vdCBkZWJ1ZyBtb2RlIGlzIG9uIG9yIG9mZlxuICAgIEBwYXJhbSB7U3RyaW5nfSBjb25mLnJvb3QgVGhlIHJvb3QgcGF0aCBwYXJ0IG9mIHRoZSBVUkkgdGhhdCBpcyBhIDJuZGFyeSBvcmlnaW4sIHVzZWQgd2l0aCBTYWZlRnJhbWVzIHRvIHJlbmRlciBjb250ZW50LiBGb3IgZXhhbXBsZSB0aGUgSFRNTCBmaWxlIGZvciByZW5kZXJpbmcgY29udGVudCBpbnRvIHdvdWxkIGJlbG9hZGVkIGZyb20gY29uZi5jZG4rXCIvXCIrY29uZi5yb290K1wiL1wiK2NvbmYudmVyc2lvbitcIi9cIitjb25mLnJlbmRlckZpbGVcbiAgICBAcGFyYW0ge1N0cmluZ30gY29uZi5yZW5kZXJGaWxlIFRoZSBmaWxlbmFtZSAobWF5IGFsc28gaW5jbHVkZSBwYXRoIGluZm8pLCBmb3Igd2hpY2ggdG8gcmVuZGVyIGNvbnRlbnQgaW50byB2aWEgYSBTYWZlRnJhbWUuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjb25mLm1zZ0ZpbGVdIFRoZSBmaWxlbmFtZSAobWF5IGFsc28gaW5jbHVkZSBwYXRoIGluZm8pLCBmb3Igd2hpY2ggdG8gdXNlIGFzIGEgcHJveHkgZm9yIHgtZG9tYWluIG1lc3NhZ2luZyB3aGVuZXZlciBIVE1MNSBtZXNzYWdpbmcgaXMgbm90IGF2YWlsYWJsZS4gT25seSByZXF1aXJlZCBpZiBzdXBwb3J0aW5nIG9sZGVyIGJyb3dzZXJzLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbY29uZi50b10gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgU2FmZUZyYW1lIHRvIGZpbmlzaCByZW5kZXJpbmcsIGRlZmF1bHRzIHRvIDYwIHNlY29uZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmYub25CZWZvcmVQb3NNc2ddIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGZpcmVkIGJlZm9yZSBhbnkgY2FuY2VsbGFibGUgYWN0aW9uIGlzIHJlcXVlc3RlZCB0byBiZSBwZWZvcm1lZCBmcm9tIGEgYSBTYWZlRnJhbWUsIHN1Y2ggYXMgZXhwYW5zaW9uLCBldGMuICBSZXR1cm4gdHJ1ZSBvdXQgb2YgdGhpcyBjYWxsYmFjayBmdW5jdGlvbiB0byBjYW5jZWwvZGlzYWxsb3cgdGhlIGFjdGlvbiBpbiBxdWVzdGlvbi5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZi5vblBvc01zZ10gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgZmlyZWQgd2hlbiBhbiBhY3Rpb24gcmVxdWVzdGVkIGJ5IGEgU2FmZUZyYW1lIGlzIHBlcmZvcm1lZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjb25mLm9uU3RhcnRQb3NSZW5kZXJdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGZpcmVkIHdoZW4gYSBTYWZlRnJhbWUgc3RhcnRzIHRvIHJlbmRlciAzcmQgcGFydHkgY29udGVudC5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZi5vbkVuZFBvc1JlbmRlcl0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgZmlyZWQgd2hlbiBhIFNhZmVGcmFtZSBmaW5pc2hlcyByZW5kZXJpbmcgM3JkIHBhcnR5IGNvbnRlbnQuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtjb25mLnBvc2l0aW9uc10gQSBtYXAgb2YgcG9zaXRpb25zIHRvIGF1dG9tYXRpY2FsbHkgY29uZmlndXJlLCB3aGVyZSBlYWNoIGtleSBlcXVhbHMgdGhlIGlkIG9mIHRoZSAkc2YuaG9zdC5Qb3NDb25maWcgb2JqZWN0LCBhbmQgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHNhaWQgb2JqZWN0J3Mgc2V0dGluZ3MuXG4gICAgICovXG4gICAgQ29uZmlnID0gZnVuY3Rpb24oY29uZikge1xuICAgICAgdmFyIGJvb3RfdXAsIGNvbmZfcG9zX21hcCwgbWUsIHBvc0lELCBwb3NfY29uZiwgcG9zX2lkLCBwb3NfbWFwO1xuICAgICAgbWUgPSB0aGlzO1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAoY29uZmlnID8gX21peCh7fSwgY29uZmlnKSA6IG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlnKGNvbmYpO1xuICAgICAgfVxuICAgICAgaWYgKCFjb25mKSB7XG4gICAgICAgIGNvbmZpZyA9IG51bGw7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgYm9vdF91cCA9ICEhY29uZmlnO1xuICAgICAgbWUuYXV0byA9IChcImF1dG9cIiBpbiBjb25mID8gX2Nib29sKGNvbmYuYXV0bykgOiB0cnVlKTtcbiAgICAgIG1lLmNkbiA9IF9jc3RyKGNvbmYuY2RuKTtcbiAgICAgIG1lLmRlYnVnID0gX2Nib29sKGNvbmYuZGVidWcpO1xuICAgICAgbWUucm9vdCA9IF9jc3RyKGNvbmYucm9vdCk7XG4gICAgICBtZS5yZW5kZXJGaWxlID0gX2NzdHIoY29uZi5yZW5kZXJGaWxlKTtcbiAgICAgIG1lLm1zZ0ZpbGUgPSBfY3N0cihjb25mLm1zZ0ZpbGUpO1xuICAgICAgbWUudG8gPSBfY251bShjb25mLnRvLCBERUZBVUxUX1JFTkRFUl9USU1FT1VUKTtcbiAgICAgIG1lLnZlciA9IF9jc3RyKGNvbmYudmVyKSB8fCBWRVJTSU9OO1xuICAgICAgbWUub25CZWZvcmVQb3NNc2cgPSAoX2NhbGxhYmxlKGNvbmYub25CZWZvcmVQb3NNc2cpID8gY29uZi5vbkJlZm9yZVBvc01zZyA6IF9ub29wKTtcbiAgICAgIG1lLm9uUG9zTXNnID0gKF9jYWxsYWJsZShjb25mLm9uUG9zTXNnKSA/IGNvbmYub25Qb3NNc2cgOiBfbm9vcCk7XG4gICAgICBtZS5vblN0YXJ0UG9zUmVuZGVyID0gKF9jYWxsYWJsZShjb25mLm9uU3RhcnRQb3NSZW5kZXIpID8gY29uZi5vblN0YXJ0UG9zUmVuZGVyIDogX25vb3ApO1xuICAgICAgbWUub25FbmRQb3NSZW5kZXIgPSAoX2NhbGxhYmxlKGNvbmYub25FbmRQb3NSZW5kZXIpID8gY29uZi5vbkVuZFBvc1JlbmRlciA6IF9ub29wKTtcbiAgICAgIG1lLm9uRmFpbHVyZSA9IChfY2FsbGFibGUoY29uZi5vbkZhaWx1cmUpID8gY29uZi5vbkZhaWx1cmUgOiBfbm9vcCk7XG4gICAgICBtZS5vbkFkTG9hZCA9IChfY2FsbGFibGUoY29uZi5vbkFkTG9hZCkgPyBjb25mLm9uQWRMb2FkIDogX25vb3ApO1xuICAgICAgbWUub25SZWFkQ29va2llID0gKF9jYWxsYWJsZShjb25mLm9uUmVhZENvb2tpZSkgPyBjb25mLm9uUmVhZENvb2tpZSA6IF9ub29wKTtcbiAgICAgIG1lLm9uV3JpdGVDb29raWUgPSAoX2NhbGxhYmxlKGNvbmYub25Xcml0ZUNvb2tpZSkgPyBjb25mLm9uV3JpdGVDb29raWUgOiBfbm9vcCk7XG4gICAgICBjb25mX3Bvc19tYXAgPSBjb25mLnBvc2l0aW9ucztcbiAgICAgIG1lLnBvc2l0aW9ucyA9IHBvc19tYXAgPSB7fTtcbiAgICAgIGlmIChjb25mX3Bvc19tYXApIHtcbiAgICAgICAgZm9yIChwb3NJRCBpbiBjb25mX3Bvc19tYXApIHtcbiAgICAgICAgICBwb3NfY29uZiA9IGNvbmZfcG9zX21hcFtwb3NJRF07XG4gICAgICAgICAgaWYgKHBvc19jb25mICYmIHR5cGVvZiBwb3NfY29uZiA9PT0gT0JKKSB7XG4gICAgICAgICAgICBwb3NfaWQgPSBwb3NJRCB8fCBwb3NfY29uZi5pZCB8fCBfZ3VpZChQT1NfSURfQVVUT19QUkVGSVgpO1xuICAgICAgICAgICAgcG9zX21hcFtwb3NfaWRdID0gbmV3IFBvc0NvbmZpZyhwb3NfY29uZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25maWcgPSBtZTtcbiAgICAgIGJvb3RfdXAgPSAhIShib290X3VwICYmIG1lLmF1dG8gJiYgKHNmLmhvc3QuYm9vdCAhPSBudWxsKSk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYm9vdF91cCkge1xuICAgICAgICAgIHNmLmhvc3QuYm9vdCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICByZXR1cm4gX21peCh7fSwgY29uZmlnKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDb25maWd1cmUgYSBwYXJ0aWN1YWxhciBwb3NpdGlvbiBmb3IgcmVuZGVyaW5nIGEgU2FmZUZyYW1lXG4gICAgRWFjaCAkc2YuaG9zdC5Qb3NDb25maWcgb2JqZWN0IGhhcyBhbiBpZCBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSB1bmlxdWUuICBDcmVhdGluZyBhIG5ldyAkc2YuaG9zdC5Qb3NDb25maWcgd2l0aCBhbiBpZCwgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgdXNlZCByZXN1bHRzIGluIGNoYW5naW5nIHRoZSBvbGQgJHNmLmhvc3QuUG9zQ29uZmlnIHNldHRpbmdzLCBhbmQgY2FuIG9ubHkgYmUgZG9uZSBpZiB0aGUgU2FmZUZyYW1lcyBsaWJyYXJ5IGlzIG5vdCBidXN5LlxuICAgIEF1dG9tYXRpY2FsbHkgYWRzIHRvIHRoZSBwb3NpdGlvbiBtYXAgb2YgdGhlICRzZi5ob3N0LkNvbmZpZyBvYmplY3QgaWYgc2FpZCBjb25maWcgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LlBvc0NvbmZpZ1xuICAgIEBwdWJsaWNcbiAgICBAY29uc3RydWN0b3JcbiAgICBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHBvc0lEb3JPYmogVGhlIGlkIG9mIHRoZSAkc2YuaG9zdC5Qb3NDb25maWcgaW5zdGFuY2UsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBzZXR0aW5ncyB0aGF0IGFyZSB0byBiZSB1c2VkIGZvciB0aGUgaW5zdGFuY2UuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLmlkXSBUaGUgaWQgb2YgdGhlICRzZi5ob3N0LlBvc0NvbmZpZyBpbnN0YW5jZSwgaWYgbm90IHNwZWNpZmllZCBvbmUgd2lsbCBiZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouZGVzdF0gVGhlIEhUTUwgZWxlbWVudCBpZCBhdHRyaWJ1dGUgb2YgdGhlIEhUTUwgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQgd2hlcmUgYSBTYWZlRnJhbWUgd2lsbCBiZSByZW5kZXJlZC4gU2FpZCBlbGVtZW50IE1VU1QgZXhpc3Qgd2l0aGluIHRoZSBwYWdlIHByaW9yIHRvIGEgcmVuZGVyLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5iZ10gVGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIHRvIGJlIHVzZWQgaW5zaWRlIHRoZSBTYWZlRnJhbWUuIERlZmF1bHQgZXF1YWxzIFwidHJhbnNwYXJlbnRcIi5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmoudGd0XSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IHdpbmRvdyB3aGVyZSBoeXBlcmxpbmtzIGluc2lkZSBhIFNhZmVGcmFtZSB3aWxsIG5hdmlnYXRlIHRvby4uLk5vdGUgdGhhdCBcIl9zZWxmXCIgaXMgbm90IGFsbG93ZWQgYW5kIGFsd2F5cyBjb252ZXJ0ZWQgdG8gXCJfdG9wXCIuIEFsbG93ZWQgdmFsdWVzIGFyZSBhbnkgc3RyaW5nIHZhbHVlIG5vdCBwcmVmaXhlZCB3aXRoIFwiX1wiLCBvciBcIl90b3BcIiBvciBcIl9ibGFua1wiLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5jc3NdIEEgc3RyaW5nIG9mIENTUyBydWxlcywgb3IgYSBVUkwgdGhhdCBwb2ludHMgdG8gYSBDU1Mgc3R5bGUgc2hlZXQgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIFNhZmVGcmFtZVxuICAgIEBwYXJhbSB7TnVtYmVyfSBbcG9zSURvck9iai53XSBUaGUgd2lkdGggb2YgdGhlIFNhZmVGcmFtZSwgc3BlY2lmaWVkIGluIHBpeGVscy4gQ2Fubm90IGJlIHNwZWNpZmllZCBpbiBlbSwgJSBvciBhbm90aGVyIHZhbHVlcy5cbiAgICBAcGFyYW0ge051bWJlcn0gW3Bvc0lEb3JPYmouaF0gVGhlIGhlaWdodCBvZiB0aGUgU2FmZUZyYW1lLCBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBDYW5ub3QgYmUgc3BlY2lmaWVkIGluIGVtLCAlIG9yIGFub3RoZXIgdmFsdWVzLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5zaXplXSBBIHN0cmluZyBmb3JtYXRlZCBhcyBcIndpZHRoWGhlaWdodFwiLCB0aGF0IGRlZmluZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIFNhZmVGcmFtZS4gVGhlIGRlbGltaXRlciBjaGFyYWN0ZXIgXCJYXCIgaXMgY2FuIGJlIHNwZWNpZmllZCBhcyBsb3dlciBvciB1cHBlciBjYXNlLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai56XSBUaGUgei1pbmRleCBvZiB0aGUgU2FmZUZyYW1lLlxuICAgIEBwYXJhbSB7T2JqZWN0fSBbcG9zSURvck9iai5zdXBwb3J0c10gQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5L3ZhbHVlIHBhaXJzIGZvciB3aGF0IGZlYXR1cmVzL2FjdGlvbnMgYXJlIHN1cHBvcnRlZCBieSB0aGUgU2FmZUZyYW1lLCBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgdmFsdWUgcmVwcmVzZW50cyBhIGJvb2xlYW4gZGV0ZXJlbWluZyB3aGV0aGVyIHRoYXQgZmVhdHVyZSBjYW4gYmUgdXNlZC4gIEN1cnJlbnRseSBzdXBwb3J0ZWQga2V5cyBhcmUgXCJleHAtb3ZyXCIgPT0gU2FmZUZyYW1lIGNhbiBleHBhbmQgaW4gb3ZlcmxheSBtb2RlLCBcImV4cC1wdXNoXCIgPT0gU2FmZUZyYW1lIGNhbiBleHBhbmQgaW4gcHVzaCBtb2RlLCBhbmQgXCJiZ1wiID09IFNhZmVGcmFtZSBjYW4gY2hhbmdlIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSBwdWJsaXNoZXIgLyBob3N0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbZGVzdElEXSBUaGUgSFRNTCBlbGVtZW50IGlkIGF0dHJpYnV0ZSBvZiB0aGUgSFRNTCBlbGVtZW50IGluIHRoZSBkb2N1bWVudCB3aGVyZSBhIFNhZmVGcmFtZSB3aWxsIGJlIHJlbmRlcmVkLiBTYWlkIGVsZW1lbnQgTVVTVCBleGlzdCB3aXRoaW4gdGhlIHBhZ2UgcHJpb3IgdG8gYSByZW5kZXIuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtiYXNlQ29uZl0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhICRzZi5ob3N0LkNvbmZpZyBvYmplY3QgdG8gYXV0b21hdGljYWxseSB1c2UgLyBjcmVhdGUgZm9yIHRoZSBTYWZlRnJhbWVzIGxpYnJhcnkuIE5vdGUgdGhhdCBiYXNlQ29uZiBjYW4gb25seSBiZSB1c2VkIG9uZSB0aW1lLCBvdGhlcndpc2UgeW91IGhhdmUgdG8gdXNlIHRoZSAkc2YuaG9zdC5Db25maWcgb2JqZWN0IGRpcmVjdGx5LlxuICAgICAqL1xuICAgIFBvc0NvbmZpZyA9IGZ1bmN0aW9uKHBvc0lEb3JPYmosIGRlc3RJRCwgYmFzZUNvbmYpIHtcbiAgICAgIHZhciBtZSwgc3osIHN6X3NwbGl0LCB0eXA7XG4gICAgICBtZSA9IHRoaXM7XG4gICAgICB0eXAgPSAocG9zSURvck9iaiAmJiB0eXBlb2YgcG9zSURvck9iaikgfHwgXCJcIjtcbiAgICAgIGlmICghKG1lIGluc3RhbmNlb2YgUG9zQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc0NvbmZpZyhwb3NJRG9yT2JqLCBkZXN0SUQsIGJhc2VDb25mKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IE9CSikge1xuICAgICAgICBtZS5pZCA9IF9jc3RyKHBvc0lEb3JPYmouaWQpO1xuICAgICAgICBtZS5kZXN0ID0gX2NzdHIocG9zSURvck9iai5kZXN0IHx8IGRlc3RJRCk7XG4gICAgICAgIG1lLmJnID0gX2NzdHIocG9zSURvck9iai5iZykgfHwgXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBtZS50Z3QgPSBfY3N0cihwb3NJRG9yT2JqLnRndCkgfHwgXCJfdG9wXCI7XG4gICAgICAgIG1lLmNzcyA9IF9jc3RyKHBvc0lEb3JPYmouY3NzKTtcbiAgICAgICAgbWUudyA9IF9jbnVtKHBvc0lEb3JPYmoudywgMCk7XG4gICAgICAgIG1lLmggPSBfY251bShwb3NJRG9yT2JqLmgsIDApO1xuICAgICAgICBtZS56ID0gX2NudW0ocG9zSURvck9iai56LCAwKTtcbiAgICAgICAgbWUuc3VwcG9ydHMgPSBfbWl4KHt9LCBwb3NJRG9yT2JqLnN1cHBvcnRzIHx8IFNVUFBPUlRTX0ZFQVRVUkVTLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFtZS53IHx8ICFtZS5oKSB7XG4gICAgICAgICAgc3ogPSBfY3N0cihwb3NJRG9yT2JqLnNpemUpO1xuICAgICAgICAgIGlmIChzeikge1xuICAgICAgICAgICAgc3pfc3BsaXQgPSBzei5zcGxpdCgveC9nKTtcbiAgICAgICAgICAgIG1lLncgPSBfY251bShzel9zcGxpdFswXSwgMCk7XG4gICAgICAgICAgICBtZS5oID0gX2NudW0oc3pfc3BsaXRbMV0sIDApO1xuICAgICAgICAgICAgbWUuc2l6ZSA9IHN6O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zaXplID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuc2l6ZSA9IG1lLncgKyBcInhcIiArIG1lLmg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lLmlkID0gX2NzdHIocG9zSURvck9iaik7XG4gICAgICAgIG1lLmRlc3QgPSBfY3N0cihkZXN0SUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWUuZGVzdCA9IFwiXCI7XG4gICAgICAgIG1lLmJnID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBtZS50Z3QgPSBcIl90b3BcIjtcbiAgICAgICAgbWUuY3NzID0gXCJcIjtcbiAgICAgICAgbWUudyA9IDA7XG4gICAgICAgIG1lLmggPSAwO1xuICAgICAgICBtZS5zaXplID0gXCJcIjtcbiAgICAgICAgbWUueiA9IDA7XG4gICAgICAgIG1lLnN1cHBvcnRzID0ge307XG4gICAgICB9XG4gICAgICBtZS5pZCA9IG1lLmlkIHx8IF9ndWlkKFBPU19JRF9BVVRPX1BSRUZJWCk7XG4gICAgICBpZiAoIWNvbmZpZyAmJiBiYXNlQ29uZikge1xuICAgICAgICBDb25maWcoYmFzZUNvbmYpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICBjb25maWcucG9zaXRpb25zW21lLmlkXSA9IG1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9taXgoe30sIG1lKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDb25zdHJ1Y3QgYSBzZXQgb2YgZHluYW1pYyBrZXkvdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgc2hhcmVkIGFzIG1ldGEtZGF0YSB3aXRoIHRoZSAzcmQgcGFydHkgY29udGVudCBpbnNpZGUgYSBTYWZlRnJhbWUuXG4gICAgQWxsIGRhdGEgaXMgdHJlYXRlZCBhcyBwcm90ZWN0ZWQsIGFuZCBjYW4gb25seSBiZSBzcGVjZmllZCBkdXJpbmcgY29uc3RydWN0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgIFxuICAgIEBleHBvcnRzIFBvc01ldGEgYXMgJHNmLmhvc3QuUG9zTWV0YSNcbiAgICBAcHVibGljXG4gICAgQGNvbnN0cnVjdG9yXG4gICAgQGNsYXNzXG4gICAgQHBhcmFtIHtPYmplY3R9IHNoYXJlZF9vYmplY3QgQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBhbmQgdmFsdWVzIHRvIGJlIHNoYXJlZCBhcyBtZXRhLWRhdGEgaW5zaWRlIHRoZSBTYWZlRnJhbWVcbiAgICBAcGFyYW0ge1N0cmluZ30gW293bmVyX2tleV0gQSBrZXkgbmFtZSB0byBiZSB1c2VkIHRvIGhvbGQgcHNldWRvIHByaXZhdGUga2V5cyAvIHZhbHVlcyBvZiBtZXRhIGRhdGEuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtvd25lZF9vYmpdIEFuIG9iamVjdCBjb250YWluaW5nIHBzdWVkbyBwcml2YXRlIGtleXMgYW5kIHZhbHVlcyB0byBiZSBzaGFyZWQgYXMgbWV0YS1kYXRhIGluc2lkZSB0aGUgU2FmZUZyYW1lLlxuICAgIEBleGFtcGxlXG4gICAgdmFyIHNoYXJlZF9kYXRhIFx0XHQgPSB7Y29udGVudF9pZDo4OTc4MDk4LHBhcnRuZXJfaWQ6OTl9LFxuICAgIHByaXZhdGVfZGF0YV9rZXlcdCA9IFwicm14XCIsXG4gICAgcHJpdmF0ZV9kYXRhICAgICAgPSB7c2VjdGlvbl9pZDoyMzQyLHNpdGVfaWQ6MjM5MDR9LFxuICAgIG1ldGFfZGF0YVx0XHQgPSBuZXcgJHNmLmhvc3QuUG9zTWV0YShzaGFyZWRfZGF0YSwgcHJpdmF0ZV9kYXRhX2tleSwgcHJpdmF0ZV9kYXRhKTtcbiAgICBcbiAgICAvL3Nob3cgc2VjdGlvbiBpZCBvbiBob3N0IHNpZGVcbiAgICBhbGVydChtZXRhX2RhdGEudmFsdWUoXCJybXhcIiwgXCJzaXRlX2lkXCIpKTsgLy89PSAyMzkwNFxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgLy9ub3cgcmV0cmlldmUgdGhpcyBpbmZvcm1hdGlvbiBpbnNpZGUgdGhlIHNhZmUgZnJhbWVcbiAgICBcbiAgICB2YXIgY29udGVudF9pZCA9ICRzZi52ZW5kLm1ldGEoXCJjb250ZW50X2lkXCIpOyAvLz09IDg5NzgwOThcbiAgICBcbiAgICB2YXIgcm14X3NlY3Rpb25faWQgPSAkc2YudmVuZC5tZXRhKFwicm14XCIsIFwic2VjdGlvbl9pZFwiKSAvLz09IDIzNDIsIGJ1dCBub3RlIHRoYXQgdmVuZG9yIHNpZGUgY29kZSBtdXN0IGtub3cgdGhlIFwib3duZXJfa2V5XCIgdXBmcm9udC5cbiAgICAgKi9cbiAgICBQb3NNZXRhID0gZnVuY3Rpb24oc2hhcmVkX29iaiwgb3duZXJfa2V5LCBvd25lZF9vYmopIHtcblxuICAgICAgLypcbiAgICAgIEEgbWV0aG9kIHJldHJpZXZlcyBhIG1ldGEgZGF0YSB2YWx1ZSBmcm9tIHRoaXMgb2JqZWN0LlxuICAgICAgXG4gICAgICBAZXhwb3J0cyBnZXRfdmFsdWUgYXMgJHNmLmhvc3QuUG9zTWV0YSN2YWx1ZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHByb3BLZXkgVGhlIG5hbWUgb2YgdGhlIHZhbHVlIHRvIHJldHJpZXZlXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW293bmVyX2tleV0gVGhlIG5hbWUgb2YgdGhlIG93bmVyIGtleSBvZiB0aGUgbWV0YSBkYXRhIHZhbHVlLiBCeSBkZWZhdWx0LCBpdCBpcyBhc3N1bWVkIHRvIGJlIHNoYXJlZCwgc28gbm90aGluZyBuZWVkcyB0byBiZSBwYXNzZWQgaW4gdW5sZXNzIGxvb2tpbmcgZm9yIGEgc3BlY2lmaWMgcHJvcHJpZXRhcnkgdmFsdWVcbiAgICAgIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ8Qm9vbGVhbn1cbiAgICAgIEBkZWZhdWx0IHtTdHJpbmd9IFwiXCJcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICB2YXIgZ2V0X3ZhbHVlLCBtZSwgbm9uX3NoYXJlZCwgb2xkLCBwb3NDb25mLCBzZXJpYWxpemUsIHNldF92YWx1ZSwgc2hhcmVkO1xuICAgICAgZ2V0X3ZhbHVlID0gZnVuY3Rpb24ocHJvcEtleSwgb3duZXJfa2V5KSB7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHJldCA9IFwiXCI7XG4gICAgICAgIGlmICghcHJvcEtleSB8fCB0eXBlb2YgcHJvcEtleSAhPT0gU1RSKSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW93bmVyX2tleSB8fCB0eXBlb2Ygb3duZXJfa2V5ICE9PSBTVFIpIHtcbiAgICAgICAgICBvd25lcl9rZXkgPSBcInNoYXJlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvd25lcl9rZXkgPT09IFwic2hhcmVkXCIpIHtcbiAgICAgICAgICByZXQgPSBzaGFyZWRbcHJvcEtleV0gfHwgXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSAocHJvcEtleSBpbiBub25fc2hhcmVkID8gbm9uX3NoYXJlZFtwcm9wX2tleV0gfHwgXCJcIiA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJuIGEgc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gKGluIHVybCBxdWVyeSBzdHJpbmcgZm9ybWF0KSBvZiB0aGUgbWV0YSBkYXRhIG9iamVjdFxuICAgICAgXG4gICAgICBAZXhwb3J0cyBzZXJpYWxpemUgYXMgJHNmLmhvc3QuUG9zTWV0YSN0b1N0cmluZ1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2JqO1xuICAgICAgICBvYmogPSBuZXcgUGFyYW1IYXNoKCk7XG4gICAgICAgIG9iai5zaGFyZWQgPSBzaGFyZWQ7XG4gICAgICAgIG9iai5ub25fc2hhcmVkID0gbm9uX3NoYXJlZDtcbiAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIHNldF92YWx1ZSA9IGZ1bmN0aW9uKHByb3BLZXksIG93bmVyS2V5LCB2YWx1ZSkge1xuICAgICAgICBub25fc2hhcmVkW293bmVyS2V5XSB8fCAobm9uX3NoYXJlZFtvd25lcktleV0gPSB7fSk7XG4gICAgICAgIHJldHVybiBub25fc2hhcmVkW293bmVyS2V5XVtwcm9wS2V5XSA9IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIHNoYXJlZCA9IHZvaWQgMDtcbiAgICAgIG5vbl9zaGFyZWQgPSB2b2lkIDA7XG4gICAgICBvbGQgPSB2b2lkIDA7XG4gICAgICBwb3NDb25mID0gdm9pZCAwO1xuICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQb3NNZXRhKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc01ldGEoa2V5LCBvd25lZF9vYmosIHBvcywgc2hhcmVkX29iaik7XG4gICAgICB9XG4gICAgICBzaGFyZWQgPSB7fTtcbiAgICAgIG5vbl9zaGFyZWQgPSB7fTtcbiAgICAgIGlmICghb3duZXJfa2V5IHx8IHR5cGVvZiBvd25lcl9rZXkgIT09IFNUUikge1xuICAgICAgICByZXR1cm4gbWU7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcmVkX29iaiAmJiB0eXBlb2Ygc2hhcmVkX29iaiA9PT0gT0JKKSB7XG4gICAgICAgIHNoYXJlZCA9IF9taXgoc2hhcmVkLCBzaGFyZWRfb2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChvd25lZF9vYmogJiYgdHlwZW9mIG93bmVkX29iaiA9PT0gT0JKKSB7XG4gICAgICAgIG5vbl9zaGFyZWRbb3duZXJfa2V5XSA9IG93bmVkX29iajtcbiAgICAgIH1cbiAgICAgIG1lLnRvU3RyaW5nID0gc2VyaWFsaXplO1xuICAgICAgbWUudmFsdWUgPSBnZXRfdmFsdWU7XG4gICAgICBtZS5zZXRWYWx1ZSA9IHNldF92YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDcmVhdGUgdGhlIEhUTUwgbWFya3VwIGZvciBhIHBvc2l0aW9uIGlmIGEgc3JjIHByb3BlcnR5IHdhcyB1c2VkXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2NyZWF0ZV9wb3NfbWFya3VwXG4gICAgQGZ1bmN0aW9uXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9jcmVhdGVfcG9zX21hcmt1cCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgdmFyIGNrVmFsLCBmVmVyO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBpZiAoc3JjLmluZGV4T2YoXCIke3NmX3Zlcn1cIikgPiAtMSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXCR7c2ZfdmVyfS9nLCAkc2YudmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLmluZGV4T2YoXCIke2NrX29ufVwiKSA+IC0xKSB7XG4gICAgICAgICAgY2tWYWwgPSAoX2Nvb2tpZXNfZW5hYmxlZF90ZXN0KCkgPyBcIjFcIiA6IFwiMFwiKTtcbiAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFwke2NrX29ufS9nLCBja1ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5pbmRleE9mKFwiJHtmbGFzaF92ZXJ9XCIpID4gLTEpIHtcbiAgICAgICAgICBmVmVyID0gX2dldF9mbGFzaF92ZXJzaW9uKCk7XG4gICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcJHtmbGFzaF92ZXJ9L2csIGZWZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NzdHIoW1wiPHNjclwiLCBcImlwdCB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnLCBzcmM9J1wiLCBzcmMsIFwiJz48L3NjclwiLCBcImlwdD5cIl0pO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdldCB0aGUgZmFsc2ggdmVyc2lvbiBudW1iZXJcbiAgICAgKi9cbiAgICBfZ2V0X2ZsYXNoX3ZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlcnIsIGdldEFjdGl2ZVhWZXJzaW9uLCBpLCBtaW1lVHlwZXMsIG9iaiwgcCwgdG1wVmVyO1xuICAgICAgaWYgKGZsYXNoX3ZlciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmxhc2hfdmVyO1xuICAgICAgfVxuICAgICAgaWYgKG5hdmlnYXRvci5wbHVnaW5zICYmIG5hdmlnYXRvci5wbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWltZVR5cGVzID0gbmF2aWdhdG9yLm1pbWVUeXBlcztcbiAgICAgICAgaWYgKG1pbWVUeXBlcyAmJiBtaW1lVHlwZXNbRkxBU0hfTUlNRV0gJiYgbWltZVR5cGVzW0ZMQVNIX01JTUVdLmVuYWJsZWRQbHVnaW4gJiYgbWltZVR5cGVzW0ZMQVNIX01JTUVdLmVuYWJsZWRQbHVnaW4uZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICBmbGFzaF92ZXIgPSBtaW1lVHlwZXNbRkxBU0hfTUlNRV0uZW5hYmxlZFBsdWdpbi52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNmLmVudi5pc0lFKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGZsYXNoQWN0aXZlWFZlcnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYmogPSBuZXcgQWN0aXZlWE9iamVjdChmbGFzaEFjdGl2ZVhWZXJzaW9uc1tpXSk7XG4gICAgICAgICAgICB0bXBWZXIgPSBvYmouR2V0VmFyaWFibGUoXCIkdmVyc2lvblwiKTtcbiAgICAgICAgICAgIHAgPSB0bXBWZXIuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICBpZiAocCA+IC0xKSB7XG4gICAgICAgICAgICAgIGZsYXNoX3ZlciA9IHRtcFZlci5zdWJzdHIocCArIDEpLnJlcGxhY2UoLywvZywgXCIuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmxhc2hfdmVyID0gdG1wVmVyLnJlcGxhY2UoLywvZywgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICAgICAgZmxhc2hfdmVyID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXNoX3ZlciA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhc2hfdmVyO1xuICAgICAgZ2V0QWN0aXZlWFZlcnNpb24gPSBmdW5jdGlvbihhY3RpdmVYT2JqKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uO1xuICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmVyc2lvbiA9IGFjdGl2ZVhPYmouR2V0VmFyaWFibGUoXCIkdmVyc2lvblwiKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qXG4gICAgVGVzdCB0byBzZWUgaWYgY29va2llcyBhcmUgZW5hYmxlZFxuICAgICAqL1xuICAgIF9jb29raWVzX2VuYWJsZWRfdGVzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvb2tpZUVuYWJsZWQ7XG4gICAgICBjb29raWVFbmFibGVkID0gKG5hdmlnYXRvci5jb29raWVFbmFibGVkID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQgPT09IFwidW5kZWZpbmVkXCIgJiYgIWNvb2tpZUVuYWJsZWQpIHtcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gXCJ0ZXN0Y29va2llXCI7XG4gICAgICAgIGNvb2tpZUVuYWJsZWQgPSAoZG9jdW1lbnQuY29va2llLmluZGV4T2YoXCJ0ZXN0Y29va2llXCIpICE9PSAtMSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IpIHtcbiAgICAgICAgICBuYXZpZ2F0b3IuY29va2llRW5hYmxlZCA9IGNvb2tpZUVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWVFbmFibGVkO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENvbnN0cnVjdGlvbiBhIHBvc3Rpb24gY29udGVudCBvYmplY3QgdGhhdCBjb250YWlucyBIVE1MLCBvcHRpb25hbGx5IG1ldGEtZGF0YSwgYW5kIG9wdGlvbmFsbHkgYSBwb3NpdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICBUaGUgaWQgc3BlY2lmaWVkIG11c3QgbWF0Y2ggYW4gaWQgZm9yIGEgJHNmLmhvc3QuUG9zQ29uZmlnIChhbHRob3VnaCBzYWlkIGNvbmZpZyBjb3VsZCBiZSBzcGVjZmllZCBkaXJlY3RseSBoZXJlIHZpYSBhcmd1bWVudHMpLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LlBvc2l0aW9uXG4gICAgQGNvbnN0cnVjdG9yXG4gICAgQHB1YmxpY1xuICAgIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcG9zSURvck9iaiBUaGUgaWQgb2YgdGhlIHBvc2l0aW9uIHdoaWNoIG1hcHMgdG8gaXRzIGNvbmZpZ3VyYXRpb24sIG9yIGFuIG9iamVjdCByZXByZXNldGluZyB0aGUgdmFyaW91cyB2YWx1ZXMgb2YgYW4gJHNmLmhvc3QuUG9zaXRpb24gaW5zdGFuY2UuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLmlkXSBUaGUgaWQgb2YgdGhlIHBvc2l0aW9uIHdoaWNoIG1hcHMgdG8gaXRzIGNvbmZpZ3VyYXRpb24uXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLmh0bWxdIFRoZSBIVE1MIGNvbnRlbnQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBTYWZlRnJhbWUuIE5vdGUgdGhhdCBIVE1MIHN0cmluZ3Mgd2hpY2ggaGF2ZSBTQ1JJUFQgdGFncyBvciBvdGhlciBzcGVjaWFsIGNoYXJhY3RlcnMgbWF5IG5lZWQgdG8gYmUgcHJvcGVybHkgZXNjYXBlZCBpbiBvcmRlciB0byBhdm9pZCBKYXZhU2NyaXB0IHN5bnRheCBlcnJvcnMuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLnNyY10gQW4gb3B0aW9uYWwgVVJMIHRvIGJlIHVzZWQgZm9yIHJlZGVyaW5nIGluc2lkZSB0aGUgU2FmZUZyYW1lIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIFNDUklQVCB0YWcgd2l0aCB0aGUgc3BlY2lmaWVkIFVSTC5cbiAgICBAcGFyYW0geyRzZi5ob3N0LlBvc01ldGF9IFtwb3NJRG9yT2JqLm1ldGFdIEFuIG9wdGlvbmFsIGluc3RhbmNlIG9mIHRoZSAkc2YuaG9zdC5Qb3NNZXRhIG9iamVjdCB0byBiZSBwYXNzZWQgYWxvbmcgaW50byB0aGUgU2FmZUZyYW1lXG4gICAgQHBhcmFtIHtPYmplY3R9IFtwb3NJRG9yT2JqLmNvbmZdIEFuIG9wdGlvbmFsIHJlcHJlc2VudGF0aW9uIG9mIGFuICRzZi5ob3N0LlBvc0NvbmZpZyBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIFNhZmVGcmFtZSBwb3NpdGlvbi5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2h0bWxdIFRoZSBIVE1MIGNvbnRlbnQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBTYWZlRnJhbWUuIE5vdGUgdGhhdCBIVE1MIHN0cmluZ3Mgd2hpY2ggaGF2ZSBTQ1JJUFQgdGFncyBvciBvdGhlciBzcGVjaWFsIGNoYXJhY3RlcnMgbWF5IG5lZWQgdG8gYmUgcHJvcGVybHkgZXNjYXBlZCBpbiBvcmRlciB0byBhdm9pZCBKYXZhU2NyaXB0IHN5bnRheCBlcnJvcnMuXG4gICAgQHBhcmFtIHskc2YuaG9zdC5Qb3NNZXRhfSBbbWV0YV0gQW4gb3B0aW9uYWwgaW5zdGFuY2Ugb2YgdGhlICRzZi5ob3N0LlBvc01ldGEgb2JqZWN0IHRvIGJlIHBhc3NlZCBhbG9uZyBpbnRvIHRoZSBTYWZlRnJhbWVcbiAgICBAcGFyYW0ge09iamVjdH0gW2NvbmZdIEFuIG9wdGlvbmFsIHJlcHJlc2VudGF0aW9uIG9mIGFuICRzZi5ob3N0LlBvc0NvbmZpZyBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIFNhZmVGcmFtZSBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc0lEb3JPYmosIGh0bWwsIG1ldGEsIGNvbmYpIHtcbiAgICAgIHZhciBpZCwgbWUsIG1zZywgb3JpZ0h0bWwsIHR5cDtcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIHR5cCA9IHBvc0lEb3JPYmogJiYgdHlwZW9mIHBvc0lEb3JPYmo7XG4gICAgICBvcmlnSHRtbCA9IGh0bWw7XG4gICAgICBpZiAoIShtZSBpbnN0YW5jZW9mIFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc0lEb3JPYmosIGh0bWwsIG1ldGEsIGNvbmYpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgIG1zZyA9IFwiUHVibGlzaGVyIENvbmZpZyBub3QgaW5pdGlhbGl6ZWQgLSBhYm9ydFwiO1xuICAgICAgICBzZi5saWIubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgIHNmLmluZm8uZXJycy5wdXNoKG1zZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IE9CSikge1xuICAgICAgICBfbWl4KG1lLCBwb3NJRG9yT2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gbWUuaWQgPSBfY3N0cihwb3NJRG9yT2JqKSB8fCBfZ3VpZChQT1NfSURfQVVUT19QUkVGSVgpO1xuICAgICAgfVxuICAgICAgaWYgKCFodG1sKSB7XG4gICAgICAgIGlmIChtZS5zcmMpIHtcbiAgICAgICAgICBtZS5odG1sID0gX2NyZWF0ZV9wb3NfbWFya3VwKG1lLnNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuaHRtbCA9IG1lLmh0bWwgfHwgXCJcIjtcbiAgICAgICAgICBtZS5zcmMgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZS5odG1sID0gaHRtbDtcbiAgICAgICAgbWUuc3JjID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICghbWUuaHRtbCkge1xuICAgICAgICBtZS5odG1sID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIG1lLm1ldGEgPSBtZXRhIHx8IG1lLm1ldGEgfHwge307XG4gICAgICBtZS5jb25mID0gY29uZiB8fCBtZS5jb25mIHx8IHt9O1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLnBvc2l0aW9uc1tpZF0pIHtcbiAgICAgICAgICBtZS5jb25mID0gY29uZmlnLnBvc2l0aW9uc1tpZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgIGNvbmYuaWQgPSBpZDtcbiAgICAgICAgICAgIG1lLmNvbmYgPSBuZXcgUG9zQ29uZmlnKGNvbmYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEBuYW1lc3BhY2UgJHNmLmxpYi5kb20ubXNnaG9zdCBDb250YWlucyBmdW5jdGlvbmFsaXR5IHRvIHJlc2lkZSBpbiB0aGUgdG9wIGxldmVsIHBhZ2UgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZyB4LWRvbWFpbiBtZXNzYWdlcyB0byBTYWZlRnJhbWUgY29udGFpbmVyc1xuICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3RcbiAgICAgKi9cblxuICAgIC8qXG4gICAgUmV0dXJucyB0aGUgcm9vdCBkb2N1bWVudCBIVE1MRWxlbWVudCAvIG5vZGVcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fZG9jTm9kZVxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQW4gSFRNTEVsZW1lbnQgdG8gdXNlIGFzIGEgcmVmZXJlbmNlIGZvciBmaW5kaW5nIHRoZSByb290IGRvY3VtZW50IGVsZW1lbnQuXG4gICAgQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIF9kb2NOb2RlID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBjb21wYXRNb2RlLCBkLCByb290O1xuICAgICAgZCA9IChlbCAmJiBfZG9jKGVsKSkgfHwgZGM7XG4gICAgICBjb21wYXRNb2RlID0gZFtDT01QQVRfTU9ERV07XG4gICAgICByb290ID0gZFtET0NfRUxdO1xuICAgICAgaWYgKGNvbXBhdE1vZGUgJiYgIW9wZXJhVmVyICYmIGNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgIHJvb3QgPSBkLmJvZHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgc3BlY2lmaWVkIGluIHBpeGVsc1xuICAgIEBuYW1lICRzZi5saWIuZG9tLV9pc1BYXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IHZhbCBBIGNzcyB2YWx1ZSBvZiBzaXplXG4gICAgQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgX2lzUFggPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9IF9jc3RyKHZhbCk7XG4gICAgICBpZiAodmFsICYmIHZhbC5zZWFyY2goL1xcRCsvZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCAmJiB2YWwuc2VhcmNoKC9weC9nKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIGFuIGFycmF5IG9mIHZhbHVlcyBvZiBjbGlwcGluZyByZWdpb24gaW5mb3JtYXRpb24uIEFycmF5IHJlcHJlc2VudHMgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IHZhbHVlcyByZXNwZWN0aXZlbHkuXG4gICAgSWYgdmFsdWVzIGFyZSBub3Qgc3BlY2lmaWVkIGluIHBpeGVscywgb3Igbm8gY2xpcCByZWdpb24gaXMgZGVmaW5lZCBmb3IgdGhhdCBlbGVtZW50LCAtMSBpcyByZXR1cm5lZCBmb3IgZWFjaCB2YWx1ZS5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fZ2V0Q2xpcFxuICAgIEBwcml2YXRlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEBwYXJhbSB7SFRNTFN0eWxlT2JqZWN0fSBjdXJTdCBUaGUgY3VycmVudCBzdHlsZSBvYmplY3Qgb2YgYW4gSFRNTEVsZW1lbnRcbiAgICBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBfZ2V0Q2xpcCA9IGZ1bmN0aW9uKGN1clN0KSB7XG4gICAgICB2YXIgY2xpcFZhbCwgaWR4LCBsZW4sIHByb3AsIHByb3BzLCByZXQsIHZhbDtcbiAgICAgIHJldCA9IFstMSwgLTEsIC0xLCAtMV07XG4gICAgICBwcm9wcyA9IFtDTElQICsgXCJUb3BcIiwgQ0xJUCArIFwiUmlnaHRcIiwgQ0xJUCArIFwiQm90dG9tXCIsIENMSVAgKyBcIkxlZnRcIl07XG4gICAgICBpZHggPSAwO1xuICAgICAgY2xpcFZhbCA9IHZvaWQgMDtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICB2YWwgPSB2b2lkIDA7XG4gICAgICBsZW4gPSB2b2lkIDA7XG4gICAgICBpZiAoIWN1clN0KSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBpZiAoaWVWZXIpIHtcbiAgICAgICAgd2hpbGUgKHByb3AgPSBwcm9wc1tpZHhdKSB7XG4gICAgICAgICAgY2xpcFZhbCA9IGN1clN0W3Byb3BdO1xuICAgICAgICAgIGlmIChfaXNQWChjbGlwVmFsKSkge1xuICAgICAgICAgICAgY2xpcFZhbCA9IF9jbnVtKGNsaXBWYWwsIC0xKTtcbiAgICAgICAgICAgIGlmIChjbGlwVmFsID49IDApIHtcbiAgICAgICAgICAgICAgcmV0W2lkeF0gPSBjbGlwVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZHgrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcFZhbCA9IGN1clN0W0NMSVBdO1xuICAgICAgICBpZiAoY2xpcFZhbCAmJiBjbGlwVmFsLnNlYXJjaCgvXFxkKy9nKSAhPT0gLTEpIHtcbiAgICAgICAgICBjbGlwVmFsID0gY2xpcFZhbC5yZXBsYWNlKC9cXHcrXFwoKFteXFwpXSo/KVxcKS9nLCBcIiQxXCIpO1xuICAgICAgICAgIHJldCA9IGNsaXBWYWwuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIHJldCA9IChyZXRbTEVOXSA8PSAxID8gcmV0LnNwbGl0KFwiLFwiKSA6IHJldCk7XG4gICAgICAgICAgbGVuID0gcmV0W0xFTl07XG4gICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgIHZhbCA9IHJldFtpZHhdO1xuICAgICAgICAgICAgaWYgKCFfaXNQWCh2YWwpKSB7XG4gICAgICAgICAgICAgIHJldFtpZHhdID0gLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXRbaWR4XSA9IF9jbnVtKHZhbCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybnMgYm9yZGVyIHZhbHVlcyBpbiBwaXhlbHMgaWYgcG9zc2libGUgdG8gaGVscCBjYWxjdWxhdGUgZ2VvbWV0cnkgb2YgYW4gZWxlbWVudFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLV9jYWxjQm9yZGVyc1xuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBIVE1MRWxlbWVudCBmb3Igd2hpY2ggdG8gbG9vayBhdC4gLiAuXG4gICAgQHBhcmFtIHtPYmplY3R9IHJlY3QgVGhlIHJlY3Qgb2JqZWN0IGdlbmVyYXRlZCBmb3IgdGhlIEhUTUxFbGVtZW50IGluIHF1ZXN0aW9uIHRvIGJlIGFkanVzdGVkXG4gICAgQHJldHVybnMge09iamVjdH0gcmVjdFxuICAgICAqL1xuICAgIF9jYWxjQm9yZGVycyA9IGZ1bmN0aW9uKGVsLCByZWN0KSB7XG4gICAgICB2YXIgbCwgcmUsIHN0LCB0O1xuICAgICAgdCA9IDA7XG4gICAgICBsID0gMDtcbiAgICAgIHN0ID0gdm9pZCAwO1xuICAgICAgcmUgPSAvXnQoPzphYmxlfGR8aHxyfGhlYWR8Zm9vdCkkL2k7XG4gICAgICBzdCA9IGN1cnJlbnRTdHlsZShlbCk7XG4gICAgICBpZiAoc3QpIHtcbiAgICAgICAgdCA9IHN0W1wiYm9yZGVyVG9wV2lkdGhcIl07XG4gICAgICAgIGwgPSBzdFtcImJvcmRlckxlZnRXaWR0aFwiXTtcbiAgICAgICAgdCA9IChfaXNQWCh0KSA/IF9jbnVtKHQsIDApIDogMCk7XG4gICAgICAgIGwgPSAoX2lzUFgobCkgPyBfY251bShsLCAwKSA6IDApO1xuICAgICAgICBpZiAoZ2Vja1ZlciAmJiByZS50ZXN0KF90YWdOYW1lKGVsKSkpIHtcbiAgICAgICAgICB0ID0gbCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY3QgPSByZWN0IHx8IHtcbiAgICAgICAgdDogMCxcbiAgICAgICAgbDogMFxuICAgICAgfTtcbiAgICAgIHJlY3QudCArPSB0O1xuICAgICAgcmVjdC5sICs9IGw7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSBzY3JvbGwgdmFsdWVzIG9mIGEgZG9jdW1lbnRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fZ2V0X2RvY19zY3JvbGxcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIEFuIEhUTUxFbGVtZW50IHRvIHVzZSBhcyBhIHJlZmVyZW5jZSBkb2N1bWVudCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBtYWluIGRvY3VtZW50XG4gICAgQHJldHVybiB7T2JqZWN0fSBDb250YWlucyB4LCB5LCB3LCBoIHByb3BlcnRpZXMgZm9yIHNjcm9sbGluZ1xuICAgICAqL1xuICAgIF9nZXRfZG9jX3Njcm9sbCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZCwgZGIsIGRlLCBkZWYsIGR2LCBvZmZzZXRYLCBvZmZzZXRZLCBwb3M7XG4gICAgICBwb3MgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IDAsXG4gICAgICAgIGg6IDBcbiAgICAgIH07XG4gICAgICBkZWYgPSB7XG4gICAgICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgICAgc2Nyb2xsV2lkdGg6IDAsXG4gICAgICAgIHNjcm9sbEhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIGQgPSB2b2lkIDA7XG4gICAgICBkZSA9IHZvaWQgMDtcbiAgICAgIGR2ID0gdm9pZCAwO1xuICAgICAgZGIgPSB2b2lkIDA7XG4gICAgICBvZmZzZXRYID0gMDtcbiAgICAgIG9mZnNldFkgPSAwO1xuICAgICAgZCA9IF9kb2MoZWwpIHx8IGRjO1xuICAgICAgZGUgPSBkW0RPQ19FTF0gfHwgZGVmO1xuICAgICAgZGIgPSBkLmJvZHkgfHwgZGVmO1xuICAgICAgZHYgPSBkLmRlZmF1bHRWaWV3O1xuICAgICAgaWYgKGR2KSB7XG4gICAgICAgIG9mZnNldFggPSBfY251bShkdi5wYWdlWE9mZnNldCwgMCk7XG4gICAgICAgIG9mZnNldFkgPSBfY251bShkdi5wYWdlWU9mZnNldCwgMCk7XG4gICAgICB9XG4gICAgICBwb3MueCA9IF9tYXgoZGUuc2Nyb2xsTGVmdCwgZGIuc2Nyb2xsTGVmdCwgb2Zmc2V0WCk7XG4gICAgICBwb3MueSA9IF9tYXgoZGUuc2Nyb2xsVG9wLCBkYi5zY3JvbGxUb3AsIG9mZnNldFkpO1xuICAgICAgcG9zLncgPSBfbWF4KGRlLnNjcm9sbFdpZHRoLCBkYi5zY3JvbGxXaWR0aCwgMCk7XG4gICAgICBwb3MuaCA9IF9tYXgoZGUuc2Nyb2xsSGVpZ2h0LCBkYi5zY3JvbGxIZWlnaHQsIDApO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuXG4gICAgLypcbiAgICBDYWxjdWxhdGUgYSBnZW9tZXRyaWMgcmVjdGFuZ2xlIGZvciBhIGdpdmVuIGVsZW1lbnQuIE5vdGUgdGhhdCBmb3IgSUUgYnJvd3NlcnNcbiAgICB3ZSBjYW4gdXNlIHRoZSBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIGZ1bmN0aW9uIHdoaWNoIHNhdmVzIHVzIHNvbWUgdGltZSAvIGluY3JlYXNlc1xuICAgIHBlZm9ybWFuY2UuIC4gaG93ZXZlciBpdCByZWFsbHkgY2FuIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBET00gaXMgY29tcGxldGVseSBsb2FkZWQsXG4gICAgYW5kIGlmIHRoYXQgaXMgdGhlIGNhc2Ugd2UgZmFsbGJhY2sgdG8gdGhlIGJydXRlLWZvcmNlIC8gbm9uLUlFIG1ldGhvZC5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fZ2V0UmVjdElFXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgIFRoZSBlbGVtZW50IGZvciB3aGljaCB0byBkZXJpdmUgYSByZWN0YW5nbGUgb2JqZWN0XG4gICAgQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVjdGFuZ2xlIGZvciB0aGUgZ2l2ZW4gSFRNTEVsZW1lbnRcbiAgICAgKi9cbiAgICBfZ2V0UmVjdElFID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBhZGp1c3RYLCBhZGp1c3RZLCBiTGVmdCwgYlRvcCwgYm94LCBjb21wYXRNb2RlLCBkLCBkZSwgZSwgcmVjdCwgc2Nyb2xsLCBzdCwgX2JhY2s7XG4gICAgICByZWN0ID0ge1xuICAgICAgICB0OiAwLFxuICAgICAgICBsOiAwLFxuICAgICAgICByOiAwLFxuICAgICAgICBiOiAwLFxuICAgICAgICB3OiAwLFxuICAgICAgICBoOiAwLFxuICAgICAgICB6OiAwXG4gICAgICB9O1xuICAgICAgX2JhY2sgPSBcIkJhY2tDb21wYXRcIjtcbiAgICAgIHNjcm9sbCA9IHZvaWQgMDtcbiAgICAgIGJveCA9IHZvaWQgMDtcbiAgICAgIGQgPSB2b2lkIDA7XG4gICAgICBkZSA9IHZvaWQgMDtcbiAgICAgIGNvbXBhdE1vZGUgPSB2b2lkIDA7XG4gICAgICBzdCA9IHZvaWQgMDtcbiAgICAgIGFkanVzdFggPSB2b2lkIDA7XG4gICAgICBhZGp1c3RZID0gdm9pZCAwO1xuICAgICAgYkxlZnQgPSB2b2lkIDA7XG4gICAgICBiVG9wID0gdm9pZCAwO1xuICAgICAgaWYgKGVsICYmIGVsW05PREVfVFlQRV0gPT09IDEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gX2RvYyhlbCkgfHwgZGM7XG4gICAgICAgICAgaWYgKCFkb20ucmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWN0Tm9uSUUoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGwgPSBfZ2V0X2RvY19zY3JvbGwoZWwpO1xuICAgICAgICAgIGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJlY3QudCA9IGJveC50b3A7XG4gICAgICAgICAgcmVjdC5sID0gYm94LmxlZnQ7XG4gICAgICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSBJRV9CT1JERVJfQURKO1xuICAgICAgICAgIGNvbXBhdE1vZGUgPSBkW0NPTVBBVF9NT0RFXTtcbiAgICAgICAgICBkZSA9IGRbRE9DX0VMXTtcbiAgICAgICAgICBzdCA9IGN1cnJlbnRTdHlsZShkZSk7XG4gICAgICAgICAgYkxlZnQgPSBzdFtcImJvcmRlckxlZnRXaWR0aFwiXTtcbiAgICAgICAgICBiVG9wID0gc3RbXCJib3JkZXJUb3BXaWR0aFwiXTtcbiAgICAgICAgICBpZiAoaWVWZXIgPT09IDYpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXRNb2RlICE9PSBfYmFjaykge1xuICAgICAgICAgICAgICBhZGp1c3RYID0gYWRqdXN0WSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21wYXRNb2RlID09PSBfYmFjaykge1xuICAgICAgICAgICAgYkxlZnQgPSAoX2lzUFgoYkxlZnQpID8gX2NudW0oYkxlZnQsIDApIDogMCk7XG4gICAgICAgICAgICBhZGp1c3RYID0gYkxlZnQ7XG4gICAgICAgICAgICBiVG9wID0gKF9pc1BYKGJUb3ApID8gX2NudW0oYlRvcCwgMCkgOiAwKTtcbiAgICAgICAgICAgIGFkanVzdFkgPSBiVG9wO1xuICAgICAgICAgICAgcmVjdC50IC09IGFkanVzdFg7XG4gICAgICAgICAgICByZWN0LmwgLT0gYWRqdXN0WTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjdC50ICs9IHNjcm9sbC55O1xuICAgICAgICAgIHJlY3QubCArPSBzY3JvbGwueDtcbiAgICAgICAgICByZWN0LmIgPSByZWN0LnQgKyBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgcmVjdC5yID0gcmVjdC5sICsgZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgcmVjdC53ID0gX21heChyZWN0LnIgLSByZWN0LmwsIDApO1xuICAgICAgICAgIHJlY3QuaCA9IF9tYXgocmVjdC5iIC0gcmVjdC50LCAwKTtcbiAgICAgICAgICByZWN0LnogPSBjdXJyZW50U3R5bGUoZWwsIFwiekluZGV4XCIpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICB0OiAwLFxuICAgICAgICAgICAgbDogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgdzogMCxcbiAgICAgICAgICAgIGg6IDAsXG4gICAgICAgICAgICB6OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2FsY3VsYXRlIGEgZ2VvbWV0cmljIHJlY3RhbmdsZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBGb3Igbm9uLUlFIGJyb3dzZXJzLCB3ZSBtdXN0IHVzZVxuICAgIGJydXRlLWZvcmNlIGFuZCB3YWxrIHVwIHRoZSBvZmZzZXRQYXJlbnQgdHJlZS4gQWxzbyB0YWtlcyBpbiBjb25zaWRlcmF0aW9uIGZvciBzb21lXG4gICAgb3RoZXIgc2xpZ2h0IHZhcmlhdGlvbnMgaW4gYnJvd3NlcnMuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX2dldFJlY3ROb25JRVxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsICBUaGUgZWxlbWVudCBmb3Igd2hpY2ggdG8gZGVyaXZlIGEgcmVjdGFuZ2xlIG9iamVjdFxuICAgIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlY3RhbmdsZSBmb3IgdGhlIGdpdmVuIEhUTUxFbGVtZW50XG4gICAgICovXG4gICAgX2dldFJlY3ROb25JRSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgYkNoZWNrLCBlLCBoLCBwYXJlbnROb2RlLCByZWN0LCByb290LCBzY3JvbGwsIHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgdztcbiAgICAgIHJlY3QgPSB7XG4gICAgICAgIHQ6IDAsXG4gICAgICAgIGw6IDAsXG4gICAgICAgIHI6IDAsXG4gICAgICAgIGI6IDAsXG4gICAgICAgIHc6IDAsXG4gICAgICAgIGg6IDAsXG4gICAgICAgIHo6IDBcbiAgICAgIH07XG4gICAgICBzY3JvbGxUb3AgPSAwO1xuICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICBiQ2hlY2sgPSBmYWxzZTtcbiAgICAgIHJvb3QgPSBfZG9jTm9kZShlbCk7XG4gICAgICBzY3JvbGwgPSBfZ2V0X2RvY19zY3JvbGwoZWwpO1xuICAgICAgcGFyZW50Tm9kZSA9IHZvaWQgMDtcbiAgICAgIHcgPSB2b2lkIDA7XG4gICAgICBoID0gdm9pZCAwO1xuICAgICAgaWYgKGVsICYmIGVsW05PREVfVFlQRV0gPT09IDEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWN0LmwgPSBlbC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgICAgcmVjdC50ID0gZWwub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9IGVsO1xuICAgICAgICAgIGJDaGVjayA9IGdlY2tWZXIgfHwgd2JWZXIgPiA1MTk7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgcmVjdC50ICs9IHBhcmVudE5vZGUub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgICByZWN0LmwgKz0gcGFyZW50Tm9kZS5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgICAgICBpZiAoYkNoZWNrKSB7XG4gICAgICAgICAgICAgIF9jYWxjQm9yZGVycyhwYXJlbnROb2RlLCByZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnROb2RlID0gZWw7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZShwYXJlbnROb2RlLCBcInBvc2l0aW9uXCIpICE9PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBlbDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnROb2RlID0gX3BhcihwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZVtOT0RFX1RZUEVdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gcGFyZW50Tm9kZS5zY3JvbGxUb3AgfHwgMDtcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gcGFyZW50Tm9kZS5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGdlY2tWZXIgJiYgY3VycmVudFN0eWxlKHBhcmVudE5vZGUsIE9WRVIpICE9PSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgICAgX2NhbGNCb3JkZXJzKHBhcmVudE5vZGUsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0LmwgLT0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICByZWN0LnQgLT0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3QudCArPSBzY3JvbGwueTtcbiAgICAgICAgICAgIHJlY3QubCArPSBzY3JvbGwueDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdC50ICs9IHNjcm9sbC55O1xuICAgICAgICAgICAgcmVjdC5sICs9IHNjcm9sbC54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWllVmVyICYmIGVsID09PSBfZG9jTm9kZShlbCkpIHtcbiAgICAgICAgICAgIGggPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB3ID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB3ID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlY3QuYiA9IHJlY3QudCArIGg7XG4gICAgICAgICAgcmVjdC5yID0gcmVjdC5sICsgdztcbiAgICAgICAgICByZWN0LncgPSBfbWF4KHJlY3QuciAtIHJlY3QubCwgMCk7XG4gICAgICAgICAgcmVjdC5oID0gX21heChyZWN0LmIgLSByZWN0LnQsIDApO1xuICAgICAgICAgIHJlY3QueiA9IGN1cnJlbnRTdHlsZShlbCwgXCJ6SW5kZXhcIik7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgICBsOiAwLFxuICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICB3OiAwLFxuICAgICAgICAgICAgaDogMCxcbiAgICAgICAgICAgIHo6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSByZWN0YW5nbGUgd2l0aCB0aGUgZ2VvbWV0cmljIGluZm9ybWF0aW9uIG9mIGFuIEhUTUxEb2N1bWVudFxuICAgIChpbmNsdWRlcyBzY3JvbGwgd2lkdGggLyBoZWlnaHQpXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uZG9jUmVjdFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gW2VsXSBBbiBIVE1MRWxlbWVudCB0byB1c2UgYXMgdGhlIHJlZmVyZW5jZSBmb3IgYW4gSFRNTERvY3VtZW50XG4gICAgQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBkb2NSZWN0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBoLCByb290LCB3O1xuICAgICAgcm9vdCA9IF9kb2NOb2RlKGVsKTtcbiAgICAgIHcgPSAwO1xuICAgICAgaCA9IDA7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICB3ID0gcm9vdC5zY3JvbGxXaWR0aCB8fCAwO1xuICAgICAgICBoID0gcm9vdC5zY3JvbGxIZWlnaHQgfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHQ6IDAsXG4gICAgICAgIGw6IDAsXG4gICAgICAgIGI6IGgsXG4gICAgICAgIHI6IHcsXG4gICAgICAgIHc6IHcsXG4gICAgICAgIGg6IGhcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgcmVjdGFuZ2xlIHdpdGggdGhlIGdlb21ldHJpYyBpbmZvcm1hdGlvbiBvZiBhbiBIVE1MV2luZG93XG4gICAgKGRvZXMgbm90IGluY2x1ZGUgc2Nyb2xsIHdpZHRoIC8gaGVpZ2h0KVxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLndpblJlY3RcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQW4gSFRNTEVsZW1lbnQgdG8gdXNlIGFzIHRoZSByZWZlcmVuY2VzIGZvciBhbiBIVE1MV2luZG93XG4gICAgQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB3aW5SZWN0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBiLCBoLCBsLCByLCByb290LCB0LCB3LCB3aTtcbiAgICAgIHdpID0gKGVsICYmIF92aWV3KGVsKSkgfHwgd2luO1xuICAgICAgaCA9IHdpLmlubmVySGVpZ2h0IHx8IDA7XG4gICAgICB3ID0gd2kuaW5uZXJXaWR0aCB8fCAwO1xuICAgICAgdCA9IHdpLnNjcmVlblkgfHwgd2kuc2NyZWVuVG9wIHx8IDA7XG4gICAgICBiID0gaCArIHQ7XG4gICAgICBsID0gd2kuc2NyZWVuWCB8fCB3aS5zY3JlZW5MZWZ0IHx8IDA7XG4gICAgICByID0gdyArIGw7XG4gICAgICByb290ID0gX2RvY05vZGUoZWwpO1xuICAgICAgaWYgKCFoICYmICF3ICYmIHJvb3QpIHtcbiAgICAgICAgaCA9IHJvb3QuY2xpZW50SGVpZ2h0IHx8IDA7XG4gICAgICAgIHcgPSByb290LmNsaWVudFdpZHRoIHx8IDA7XG4gICAgICAgIHIgPSBsICsgdztcbiAgICAgICAgYiA9IHQgKyBoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdDogdCxcbiAgICAgICAgbDogbCxcbiAgICAgICAgYjogYixcbiAgICAgICAgcjogcixcbiAgICAgICAgdzogdyxcbiAgICAgICAgaDogaFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIEhUTUxFbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW5vdGhlciBIVE1MRWxlbWVudFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmNvbnRhaW5zXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBIVE1MRWxlbWVudCByZWZlcmVuY2UgdG8gc2VhcmNoIHdpdGhpblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5lZWRsZSBUaGUgSFRNTEVsZW1lbnQgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoZWNrIGlmIGl0cyBjb250YWluZWQgYnkgdGhlIDFzdCBwYXJhbWV0ZXJcbiAgICBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWlucyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5lZWRsZSkge1xuICAgICAgdmFyIGVsX25vZGVfdHlwZSwgbmVlZGxlX25vZGVfdHlwZSwgcmV0O1xuICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICBlbF9ub2RlX3R5cGUgPSAoZWxlbWVudCAmJiBlbGVtZW50W05PREVfVFlQRV0pIHx8IC0xO1xuICAgICAgbmVlZGxlX25vZGVfdHlwZSA9IChuZWVkbGUgJiYgbmVlZGxlW05PREVfVFlQRV0pIHx8IC0xO1xuICAgICAgaWYgKGVsX25vZGVfdHlwZSA9PT0gMSAmJiBuZWVkbGVfbm9kZV90eXBlICE9PSAtMSkge1xuICAgICAgICBpZiAoZWxlbWVudFtDT05UQUlOU10pIHtcbiAgICAgICAgICBpZiAob3BlcmFWZXIgfHwgbmVlZGxlX25vZGVfdHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0ID0gZWxlbWVudFtDT05UQUlOU10obmVlZGxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKG5lZWRsZSkge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gbmVlZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZWVkbGUgPSBuZWVkbGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRbQ09NUEFSRV9ET0NfUE9TXSkge1xuICAgICAgICAgICAgcmV0ID0gZWxlbWVudCA9PT0gbmVlZGxlIHx8ICEhKGVsZW1lbnRbQ09NUEFSRV9ET0NfUE9TXShuZWVkbGUpICYgMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgc3R5bGUgYXR0cmlidXRlLCBvciB0aGUgY3VycmVudCBzdHlsZSBvYmplY3QgaW4gaXRzIGVudGlyZXR5IGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIGF0dHJpYnV0ZSBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uY3VycmVudFN0eWxlXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIGluZm9ybWF0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IFthdHRyXSBUaGUgc3R5bGUgYXR0cmlidXRlIChpbiBKYXZhU2NyaXB0IG5vdGF0aW9uLCBlLmcuICdiYWNrZ3JvdW5kQ29sb3InIHJhdGhlciB0aGFuICdiYWNrZ3JvdW5kLWNvbG9yJykgdG8gZmV0Y2guXG4gICAgQHJldHVybiB7SFRNTFN0eWxlT2JqZWN0fSBBbiBIVE1MU3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgY3VycmVudCBzdHlsZSBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgQHJldHVybiB7U3RyaW5nfSBUaGUgdmFsdWUgb2YgYW4gc3R5bGUgYXR0cmlidXRlIChvbmx5IGlmIGF0dHIgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCkuXG4gICAgICovXG4gICAgY3VycmVudFN0eWxlID0gZnVuY3Rpb24oZWwsIGF0dHIpIHtcbiAgICAgIHZhciBjb21wLCBlLCBoYXNBdHRyLCB2YWw7XG4gICAgICB2YWwgPSBcIlwiO1xuICAgICAgaGFzQXR0ciA9ICEhKGFyZ3VtZW50cy5sZW5ndGggJiYgYXR0cik7XG4gICAgICBjb21wID0gXCJnZXRDb21wdXRlZFN0eWxlXCI7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgaWYgKGhhc0F0dHIpIHtcbiAgICAgICAgaWYgKGllVmVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZVthdHRyXTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsID0gX3ZpZXcoZWwpW2NvbXBdKGVsLCBudWxsKVthdHRyXTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGllVmVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsID0gX3ZpZXcoZWwpW2NvbXBdKGVsLCBudWxsKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDYWxjdWxhdGUgdGhlIHN1cnJvdW5kaW5nIGJvdW5kYXJpZXMgb2YgYW4gSFRNTEVsZW1lbnQsIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgSFRNTEVsZW1lbnQgaXMgXCJpbi12aWV3XCIgb2YgdGhlIHVzZXJcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5ib3VuZHNcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgaW5mb3JtYXRpb25cbiAgICBAcGFyYW0ge09iamVjdH0gW2RldGFpbHNdIEFuIG9iamVjdCByZWZlcmVuY2UgdXNlZCBhcyBhbiBvdXRwdXQgcGFyYW1ldGVyIGluIHdoaWNoIGZ1cnRoZXIgZGV0YWlscyBhYm91dCB0aGUgYm91bmRhcmllcyBvZiB0aGUgZWxlbWVudCBhcmUgc3BlY2lmaWVkXG4gICAgQHBhcmFtIHtCb29sZWFufSBbY2hlY2tfM0RdIENoZWNrIHRoZSBlbGVtZW50IHdpdGhpbiAzIGRpbWVuc2lvbmFsIHNwYWNlIHN1Y2ggdGhhdCBhbnkgZWxlbWVudHMgY292ZXJpbmcgc2FpZCBlbGVtZW50IGFyZSBhbHNvIHRha2UgaW50byBjb25zaWRlcmF0aW9uXG4gICAgQHJldHVybnMge09iamVjdH0gaW5mbyBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZWxlbWVudCBib3VuZGFyaWVzXG4gICAgICovXG4gICAgYm91bmRzID0gZnVuY3Rpb24oZWwsIGRldGFpbHMsIGNoZWNrXzNEKSB7XG4gICAgICB2YXIgYiwgY2xpZW50X2hlaWdodCwgY2xpZW50X3dpZHRoLCBjbGlwLCBjbGlwX3JlY3QsIGN1cl9zdCwgZG9jX3JlY3QsIGVsX3JlY3QsIGV4cF9yZWN0LCBoLCBpc19zY3JvbGxfbm9kZSwgaXNfdXNpbmdfZG9jX3Jvb3RfYiwgaXNfdXNpbmdfZG9jX3Jvb3RfciwgbCwgb2Zmc2V0X2hlaWdodCwgb2Zmc2V0X3dpZHRoLCBvdmVyX3hfdmFsLCBvdmVyX3lfdmFsLCBwYXIsIHIsIHJlZl9ub2RlLCByb290LCByb290X3JlY3QsIHJvb3Rfc2Nyb2xsLCBzY3JvbGxfaGVpZ2h0LCBzY3JvbGxfbGVmdCwgc2Nyb2xsX3RvcCwgc2Nyb2xsX3dpZHRoLCB0LCB0ZW1wX3JlY3QsIHcsIHhfaGlkZGVuLCB4c2JfaCwgeV9oaWRkZW4sIHlzYl93O1xuICAgICAgcGFyID0gZWwgJiYgX3BhcihlbCk7XG4gICAgICByb290ID0gX2RvY05vZGUoZWwpO1xuICAgICAgZWxfcmVjdCA9IF9yZWN0KGVsKTtcbiAgICAgIHJvb3RfcmVjdCA9IF9yZWN0KHJvb3QpO1xuICAgICAgcm9vdF9zY3JvbGwgPSBfZ2V0X2RvY19zY3JvbGwocm9vdCk7XG4gICAgICBkb2NfcmVjdCA9IGRvY1JlY3QoZWwpO1xuICAgICAgY2xpcF9yZWN0ID0ge1xuICAgICAgICB0OiAwLFxuICAgICAgICBsOiAwLFxuICAgICAgICByOiAwLFxuICAgICAgICBiOiAwLFxuICAgICAgICB3OiAwLFxuICAgICAgICBoOiAwXG4gICAgICB9O1xuICAgICAgZXhwX3JlY3QgPSB7XG4gICAgICAgIHQ6IDAsXG4gICAgICAgIGw6IDAsXG4gICAgICAgIHI6IDAsXG4gICAgICAgIGI6IDAsXG4gICAgICAgIHhzOiAwLFxuICAgICAgICB5czogMCxcbiAgICAgICAgeGl2OiAwLFxuICAgICAgICB5aXY6IDAsXG4gICAgICAgIGl2OiAwLFxuICAgICAgICB3OiAwLFxuICAgICAgICBoOiAwXG4gICAgICB9O1xuICAgICAgeHNiX2ggPSAwO1xuICAgICAgeXNiX3cgPSAwO1xuICAgICAgaXNfc2Nyb2xsX25vZGUgPSBmYWxzZTtcbiAgICAgIGlzX3VzaW5nX2RvY19yb290X3IgPSBmYWxzZTtcbiAgICAgIGlzX3VzaW5nX2RvY19yb290X2IgPSBmYWxzZTtcbiAgICAgIGN1cl9zdCA9IHZvaWQgMDtcbiAgICAgIHcgPSB2b2lkIDA7XG4gICAgICBoID0gdm9pZCAwO1xuICAgICAgdCA9IHZvaWQgMDtcbiAgICAgIGwgPSB2b2lkIDA7XG4gICAgICByID0gdm9pZCAwO1xuICAgICAgYiA9IHZvaWQgMDtcbiAgICAgIHNjcm9sbF93aWR0aCA9IHZvaWQgMDtcbiAgICAgIG9mZnNldF93aWR0aCA9IHZvaWQgMDtcbiAgICAgIGNsaWVudF93aWR0aCA9IHZvaWQgMDtcbiAgICAgIHNjcm9sbF9oZWlnaHQgPSB2b2lkIDA7XG4gICAgICBvZmZzZXRfaGVpZ2h0ID0gdm9pZCAwO1xuICAgICAgY2xpZW50X2hlaWdodCA9IHZvaWQgMDtcbiAgICAgIG92ZXJfeF92YWwgPSB2b2lkIDA7XG4gICAgICBzY3JvbGxfbGVmdCA9IHZvaWQgMDtcbiAgICAgIHNjcm9sbF90b3AgPSB2b2lkIDA7XG4gICAgICBvdmVyX3lfdmFsID0gdm9pZCAwO1xuICAgICAgY2xpcCA9IHZvaWQgMDtcbiAgICAgIHhfaGlkZGVuID0gdm9pZCAwO1xuICAgICAgeV9oaWRkZW4gPSB2b2lkIDA7XG4gICAgICByZWZfbm9kZSA9IHZvaWQgMDtcbiAgICAgIHRlbXBfcmVjdCA9IHZvaWQgMDtcbiAgICAgIGlzX3Njcm9sbF9ub2RlID0gZmFsc2U7XG4gICAgICBkZXRhaWxzID0gKGRldGFpbHMgJiYgdHlwZW9mIGRldGFpbHMgPT09IE9CSiA/IGRldGFpbHMgOiB7fSk7XG4gICAgICBpZiAocGFyKSB7XG4gICAgICAgIHdoaWxlIChjdXJfc3QgPSBjdXJyZW50U3R5bGUocGFyKSkge1xuICAgICAgICAgIGlmIChjdXJfc3RbXCJkaXNwbGF5XCJdID09PSBcImJsb2NrXCIgfHwgY3VyX3N0W1wicG9zaXRpb25cIl0gPT09IFwiYWJzb2x1dGVcIiB8fCBjdXJfc3RbXCJmbG9hdFwiXSAhPT0gXCJub25lXCIgfHwgY3VyX3N0W1wiY2xlYXJcIl0gIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBvdmVyX3hfdmFsID0gY3VyX3N0W09WRVIgKyBcIlhcIl07XG4gICAgICAgICAgICBvdmVyX3lfdmFsID0gY3VyX3N0W09WRVIgKyBcIllcIl07XG4gICAgICAgICAgICBjbGlwID0gX2dldENsaXAoY3VyX3N0KTtcbiAgICAgICAgICAgIGlmIChwYXIgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsX3dpZHRoID0gcm9vdF9zY3JvbGwudztcbiAgICAgICAgICAgICAgc2Nyb2xsX2hlaWdodCA9IHJvb3Rfc2Nyb2xsLmg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY3JvbGxfd2lkdGggPSBwYXIuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICAgIHNjcm9sbF9oZWlnaHQgPSBwYXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0X3dpZHRoID0gcGFyLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgb2Zmc2V0X2hlaWdodCA9IHBhci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBjbGllbnRfd2lkdGggPSBwYXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBjbGllbnRfaGVpZ2h0ID0gcGFyLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGlmIChvdmVyX3hfdmFsID09PSBISURERU4gfHwgY2xpcFsxXSA+IDAgfHwgY2xpcFszXSA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKCFyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgIHhfaGlkZGVuID0gMTtcbiAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJfeV92YWwgPT09IEhJRERFTiB8fCBjbGlwWzBdID4gMCB8fCBjbGlwWzJdID4gMCkge1xuICAgICAgICAgICAgICBpZiAoIXJlZl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgeV9oaWRkZW4gPSAxO1xuICAgICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3Zlcl94X3ZhbCA9PT0gU0NST0xMKSB7XG4gICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICB4c2JfaCA9IG9mZnNldF9oZWlnaHQgLSBjbGllbnRfaGVpZ2h0O1xuICAgICAgICAgICAgICBpc19zY3JvbGxfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3Zlcl95X3ZhbCA9PT0gU0NST0xMKSB7XG4gICAgICAgICAgICAgIGlmICghcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB5c2JfdyA9IG9mZnNldF93aWR0aCAtIGNsaWVudF93aWR0aDtcbiAgICAgICAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJfeF92YWwgPT09IEFVVE8pIHtcbiAgICAgICAgICAgICAgaWYgKCFyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzY3JvbGxfd2lkdGggPiBjbGllbnRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4c2JfaCA9IG9mZnNldF9oZWlnaHQgLSBjbGllbnRfaGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzX3Njcm9sbF9ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdmVyX3lfdmFsID09PSBBVVRPKSB7XG4gICAgICAgICAgICAgIGlmICghcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2Nyb2xsX2hlaWdodCA+IGNsaWVudF9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB5c2JfdyA9IG9mZnNldF93aWR0aCAtIGNsaWVudF93aWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc19zY3JvbGxfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXIgPT09IHJvb3QpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxfd2lkdGggPiBjbGllbnRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgaCA9ICh3aW4uaW5uZXJIZWlnaHQgfHwgMCkgfHwgb2Zmc2V0X2hlaWdodDtcbiAgICAgICAgICAgICAgeHNiX2ggPSBoIC0gY2xpZW50X2hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY3JvbGxfaGVpZ2h0ID4gY2xpZW50X2hlaWdodCkge1xuICAgICAgICAgICAgICB3ID0gKHdpbi5pbm5lcldpZHRoIHx8IDApIHx8IG9mZnNldF93aWR0aDtcbiAgICAgICAgICAgICAgeXNiX3cgPSB3IC0gY2xpZW50X3dpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXIgPSBfcGFyKHBhcik7XG4gICAgICAgICAgaWYgKCFwYXIgfHwgcGFyW05PREVfVFlQRV0gIT09IDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsX3JlY3QudyAmJiBlbF9yZWN0LmgpIHtcbiAgICAgICAgaWYgKCFyZWZfbm9kZSB8fCByZWZfbm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgIGV4cF9yZWN0LnQgPSBfbWF4KGVsX3JlY3QudCwgMCk7XG4gICAgICAgICAgZXhwX3JlY3QubCA9IF9tYXgoZWxfcmVjdC5sLCAwKTtcbiAgICAgICAgICBpZiAoaWVWZXIgJiYgZGNbQ09NUEFUX01PREVdID09PSBcIkJhY2tDb21wYXRcIiAmJiBfYXR0cihyb290LCBTQ1JPTEwpID09PSBcIm5vXCIpIHtcbiAgICAgICAgICAgIHlfaGlkZGVuID0geF9oaWRkZW4gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJfc3QgPSBjdXJyZW50U3R5bGUocm9vdCk7XG4gICAgICAgICAgICBpZiAoY3VyX3N0KSB7XG4gICAgICAgICAgICAgIHhfaGlkZGVuID0gY3VyX3N0W09WRVIgKyBcIlhcIl0gPT09IEhJRERFTjtcbiAgICAgICAgICAgICAgeV9oaWRkZW4gPSBjdXJfc3RbT1ZFUiArIFwiWVwiXSA9PT0gSElEREVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdF9zY3JvbGwuaCA+IHJvb3QuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoeV9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc191c2luZ19kb2Nfcm9vdF9iID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IF9tYXgoKChkb2NfcmVjdC5oIC0gZWxfcmVjdC5oKSAtIHhzYl9oKSAtIGVsX3JlY3QudCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cF9yZWN0LmIgPSBfbWF4KCgocm9vdF9yZWN0LmggLSBlbF9yZWN0LmgpIC0geHNiX2gpIC0gZWxfcmVjdC50LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3Rfc2Nyb2xsLncgPiByb290LmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoeF9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc191c2luZ19kb2Nfcm9vdF9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IF9tYXgoKChkb2NfcmVjdC53IC0gZWxfcmVjdC53KSAtIHlzYl93KSAtIGVsX3JlY3QubCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cF9yZWN0LnIgPSBfbWF4KCgocm9vdF9yZWN0LnIgLSBlbF9yZWN0LncpIC0geXNiX3cpIC0gZWxfcmVjdC5sLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyX3N0ID0gY3VycmVudFN0eWxlKHJlZl9ub2RlKTtcbiAgICAgICAgICBpZiAoX3RhZ05hbWUocmVmX25vZGUpID09PSBcImJvZHlcIikge1xuICAgICAgICAgICAgcmVmX25vZGUgPSByb290O1xuICAgICAgICAgICAgdCA9IGVsX3JlY3QudDtcbiAgICAgICAgICAgIGwgPSBlbF9yZWN0Lmw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQgPSBsID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xpcF9yZWN0ID0gX3JlY3QocmVmX25vZGUpO1xuICAgICAgICAgIGlmIChjbGlwWzFdID4gMCkge1xuICAgICAgICAgICAgY2xpcF9yZWN0LncgPSBjbGlwWzFdO1xuICAgICAgICAgICAgY2xpcF9yZWN0LnIgPSBjbGlwX3JlY3QubCArIGNsaXBfcmVjdC53O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xpcFszXSA+IDApIHtcbiAgICAgICAgICAgIGNsaXBfcmVjdC5sID0gY2xpcF9yZWN0LmwgKyBjbGlwWzNdO1xuICAgICAgICAgICAgY2xpcF9yZWN0LncgPSBjbGlwX3JlY3QudyAtIGNsaXBbM107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbGlwWzJdID4gMCkge1xuICAgICAgICAgICAgY2xpcF9yZWN0LmggPSBjbGlwWzJdO1xuICAgICAgICAgICAgY2xpcF9yZWN0LmIgPSBjbGlwX3JlY3QudCArIGNsaXBfcmVjdC5oO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xpcFswXSA+IDApIHtcbiAgICAgICAgICAgIGNsaXBfcmVjdC50ID0gY2xpcF9yZWN0LnQgKyBjbGlwWzBdO1xuICAgICAgICAgICAgY2xpcF9yZWN0LmggPSBjbGlwX3JlY3QuaCAtIGNsaXBbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbF9yZWN0LnQgPiBjbGlwX3JlY3QudCAmJiBjbGlwX3JlY3QudCA+IDApIHtcbiAgICAgICAgICAgIHQgPSBlbF9yZWN0LnQgLSBjbGlwX3JlY3QudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsX3JlY3QubCA+IGNsaXBfcmVjdC5sICYmIGNsaXBfcmVjdC5sID4gMCkge1xuICAgICAgICAgICAgbCA9IGVsX3JlY3QubCAtIGNsaXBfcmVjdC5sO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxfdG9wID0gcmVmX25vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgIHNjcm9sbF9sZWZ0ID0gcmVmX25vZGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgICBzY3JvbGxfaGVpZ2h0ID0gcmVmX25vZGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIHNjcm9sbF93aWR0aCA9IHJlZl9ub2RlLnNjcm9sbFdpZHRoO1xuICAgICAgICAgIGV4cF9yZWN0LnQgPSBfbWF4KHQsIDApO1xuICAgICAgICAgIGV4cF9yZWN0LmwgPSBfbWF4KGwsIDApO1xuICAgICAgICAgIGlmIChjdXJfc3QpIHtcbiAgICAgICAgICAgIHhfaGlkZGVuID0gY3VyX3N0W09WRVIgKyBcIlhcIl0gPT09IEhJRERFTiB8fCBjbGlwWzFdID4gMCB8fCBjbGlwWzNdID4gMDtcbiAgICAgICAgICAgIHlfaGlkZGVuID0gY3VyX3N0W09WRVIgKyBcIllcIl0gPT09IEhJRERFTiB8fCBjbGlwWzBdID4gMCB8fCBjbGlwWzJdID4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsX3JlY3QudCA+PSBjbGlwX3JlY3QuYikge1xuICAgICAgICAgICAgZXhwX3JlY3QuYiA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgheV9oaWRkZW4gJiYgZWxfcmVjdC50ID49IGNsaXBfcmVjdC5iKSB7XG4gICAgICAgICAgICAgIHlfaGlkZGVuID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY3JvbGxfaGVpZ2h0ID4gcmVmX25vZGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGlmICh5X2hpZGRlbikge1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSBfbWF4KCgoc2Nyb2xsX2hlaWdodCAtIGVsX3JlY3QuaCkgLSB4c2JfaCkgLSB0LCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IF9tYXgoKChjbGlwX3JlY3QuaCAtIGVsX3JlY3QuaCkgLSB4c2JfaCkgLSB0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsX3JlY3QubCA+PSBjbGlwX3JlY3Qucikge1xuICAgICAgICAgICAgZXhwX3JlY3QuciA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgheF9oaWRkZW4gJiYgZWxfcmVjdC5sID49IGNsaXBfcmVjdC5yKSB7XG4gICAgICAgICAgICAgIHhfaGlkZGVuID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY3JvbGxfd2lkdGggPiByZWZfbm9kZS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICBpZiAoeF9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBleHBfcmVjdC5yID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBfcmVjdC5yID0gX21heCgoKHNjcm9sbF93aWR0aCAtIGVsX3JlY3QudykgLSB5c2JfdykgLSBsLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IF9tYXgoKChjbGlwX3JlY3QudyAtIGVsX3JlY3QudykgLSB5c2JfdykgLSBsLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwX3JlY3QueHMgPSAoeHNiX2ggPyAxIDogMCk7XG4gICAgICAgIGV4cF9yZWN0LnlzID0gKHlzYl93ID8gMSA6IDApO1xuICAgICAgICBleHBfcmVjdC53ID0gZXhwX3JlY3QuciArIGV4cF9yZWN0Lmw7XG4gICAgICAgIGV4cF9yZWN0LmggPSBleHBfcmVjdC50ICsgZXhwX3JlY3QuYjtcbiAgICAgICAgaWYgKCFyZWZfbm9kZSB8fCByZWZfbm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgIHRlbXBfcmVjdCA9IHJvb3RfcmVjdDtcbiAgICAgICAgICByZWZfbm9kZSA9IHJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcF9yZWN0ID0gY2xpcF9yZWN0O1xuICAgICAgICB9XG4gICAgICAgIGwgPSBfbWF4KGVsX3JlY3QubCwgdGVtcF9yZWN0LmwpO1xuICAgICAgICByID0gX21pbihlbF9yZWN0LnIsIChpc191c2luZ19kb2Nfcm9vdF9yID8gX21pbihkb2NfcmVjdC5yLCB0ZW1wX3JlY3QucikgOiB0ZW1wX3JlY3QucikpO1xuICAgICAgICB3ID0gX21heChyIC0gbCwgMCk7XG4gICAgICAgIHQgPSBfbWF4KGVsX3JlY3QudCwgdGVtcF9yZWN0LnQpO1xuICAgICAgICBiID0gX21pbihlbF9yZWN0LmIsIChpc191c2luZ19kb2Nfcm9vdF9iID8gX21pbihkb2NfcmVjdC5iLCB0ZW1wX3JlY3QuYikgOiB0ZW1wX3JlY3QuYikpO1xuICAgICAgICBoID0gX21heChiIC0gdCwgMCk7XG4gICAgICAgIGV4cF9yZWN0LnhpdiA9IF9jbnVtKCh3IC8gZWxfcmVjdC53KVtURlhEXSgyKSk7XG4gICAgICAgIGV4cF9yZWN0LnlpdiA9IF9jbnVtKChoIC8gZWxfcmVjdC5oKVtURlhEXSgyKSk7XG4gICAgICAgIGV4cF9yZWN0Lml2ID0gX2NudW0oKCh3ICogaCkgLyAoZWxfcmVjdC53ICogZWxfcmVjdC5oKSlbVEZYRF0oMikpO1xuICAgICAgfVxuICAgICAgZGV0YWlscy5yZWZOb2RlID0gcmVmX25vZGUgfHwgcm9vdDtcbiAgICAgIGRldGFpbHMuaXNSb290ID0gcmVmX25vZGUgPT09IHJvb3Q7XG4gICAgICBkZXRhaWxzLmNhblNjcm9sbCA9IGlzX3Njcm9sbF9ub2RlO1xuICAgICAgZGV0YWlscy5yZWZSZWN0ID0gKCFyZWZfbm9kZSB8fCByZWZfbm9kZSA9PT0gcm9vdCA/IHJvb3RfcmVjdCA6IGNsaXBfcmVjdCk7XG4gICAgICBkZXRhaWxzLmV4cFJlY3QgPSBleHBfcmVjdDtcbiAgICAgIGRldGFpbHMucmVjdCA9IGVsX3JlY3Q7XG4gICAgICBpZiAoY2hlY2tfM0QpIHtcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhck92cmxhcHMsIGVsX2FyZWEsIGVsX2gsIGVsX3csIGlkeCwgbGVuLCBuZXdfaXYsIG5ld194aXYsIG5ld195aXYsIG92cl9hcmVhLCBvdnJfbm9kZSwgb3ZyX25vZGVfcmVjdDtcbiAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgYXJPdnJsYXBzID0gdm9pZCAwO1xuICAgICAgICAgIGVsX3cgPSB2b2lkIDA7XG4gICAgICAgICAgZWxfaCA9IHZvaWQgMDtcbiAgICAgICAgICBlbF9hcmVhID0gdm9pZCAwO1xuICAgICAgICAgIG92cl9ub2RlID0gdm9pZCAwO1xuICAgICAgICAgIG92cl9ub2RlX3JlY3QgPSB2b2lkIDA7XG4gICAgICAgICAgdCA9IHZvaWQgMDtcbiAgICAgICAgICBiID0gdm9pZCAwO1xuICAgICAgICAgIGwgPSB2b2lkIDA7XG4gICAgICAgICAgciA9IHZvaWQgMDtcbiAgICAgICAgICBoID0gdm9pZCAwO1xuICAgICAgICAgIHcgPSB2b2lkIDA7XG4gICAgICAgICAgb3ZyX2FyZWEgPSB2b2lkIDA7XG4gICAgICAgICAgbmV3X2l2ID0gdm9pZCAwO1xuICAgICAgICAgIG5ld194aXYgPSB2b2lkIDA7XG4gICAgICAgICAgbmV3X3lpdiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoZXhwX3JlY3QuaXYgPiAuNSkge1xuICAgICAgICAgICAgbWdyX2JvdW5kc19kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgICAgIGFyT3ZybGFwcyA9IG92ZXJsYXBzKGVsLCBfY251bShjaGVja18zRCwgMSwgMSkpO1xuICAgICAgICAgICAgbWdyX2JvdW5kc19kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgICAgIGxlbiA9IGFyT3ZybGFwc1tMRU5dO1xuICAgICAgICAgICAgZWxfdyA9IGVsX3JlY3QudztcbiAgICAgICAgICAgIGVsX2ggPSBlbF9yZWN0Lmg7XG4gICAgICAgICAgICBlbF9hcmVhID0gZWxfdyAqIGVsX2g7XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChvdnJfbm9kZSA9IGFyT3ZybGFwc1tpZHgrK10pIHtcbiAgICAgICAgICAgICAgICBvdnJfbm9kZV9yZWN0ID0gX3JlY3Qob3ZyX25vZGUpO1xuICAgICAgICAgICAgICAgIGwgPSBfbWF4KGVsX3JlY3QubCwgb3ZyX25vZGVfcmVjdC5sKTtcbiAgICAgICAgICAgICAgICByID0gX21pbihlbF9yZWN0LnIsIG92cl9ub2RlX3JlY3Qucik7XG4gICAgICAgICAgICAgICAgdCA9IF9tYXgoZWxfcmVjdC50LCBvdnJfbm9kZV9yZWN0LnQpO1xuICAgICAgICAgICAgICAgIGIgPSBfbWluKGVsX3JlY3QuYiwgb3ZyX25vZGVfcmVjdC5iKTtcbiAgICAgICAgICAgICAgICB3ID0gciAtIGw7XG4gICAgICAgICAgICAgICAgaCA9IGIgLSB0O1xuICAgICAgICAgICAgICAgIG92cl9hcmVhID0gdyAqIGg7XG4gICAgICAgICAgICAgICAgbmV3X3hpdiA9ICgxIC0gKHcgLyBlbF93KSlbVEZYRF0oMik7XG4gICAgICAgICAgICAgICAgbmV3X3lpdiA9ICgxIC0gKGggLyBlbF9oKSlbVEZYRF0oMik7XG4gICAgICAgICAgICAgICAgbmV3X2l2ID0gKDEgLSAob3ZyX2FyZWEgLyBlbF9hcmVhKSlbVEZYRF0oMik7XG4gICAgICAgICAgICAgICAgaWYgKChuZXdfeGl2ID4gMCAmJiBuZXdfeGl2IDwgZXhwX3JlY3QueGl2KSB8fCAobmV3X3lpdiA+IDAgJiYgbmV3X3lpdiA8IGV4cF9yZWN0LnlpdikpIHtcbiAgICAgICAgICAgICAgICAgIGV4cF9yZWN0LnhpdiA9IG5ld194aXY7XG4gICAgICAgICAgICAgICAgICBleHBfcmVjdC55aXYgPSBuZXdfeWl2O1xuICAgICAgICAgICAgICAgICAgZXhwX3JlY3QuaXYgPSBuZXdfaXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cF9yZWN0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEZpbmQgYW55IEhUTUxFbGVtZW50cyB0aGF0IGFyZSBjb3ZlcmluZyBhIGdpdmVuIEhUTUxFbGVtZW50LlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLm92ZXJsYXBzXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTEVsZW1lbnQgZm9yIHdoaWNoIHRvIGZpbmQgYW55IG90aGVyIGVsZW1lbnRzIHRoYXQgbWF5IGJlIGNvdmVyaW5nIGl0LlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb3ZlcmluZyBlbGVtZW50cyB0byByZXR1cm5cbiAgICBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGNvdmVyaW5nIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICovXG4gICAgb3ZlcmxhcHMgPSBmdW5jdGlvbihlbCwgbGltaXQpIHtcbiAgICAgIHZhciBiYXNlSCwgYmFzZVcsIGNoZWNrRWwsIGN1ckgsIGN1clcsIGRvYywgZmFjdG9yLCBoLCBpZCwgaWR4LCBsLCBtYXhYLCBtYXhZLCBwYXJfZGV0YWlscywgcG9pbnRzLCBwdCwgcmVjdCwgcmVmX3Bhcl9ub2RlLCByZWZfcGFyX3JlY3QsIHJldCwgcm9vdCwgc2VlbiwgdCwgdywgeCwgeTtcbiAgICAgIHJlY3QgPSBfcmVjdChlbCk7XG4gICAgICBkb2MgPSBfZG9jKGVsKTtcbiAgICAgIHJvb3QgPSBfZG9jTm9kZShkb2MpO1xuICAgICAgdCA9IHJlY3QudDtcbiAgICAgIGwgPSByZWN0Lmw7XG4gICAgICB3ID0gcmVjdC5yIC0gcmVjdC5sO1xuICAgICAgaCA9IHJlY3QuYiAtIHJlY3QudDtcbiAgICAgIGZhY3RvciA9IElOVEVSU0VDVF9GQUNUT1I7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIGJhc2VXID0gX3JvdW5kKHcgLyBmYWN0b3IpO1xuICAgICAgYmFzZUggPSBfcm91bmQoaCAvIGZhY3Rvcik7XG4gICAgICBjdXJXID0gYmFzZVc7XG4gICAgICBjdXJIID0gYmFzZUg7XG4gICAgICBzZWVuID0ge307XG4gICAgICBwYXJfZGV0YWlscyA9IHt9O1xuICAgICAgcG9pbnRzID0gW107XG4gICAgICBpZHggPSAwO1xuICAgICAgeCA9IHZvaWQgMDtcbiAgICAgIHkgPSB2b2lkIDA7XG4gICAgICBwdCA9IHZvaWQgMDtcbiAgICAgIGlkID0gdm9pZCAwO1xuICAgICAgY2hlY2tFbCA9IHZvaWQgMDtcbiAgICAgIHJlZl9wYXJfbm9kZSA9IHZvaWQgMDtcbiAgICAgIHJlZl9wYXJfcmVjdCA9IHZvaWQgMDtcbiAgICAgIG1heFggPSB2b2lkIDA7XG4gICAgICBtYXhZID0gdm9pZCAwO1xuICAgICAgaWYgKG1ncl9ib3VuZHNfZGV0YWlscykge1xuICAgICAgICBwYXJfZGV0YWlscyA9IG1ncl9ib3VuZHNfZGV0YWlscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcyhlbCwgcGFyX2RldGFpbHMsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmVmX3Bhcl9ub2RlID0gcGFyX2RldGFpbHMucmVmTm9kZTtcbiAgICAgIHJlZl9wYXJfcmVjdCA9IHBhcl9kZXRhaWxzLnJlZlJlY3Q7XG4gICAgICBpZiAocmVmX3Bhcl9yZWN0ICYmIHJlZl9wYXJfbm9kZSAmJiByZWZfcGFyX25vZGUgIT09IHJvb3QpIHtcbiAgICAgICAgbWF4WCA9IHJlZl9wYXJfcmVjdC5yO1xuICAgICAgICBtYXhZID0gcmVmX3Bhcl9yZWN0LmI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhYID0gbCArIHc7XG4gICAgICAgIG1heFkgPSB0ICsgaDtcbiAgICAgIH1cbiAgICAgIGlmIChkb2MgJiYgcm9vdCAmJiBkb2NbRUxfRlJPTV9QVF0pIHtcbiAgICAgICAgd2hpbGUgKGN1clcgPCB3KSB7XG4gICAgICAgICAgY3VySCA9IGJhc2VIO1xuICAgICAgICAgIHdoaWxlIChjdXJIIDwgaCkge1xuICAgICAgICAgICAgeCA9IGwgKyBjdXJXO1xuICAgICAgICAgICAgeSA9IHQgKyBjdXJIO1xuICAgICAgICAgICAgaWYgKHggPCBtYXhYICYmIHkgPCBtYXhZKSB7XG4gICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJIICs9IGJhc2VIO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJXICs9IGJhc2VXO1xuICAgICAgICB9XG4gICAgICAgIGxpbWl0ID0gX2NudW0obGltaXQsIHBvaW50c1tMRU5dKTtcbiAgICAgICAgd2hpbGUgKHB0ID0gcG9pbnRzW2lkeCsrXSkge1xuICAgICAgICAgIGNoZWNrRWwgPSBkb2NbRUxfRlJPTV9QVF0ocHRbMF0sIHB0WzFdKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNoZWNrRWwgJiYgY2hlY2tFbC5ub2RlVHlwZSA9PT0gMSAmJiBjaGVja0VsICE9PSByb290ICYmIGNoZWNrRWwgIT09IGVsICYmICFjb250YWlucyhlbCwgY2hlY2tFbCkpIHtcbiAgICAgICAgICAgICAgaWQgPSBfYXR0cihjaGVja0VsLCBcImlkXCIpO1xuICAgICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBsYW5nLmd1aWQoXCJnZW9tX2ludGVyXCIpO1xuICAgICAgICAgICAgICAgIF9hdHRyKGNoZWNrRWwsIFwiaWRcIiwgaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc2VlbltpZF0gJiYgcmV0W0xFTl0gPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHNlZW5baWRdID0gMTtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjaGVja0VsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWQgPSBcIlwiO1xuICAgICAgZm9yIChpZCBpbiBzZWVuKSB7XG4gICAgICAgIGlmIChpZC5pbmRleE9mKFwiZ2VvbV9pbnRlclwiKSA9PT0gMCkge1xuICAgICAgICAgIGNoZWNrRWwgPSBfZWx0KGlkKTtcbiAgICAgICAgICBpZiAoY2hlY2tFbCkge1xuICAgICAgICAgICAgX2F0dHIoY2hlY2tFbCwgXCJpZFwiLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBwcm94eSB3cmFwcGVyIGZvciBjYWxsaW5nIGludG8gdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgaG9zdCBmYWxsIGJhY2sgbGlicmFyeVxuICAgIExvb2tzIGZvciBuYW1lc3BhY2Ugd2lsbCBiZSAkc2YubGliLmRvbS5tc2dob3N0X2ZiXG4gICAgU2FpZCBsaWJyYXJ5IGlzIHVzZWQgaW4gY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm90IEhUTUw1IHN0eWxlIG1lc3NhZ2luZyAoaS5lLiBubyBwb3N0TWVzc2FnZSBtZXRob2QgYXZhaWxhYmxlKS5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5tc2dob3N0LV9jYWxsX3htc2dfaG9zdF9mYlxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBtZXRoTmFtZSBUaGUgbWV0aG9kIG5hbWUgaW4gdGhlIG1zZyBob3N0IGxpYnJhcnkgdG8gY2FsbFxuICAgIEBwYXJhbSB7Kn0gYXJnMSBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgMXN0IGFyZ1xuICAgIEBwYXJhbSB7Kn0gYXJnMiBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgMm5kIGFyZ1xuICAgIEBwYXJhbSB7Kn0gYXJnMyBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgM3JkIGFyZ1xuICAgIEByZXR1cm5zIHsqfSB3aGF0ZXZlciBjb21lcyBiYWNrIGZyb20gdGhlIG1ldGhvZFxuICAgICAqL1xuICAgIF9jYWxsX3htc2dfaG9zdF9mYiA9IGZ1bmN0aW9uKG1ldGhOYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBpZiAoIW1zZ2hvc3RmYikge1xuICAgICAgICBtc2dob3N0ZmIgPSBkb20ubXNnaG9zdF9mYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRoTmFtZSAmJiBtc2dob3N0ZmIgJiYgbXNnaG9zdGZiW21ldGhOYW1lXSAmJiBtc2dob3N0ZmJbbWV0aE5hbWVdKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIExpc3RlbiBmb3IgYW4gaW5pdGlhbCBIVE1MNSBwb3N0TWVzc2FnZSBldmVudCwgdG8gdmFsaWRhdGUgdGhhdCBIVE1MNSBzdHlsZVxuICAgIG1lc3NhZ2luZyBjYW4gYmUgdXNlZFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QtX2NoZWNrX2h0bWw1X2luaXRcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgSFRNTCBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSB0aGUgcG9zdE1lc3NhZ2UgY2FsbFxuICAgICAqL1xuICAgIF9jaGVja19odG1sNV9pbml0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoIWNhblVzZUhUTUw1ICYmIGV2dCAmJiBldnQuZGF0YSA9PT0gaW5pdElEKSB7XG4gICAgICAgIGNhblVzZUhUTUw1ID0gdHJ1ZTtcbiAgICAgICAgZG9tLmV2dENuY2woZXZ0KTtcbiAgICAgICAgZG9tW0RFVEFDSF0od2luLCBNU0csIF9jaGVja19odG1sNV9pbml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBMaXN0ZW4gZm9yIG9ubWVzc2FnZSBldmVudHMgaW4gdGhlIG1haW4gd2luZG93LiBWYWxpZGF0ZSB0aGF0IG1lc3NhZ2UgaXMgZm9yIHVzLCBhbmQgaWYgc29cbiAgICBwYXNzIGl0IHRocm91Z2ggdG8gdGhlIHJlc3Qgb2YgdGhlIGNvZGUgYW5kIGNhbmNlbCBmdXJ0aGVyIGhhbmRsaW5nLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QtX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IEhUTUwgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gdGhlIHBvc3RNZXNzYWdlIGNhbGxcbiAgICAgKi9cbiAgICBfaGFuZGxlX21zZ19mcm9tX291dHNpZGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBjYiwgZGF0YSwgZGF0YUdVSUQsIGUsIGZyX3dpbiwgaWZyLCBtc2dfd2luLCBwYXJhbXMsIHBpcGUsIHBpcGVHVUlELCByZXQsIHRndElEO1xuICAgICAgZGF0YSA9IGV2dCAmJiBldnQuZGF0YTtcbiAgICAgIG1zZ193aW4gPSBldnQgJiYgZXZ0LnNvdXJjZTtcbiAgICAgIHBhcmFtcyA9IGRhdGEgJiYgKGRhdGEuaW5kZXhPZihHVUlEKSAhPT0gLTEpICYmIFBhcmFtSGFzaChkYXRhKTtcbiAgICAgIHRndElEID0gcGFyYW1zICYmIHBhcmFtcy5pZDtcbiAgICAgIGlmciA9IHRndElEICYmIF9lbHQodGd0SUQpO1xuICAgICAgZnJfd2luID0gaWZyICYmIF9pZnJfdmlldyhpZnIpO1xuICAgICAgcGlwZSA9IHRndElEICYmIG1zZ19waXBlc1t0Z3RJRF07XG4gICAgICBkYXRhR1VJRCA9IHBhcmFtcyAmJiBwYXJhbXNbR1VJRF07XG4gICAgICBwaXBlR1VJRCA9IHBpcGUgJiYgcGlwZVtHVUlEXTtcbiAgICAgIGNiID0gcGlwZSAmJiBwaXBlLl94bXNnY2I7XG4gICAgICByZXQgPSBmYWxzZTtcbiAgICAgIGlmIChwaXBlR1VJRCAmJiBkYXRhR1VJRCAmJiBkYXRhR1VJRCA9PT0gcGlwZUdVSUQgJiYgbXNnX3dpbiAmJiBmcl93aW4gJiYgZnJfd2luID09PSBtc2dfd2luKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gY2IocGFyYW1zLm1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgZG9tLmV2dENuY2woZXZ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VuZCBhIG1lc3NhZ2UgdG8gYSBjaGlsZCBpZnJhbWUuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC5zZW5kXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gdGd0SUQgVGhlIEhUTUwgaWQgYXR0cmlidXRlIG9mIHRoZSBpZnJhbWUgZWxlbWVudCBmb3Igd2hpY2ggdG8gc2VuZCBhIG1lc3NhZ2VcbiAgICBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgc3RyaW5nIG9mIGRhdGEgdG8gc2VuZCB0byB0aGUgZ2l2ZW4gaWZyYW1lXG4gICAgQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IG1lc3NhZ2Ugd2FzIHNlbmQgc3VjY2VzZnVsbHkgKG5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IG1lYW4gbWVzc2FnZSB3YXMgaGFuZGxlZCAvIHJlY2V2aWVkLCBvbmx5IHRoYXQgc2VuZGluZyB3YXMgb2spLlxuICAgICAqL1xuICAgIHNlbmRfbXNnX3RvX2NoaWxkX2lmcmFtZSA9IGZ1bmN0aW9uKHRndElELCBkYXRhKSB7XG4gICAgICB2YXIgZSwgZWwsIG1zZ09iaiwgcGlwZSwgc3VjY2VzcywgdztcbiAgICAgIHBpcGUgPSB0Z3RJRCAmJiBtc2dfcGlwZXNbdGd0SURdO1xuICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgbXNnT2JqID0gdm9pZCAwO1xuICAgICAgdyA9IHZvaWQgMDtcbiAgICAgIGVsID0gdm9pZCAwO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGlmICghcGlwZSkge1xuICAgICAgICBzdWNjZXNzID0gX2NhbGxfeG1zZ19ob3N0X2ZiKFwic2VuZFwiLCB0Z3RJRCwgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGlwZSkge1xuICAgICAgICAgIG1zZ09iaiA9IFBhcmFtSGFzaCgpO1xuICAgICAgICAgIG1zZ09iai5tc2cgPSBkYXRhO1xuICAgICAgICAgIG1zZ09iai5ndWlkID0gcGlwZS5ndWlkO1xuICAgICAgICAgIGlmICh1c2luZ0hUTUw1KCkpIHtcbiAgICAgICAgICAgIGVsID0gX2VsdCh0Z3RJRCk7XG4gICAgICAgICAgICB3ID0gX2lmcl92aWV3KGVsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdbUE1TR10oX2NzdHIobXNnT2JqKSwgcGlwZS5zcmNIb3N0IHx8IFwiKlwiKTtcbiAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gX2NhbGxfeG1zZ19ob3N0X2ZiKFwic2VuZFwiLCB0Z3RJRCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtc2dPYmogPSB3ID0gZWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2V0IHdoZXRoZXIgb3Igbm90IEhUTUw1IHN0eWxlIG1lc3NhZ2luZyBjYW4gYmUgdXNlZFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QudXNpbmdIVE1MNVxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgdXNpbmdIVE1MNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhblVzZUhUTUw1O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdldHMgYSBsb2NhdGlvbiBvZiB0aGUgaG9zdGluZyBwYWdlLCBzdHJpcHBlZCBvZiB0aGUgc2VhcmNoIGhhc2gsXG4gICAgYnV0IGxlYXZpbmcgcXVlcnkgcGFyYW1ldGVycywgcG9ydCwgaG9zdCwgcGF0aCwgZXRjLlxuICAgICAqL1xuICAgIF9zdHJpcHBlZEVuY29kZWRMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNsZWFuZWQsIHBvcztcbiAgICAgIGNsZWFuZWQgPSB2b2lkIDA7XG4gICAgICBwb3MgPSBsb2MuaHJlZi5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICBjbGVhbmVkID0gbG9jLmhyZWYuc3Vic3RyKDAsIHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbmVkID0gbG9jLmhyZWY7XG4gICAgICB9XG4gICAgICBwb3MgPSBjbGVhbmVkLmluZGV4T2YoXCI/XCIpO1xuICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnN1YnN0cigwLCBwb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVzY2FwZShjbGVhbmVkKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBQcmVwYXJlIGFuIGlmcmFtZSBpbiB0aGUgdG9wIGxldmVsIHdpbmRvdyB0byBiZSBhYmxlIHRvIHNlbmQgLyByZWNlaXZlIGNyb3NzLWRvbWFpbiBtZXNzYWdlc1xuICAgIEdlbmVyYWxseSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSAkc2YubGliLmlmcmFtZXMuICBUaGUgYXR0cnMgb2JqZWN0IGluIHF1ZXN0aW9uIHNob3VsZFxuICAgIHJlcHJlc2VudCBrZXkvdmFsdWUgcGFpcnMgb2YgSFRNTCBhdHRyaWJ1dGVzIGZvciB0aGUgaWZyYW1lLiBOb3RlIHRoYXQgdGhlIGF0dHJzIG9iamVjdCBwYXNzZWRcbiAgICBpbiB3aWxsIGJlIG1vZGlmaWVkIHdpdGggYSBuZXcgXCJuYW1lXCIgcHJvcGVydHksIHRvIHNlbmQgaW5mb3JtYXRpb24gaW50byB0aGUgaWZyYW1lIGFuZCBzZXR1cFxuICAgIG1lc3NhZ2luZy5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5tc2dob3N0LnByZXBcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBJbmZvcm1hdGlvbiByZXF1aXJlZCB0byBzZXQgdXAgdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgY2hhbm5lbFxuICAgIEBwYXJhbSB7U3RyaW5nfSBhdHRycy5pZCBUaGUgSUZSQU1FIEhUTUwgaWQgYXR0cmlidXRlXG4gICAgQHBhcmFtIHtTdHJpbmd9IGF0dHJzLnNyYyBUaGUgVVJMIC8gc3JjIGF0dHJpYnV0ZSBvZiB0aGUgSUZSQU1FXG4gICAgQHBhcmFtIHtTdHJpbmd9IFthdHRycy5ndWlkXSBUaGUgZ3VpZCAvIHNpZ25hdHVyZSB0byB1c2UgdG8gdmFsaWRhdGUgdGhhdCBtZXNzYWdlcyBzZW50LyByZWNlaXZlZCBjYW4gYmUgYWNjZXB0ZWQuIElmIG5vdCBzcGVjaWZpZWQsIG9uZSB3aWxsIGJlIGNyZWF0ZWQgYXV0b21hdGljYWxseS5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2F0dHJzLm5hbWVdIFRoZSBJRlJBTUUgSFRNTCBuYW1lIGF0dHJpYnV0ZSB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2VuZCBhbiBpbnRpYWwgbWVzc2FnZSB0byB0aGUgSFRNTCBkb2N1bWVudCBpbnNpZGUgdGhlIElGUkFNRS5cbiAgICBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB2YXJpb3VzIHByb3BlcnRpZXMgZGV0YWlsaW5nIHRoZSBtZXNzYWdpbmcgcGlwZS1saW5lLlxuICAgICAqL1xuICAgIHByZXBfaWZyYW1lX21zZ2luZyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICB2YXIgaWZyYW1lTmFtZSwgbG9jU3RyaXBwZWQsIG5hbWVQYXJhbXMsIG5ld1BpcGUsIHBpcGUsIHNyYywgc3JjSG9zdDtcbiAgICAgIHBpcGUgPSBudWxsO1xuICAgICAgaWZyYW1lTmFtZSA9IHZvaWQgMDtcbiAgICAgIG5hbWVQYXJhbXMgPSB2b2lkIDA7XG4gICAgICBzcmMgPSB2b2lkIDA7XG4gICAgICBzcmNIb3N0ID0gdm9pZCAwO1xuICAgICAgbmV3UGlwZSA9IHZvaWQgMDtcbiAgICAgIGxvY1N0cmlwcGVkID0gX3N0cmlwcGVkRW5jb2RlZExvY2F0aW9uKCk7XG4gICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgaWZyYW1lTmFtZSA9IGF0dHJzLm5hbWU7XG4gICAgICAgIG5hbWVQYXJhbXMgPSBQYXJhbUhhc2goaWZyYW1lTmFtZSk7XG4gICAgICAgIHNyYyA9IF9jc3RyKGF0dHJzLnNyYyk7XG4gICAgICAgIHNyY0hvc3QgPSBzcmMgJiYgc3JjLnN1YnN0cmluZygwLCBzcmMuaW5kZXhPZihcIi9cIiwgOSkpO1xuICAgICAgICBzcmNIb3N0ID0gKHNyY0hvc3Quc2VhcmNoKC9odHRwL2cpICE9PSAwID8gXCJcIiA6IHNyY0hvc3QpO1xuICAgICAgICBwaXBlID0gUGFyYW1IYXNoKG5hbWVQYXJhbXMpO1xuICAgICAgICBwaXBlLmlkID0gYXR0cnMuaWQgfHwgKFwiaWZyYW1lX1wiICsgX2d1aWQoKSk7XG4gICAgICAgIHBpcGUuc3JjID0gc3JjO1xuICAgICAgICBwaXBlLnNyY0hvc3QgPSBzcmNIb3N0O1xuICAgICAgICBwaXBlW0dVSURdID0gcGlwZVtHVUlEXSB8fCBfZ3VpZCgpO1xuICAgICAgICBwaXBlLmhvc3QgPSBsb2NIb3N0O1xuICAgICAgICBwaXBlLmxvYyA9IGxvY1N0cmlwcGVkO1xuICAgICAgICBwaXBlLnByb3h5SUQgPSBcIlwiO1xuICAgICAgICBpZiAodXNpbmdIVE1MNSgpKSB7XG4gICAgICAgICAgcGlwZS5odG1sNSA9IDE7XG4gICAgICAgICAgcGlwZS5wcm94eVBhdGggPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1BpcGUgPSBfY2FsbF94bXNnX2hvc3RfZmIoXCJwcmVwXCIsIHBpcGUpO1xuICAgICAgICAgIGlmIChuZXdQaXBlKSB7XG4gICAgICAgICAgICBwaXBlID0gbmV3UGlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMubmFtZSA9IHBpcGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlwZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gYW4gSUZSQU1FLiBOb3RlIHRoYXQgb24gdGhlIGhvc3QgLyBwdWJsaXNoZXIgc2lkZVxuICAgIHRoaXMgbGlicmFyeSBvbmx5IGFsbG93cyBmb3Igb25lIG1lc3NhZ2UgaGFuZGxlciB0byBiZSBhdHRhY2hlZCB0byBhIGdpdmVuXG4gICAgSUZSQU1FLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QuYXR0YWNoXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSUZSQU1FIHJlZmVyZW5jZSB0byBhdHRhY2ggYSBsaXN0ZW5lciBjYWxsYmFjayB0b28uIC5cbiAgICBAcGFyYW0ge09iamVjdH0gcGlwZSBUaGUgbWVzc2FnZSBwaXBlIG9iamVjdCBjcmVhdGVkIGZyb20gJHNmLmxpYi5kb20ubXNnaG9zdC5wcmVwXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgKi9cbiAgICBhdHRhY2hfaWZyYW1lX21zZ2luZyA9IGZ1bmN0aW9uKGVsLCBwaXBlLCBjYikge1xuICAgICAgdmFyIHRndElEO1xuICAgICAgdGd0SUQgPSB2b2lkIDA7XG4gICAgICBpZiAoX3RhZ05hbWUoZWwpID09PSBcImlmcmFtZVwiKSB7XG4gICAgICAgIHRndElEID0gX2F0dHIoZWwsIFwiaWRcIik7XG4gICAgICAgIGlmICh0Z3RJRCAmJiBwaXBlICYmIChwaXBlIGluc3RhbmNlb2YgUGFyYW1IYXNoKSAmJiB0Z3RJRCA9PT0gcGlwZS5pZCkge1xuICAgICAgICAgIGlmICh1c2luZ0hUTUw1KCkpIHtcbiAgICAgICAgICAgIG1zZ19waXBlc1t0Z3RJRF0gPSBwaXBlO1xuICAgICAgICAgICAgcGlwZS5feG1zZ2NiID0gY2I7XG4gICAgICAgICAgICBpZiAoIWh0bWw1Qm91bmQpIHtcbiAgICAgICAgICAgICAgZG9tW0FUVEFDSF0od2luLCBNU0csIF9oYW5kbGVfbXNnX2Zyb21fb3V0c2lkZSk7XG4gICAgICAgICAgICAgIGh0bWw1Qm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY2FsbF94bXNnX2hvc3RfZmIoQVRUQUNILCBlbCwgcGlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIERldGFjaCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzIGZyb20gYW4gSUZSQU1FXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC5kZXRhY2hcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBJRlJBTUUgcmVmZXJlbmNlIHRvIGRldGFjaCBhIGxpc3RlbmVyXG4gICAgICovXG4gICAgZGV0YWNoX2lmcmFtZV9tc2dpbmcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGVtcHR5LCBpZCwgcGlwZSwgdztcbiAgICAgIGlkID0gX2F0dHIoZWwsIFwiaWRcIik7XG4gICAgICBwaXBlID0gaWQgJiYgbXNnX3BpcGVzW2lkXTtcbiAgICAgIHcgPSBudWxsO1xuICAgICAgZW1wdHkgPSB0cnVlO1xuICAgICAgaWYgKCFwaXBlKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdF9mYihERVRBQ0gsIGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBpcGUpIHtcbiAgICAgICAgcGlwZS5feG1zZ2NiID0gbXNnX3BpcGVzW2lkXSA9IG51bGw7XG4gICAgICAgIHBpcGUgPSBudWxsO1xuICAgICAgICBkZWxldGUgbXNnX3BpcGVzW2lkXTtcbiAgICAgIH1cbiAgICAgIGlkID0gXCJcIjtcbiAgICAgIGZvciAoaWQgaW4gbXNnX3BpcGVzKSB7XG4gICAgICAgIHBpcGUgPSBtc2dfcGlwZXNbaWRdO1xuICAgICAgICBpZiAocGlwZSAmJiBwaXBlW0dVSURdKSB7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVtcHR5ICYmIHVzaW5nSFRNTDUoKSAmJiBodG1sNUJvdW5kKSB7XG4gICAgICAgIGh0bWw1Qm91bmQgPSBmYWxzZTtcbiAgICAgICAgZG9tW0RFVEFDSF0od2luLCBNU0csIF9oYW5kbGVfbXNnX2Zyb21fb3V0c2lkZSk7XG4gICAgICB9XG4gICAgICBlbCA9IHcgPSBwaXBlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBGaXJlIHRoZSBzcGVjaWZlZCBjYWxsYmFjayBvdXQgdG8gdGhlIHB1Ymxpc2hlci4gTm90ZSB0aGF0IG90aGVyIGFyZ3VtZW50cyBiZXlvbmQgdGhlIDFzdCBhcmd1bWVudCBhcmUgcGFzc2VkIHRocm91ZyB0byB0aGUgY2FsbGJhY2suXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2ZpcmVfcHViX2NhbGxiYWNrXG4gICAgQHN0YXRpY1xuICAgIEBwcml2YXRlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IGNiX25hbWUgVGhlIGNhbGxiYWNrIG5hbWUgdG8gZmlyZVxuICAgICAqL1xuICAgIF9maXJlX3B1Yl9jYWxsYmFjayA9IGZ1bmN0aW9uKGNiX25hbWUpIHtcbiAgICAgIHZhciBhLCBhcmdzLCBjYl9hcmdzLCBlLCBmLCBpZHgsIGxlbiwgcmV0O1xuICAgICAgY2JfYXJncyA9IFtdO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGxlbiA9IGFyZ3NbTEVOXTtcbiAgICAgIGlkeCA9IDA7XG4gICAgICBmID0gdm9pZCAwO1xuICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgYSA9IHZvaWQgMDtcbiAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgZiA9IGNvbmZpZ1tjYl9uYW1lXTtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgIGEgPSBhcmdzW2lkeCsrXTtcbiAgICAgICAgICAgIGlmIChhICE9PSBjYl9uYW1lKSB7XG4gICAgICAgICAgICAgIGNiX2FyZ3MucHVzaChhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldCA9IGYuYXBwbHkobnVsbCwgY2JfYXJncyk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIE51a2UgdGhlIHBvc2l0aW9uIGFuIHJlcG9ydCB0aGF0IHNhaWQgcG9zaXRpb24gdG9vayB0b28gbG9uZyB0byByZW5kZXJcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1faGFuZGxlX3JlbmRlcl90aW1lb3V0XG4gICAgQHN0YXRpY1xuICAgIEBwcml2YXRlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IHBvc19pZCBUaGUgcG9zaXRpb24gaWQgdGhhdCBoYXMgdGFrZW4gdG9vIGxvbmdcbiAgICAgKi9cbiAgICBfaGFuZGxlX3JlbmRlcl90aW1lb3V0ID0gZnVuY3Rpb24ocG9zX2lkKSB7XG4gICAgICB2YXIgcGVuZDtcbiAgICAgIHBlbmQgPSBwb3NfaWQgJiYgcGVuZGluZ19pZnJzW3Bvc19pZF07XG4gICAgICBpZiAocGVuZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQocGVuZCk7XG4gICAgICAgIG51a2UocG9zX2lkKTtcbiAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIFwicmVuZGVyLXRpbWVvdXRcIiwgcG9zX2lkKTtcbiAgICAgIH1cbiAgICAgIGlmICghX2hhc19wZW5kaW5nX3JlbmRlcnMoKSkge1xuICAgICAgICBjdXJyZW50X3N0YXR1cyA9IFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2xlYXIgdGhlIHRpbWVyIHRoYXQgZmlyZXMgZXZlcnkgc28gb2Z0ZW4gdG8gdXBkYXRlIHRoZSBnZW9tZXRyeSBpbiBzaWRlXG4gICAgb2YgU2FmZUZyYW1lc1xuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lclxuICAgIEBzdGF0aWNcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGdlb21fdXBkYXRlX3RpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChnZW9tX3VwZGF0ZV90aW1lcik7XG4gICAgICAgIGdlb21fdXBkYXRlX3RpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICArXHQgKiBDbGVhciB0aGUgdGltZXIgdGhhdCBmaXJlcyBldmVyeSBzbyBvZnRlbiB0byB1cGRhdGUgdGhlIGdlb21ldHJ5IGluIHNpZGVcbiAgICArXHQgKiBvZiBTYWZlRnJhbWVzXG4gICAgK1x0ICpcbiAgICArXHQgKiBAbmFtZSAkc2YuaG9zdC1fY2xlYXJfZ2VvbV91cGRhdGVfdGltZXJcbiAgICArXHQgKiBAc3RhdGljXG4gICAgK1x0ICogQHByaXZhdGVcbiAgICArXHQgKiBAZnVuY3Rpb25cbiAgICArXHQgKlxuICAgICtcbiAgICAgKi9cbiAgICBfY2xlYXJfZm9jdXNfdXBkYXRlX3RpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZm9jdXNfdXBkYXRlX3RpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChmb2N1c191cGRhdGVfdGltZXIpO1xuICAgICAgICBmb2N1c191cGRhdGVfdGltZXIgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgX3NldF9mb2N1c191cGRhdGVfdGltZXIgPSBmdW5jdGlvbihpbl9mb2N1cykge1xuICAgICAgX2NsZWFyX2ZvY3VzX3VwZGF0ZV90aW1lcigpO1xuICAgICAgZm9jdXNfdXBkYXRlX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3VwZGF0ZV9mb2N1cyhpbl9mb2N1cyk7XG4gICAgICB9LCAyKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZXQgdXAgdGhlIHRpbWVyIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBlYWNoIFNhZmVGcmFtZSB3aXRoIHVwIHRvIGRhdGUgZ2VvbWV0cmljIGluZm9ybWF0aW9uXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX3NldF9nZW9tX3VwZGF0ZV90aW1lclxuICAgIEBzdGF0aWNcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9zZXRfZ2VvbV91cGRhdGVfdGltZXIgPSBmdW5jdGlvbihpc193aW5fc2Nyb2xsKSB7XG4gICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICAgIGlmIChpc193aW5fc2Nyb2xsKSB7XG4gICAgICAgIGdlb21fdXBkYXRlX3RpbWVyID0gc2V0VGltZW91dChfdXBkYXRlX2dlb21fd2luX3Njcm9sbCwgR0VPTV9VUERBVEVfSU5UUlZBTCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tX3VwZGF0ZV90aW1lciA9IHNldFRpbWVvdXQoX3VwZGF0ZV9nZW9tX3dpbl9yZXNpemUsIEdFT01fVVBEQVRFX0lOVFJWQUwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFVwZGF0ZSBhbGwgU2FmZUZyYW1lcyB3aXRoIHVwZGF0ZWQgZ2VvbWV0cmljIGluZm9ybWF0aW9uXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX3VwZGF0ZV9nZW9tXG4gICAgQHN0YXRpY1xuICAgIEBwcml2YXRlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtCb29sZWFufSBpc193aW5fc2Nyb2xsIFdoZXRoZXIgb3Igbm90IHdlIGFyZSB1cGRhdGluZyBkdWUgdG8gdGhlIG1haW4gd2luZG93IGJlaW5nIHNjcm9sbGVkXG4gICAgICovXG4gICAgX3VwZGF0ZV9nZW9tID0gZnVuY3Rpb24oaXNfd2luX3Njcm9sbCkge1xuICAgICAgdmFyIGcsIGlkLCBpZnIsIG1zZ09iaiwgcGFyYW1zLCBwb3NJRDtcbiAgICAgIHBvc0lEID0gdm9pZCAwO1xuICAgICAgcGFyYW1zID0gdm9pZCAwO1xuICAgICAgbXNnT2JqID0gdm9pZCAwO1xuICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICBpZnIgPSB2b2lkIDA7XG4gICAgICBnID0gdm9pZCAwO1xuICAgICAgZm9yIChwb3NJRCBpbiByZW5kZXJlZF9pZnJzKSB7XG4gICAgICAgIGlmIChpc193aW5fc2Nyb2xsICYmIChwb3NJRCBpbiBzY3JvbGxfcGFyZW50c19hdHRhY2hlZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgaWQgPSBwYXJhbXMgJiYgcGFyYW1zLmRlc3Q7XG4gICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICBpZiAoaWZyICYmIHBhcmFtcykge1xuICAgICAgICAgIGcgPSBfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKTtcbiAgICAgICAgICBtc2dPYmogPSBQYXJhbUhhc2goKTtcbiAgICAgICAgICBtc2dPYmoucG9zID0gcG9zSUQ7XG4gICAgICAgICAgbXNnT2JqLmNtZCA9IE5PVElGWV9HRU9NX1VQREFURTtcbiAgICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhnKTtcbiAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgcG9zSUQsIE5PVElGWV9HRU9NX1VQREFURSwgZyk7XG4gICAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBVcGRhdGUgYWxsIFNhZmVGcmFtZXMgd2l0aCB1cGRhdGVkIGdlb21ldHJpYyBpbmZvcm1hdGlvbiBkdWUgdG8gYSB3aW5kb3cgcmVzaXplXG4gICAgZXZlbnQuXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX3VwZGF0ZV9nZW9tX3dpbl9yZXNpemVcbiAgICBAc3RhdGljXG4gICAgQHByaXZhdGVcbiAgICBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfdXBkYXRlX2dlb21fd2luX3Jlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3VwZGF0ZV9nZW9tKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVXBkYXRlIGFsbCBTYWZlRnJhbWVzIHdpdGggdXBkYXRlZCBnZW9tZXRyaWMgaW5mb3JtYXRpb24gZHVlIHRvIGEgd2luZG93IHNjcm9sbCBldmVudFxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV91cGRhdGVfZ2VvbV93aW5fc2Nyb2xsXG4gICAgQHN0YXRpY1xuICAgIEBwcml2YXRlXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX3VwZGF0ZV9nZW9tX3dpbl9zY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIF91cGRhdGVfZ2VvbSh0cnVlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBVcGRhdGUgYSBTYWZlRnJhbWUgdGhhdCBoYXMgbmV3IGdlb21ldHJpYyBpbmZvcm1hdGlvbiBkdWUgdG8gaXRzIHBhcmVudCBIVE1MIGVsZW1lbnRcbiAgICBzY3JvbGxpbmcuXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV9ub2RlX3Njcm9sbFxuICAgIEBzdGF0aWNcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9oYW5kbGVfbm9kZV9zY3JvbGwgPSBmdW5jdGlvbihldnQsIHBvc0lELCBub2RlKSB7XG4gICAgICB2YXIgZywgc2NyX2hhbmRsZTtcbiAgICAgIHNjcl9oYW5kbGUgPSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICBnID0gdm9pZCAwO1xuICAgICAgaWYgKHNjcl9oYW5kbGUpIHtcbiAgICAgICAgaWYgKHNjcl9oYW5kbGUudElEKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcl9oYW5kbGUudElEKTtcbiAgICAgICAgICBkZWxldGUgc2NyX2hhbmRsZS50SUQ7XG4gICAgICAgIH1cbiAgICAgICAgc2NyX2hhbmRsZS50SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpZCwgaWZyLCBtc2dPYmosIHBhcmFtcztcbiAgICAgICAgICBwYXJhbXMgPSByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgICBpZCA9IHBhcmFtcyAmJiBwYXJhbXMuZGVzdDtcbiAgICAgICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgICAgICBnID0gdm9pZCAwO1xuICAgICAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoaWZyICYmIHBhcmFtcykge1xuICAgICAgICAgICAgZyA9IF9idWlsZF9nZW9tKHBvc0lELCBpZnIsIHRydWUpO1xuICAgICAgICAgICAgbXNnT2JqID0gUGFyYW1IYXNoKCk7XG4gICAgICAgICAgICBtc2dPYmoucG9zID0gcG9zSUQ7XG4gICAgICAgICAgICBtc2dPYmouY21kID0gTk9USUZZX0dFT01fVVBEQVRFO1xuICAgICAgICAgICAgbXNnT2JqLmdlb20gPSBfZXMoZyk7XG4gICAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgcG9zSUQsIE5PVElGWV9HRU9NX1VQREFURSwgZyk7XG4gICAgICAgICAgICBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBzY3JfaGFuZGxlLnRJRDtcbiAgICAgICAgfSwgR0VPTV9VUERBVEVfSU5UUlZBTCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgSGFuZGxlIHRoZSB3aW5kb3cgb25zY3JvbGwgZXZlbnQsIGV2ZW50dWFsbHkgbGVhZGluZyB0byBhIGdlb21ldHJpYyB1cGRhdGVcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1faGFuZGxlX3dpbl9nZW9tX3Njcm9sbFxuICAgIEBzdGF0aWNcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBldmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgX3NldF9nZW9tX3VwZGF0ZV90aW1lcigxKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBIYW5kbGUgdGhlIHdpbmRvdyBvbnJlc2l6ZSBldmVudCwgZXZlbnR1YWxseSBsZWFkaW5nIHRvIGEgZ2VvbWV0cmljIHVwZGF0ZVxuICAgIG9uY2UgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNsb3dlZCBkb3duXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV93aW5fZ2VvbV9yZXNpemVcbiAgICBAc3RhdGljXG4gICAgQHByaXZhdGVcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2hhbmRsZV93aW5fZ2VvbV9yZXNpemUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIF9zZXRfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBVcGRhdGUgYWxsIFNhZmVGcmFtZXMgd2l0aCB1cGRhdGVkIGZvY3VzIGluZm9ybWF0aW9uXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX3VwZGF0ZV9mb2N1c1xuICAgIEBzdGF0aWNcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gaW5fZm9jdXMgVHJ1ZSB3aGVuIHRoZSB3aW5kb3cgaGFzIGdhaW5lZCBmb2N1c1xuICAgICAqL1xuICAgIF91cGRhdGVfZm9jdXMgPSBmdW5jdGlvbihpbl9mb2N1cykge1xuICAgICAgdmFyIGRhdGEsIGlkLCBpZnIsIG1zZ09iaiwgcGFyYW1zLCBwb3NJRDtcbiAgICAgIHBvc0lEID0gdm9pZCAwO1xuICAgICAgcGFyYW1zID0gdm9pZCAwO1xuICAgICAgbXNnT2JqID0gdm9pZCAwO1xuICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICBpZnIgPSB2b2lkIDA7XG4gICAgICBmb3IgKHBvc0lEIGluIHJlbmRlcmVkX2lmcnMpIHtcbiAgICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIGlkID0gcGFyYW1zICYmIHBhcmFtcy5kZXN0O1xuICAgICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgICAgaWYgKGlmciAmJiBwYXJhbXMpIHtcbiAgICAgICAgICBtc2dPYmogPSBQYXJhbUhhc2goKTtcbiAgICAgICAgICBkYXRhID0gUGFyYW1IYXNoKCk7XG4gICAgICAgICAgbXNnT2JqLnBvcyA9IHBvc0lEO1xuICAgICAgICAgIG1zZ09iai5jbWQgPSBkYXRhLmNtZCA9IE5PVElGWV9GT0NVU19DSEFOR0U7XG4gICAgICAgICAgbXNnT2JqLnZhbHVlID0gaW5fZm9jdXM7XG4gICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBOT1RJRllfRk9DVVNfQ0hBTkdFLCBpbl9mb2N1cyk7XG4gICAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfY2xlYXJfZm9jdXNfdXBkYXRlX3RpbWVyKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgSGFuZGxlIHRoZSB3aW5kb3cgZm9jdXMgZXZlbnQsIHdoaWNoIG5vdGlmaWVzIGFkcyBvZiB0aGUgY2hhbmdlXG4gICAgICovXG4gICAgX2hhbmRsZV93aW5fZm9jdXMgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIF9zZXRfZm9jdXNfdXBkYXRlX3RpbWVyKHRydWUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEhhbmRsZSB0aGUgd2luZG93IGJsdXIgZXZlbnQsIHdoaWNoIG5vdGlmaWVzIGFkcyBvZiB0aGUgY2hhbmdlXG4gICAgICovXG4gICAgX2hhbmRsZV93aW5fYmx1ciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgX3NldF9mb2N1c191cGRhdGVfdGltZXIoZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEhhbmRsZSB0aGUgd2luZG93IHVubG9hZCBldmVudCwgY2xlYXJpbmcgdXAgb3VyIHN0YXRlXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV91bmxvYWRcbiAgICBAc3RhdGljXG4gICAgQHByaXZhdGVcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2hhbmRsZV91bmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlLCBwcm9wLCBzY3JfaGFuZGxlO1xuICAgICAgcHJvcCA9IHZvaWQgMDtcbiAgICAgIHNjcl9oYW5kbGUgPSB2b2lkIDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICBkb20uZGV0YWNoKHdpbiwgU0NST0xMLCBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCk7XG4gICAgICAgIGRvbS5kZXRhY2god2luLCBcInJlc2l6ZVwiLCBfaGFuZGxlX3dpbl9nZW9tX3Jlc2l6ZSk7XG4gICAgICAgIGRvbS5kZXRhY2god2luLCBcInVubG9hZFwiLCBfaGFuZGxlX3VubG9hZCk7XG4gICAgICAgIGRvbS5kZXRhY2god2luLCBcImZvY3VzXCIsIF9oYW5kbGVfd2luX2ZvY3VzKTtcbiAgICAgICAgZG9tLmRldGFjaCh3aW4sIFwiYmx1clwiLCBfaGFuZGxlX3dpbl9ibHVyKTtcbiAgICAgICAgZm9yIChwcm9wIGluIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkKSB7XG4gICAgICAgICAgc2NyX2hhbmRsZSA9IHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Byb3BdO1xuICAgICAgICAgIGlmIChzY3JfaGFuZGxlKSB7XG4gICAgICAgICAgICBpZiAoc2NyX2hhbmRsZS50SUQpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcl9oYW5kbGUudElEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbS5kZXRhY2goc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcHJvcF0sIFNDUk9MTCwgc2NyX2hhbmRsZVtPTlNDUk9MTF0pO1xuICAgICAgICAgICAgc2NyX2hhbmRsZVtPTlNDUk9MTF0gPSBzY3JfaGFuZGxlLm5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwcm9wXSA9IG51bGw7XG4gICAgICAgICAgZGVsZXRlIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHdpbl9ldmVudHNfYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICB9O1xuXG4gICAgLypcbiAgICBIYW5kbGUgdGhlIHdpbmRvdyBtZXNzYWdlIGV2ZW50LCBwYXNzZWQgZnJvbSByYXcgZXZlbnQgaGFuZGxpbmcgb2YgdGhlIG1zZ2hvc3QgY29kZS5cbiAgICBQYXNzIHRocm91Z2ggdGhlIGRhdGEgdG8gb3VyIGZvcm1hdCBoYW5kbGluZyBmdW5jdGlvbnMgZm9yIGV4cGFuZCwgZXRjLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfbXNnX2V2dFxuICAgIEBzdGF0aWNcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YSB0aGUgbWVzc2FnZSB0byBiZSBoYW5kbGVkXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBtZXNzYWdlIHdhcyBoYW5kbGVkXG4gICAgICovXG4gICAgX2hhbmRsZV9tc2dfZXZ0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGNhblJlYWQsIGNhbldyaXRlLCBpbmZvLCBtc2dPYmosIHJldDtcbiAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgaW5mbyA9IHZvaWQgMDtcbiAgICAgIG1zZ09iaiA9IFBhcmFtSGFzaChkYXRhLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChtc2dPYmogJiYgbXNnT2JqLnBvcykge1xuICAgICAgICBpbmZvID0gcmVuZGVyZWRfaWZyc1ttc2dPYmoucG9zXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICByZXQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1zZ09iai5jbWQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImV4cC1wdXNoXCI6XG4gICAgICAgICAgICAgICAgX2V4cGFuZF9zYWZlZnJhbWUobXNnT2JqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FzZSBcImV4cC1vdnJcIjpcbiAgICAgICAgICAgICAgICBfZXhwYW5kX3NhZmVmcmFtZShtc2dPYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICBjYXNlIFwiY29sbGFwc2VcIjpcbiAgICAgICAgICAgICAgICBfY29sbGFwc2Vfc2FmZWZyYW1lKG1zZ09iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGNhc2UgXCJtc2dcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImNsaWNrZWRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInZpZXdlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVxdWVzdGVkXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJ1bnZpZXdlZFwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVsb2FkXCI6XG4gICAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIG1zZ09iai5wb3MsIG1zZ09iai5jbWQsIG1zZ09iai5tc2cpO1xuICAgICAgICAgICAgICAgIF9zZW5kX2dlbmVyaWNfcmVzcG9uc2UobXNnT2JqLnBvcywgbXNnT2JqLmNtZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGNhc2UgXCJsb2FkZWRcIjpcbiAgICAgICAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soXCJvbkFkTG9hZFwiLCBtc2dPYmoucG9zLCBtc2dPYmopO1xuICAgICAgICAgICAgICAgIF9zZW5kX2dlbmVyaWNfcmVzcG9uc2UobXNnT2JqLnBvcywgbXNnT2JqLmNtZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGNhc2UgRVJST1JfQ09NTUFORDpcbiAgICAgICAgICAgICAgICBfcmVjb3JkX2Vycm9yKG1zZ09iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGNhc2UgTk9USUZZX0dFT01fVVBEQVRFOlxuICAgICAgICAgICAgICAgIHNmLmxpYi5sb2dnZXIubG9nKFwiR2VvbSB1cGRhdGUgY29tcGxldGU6IFwiICsgbXNnT2JqLnBvcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFkLWNvb2tpZVwiOlxuICAgICAgICAgICAgICAgIGNhblJlYWQgPSBpbmZvLmNvbmYgJiYgaW5mby5jb25mLnN1cHBvcnRzICYmIGluZm8uY29uZi5zdXBwb3J0c1ttc2dPYmouY21kXSAmJiBpbmZvLmNvbmYuc3VwcG9ydHNbbXNnT2JqLmNtZF0gIT09IFwiMFwiO1xuICAgICAgICAgICAgICAgIGlmIChjYW5SZWFkKSB7XG4gICAgICAgICAgICAgICAgICBfcmVhZF9jb29raWUobXNnT2JqKTtcbiAgICAgICAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhcIm9uQ29va2llUmVhZFwiLCBtc2dPYmoucG9zLCBtc2dPYmouY29va2llKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwid3JpdGUtY29va2llXCI6XG4gICAgICAgICAgICAgICAgY2FuV3JpdGUgPSBpbmZvLmNvbmYgJiYgaW5mby5jb25mLnN1cHBvcnRzICYmIGluZm8uY29uZi5zdXBwb3J0c1ttc2dPYmouY21kXSAmJiBpbmZvLmNvbmYuc3VwcG9ydHNbbXNnT2JqLmNtZF0gIT09IFwiMFwiO1xuICAgICAgICAgICAgICAgIGlmIChjYW5Xcml0ZSkge1xuICAgICAgICAgICAgICAgICAgX3dyaXRlX2Nvb2tpZShtc2dPYmopO1xuICAgICAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFwib25Db29raWVXcml0ZVwiLCBtc2dPYmoucG9zLCBtc2dPYmouY29va2llKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2sgd2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBTYWZlRnJhbWVzIGJlaW5nIHJlbmRlcmVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2hhc19wZW5kaW5nX3JlbmRlcnNcbiAgICBAc3RhdGljXG4gICAgQHByaXZhdGVcbiAgICBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfaGFzX3BlbmRpbmdfcmVuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFsbF9yZW5kZXJzX2RvbmUsIHBvc19pZDtcbiAgICAgIGFsbF9yZW5kZXJzX2RvbmUgPSB0cnVlO1xuICAgICAgcG9zX2lkID0gdm9pZCAwO1xuICAgICAgZm9yIChwb3NfaWQgaW4gcGVuZGluZ19pZnJzKSB7XG4gICAgICAgIGFsbF9yZW5kZXJzX2RvbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsX3JlbmRlcnNfZG9uZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZW5kIGEgcmVzcG9uc2UgYmFjayBkb3duIHRvIHRoZSBTYWZlRnJhbWUgYWZ0ZXIgYSBtZXNzYWdlIHdhcyBoYW5kbGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX3NlbmRfcmVzcG9uc2VcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IHBhcmFtcyBUaGUgcGFyYW1ldGVycyBvYmplY3Qgc3RvcmVkIGZvciBhIHJlbmRlcmVkIFNhZmVGcmFtZSBob2xkaW5nIHN0YXRlIGluZm9ybWF0aW9uXG4gICAgQHBhcmFtIHskc2YubGliLmxhbmcuUGFyYW1IYXNofSBtc2dPYmogVGhlIG1lc3NhZ2UgdG8gc2VuZCBiYWNrIGRvd24gaW50byB0aGUgU2FmZUZyYW1lXG4gICAgICovXG4gICAgX3NlbmRfcmVzcG9uc2UgPSBmdW5jdGlvbihwYXJhbXMsIG1zZ09iaikge1xuXG4gICAgICAvKlxuICAgICAgQGlnbm9yZVxuICAgICAgICovXG4gICAgICBjdXJyZW50X3N0YXR1cyA9IFwic2VuZGluZy1tc2ctZG93bi1cIiArIG1zZ09iai5jbWQ7XG4gICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZCA9IHBhcmFtcyAmJiBwYXJhbXMuZGVzdDtcbiAgICAgICAgaWYgKGlkICYmIG1zZ09iaikge1xuICAgICAgICAgIHNlbmRfbXNnX3RvX2NoaWxkX2lmcmFtZShpZCwgbXNnT2JqLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJcIjtcbiAgICAgICAgbXNnT2JqID0gaWQgPSBwYXJhbXMgPSBudWxsO1xuICAgICAgfSksIFhDT01fUkVTUF9ERUxBWSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgSGFuZGxlIHRoZSBvbmxvYWQgZXZlbnQgZnJvbSB0aGUgSUZSQU1FIHRhZyBjcmVhdGVkIGZvciBhIFNhZmVGcmFtZS5cbiAgICBOb3RlIHRoYXQgYi9jIHdlIHVzZWQgb3VyIG93biBsaWJyYXJ5IHRvIGNyZWF0ZSB0aGUgSUZSQU1FICgkc2YubGliLmRvbS5pZnJhbWVzKSxcbiAgICB0aGUgXCJ0aGlzXCIga2V5d29yZCB3aWxsIG5vdyBwcm9wZXJseSBwb2ludCB0byB0aGUgSUZSQU1FIGluIHF1ZXN0aW9uLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfZnJhbWVfbG9hZFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9oYW5kbGVfZnJhbWVfbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFsbF9yZW5kZXJzX2RvbmUsIGVsLCBwb3NfaWQ7XG4gICAgICBlbCA9IHRoaXM7XG4gICAgICBwb3NfaWQgPSBkb20uYXR0cihlbCwgXCJfcG9zX2lkXCIpO1xuICAgICAgYWxsX3JlbmRlcnNfZG9uZSA9IHRydWU7XG4gICAgICBpZiAocGVuZGluZ19pZnJzW3Bvc19pZF0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmdfaWZyc1twb3NfaWRdKTtcbiAgICAgICAgZGVsZXRlIHBlbmRpbmdfaWZyc1twb3NfaWRdO1xuICAgICAgICBjb21wbGV0ZV9pZnJzW3Bvc19pZF0gPSBwb3NfaWQ7XG4gICAgICAgIGRvbS5hdHRyKGVsLCBcIl9wb3NfaWRcIiwgbnVsbCk7XG4gICAgICAgIGRvbS5hdHRyKGVsLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgICAgIGVsW1NUXS52aXNpYmlsaXR5ID0gXCJpbmhlcml0XCI7XG4gICAgICAgIGVsW1NUXS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soXCJvbkVuZFBvc1JlbmRlclwiLCBwb3NfaWQpO1xuICAgICAgfVxuICAgICAgaWYgKCFfaGFzX3BlbmRpbmdfcmVuZGVycygpKSB7XG4gICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBCdWlsZCBhbiBleHRyYSBJRlJBTUUgdG8gcHV0IGJlaGluZCBhbnkgaWZyYW1lIHRoYXQgaXMgZXhwYW5kaW5nLCB0byBwcm90ZWN0XG4gICAgYWdhaW5zdCBwYWludGluZyBpc3N1ZXMgaW4gSUUgd2l0aCB3aW5kb3cnZCBtb2RlIGZsYXNoLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9zaGltX2ZyYW1lXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX3NoaW1fZnJhbWUgPSBmdW5jdGlvbihpZCwgc2hvd0l0LCB3LCBoLCB6KSB7XG4gICAgICB2YXIgaWZyLCBzaG1Gcm0sIHNobUlEO1xuICAgICAgaWYgKCFpc0lFKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmciA9IF9lbHQoaWQpO1xuICAgICAgc2htSUQgPSBcInNobV9cIiArIGlkO1xuICAgICAgc2htRnJtID0gX2VsdChzaG1JRCk7XG4gICAgICBpZiAoc2hvd0l0KSB7XG4gICAgICAgIGlmIChzaG1Gcm0pIHtcbiAgICAgICAgICBzaG1Gcm1bU1RdLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2htRnJtID0gaWZyYW1lcy5jbG9uZShpZnIsIHtcbiAgICAgICAgICBpZDogc2htSUQsXG4gICAgICAgICAgc3JjOiBcIlwiLFxuICAgICAgICAgIG5hbWU6IHNobUlEXG4gICAgICAgIH0sIFtXSURUSCwgXCI6XCIsIHcsIFBYLCBcIjtwb3NpdGlvbjphYnNvbHV0ZTtcIiwgSEVJR0hULCBcIjpcIiwgaCwgUFgsIFwiO3otaW5kZXg6XCIsIHogLSAxLCBcIjtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKG9wYWNpdHk9MClcIl0pO1xuICAgICAgICBkb20uYXBwZW5kKF9wYXIoaWZyKSwgc2htRnJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc2hvd0l0ICYmIHNobUZybSkge1xuICAgICAgICAgIHNobUZybVtTVF0udmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBCdWlsZCBhIGdlb21ldHJ5IGluZm8gb2JqZWN0IGZvciBhIHBhcnRpY3VsYXIgU2FmZUZyYW1lIHBvc2l0aW9uLCBhbmQgYWxzb1xuICAgIG1heSBhdHRhY2ggYW4gb25zY3JvbGwgZXZlbnQgbGlzdGVuZXIgdG8gYSBwYXJlbnQgSFRNTCBlbGVtZW50IGlmIHNhaWQgcGFyZW50IGVsZW1lbnRcbiAgICBpcyBzY3JvbGxhYmxlIGJ1dCBub3QgdGhlIHJvb3QgZG9jdW1lbnQgbm9kZSAvIGJvZHlcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1fYnVpbGRfZ2VvbVxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEByZXR1cm4ge09iamVjdH0gV2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gU2FmZUZyYW1lXG4gICAgICovXG4gICAgX2J1aWxkX2dlb20gPSBmdW5jdGlvbihwb3NJRCwgZGVzdCwgZG9udF9hdHRhY2hfc2Nyb2xsX2V2dCkge1xuICAgICAgdmFyIGRldGFpbHMsIGUsIGV4LCBpbmZvLCBuZXdfcmVmX25vZGUsIG5vZGUsIHMsIHNjcl9oYW5kbGU7XG4gICAgICBib3VuZHMgPSB2b2lkIDA7XG4gICAgICBpbmZvID0gUGFyYW1IYXNoKCk7XG4gICAgICBkZXRhaWxzID0ge307XG4gICAgICBzY3JfaGFuZGxlID0gdm9pZCAwO1xuICAgICAgbm9kZSA9IHZvaWQgMDtcbiAgICAgIG5ld19yZWZfbm9kZSA9IHZvaWQgMDtcbiAgICAgIGV4ID0gdm9pZCAwO1xuICAgICAgcyA9IHZvaWQgMDtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBib3VuZHMgPSBkb20uYm91bmRzKGRlc3QsIGRldGFpbHMsIHRydWUpO1xuICAgICAgICBpZiAoIWRvbnRfYXR0YWNoX3Njcm9sbF9ldnQgJiYgIWRldGFpbHMuaXNSb290ICYmIGRldGFpbHMuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgZXggPSBkZXRhaWxzLmV4cFJlY3Q7XG4gICAgICAgICAgaWYgKGV4LnhzIHx8IGV4LnlzKSB7XG4gICAgICAgICAgICBzY3JfaGFuZGxlID0gc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcG9zSURdO1xuICAgICAgICAgICAgbmV3X3JlZl9ub2RlID0gZGV0YWlscy5yZWZOb2RlO1xuICAgICAgICAgICAgaWYgKHNjcl9oYW5kbGUgJiYgc2NyX2hhbmRsZS5ub2RlICE9PSBuZXdfcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNjcl9oYW5kbGUudElEKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcl9oYW5kbGUudElEKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb20uZGV0YWNoKG5vZGUsIFNDUk9MTCwgc2NyX2hhbmRsZVtPTlNDUk9MTF0pO1xuICAgICAgICAgICAgICBzY3JfaGFuZGxlLm5vZGUgPSBzY3JfaGFuZGxlW09OU0NST0xMXSA9IG51bGw7XG4gICAgICAgICAgICAgIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXSA9IG51bGw7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXSkge1xuICAgICAgICAgICAgICBzY3JfaGFuZGxlID0ge307XG4gICAgICAgICAgICAgIHNjcl9oYW5kbGUubm9kZSA9IG5ld19yZWZfbm9kZTtcblxuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBAaWdub3JlXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBzY3JfaGFuZGxlW09OU0NST0xMXSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIF9oYW5kbGVfbm9kZV9zY3JvbGwoZXZ0LCBwb3NJRCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXSA9IHNjcl9oYW5kbGU7XG4gICAgICAgICAgICAgIGRvbS5hdHRhY2gobmV3X3JlZl9ub2RlLCBTQ1JPTEwsIHNjcl9oYW5kbGVbT05TQ1JPTExdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBpbmZvID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgaW5mby53aW4gPSBQYXJhbUhhc2goZG9tLndpblJlY3QoKSk7XG4gICAgICAgICAgaW5mby5wYXIgPSBQYXJhbUhhc2goZGV0YWlscy5yZWZSZWN0KTtcbiAgICAgICAgICBleCA9IFBhcmFtSGFzaChkZXRhaWxzLmV4cFJlY3QpO1xuICAgICAgICAgIHMgPSBQYXJhbUhhc2goZGV0YWlscy5yZWN0KTtcbiAgICAgICAgICBzLml2ID0gZXguaXY7XG4gICAgICAgICAgcy54aXYgPSBleC54aXY7XG4gICAgICAgICAgcy55aXYgPSBleC55aXY7XG4gICAgICAgICAgZGVsZXRlIGV4Lml2O1xuICAgICAgICAgIGRlbGV0ZSBleC54aXY7XG4gICAgICAgICAgZGVsZXRlIGV4LnlpdjtcbiAgICAgICAgICBpbmZvLmV4cCA9IGV4O1xuICAgICAgICAgIGluZm8uc2VsZiA9IHM7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBpbmZvID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEV4cGFuZHMgYSBnaXZlbiBTYWZlRnJhbWUgYmFzZWQgb24gYSBjb21tYW5kIGZyb20gdGhlIDNyZCBwYXJ0eSBjb250ZW50XG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2V4cGFuZF9zYWZlZnJhbWVcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBEZXRhaWxzIGFib3V0IGhvdyB0byBkbyB0aGUgZXhwYW5zaW9uXG4gICAgXG4gICAgVE9ETywgaGFuZGxlIG9tbmktZGlyZWN0aW9uYWwgYW5kIHB1c2hcbiAgICAgKi9cbiAgICBfZXhwYW5kX3NhZmVmcmFtZSA9IGZ1bmN0aW9uKG1zZ09iaiwgcHVzaCkge1xuICAgICAgdmFyIGIsIGRlbHRhLCBkeCwgZHksIGV4cCwgaWQsIGlmciwgaWZyU3QsIGwsIG5IdCwgbldkLCBvckh0LCBvcldkLCBwYXIsIHBhclN0LCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRCwgciwgc2NyX2hhbmRsZSwgdCwgeG4sIHluLCB6O1xuICAgICAgeG4gPSBmYWxzZTtcbiAgICAgIHluID0gZmFsc2U7XG4gICAgICBwb3NJRCA9IG1zZ09iaiAmJiBtc2dPYmoucG9zO1xuICAgICAgcGFyYW1zID0gdm9pZCAwO1xuICAgICAgcGFyYW1zX2NvbmYgPSB2b2lkIDA7XG4gICAgICBpZnIgPSB2b2lkIDA7XG4gICAgICBwYXIgPSB2b2lkIDA7XG4gICAgICBpZnJTdCA9IHZvaWQgMDtcbiAgICAgIHBhclN0ID0gdm9pZCAwO1xuICAgICAgb3JXZCA9IHZvaWQgMDtcbiAgICAgIG9ySHQgPSB2b2lkIDA7XG4gICAgICBkeCA9IHZvaWQgMDtcbiAgICAgIGR5ID0gdm9pZCAwO1xuICAgICAgbldkID0gdm9pZCAwO1xuICAgICAgbkh0ID0gdm9pZCAwO1xuICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICB0ID0gdm9pZCAwO1xuICAgICAgbCA9IHZvaWQgMDtcbiAgICAgIHIgPSB2b2lkIDA7XG4gICAgICBiID0gdm9pZCAwO1xuICAgICAgZXhwID0gdm9pZCAwO1xuICAgICAgeiA9IHZvaWQgMDtcbiAgICAgIGRlbHRhID0gdm9pZCAwO1xuICAgICAgc2NyX2hhbmRsZSA9IHZvaWQgMDtcbiAgICAgIGlmICghcG9zSUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICBwYXJhbXNfY29uZiA9IHBhcmFtcyAmJiBwYXJhbXMuY29uZjtcbiAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXNfY29uZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZCA9IHBhcmFtcy5kZXN0O1xuICAgICAgaWZyID0gX2VsdChpZCk7XG4gICAgICBwYXIgPSBfZWx0KFBPU19SRUxfQk9YX0lEX1BSRUZJWCArIFwiX1wiICsgcG9zSUQpO1xuICAgICAgaWYgKCFpZnIgfHwgIXBhcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZnJTdCA9IGlmcltTVF07XG4gICAgICBwYXJTdCA9IHBhcltTVF07XG4gICAgICBpZiAoIWlmclN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNjcl9oYW5kbGUgPSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICBpZiAoc2NyX2hhbmRsZSAmJiBzY3JfaGFuZGxlLnRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgfVxuICAgICAgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyKCk7XG4gICAgICBleHAgPSBtc2dPYmouZXhwX29iajtcbiAgICAgIG9yV2QgPSBwYXJhbXNfY29uZi53O1xuICAgICAgb3JIdCA9IHBhcmFtc19jb25mLmg7XG4gICAgICBpZiAoIWV4cCkge1xuICAgICAgICBkeCA9IHBhcmFtcy5keCA9IF9jbnVtKG1zZ09iai5keCk7XG4gICAgICAgIGR5ID0gcGFyYW1zLmR5ID0gX2NudW0obXNnT2JqLmR5KTtcbiAgICAgICAgeG4gPSBkeCA8IDA7XG4gICAgICAgIHluID0gZHkgPCAwO1xuICAgICAgICBuV2QgPSAoeG4gPyBvcldkICsgKGR4ICogLTEpIDogb3JXZCArIGR4KTtcbiAgICAgICAgbkh0ID0gKHluID8gb3JIdCArIChkeSAqIC0xKSA6IG9ySHQgKyBkeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0gX2NudW0oZXhwLnQsIDAsIDApO1xuICAgICAgICBsID0gX2NudW0oZXhwLmwsIDAsIDApO1xuICAgICAgICByID0gX2NudW0oZXhwLnIsIDAsIDApO1xuICAgICAgICBiID0gX2NudW0oZXhwLmIsIDAsIDApO1xuICAgICAgICBuV2QgPSBfY251bShvcldkICsgbCArIHIsIDAsIDApO1xuICAgICAgICBuSHQgPSBfY251bShvckh0ICsgdCArIGIsIDAsIDApO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIGR5ID0gdCAqIC0xO1xuICAgICAgICAgIHluID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICBkeCA9IGwgKiAtMTtcbiAgICAgICAgICB4biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobldkIDw9IG9yV2QgJiYgbkh0IDw9IG9ySHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF9maXJlX3B1Yl9jYWxsYmFjayhCRl9QT1NfTVNHLCBwb3NJRCwgRVhQQU5EX0NPTU1BTkQsIGR4LCBkeSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWZyU3RbV0lEVEhdID0gbldkICsgUFg7XG4gICAgICBpZnJTdFtIRUlHSFRdID0gbkh0ICsgUFg7XG4gICAgICBpZiAoeG4pIHtcbiAgICAgICAgaWZyU3QubGVmdCA9IGR4ICsgUFg7XG4gICAgICB9XG4gICAgICBpZiAoeW4pIHtcbiAgICAgICAgaWZyU3QudG9wID0gZHkgKyBQWDtcbiAgICAgIH1cbiAgICAgIHogPSBfY251bShwYXJhbXMueiwgMCk7XG4gICAgICBpZiAoIXopIHtcbiAgICAgICAgeiA9IERFRkFVTFRfWklOREVYO1xuICAgICAgfVxuICAgICAgaWZyU3QuekluZGV4ID0gejtcbiAgICAgIF9zaGltX2ZyYW1lKGlkLCB0cnVlLCBuV2QsIG5IdCwgeiAtIDEpO1xuICAgICAgaWYgKHB1c2gpIHtcbiAgICAgICAgcGFyU3RbV0lEVEhdID0gbldkICsgUFg7XG4gICAgICAgIHBhclN0W0hFSUdIVF0gPSBuSHQgKyBQWDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhclN0W1dJRFRIXSA9IG9yV2QgKyBQWDtcbiAgICAgICAgcGFyU3RbSEVJR0hUXSA9IG9ySHQgKyBQWDtcbiAgICAgIH1cbiAgICAgIHBhcmFtcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICBtc2dPYmouZHggPSBkeDtcbiAgICAgIG1zZ09iai5keSA9IGR5O1xuICAgICAgbXNnT2JqLncgPSBuV2Q7XG4gICAgICBtc2dPYmouaCA9IG5IdDtcbiAgICAgIG1zZ09iai5jbWQgPSBcImV4cGFuZFwiO1xuICAgICAgbXNnT2JqLmdlb20gPSBfZXMoX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSkpO1xuICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBFWFBBTkRfQ09NTUFORCwgZHgsIGR5KTtcbiAgICAgIF9zZW5kX3Jlc3BvbnNlKHBhcmFtcywgbXNnT2JqKTtcbiAgICAgIGlmclN0ID0gcGFyID0gaWZyID0gcGFyYW1zID0gbXNnT2JqID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDb2xsYXBzZSBhIFNhZmVGcmFtZSBhZnRlciBpdCBoYXMgYmVlbiBleHBhbmRlZFxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9jb2xsYXBzZV9zYWZlZnJhbWVcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBUaGUgZGV0YWlscyBhYm91dCB0aGUgbWVzc2FnZSBzZW5kIGZyb20gdGhlIFNhZmVGcmFtZSB0byBjb2xsYXBzZVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2lzT3V0c2lkZV0gV2hldGhlciBvciBub3QgdGhlIGNvbGxhcHNlIGNvbW1hbmQgY2FtZSBmcm9tIHRoZSBwdWJsaXNoZXJcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtub01zZ2luZ10gV2hldGhlciBvciBub3QgdG8gc2VuZCBhIG1lc3NhZ2Ugb2YgcmVzcG9uc2UgYmFjayB0byB0aGUgU2FmZUZyYW1lIGJlaW5nIGNvbGxhcHNlZFxuICAgICAqL1xuICAgIF9jb2xsYXBzZV9zYWZlZnJhbWUgPSBmdW5jdGlvbihtc2dPYmosIGlzT3V0c2lkZSwgbm9Nc2dpbmcpIHtcbiAgICAgIHZhciBpZCwgaWZyLCBpZnJTdCwgcGFyLCBwYXJTdCwgcGFyYW1zLCBwYXJhbXNfY29uZiwgcG9zSUQsIHNjcl9oYW5kbGU7XG4gICAgICBwb3NJRCA9IG1zZ09iaiAmJiBtc2dPYmoucG9zO1xuICAgICAgcGFyYW1zID0gcG9zSUQgJiYgcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICBwYXJhbXNfY29uZiA9IHBhcmFtcyAmJiBwYXJhbXMuY29uZjtcbiAgICAgIGlkID0gcGFyYW1zX2NvbmYgJiYgcGFyYW1zX2NvbmYuZGVzdDtcbiAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgcGFyID0gaWZyICYmIF9lbHQoUE9TX1JFTF9CT1hfSURfUFJFRklYICsgXCJfXCIgKyBwb3NJRCk7XG4gICAgICBpZnJTdCA9IGlmciAmJiBpZnJbU1RdO1xuICAgICAgcGFyU3QgPSBwYXIgJiYgcGFyW1NUXTtcbiAgICAgIHNjcl9oYW5kbGUgPSB2b2lkIDA7XG4gICAgICBpZiAoIXBvc0lEIHx8ICFwYXJhbXMgfHwgIWlmciB8fCAhcGFyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyYW1zLmV4cGFuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNjcl9oYW5kbGUgPSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICBpZiAoc2NyX2hhbmRsZSAmJiBzY3JfaGFuZGxlLnRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgfVxuICAgICAgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyKCk7XG4gICAgICBpZiAoIW5vTXNnaW5nKSB7XG4gICAgICAgIGlmIChfZmlyZV9wdWJfY2FsbGJhY2soQkZfUE9TX01TRywgcG9zSUQsIENPTExBUFNFX0NPTU1BTkQsIDAsIDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZnJTdC5sZWZ0ID0gaWZyU3QudG9wID0gXCIwcHhcIjtcbiAgICAgIHBhclN0W1dJRFRIXSA9IGlmclN0W1dJRFRIXSA9IHBhcmFtc19jb25mLncgKyBQWDtcbiAgICAgIHBhclN0W0hFSUdIVF0gPSBpZnJTdFtIRUlHSFRdID0gcGFyYW1zX2NvbmYuaCArIFBYO1xuICAgICAgaWZyU3QuekluZGV4ID0gcGFyYW1zLmR4ID0gcGFyYW1zLmR5ID0gMDtcbiAgICAgIF9zaGltX2ZyYW1lKGlkKTtcbiAgICAgIGlmICghbm9Nc2dpbmcpIHtcbiAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBDT0xMQVBTRV9DT01NQU5ELCAwLCAwKTtcbiAgICAgICAgbXNnT2JqLmNtZCA9IChpc091dHNpZGUgPyBcImNvbGxhcHNlZFwiIDogXCJjb2xsYXBzZVwiKTtcbiAgICAgICAgbXNnT2JqLmdlb20gPSBfZXMoX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSkpO1xuICAgICAgICBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICB9XG4gICAgICBpZnIgPSBpZnJTdCA9IHBhciA9IHBhclN0ID0gcGFyYW1zID0gbXNnT2JqID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZWNvcmRzIGEgcmVwb3J0ZWQgZXJyb3IgbWVzc2FnZSB0byAkc2YuaW5mby5lcnJvcnMgYW5kIGZpcmVzIGFueSBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1fcmVjb3JkX2Vycm9yXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHskc2YubGliLmxhbmcuUGFyYW1IYXNofSBtc2dPYmogVGhlIGRldGFpbHMgYWJvdXQgdGhlIG1lc3NhZ2Ugc2VuZCBmcm9tIHRoZSBTYWZlRnJhbWUgaGF2aW5nIGFuIGVycm9yXG4gICAgICovXG4gICAgX3JlY29yZF9lcnJvciA9IGZ1bmN0aW9uKG1zZ09iaikge1xuICAgICAgdmFyIGlkLCBpZnIsIGlmclN0LCBwYXIsIHBhclN0LCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRCwgc2NyX2hhbmRsZTtcbiAgICAgIHBvc0lEID0gbXNnT2JqICYmIG1zZ09iai5wb3M7XG4gICAgICBwYXJhbXMgPSBwb3NJRCAmJiByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgaWQgPSBwYXJhbXNfY29uZiAmJiBwYXJhbXNfY29uZi5kZXN0O1xuICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICBwYXIgPSBpZnIgJiYgX2VsdChQT1NfUkVMX0JPWF9JRF9QUkVGSVggKyBcIl9cIiArIHBvc0lEKTtcbiAgICAgIGlmclN0ID0gaWZyICYmIGlmcltTVF07XG4gICAgICBwYXJTdCA9IHBhciAmJiBwYXJbU1RdO1xuICAgICAgc2NyX2hhbmRsZSA9IHZvaWQgMDtcbiAgICAgIGlmIChzZiAmJiBzZi5pbmZvICYmIHNmLmluZm8uZXJycykge1xuICAgICAgICBzZi5pbmZvLmVycnMucHVzaChtc2dPYmopO1xuICAgICAgfVxuICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBFUlJPUl9DT01NQU5ELCBtc2dPYmopO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnQgY29va2llcyBhcyBhIGhhc2hcbiAgICBAbmFtZSAkc2YubGliLl9jb29raWVIYXNoXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBfY29va2llSGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMsIGNvb2tpZXMsIGNvb2tzLCBpLCBrZXk7XG4gICAgICBjb29rcyA9IHZvaWQgMDtcbiAgICAgIGtleSA9IHZvaWQgMDtcbiAgICAgIGkgPSB2b2lkIDA7XG4gICAgICBjb29raWVzID0ge307XG4gICAgICBjID0gdm9pZCAwO1xuICAgICAgY29va3MgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7IFwiKTtcbiAgICAgIGkgPSBjb29rcy5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICBjID0gY29va3NbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBjb29raWVzW2NbMF1dID0gY1sxXTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmVhZCBhIGhvc3QgZG9tYWluIGNvb2tpZVxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9yZWFkX2Nvb2tpZVxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7JHNmLmxpYi5sYW5nLlBhcmFtSGFzaH0gbXNnT2JqIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBtZXNzYWdlIHNlbmQgZnJvbSB0aGUgU2FmZUZyYW1lXG4gICAgQHBhcmFtIHtCb29sZWFufSBbaXNPdXRzaWRlXSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZC1jb29raWUgY29tbWFuZCBjYW1lIGZyb20gdGhlIHB1Ymxpc2hlclxuICAgICAqL1xuICAgIF9yZWFkX2Nvb2tpZSA9IGZ1bmN0aW9uKG1zZ09iaiwgaXNPdXRzaWRlKSB7XG4gICAgICB2YXIgY2FuUmVhZCwgY29tbWFuZCwgY29va2llcywgaWQsIGlmciwga2V5LCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRDtcbiAgICAgIHBvc0lEID0gbXNnT2JqICYmIG1zZ09iai5wb3M7XG4gICAgICBwYXJhbXMgPSBwb3NJRCAmJiByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgaWQgPSBwYXJhbXNfY29uZiAmJiBwYXJhbXNfY29uZi5kZXN0O1xuICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICBrZXkgPSB2b2lkIDA7XG4gICAgICBjb29raWVzID0gdm9pZCAwO1xuICAgICAgY29tbWFuZCA9IFwicmVhZC1jb29raWVcIjtcbiAgICAgIGNhblJlYWQgPSBwYXJhbXNfY29uZi5zdXBwb3J0cyAmJiBwYXJhbXNfY29uZi5zdXBwb3J0c1tjb21tYW5kXSAmJiBwYXJhbXNfY29uZi5zdXBwb3J0c1tjb21tYW5kXSAhPT0gXCIwXCI7XG4gICAgICBpZiAoIWNhblJlYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFwb3NJRCB8fCAhcGFyYW1zIHx8ICFpZnIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAga2V5ID0gbXNnT2JqLmNvb2tpZTtcbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvb2tpZXMgPSBfY29va2llSGFzaCgpO1xuICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIGNvbW1hbmQsIHBvc0lELCAwLCAwKTtcbiAgICAgIG1zZ09iai5jbWQgPSBjb21tYW5kO1xuICAgICAgbXNnT2JqLmdlb20gPSBfZXMoX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSkpO1xuICAgICAgbXNnT2JqLnZhbHVlID0gY29va2llc1trZXldO1xuICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgaWZyID0gcGFyYW1zID0gbXNnT2JqID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBXcml0ZSBhIGhvc3QgZG9tYWluIGNvb2tpZVxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV93cml0ZV9jb29raWVcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBUaGUgZGV0YWlscyBhYm91dCB0aGUgbWVzc2FnZSBzZW5kIGZyb20gdGhlIFNhZmVGcmFtZVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2lzT3V0c2lkZV0gV2hldGhlciBvciBub3QgdGhlIHdyaXRlLWNvb2tpZSBjb21tYW5kIGNhbWUgZnJvbSB0aGUgcHVibGlzaGVyXG4gICAgICovXG4gICAgX3dyaXRlX2Nvb2tpZSA9IGZ1bmN0aW9uKG1zZ09iaiwgaXNPdXRzaWRlKSB7XG4gICAgICB2YXIgY192YWx1ZSwgY2FuUmVhZCwgY29tbWFuZCwgY29va2llcywgZXhkYXRlLCBpZCwgaWZyLCBrZXksIG5ld0Nvb2tpZXMsIG5ld1ZhbHVlLCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRDtcbiAgICAgIHBvc0lEID0gbXNnT2JqICYmIG1zZ09iai5wb3M7XG4gICAgICBwYXJhbXMgPSBwb3NJRCAmJiByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgaWQgPSBwYXJhbXNfY29uZiAmJiBwYXJhbXNfY29uZi5kZXN0O1xuICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICBrZXkgPSB2b2lkIDA7XG4gICAgICBuZXdWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIGNvb2tpZXMgPSB2b2lkIDA7XG4gICAgICBuZXdDb29raWVzID0gdm9pZCAwO1xuICAgICAgY29tbWFuZCA9IFwid3JpdGUtY29va2llXCI7XG4gICAgICBjYW5SZWFkID0gcGFyYW1zX2NvbmYuc3VwcG9ydHMgJiYgcGFyYW1zX2NvbmYuc3VwcG9ydHNbY29tbWFuZF0gJiYgcGFyYW1zX2NvbmYuc3VwcG9ydHNbY29tbWFuZF0gIT09IFwiMFwiO1xuICAgICAgaWYgKCFjYW5SZWFkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcG9zSUQgfHwgIXBhcmFtcyB8fCAhaWZyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGtleSA9IG1zZ09iai5jb29raWU7XG4gICAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdWYWx1ZSA9IGVzY2FwZShtc2dPYmoudmFsdWUpO1xuICAgICAgZXhkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGV4ZGF0ZS5zZXREYXRlKGV4ZGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgIGNfdmFsdWUgPSBuZXdWYWx1ZSArIFwiOyBleHBpcmVzPVwiICsgZXhkYXRlLnRvVVRDU3RyaW5nKCk7XG4gICAgICBkb2N1bWVudC5jb29raWUgPSBrZXkgKyBcIj1cIiArIGNfdmFsdWU7XG4gICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgY29tbWFuZCwgcG9zSUQsIDAsIDApO1xuICAgICAgbXNnT2JqLmNtZCA9IGNvbW1hbmQ7XG4gICAgICBtc2dPYmouZ2VvbSA9IF9lcyhfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKSk7XG4gICAgICBtc2dPYmouaW5mbyA9IG5ld1ZhbHVlO1xuICAgICAgbXNnT2JqLnZhbHVlID0gXCJcIjtcbiAgICAgIF9zZW5kX3Jlc3BvbnNlKHBhcmFtcywgbXNnT2JqKTtcbiAgICAgIGlmciA9IHBhcmFtcyA9IG1zZ09iaiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmVtb3ZlIC8gZGVzdHJveSBvbmUgb3IgbW9yZSBTYWZlRnJhbWVzIGZyb20gdGhlIHB1Ymxpc2hlciBwYWdlXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QubnVrZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcHVibGljXG4gICAgQHBhcmFtIHtTdHJpbmd9IHBvc19pZCogT25lIG9yIG1vcmUgcG9zaXRpb24gaWRzIHRvIHJlbW92ZSBmcm9tIHRoZSBwYWdlLiBJZiBubyBhcmd1bWVudHMgYXJlIHNwZWNpZmVkLCBhbGwgcG9zaXRpb25zIGN1cnJlbnRseSByZW5kZXJlZCBhcmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBudWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncywgZWwsIGVsX2lkLCBlbXB0eSwgaWR4LCBwYXIsIHBvcywgcG9zX2lkLCBzYl9yZWw7XG4gICAgICBpZHggPSAwO1xuICAgICAgZW1wdHkgPSB0cnVlO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHBvc19pZCA9IHZvaWQgMDtcbiAgICAgIHBvcyA9IHZvaWQgMDtcbiAgICAgIGVsX2lkID0gdm9pZCAwO1xuICAgICAgZWwgPSB2b2lkIDA7XG4gICAgICBzYl9yZWwgPSB2b2lkIDA7XG4gICAgICBwYXIgPSB2b2lkIDA7XG4gICAgICBpZiAoIWFyZ3NbTEVOXSB8fCBhcmdzW2lkeF0gPT09IFwiKlwiKSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yIChwb3NfaWQgaW4gcmVuZGVyZWRfaWZycykge1xuICAgICAgICAgIGFyZ3MucHVzaChwb3NfaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zX2lkID0gYXJnc1tpZHgrK10pIHtcbiAgICAgICAgcG9zID0gcmVuZGVyZWRfaWZyc1twb3NfaWRdO1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgaWYgKHBvc19pZCBpbiBwZW5kaW5nX2lmcnMpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nX2lmcnNbcG9zX2lkXSk7XG4gICAgICAgICAgICBkZWxldGUgcGVuZGluZ19pZnJzW3Bvc19pZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NfaWQgaW4gY29tcGxldGVfaWZycykge1xuICAgICAgICAgICAgZGVsZXRlIGNvbXBsZXRlX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxfaWQgPSBwb3MuZGVzdDtcbiAgICAgICAgICBlbCA9IGVsX2lkICYmIF9lbHQoZWxfaWQpO1xuICAgICAgICAgIHBhciA9IGVsICYmIF9wYXIoZWwpO1xuICAgICAgICAgIGlmIChkb20uYXR0cihwYXIsIFwiaWRcIikuaW5kZXhPZihQT1NfUkVMX0JPWF9JRF9QUkVGSVgpICE9PSAtMSkge1xuICAgICAgICAgICAgc2JfcmVsID0gcGFyO1xuICAgICAgICAgICAgcGFyID0gX3BhcihzYl9yZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb20ucHVyZ2UoZWwpO1xuICAgICAgICAgIGlmIChzYl9yZWwpIHtcbiAgICAgICAgICAgIGRvbS5wdXJnZShzYl9yZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW5kZXJlZF9pZnJzW3Bvc19pZF0gPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZSByZW5kZXJlZF9pZnJzW3Bvc19pZF07XG4gICAgICAgICAgZWwgPSBkb20ubWFrZShcImRpdlwiKTtcbiAgICAgICAgICBkb20uYXR0cihlbCwgXCJpZFwiLCBlbF9pZCk7XG4gICAgICAgICAgZG9tLmFwcGVuZChwYXIsIGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9zX2lkID0gXCJcIjtcbiAgICAgIGZvciAocG9zX2lkIGluIHJlbmRlcmVkX2lmcnMpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgY3VycmVudF9zdGF0dXMgPSBcIlwiO1xuICAgICAgICBfaGFuZGxlX3VubG9hZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFJlbmRlciBvbmUgb3IgbW9yZSAkc2YuaG9zdC5Qb3NpdGlvbiBvYmplY3RzIGludG8gdGhlIHBhZ2VcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC5yZW5kZXJcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7JHNmLmhvc3QuUG9zaXRpb259IHBvcyogQW4gaW5zdGFuY2Ugb2YgYW4gJHNmLmhvc3QuUG9zaXRpb24gb2JqZWN0IHRvIHJlbmRlci4gTm90ZSB0aGF0IHNhaWQgb2JqZWN0IG11c3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgJHNmLmhvc3QuUG9zQ29uZmlnLCBhcyB3ZWxsIGFzICRzZi5ob3N0LkNvbmZpZyBtdXN0IGhhdmUgYmVlbiBzZXRcbiAgICAgKi9cbiAgICByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzLCBjc3NfdHh0LCBkZXN0X2VsLCBkZXN0X2lkLCBkZXN0X3JlbF9pZCwgZSwgZmluYWxDU1NFbmQsIGZpbmFsQ1NTUG9zLCBmaXJzdENTU1BvcywgaCwgaWR4LCBuYW1lX3BhcmFtcywgbmV3X2Rlc3RfZWwsIHBhcl9lbCwgcGVuZCwgcG9zLCBwb3NfY29uZiwgcG9zX2lkLCByZWxfZWwsIHN0LCB3O1xuICAgICAgaWR4ID0gMDtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBmaXJzdENTU1BvcyA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGZpbmFsQ1NTUG9zID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgZmluYWxDU1NFbmQgPSBcInRvcDowcHg7bGVmdDowcHg7dmlzaWJpbGl0eTpoaWRkZW47ZGlzcGxheTpub25lO1wiO1xuICAgICAgcG9zID0gdm9pZCAwO1xuICAgICAgcG9zX2lkID0gdm9pZCAwO1xuICAgICAgcG9zX2NvbmYgPSB2b2lkIDA7XG4gICAgICBkZXN0X2VsID0gdm9pZCAwO1xuICAgICAgbmV3X2Rlc3RfZWwgPSB2b2lkIDA7XG4gICAgICByZWxfZWwgPSB2b2lkIDA7XG4gICAgICBwYXJfZWwgPSB2b2lkIDA7XG4gICAgICBuYW1lX3BhcmFtcyA9IHZvaWQgMDtcbiAgICAgIGRlc3RfaWQgPSB2b2lkIDA7XG4gICAgICBkZXN0X3JlbF9pZCA9IHZvaWQgMDtcbiAgICAgIGNzc190eHQgPSB2b2lkIDA7XG4gICAgICB3ID0gdm9pZCAwO1xuICAgICAgaCA9IHZvaWQgMDtcbiAgICAgIHN0ID0gdm9pZCAwO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHBlbmQgPSB2b2lkIDA7XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWRvbS5yZWFkeSgpKSB7XG4gICAgICAgIGRvbS53YWl0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbmRlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICBhcmdzID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKChhcmdzWzBdIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZ3NbTEVOXSA9PT0gMSkge1xuICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPSBhcmdzW2lkeCsrXSkge1xuICAgICAgICBwb3NfaWQgPSBwb3MuaWQ7XG4gICAgICAgIHBvc19jb25mID0gKHBvc19pZCA/IGNvbmZpZy5wb3NpdGlvbnNbcG9zX2lkXSA6IG51bGwpO1xuICAgICAgICBpZiAocG9zX2NvbmYpIHtcbiAgICAgICAgICBkZXN0X2lkID0gcG9zX2NvbmYuZGVzdDtcbiAgICAgICAgICBkZXN0X2VsID0gZGVzdF9pZCAmJiBfZWx0KGRlc3RfaWQpO1xuICAgICAgICAgIGlmIChkZXN0X2VsKSB7XG4gICAgICAgICAgICB3ID0gcG9zX2NvbmYudztcbiAgICAgICAgICAgIGggPSBwb3NfY29uZi5oO1xuICAgICAgICAgICAgaWYgKCF3KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdyA9IGRlc3RfZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICBwb3NfY29uZi53ID0gdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaCA9IGRlc3RfZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICAgIGggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICAgICAgcG9zX2NvbmYuaCA9IGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgICAgICAgbmFtZV9wYXJhbXMgPSBuZXcgUGFyYW1IYXNoKCk7XG4gICAgICAgICAgICAgIGRlc3RfcmVsX2lkID0gUE9TX1JFTF9CT1hfSURfUFJFRklYICsgXCJfXCIgKyBwb3NfaWQ7XG4gICAgICAgICAgICAgIHJlbF9lbCA9IF9lbHQoZGVzdF9yZWxfaWQpO1xuICAgICAgICAgICAgICBwYXJfZWwgPSBfcGFyKGRlc3RfZWwpO1xuICAgICAgICAgICAgICBpZiAocmVsX2VsICYmIHBhcl9lbCA9PT0gcmVsX2VsKSB7XG4gICAgICAgICAgICAgICAgcGFyX2VsID0gX3BhcihyZWxfZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9zaGltX2ZyYW1lKGRlc3RfaWQpO1xuXG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIEBpZ25vcmVcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIHBlbmQgPSBwZW5kaW5nX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgICAgaWYgKHBlbmQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocGVuZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGVuZCA9IGNvbXBsZXRlX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgICAgaWYgKHBlbmQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29tcGxldGVfaWZyc1twb3NfaWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBlbmRpbmdfaWZyc1twb3NfaWRdID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfaGFuZGxlX3JlbmRlcl90aW1lb3V0KHBvc19pZCk7XG4gICAgICAgICAgICAgIH0sIGNvbmZpZy50byk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJyZW5kZXJpbmdcIjtcbiAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFwib25TdGFydFBvc1JlbmRlclwiLCBwb3NfaWQsIHBvc19jb25mLCBwb3MpO1xuICAgICAgICAgICAgICBjc3NfdHh0ID0gW1wicG9zaXRpb246XCIsIFwiXCIsIFwiO3otaW5kZXg6MDtcIiwgV0lEVEgsIFwiOlwiLCB3LCBQWCwgXCI7XCIsIEhFSUdIVCwgXCI6XCIsIGgsIFBYLCBcIjtcIiwgXCJ2aXNpYmlsaXR5OmluaGVyaXQ7XCJdO1xuICAgICAgICAgICAgICBpZiAoIXJlbF9lbCkge1xuICAgICAgICAgICAgICAgIGNzc190eHRbMV0gPSBmaXJzdENTU1BvcztcbiAgICAgICAgICAgICAgICByZWxfZWwgPSBkb20ubWFrZShcImRpdlwiKTtcbiAgICAgICAgICAgICAgICByZWxfZWwuaWQgPSBkZXN0X3JlbF9pZDtcbiAgICAgICAgICAgICAgICByZWxfZWwuY2xhc3NOYW1lID0gXCJpYWJfc2ZcIjtcbiAgICAgICAgICAgICAgICBuZXdfZGVzdF9lbCA9IGRlc3RfZWwuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkb20uY3NzKG5ld19kZXN0X2VsLCBjc3NfdHh0KTtcbiAgICAgICAgICAgICAgICByZWxfZWwuYXBwZW5kQ2hpbGQobmV3X2Rlc3RfZWwpO1xuICAgICAgICAgICAgICAgIGRvbS5jc3MocmVsX2VsLCBjc3NfdHh0KTtcbiAgICAgICAgICAgICAgICBwYXJfZWwucmVwbGFjZUNoaWxkKHJlbF9lbCwgZGVzdF9lbCk7XG4gICAgICAgICAgICAgICAgZGVzdF9lbCA9IF9lbHQoZGVzdF9pZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3QgPSByZWxfZWxbU1RdO1xuICAgICAgICAgICAgICAgIHN0LndpZHRoID0gdyArIFBYO1xuICAgICAgICAgICAgICAgIHN0LmhlaWdodCA9IGggKyBQWDtcbiAgICAgICAgICAgICAgICBzdCA9IGRlc3RfZWwgJiYgZGVzdF9lbFtTVF07XG4gICAgICAgICAgICAgICAgc3Qud2lkdGggPSB3ICsgUFg7XG4gICAgICAgICAgICAgICAgc3QuaGVpZ2h0ID0gaCArIFBYO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmlkID0gcG9zX2lkO1xuICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5kZXN0ID0gZGVzdF9pZDtcbiAgICAgICAgICAgICAgbmFtZV9wYXJhbXMuY29uZiA9IFBhcmFtSGFzaChwb3NfY29uZik7XG4gICAgICAgICAgICAgIG5hbWVfcGFyYW1zLm1ldGEgPSBwb3MubWV0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5odG1sID0gX2VzKHBvcy5odG1sKTtcbiAgICAgICAgICAgICAgbmFtZV9wYXJhbXMuZ2VvbSA9IF9lcyhfYnVpbGRfZ2VvbShwb3NfaWQsIGRlc3RfZWwpKTtcbiAgICAgICAgICAgICAgbmFtZV9wYXJhbXMuc3JjID0gY29uZmlnLnJlbmRlckZpbGU7XG4gICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmhhc19mb2N1cyA9IGxhbmcuY3N0cihkb2N1bWVudC5oYXNGb2N1cygpKTtcbiAgICAgICAgICAgICAgY3NzX3R4dFsxXSA9IGZpbmFsQ1NTUG9zO1xuICAgICAgICAgICAgICBjc3NfdHh0WzEzXSA9IGZpbmFsQ1NTRW5kO1xuICAgICAgICAgICAgICBpZiAoIXdpbl9ldmVudHNfYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgU0NST0xMLCBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCk7XG4gICAgICAgICAgICAgICAgZG9tLmF0dGFjaCh3aW4sIFwicmVzaXplXCIsIF9oYW5kbGVfd2luX2dlb21fcmVzaXplKTtcbiAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgXCJ1bmxvYWRcIiwgX2hhbmRsZV91bmxvYWQpO1xuICAgICAgICAgICAgICAgIGRvbS5hdHRhY2god2luLCBcImZvY3VzXCIsIF9oYW5kbGVfd2luX2ZvY3VzKTtcbiAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgXCJibHVyXCIsIF9oYW5kbGVfd2luX2JsdXIpO1xuICAgICAgICAgICAgICAgIHdpbl9ldmVudHNfYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmcmFtZXMucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGRlc3RfaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV9wYXJhbXMsXG4gICAgICAgICAgICAgICAgc3JjOiBjb25maWcucmVuZGVyRmlsZSxcbiAgICAgICAgICAgICAgICBfcG9zX2lkOiBwb3NfaWRcbiAgICAgICAgICAgICAgfSwgY3NzX3R4dCwgcmVsX2VsLCBfaGFuZGxlX2ZyYW1lX2xvYWQsIF9oYW5kbGVfbXNnX2V2dCk7XG4gICAgICAgICAgICAgIHJlbmRlcmVkX2lmcnNbcG9zX2lkXSA9IG5hbWVfcGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEdldHMgYSBjb3B5IG9mIHRoZSBQb3NpdGlvbiBjb25maWd1cmF0aW9uLCBjb250ZW50LCBhbmQgbWV0YSBkYXRhIGZvciBhIGdpdmVuIFNhZmVGcmFtZVxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LmdldFxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldCA9IGZ1bmN0aW9uKHBvc2l0aW9uSWQpIHtcbiAgICAgIHZhciBvYmo7XG4gICAgICBvYmogPSByZW5kZXJlZF9pZnJzW3Bvc2l0aW9uSWRdO1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gX21peCh7fSwgb2JqKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm5zIGEgc3RyaW5nIGFzIHRvIHdoZXRoZXIgb3Igbm90IHRoZSBsaWJyYXJ5IGlzIGJ1c3ksIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBvbiBpZGxlXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3Quc3RhdHVzXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3VycmVudF9zdGF0dXM7XG4gICAgfTtcbiAgICBfc2VuZF9nZW5lcmljX3Jlc3BvbnNlID0gZnVuY3Rpb24ocG9zSUQsIGNvbW1hbmQpIHtcbiAgICAgIHZhciBtc2dPYmosIHBhcmFtcztcbiAgICAgIG1zZ09iaiA9IG5ldyBQYXJhbUhhc2goKTtcbiAgICAgIHBhcmFtcyA9IHBvc0lEICYmIHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgbXNnT2JqLmNtZCA9IGNvbW1hbmQ7XG4gICAgICBtc2dPYmoucG9zID0gcG9zSUQ7XG4gICAgICByZXR1cm4gX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgIH07XG4gICAgX2dldEdlb20gPSBmdW5jdGlvbihwb3NJRCkge1xuICAgICAgdmFyIGcsIGlkLCBpZnIsIHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgaWQgPSBwYXJhbXMgJiYgcGFyYW1zLmRlc3Q7XG4gICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgIGcgPSBfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKTtcbiAgICAgIHJldHVybiBnO1xuICAgIH07XG4gICAgaW5WaWV3UGVyY2VudGFnZSA9IGZ1bmN0aW9uKHBvc0lEKSB7XG4gICAgICB2YXIgZ2VvbV9pbmZvLCBpdiwgdHYsIF9yZWY7XG4gICAgICBnZW9tX2luZm8gPSBfZ2V0R2VvbShwb3NJRCk7XG4gICAgICBpdiA9IF9jbnVtKGdlb21faW5mbyAhPSBudWxsID8gKF9yZWYgPSBnZW9tX2luZm8uc2VsZikgIT0gbnVsbCA/IF9yZWYuaXYgOiB2b2lkIDAgOiB2b2lkIDAsIC0xLCAwKTtcbiAgICAgIGlmIChpdiA+PSAwKSB7XG4gICAgICAgIHR2ID0gTWF0aC5mbG9vcihpdiAqIDEwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHY7XG4gICAgfTtcbiAgICBpZiAobGFuZykge1xuICAgICAgaWYgKHdpbiA9PT0gdG9wKSB7XG4gICAgICAgIF9yZWN0ID0gKGllVmVyID8gX2dldFJlY3RJRSA6IF9nZXRSZWN0Tm9uSUUpO1xuICAgICAgICBfbWl4KGRvbSwge1xuICAgICAgICAgIHJlY3Q6IF9yZWN0LFxuICAgICAgICAgIGN1cnJlbnRTdHlsZTogY3VycmVudFN0eWxlLFxuICAgICAgICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICAgICAgICBkb2NSZWN0OiBkb2NSZWN0LFxuICAgICAgICAgIHdpblJlY3Q6IHdpblJlY3QsXG4gICAgICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICAgICAgb3ZlcmxhcHM6IG92ZXJsYXBzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qXG4gICAgICAgIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICAgIGRvbS5tc2dob3N0ID0ge1xuICAgICAgICAgICAgcHJlcDogcHJlcF9pZnJhbWVfbXNnaW5nLFxuICAgICAgICAgICAgYXR0YWNoOiBhdHRhY2hfaWZyYW1lX21zZ2luZyxcbiAgICAgICAgICAgIGRldGFjaDogZGV0YWNoX2lmcmFtZV9tc2dpbmcsXG4gICAgICAgICAgICB1c2luZ0hUTUw1OiB1c2luZ0hUTUw1LFxuICAgICAgICAgICAgc2VuZDogc2VuZF9tc2dfdG9fY2hpbGRfaWZyYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkb21bQVRUQUNIXSh3aW4sIE1TRywgX2NoZWNrX2h0bWw1X2luaXQpO1xuICAgICAgICAgIGluaXRJRCA9IFwieGRtLWh0bWw1LWluaXQtXCIgKyBfZ3VpZCgpO1xuICAgICAgICAgIGxvY0hvc3QgPSAobG9jSG9zdC5pbmRleE9mKFwiZmlsZVwiKSA9PT0gMCA/IGxvY0hvc3QgPSBcImZpbGVcIiA6IGxvY0hvc3QpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5bUE1TR10oaW5pdElELCAobG9jSG9zdCA9PT0gXCJmaWxlXCIgPyBcIipcIiA6IGxvY0hvc3QpKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICBkb21bREVUQUNIXSh3aW4sIE1TRywgX2NoZWNrX2h0bWw1X2luaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgX21peChzZi5ob3N0LCB7XG4gICAgICAgICAgQ29uZmlnOiBDb25maWcsXG4gICAgICAgICAgUG9zQ29uZmlnOiBQb3NDb25maWcsXG4gICAgICAgICAgUG9zTWV0YTogUG9zTWV0YSxcbiAgICAgICAgICBQb3NpdGlvbjogUG9zaXRpb24sXG4gICAgICAgICAgbnVrZTogbnVrZSxcbiAgICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBpblZpZXdQZXJjZW50YWdlOiBpblZpZXdQZXJjZW50YWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Y7XG4gIH0pKHdpbmRvdywgc2YpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tLCBlbnYsIGxhbmcsIGxvZ2dlcjtcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG4gIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24obGFuZywgZW52LCBkb20sIGxvZ2dlcikge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXI6IFwiMS0xLTBcIixcbiAgICAgIHNwZWNWZXJzaW9uOiBcIjEuMVwiLFxuICAgICAgbGliOiB7XG4gICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgIGRvbTogZG9tLFxuICAgICAgICBsb2dnZXI6IGxvZ2dlclxuICAgICAgfSxcbiAgICAgIGVudjogZW52LFxuICAgICAgaG9zdDoge30sXG4gICAgICBleHQ6IHt9LFxuICAgICAgaW5mbzoge1xuICAgICAgICBlcnJzOiBbXSxcbiAgICAgICAgbGlzdDogW11cbiAgICAgIH1cbiAgICB9O1xuICB9KShsYW5nLCBlbnYsIGRvbSwgbG9nZ2VyKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGVudiwgbGFuZztcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3csIGxhbmcsIGVudikge1xuICAgIHZhciBCTEFOS19VUkwsIEVWVF9DTkNMX01FVEhPRFMsIEdDLCBJRV9HQ19JTlRFUlZBTCwgSUZSQU1FLCBhcHBlbmQsIGF0dGFjaCwgYXR0ciwgY2xvbmVfaWZyYW1lLCBjc3MsIGRldGFjaCwgZG9jLCBkb20sIGRvbV9pc19yZWFkeSwgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSwgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50LCBkb21fcmVhZHlfY2hrX21heF90cmllcywgZG9tX3JlYWR5X2Noa190aW1lcl9pZCwgZG9tX3JlYWR5X2Noa190cmllcywgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwsIGVsdCwgZXZ0Q25jbCwgZXZ0VGd0LCBldnRfdGd0X3Byb3BfYSwgZXZ0X3RndF9wcm9wX2IsIGdjLCBnY190aW1lcl9pZCwgaWVfYXR0YWNoLCBpZV9kZXRhY2gsIGlmcmFtZV9jYnNfYXR0YWNoZWQsIGlmcmFtZV9tc2dfaG9zdF9saWIsIGlmcmFtZV9uZXh0X2lkLCBpZnJhbWVfdmlldywgaXNJRSwgbWFrZV9lbGVtZW50LCBtYWtlX2lmcmFtZSwgcGFyLCBwdXJnZSwgcmVhZHksIHJlcGxhY2VfaWZyYW1lLCB0YWdOYW1lLCB0YWdzLCB0aGVEb2N1bWVudCwgdXNlT2xkU3R5bGVBdHRyTWV0aG9kcywgdXNlX2F0dGFjaCwgdXNlX2RldGFjaCwgdXNlX2llX29sZF9hdHRhY2gsIHZpZXcsIHczY19hdHRhY2gsIHczY19kZXRhY2gsIHdhaXQsIHdpbiwgX2JpbmRfaWZyYW1lX29ubG9hZCwgX2J5SUQsIF9jYWxsX3htc2dfaG9zdCwgX2NhbGxhYmxlLCBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2ssIF9jbG9uZV9pZnJhbWUsIF9jc3RyLCBfZW52LCBfaGFuZGxlX2RvbV9sb2FkX2V2dCwgX2xhbmcsIF9yZWFkeV9zdGF0ZV9jaGVjaywgX3VuYmluZF9pZnJhbWVfb25sb2FkO1xuICAgIGRvbSA9IHt9O1xuICAgIF9sYW5nID0gbGFuZztcbiAgICBfZW52ID0gZW52O1xuICAgIHdpbiA9IHdpbmRvdztcbiAgICBJRlJBTUUgPSBcImlmcmFtZVwiO1xuICAgIEdDID0gXCJDb2xsZWN0R2FyYmFnZVwiO1xuICAgIGllX2F0dGFjaCA9IFwiYXR0YWNoRXZlbnRcIjtcbiAgICB3M2NfYXR0YWNoID0gXCJhZGRFdmVudExpc3RlbmVyXCI7XG4gICAgaWVfZGV0YWNoID0gXCJkZXRhY2hFdmVudFwiO1xuICAgIHczY19kZXRhY2ggPSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjtcbiAgICB1c2VfYXR0YWNoID0gXCJcIjtcbiAgICB1c2VfZGV0YWNoID0gXCJcIjtcbiAgICB1c2VfaWVfb2xkX2F0dGFjaCA9IGZhbHNlO1xuICAgIElFX0dDX0lOVEVSVkFMID0gMzAwMDtcbiAgICBFVlRfQ05DTF9NRVRIT0RTID0ge1xuICAgICAgXCJwcmV2ZW50RGVmYXVsdFwiOiAwLFxuICAgICAgXCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIjogMCxcbiAgICAgIFwic3RvcFByb3BhZ2F0aW9uXCI6IDAsXG4gICAgICBcInByZXZlbnRCdWJibGVcIjogMFxuICAgIH07XG4gICAgaXNJRSA9IGVudi5pc0lFO1xuICAgIHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMgPSBmYWxzZTtcbiAgICBnY190aW1lcl9pZCA9IDA7XG4gICAgZG9tX2lzX3JlYWR5ID0gbnVsbDtcbiAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgIGRvbV9yZWFkeV9jaGtfbWF4X3RyaWVzID0gMzAwO1xuICAgIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsID0gNTA7XG4gICAgZG9tX3JlYWR5X2Noa190cmllcyA9IDA7XG4gICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IDA7XG4gICAgaWZyYW1lX25leHRfaWQgPSAwO1xuICAgIGlmcmFtZV9jYnNfYXR0YWNoZWQgPSB7fTtcbiAgICBldnRfdGd0X3Byb3BfYSA9IFwiXCI7XG4gICAgZXZ0X3RndF9wcm9wX2IgPSBcIlwiO1xuICAgIGlmcmFtZV9tc2dfaG9zdF9saWIgPSBudWxsO1xuICAgIHRoZURvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuICAgIEJMQU5LX1VSTCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICBfY2FsbGFibGUgPSBsYW5nLmNhbGxhYmxlO1xuXG4gICAgLypcbiAgICBDbGVhciBvdXQgdGhlIHRpbWVyIGZ1bmN0aW9uIHVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIHJlYWR5IHN0YXRlIG9mIHRoZSBET01cbiAgICBjYW5ub3QgYmUgZGlyZWN0bHkgZGV0ZWN0ZWRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fY2xlYXJfcmVhZHlfdGltZXJfY2hlY2tcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb21fcmVhZHlfY2hrX3RpbWVyX2lkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkb21fcmVhZHlfY2hrX3RpbWVyX2lkKTtcbiAgICAgICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBfaGFuZGxlX2RvbV9sb2FkX2V2dCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZGV0YWNoKHdpbiwgXCJsb2FkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIGRldGFjaCh3aW4sIFwiRE9NQ29udGVudExvYWRlZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyB0byBzZWUgaWYgdGhlIERPTSBpcyByZWFkeSB0byBiZSBtYW5pcHVsYXRlZCwgd2l0aG91dCB0aGUgbmVlZCBmb3IgZXZlbnQgaG9va2luZy5cbiAgICBPZnRlbiB0aW1lcyB5b3UnbGwgc2VlIGZvbGtzIHVzZSB0aGUgb25sb2FkIGV2ZW50IG9yIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQuICBIb3dldmVyXG4gICAgdGhlIHByb2JsZW0gd2l0aCB0aG9zZSwgaXMgdGhhdCB5b3VyIEphdmFTY3JpcHQgY29kZSBtYXkgaGF2ZSBiZWVuIGxvYWRlZCBhc3luY2hyb25vdXNseSxcbiAgICBhZnRlciBlaXRoZXIgb25lIG9mIHRob3NlIGV2ZW50cyBoYXZlIGZpcmVkLCBhbmQgaW4gd2hpY2ggY2FzZSB5b3Ugc3RpbGwgZG9uJ3Qga25vdyBpZiB0aGUgRE9NIGlzIHJlYWxseVxuICAgIHJlYWR5LiAgTW9zdCBtb2Rlcm4gYnJvd3NlcnMgKGluY2x1ZGluZyBJRSksIGltcGxlbWVudCBhIGRvY3VtZW50LnJlYWR5U3RhdGUgcHJvcGVydHkgdGhhdCB3ZSBjYW5cbiAgICBjaGVjaywgYnV0IG5vdCBhbGwuICBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIHByb3BlcnR5IGlzIG5vdCBpbXBsZW1lbnRlZCwgd2UgZG8gYSBzZXJpZXMgb2Ygbm9kZVxuICAgIGNoZWNrcyBhbmQgdGFnIGNvdW50cyB2aWEgdGltZXJzLiAgT2YgY291cnNlIHRoaXMgbWVhbnMgdGhhdCBvbiB0aGUgdmVyeSAxc3QgY2FsbCwgd2Ugd2lsbCBhbHdheXNcbiAgICBhcHBlYXIgdG8gYmUgbm90IHJlYWR5IGV2ZW50aG91Z2ggdGhlIERPTSBpdHNlbGYgbWF5IGJlIGluIGEgcmVhZHkgc3RhdGUsIGJ1dCBvdXIgdGltZW91dCBpbnRlcnZhbFxuICAgIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoaXMgaXMgT0suXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX3JlYWR5X3N0YXRlX2NoZWNrXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX3JlYWR5X3N0YXRlX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYiwgZSwga2lkcywgbHN0LCB0YWdfY250O1xuICAgICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrKCk7XG4gICAgICBpZiAoZG9tX3JlYWR5X2Noa190cmllcyA+PSBkb21fcmVhZHlfY2hrX21heF90cmllcykge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb21faXNfcmVhZHkgPT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiID0gdGhlRG9jdW1lbnQgJiYgdGhlRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICBraWRzID0gYiAmJiB0YWdzKFwiKlwiLCBiKTtcbiAgICAgICAgICB0YWdfY250ID0ga2lkcyAmJiBraWRzW0xFTl07XG4gICAgICAgICAgbHN0ID0gYiAmJiBiLmxhc3RDaGlsZDtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21fbGFzdF9rbm93bl90YWdfY291bnQgJiYgdGFnX2NudCA9PT0gZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ICYmIGxzdCA9PT0gZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSkge1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gdGFnX2NudDtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbHN0O1xuICAgICAgICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgKz0gMTtcbiAgICAgICAgICBkb21fcmVhZHlfY2hrX3RpbWVyX2lkID0gc2V0VGltZW91dChfcmVhZHlfc3RhdGVfY2hlY2ssIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRGV0YWNoIG9ubG9hZCBoYW5kbGVycyBvbiBpZnJhbWVzIHRoYXQgd2UgaGF2ZSBjcmVhdGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fdW5iaW5kX2lmcmFtZV9vbmxvYWRcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgaWZyYW1lIGVsZW1lbnQgdG8gdW5iaW5kIGZyb21cbiAgICAgKi9cbiAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGlkLCBvbGRDQjtcbiAgICAgIGlkID0gYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgIG9sZENCID0gdm9pZCAwO1xuICAgICAgb2xkQ0IgPSBpZCAmJiBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXTtcbiAgICAgIGlmIChvbGRDQikge1xuICAgICAgICBkZXRhY2goZWwsIFwibG9hZFwiLCBvbGRDQik7XG4gICAgICAgIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEEgZGVmYXVsdCBvbmxvYWQgZXZlbnQgaGFuZGxlciBmb3IgSUZyYW1lcy4gV2UgZG9uJ3RcbiAgICB3YW50IHRvIGF0dGFjaCB0byBvbmxvYWQgZXZlbnRzIGZvciBJRnJhbWVzIHZpYSBhdHRyaWJ1dGVzXG4gICAgYi9jIHdlIGRvbid0IHdhbnQgb3RoZXJzIHRvIHNlZSB3aGF0IGhhbmRsZXJzIGFyZSB0aGVyZS5cbiAgICBJbiB0dXJuIHdlIGFsc28gbWFrZSBzdXJlIHRoZSBcInRoaXNcIiByZWZlcmVuY2UgZm9yIHRoZSBvdXRzaWRlXG4gICAgaGFuZGxlIGdldHMgc2V0IHByb3Blcmx5LCBhbmQgaXQgYWxsb3dzIHVzIHRvIG1ha2Ugc3VyZVxuICAgIHRoYXQgdW5iaW5kaW5nIG9mIHRoZSBldmVudCBoYW5kbGVyIGFsc28gZ2V0cyBoYW5kbGVkIGFsd2F5c1xuICAgIHNvIGFzIG5vdCB0byBjcmVhdGUgbWVtb3J5IGxlYWsgaXNzdWVzLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX2JpbmRfaWZyYW1lX29ubG9hZFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBpZnJhbWUgZWxlbWVudCB0byBiaW5kIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBvbmxvYWQgaGFuZGxlciBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICovXG4gICAgX2JpbmRfaWZyYW1lX29ubG9hZCA9IGZ1bmN0aW9uKGVsLCBjYikge1xuICAgICAgdmFyIGlkLCBuZXdDQjtcbiAgICAgIG5ld0NCID0gdm9pZCAwO1xuICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICBpZiAoX2NhbGxhYmxlKGNiKSkge1xuXG4gICAgICAgIC8qXG4gICAgICAgIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIG5ld0NCID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIGUsIHRndDtcbiAgICAgICAgICB0Z3QgPSBldnRUZ3QoZXZ0KTtcbiAgICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZCh0Z3QpO1xuICAgICAgICAgIGlmICh0Z3QgJiYgY2IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNiLmNhbGwodGd0LCBldnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgICB0Z3QgPSBlbCA9IGNiID0gbmV3Q0IgPSBpZCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlkID0gYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKGVsKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF0gPSBuZXdDQjtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2goZWwsIFwibG9hZFwiLCBuZXdDQik7XG4gICAgICB9XG4gICAgICBuZXdDQiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBlbGVtZW50IHJlZmVyZW5jZSBwYXNzZWQgaW4sIGFuZCBpZiBpdHMgYSBzdHJpbmcgdmFsdWUgcGFzc2VkXG4gICAgaW4gdXNlIHRoYXQgdG8gbG9va3VwIHRoZSBlbGVtZW50IGJ5IGlkIGF0dHJpYnV0ZS5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fYnlJRFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBlbCAgdGhlIGVsZW1lbnQgaWQgLyBlbGVtZW50IHJlZmVyZW5jZVxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fGVsfVxuICAgICAqL1xuICAgIF9ieUlEID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGVsdChlbCkgfHwgZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBwcm94eSB3cmFwcGVyIGZvciBjYWxsaW5nIGludG8gdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgaG9zdCBsaWJyYXJ5XG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fY2FsbF94bXNnX2hvc3RcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gbWV0aE5hbWUgVGhlIG1ldGhvZCBuYW1lIGluIHRoZSBtc2cgaG9zdCBsaWJyYXJ5IHRvIGNhbGxcbiAgICBAcGFyYW0geyp9IGFyZzEgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDFzdCBhcmdcbiAgICBAcGFyYW0geyp9IGFyZzIgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDJuZCBhcmdcbiAgICBAcGFyYW0geyp9IGFyZzMgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDNyZCBhcmdcbiAgICBAcmV0dXJuIHsqfSB3aGF0ZXZlciBjb21lcyBiYWNrIGZyb20gdGhlIG1ldGhvZFxuICAgICAqL1xuICAgIF9jYWxsX3htc2dfaG9zdCA9IGZ1bmN0aW9uKG1ldGhOYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlmcmFtZV9tc2dfaG9zdF9saWIpIHtcbiAgICAgICAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gZG9tLm1zZ2hvc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW4gIT09IHRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aE5hbWUgJiYgaWZyYW1lX21zZ19ob3N0X2xpYiAmJiBpZnJhbWVfbXNnX2hvc3RfbGliW21ldGhOYW1lXSAmJiBpZnJhbWVfbXNnX2hvc3RfbGliW21ldGhOYW1lXShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSBhIGRvY3VtZW50IGZvciBhIGdpdmVuIEhUTUwgRWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGRvYyBhcyAkc2YubGliLmRvbS5kb2NcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHdoaWNoIHlvdSB3aXNoIHRvIGZpbmQgaXQncyBwYXJlbnQgZG9jdW1lbnRcbiAgICBAcmV0dXJuIHtEb2N1bWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICBkb2MgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGxvY2FsRDtcbiAgICAgIGxvY2FsRCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBlbC5kb2N1bWVudCB8fCBlbC5vd25lckRvY3VtZW50IHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgbG9jYWxEID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NhbEQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgdGhlIGhvc3Qgd2luZG93IG9iamVjdCBmb3IgYSBnaXZlbiBIVE1MIEVsZW1lbnQvZG9jdW1lbnQuIE5vdGUgdGhhdCB0aGlzIGlzIE5PVCB0aGUgc2FtZSBhcyAkc2YubGliLmRvbS5pZnJhbWVzLnZpZXcsIHdoaWNoXG4gICAgcmV0dXJucyB0aGUgd2luZG93IHJlZmVyZW5jZSBJTlNJREUgdGhlIElGUkFNRSBlbGVtZW50LlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHZpZXcgYXMgJHNmLmxpYi5kb20udmlld1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MRG9jdW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQvZG9jdW1lbnQgZm9yIHdoaWNoIHlvdSB3aXNoIHRvIGZpbmQgaXQncyBwYXJlbnQgd2luZG93XG4gICAgQHJldHVybiB7RG9jdW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgdmlldyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZSwgbG9jYWxELCBwcm9wMSwgcHJvcDIsIHc7XG4gICAgICB3ID0gbnVsbDtcbiAgICAgIGxvY2FsRCA9IHZvaWQgMDtcbiAgICAgIHByb3AxID0gXCJwYXJlbnRXaW5kb3dcIjtcbiAgICAgIHByb3AyID0gXCJkZWZhdWx0Vmlld1wiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdyA9IGVsW3Byb3AxXSB8fCBlbFtwcm9wMl0gfHwgbnVsbDtcbiAgICAgICAgICBpZiAoIXcpIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGRvYyhlbCk7XG4gICAgICAgICAgICB3ID0gKGxvY2FsRCAmJiAobG9jYWxEW3Byb3AxXSB8fCBsb2NhbERbcHJvcDJdKSkgfHwgbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB3ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIGFuIGVsZW1lbnQgYnkgaXRzIElELiAuIGJhc2ljYWxseSBhIHNob3J0IGhhbmQgd3JhcHBlciBhcm91bmQgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZWx0IGFzICRzZi5saWIuZG9tLmVsdFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IGlkIChSZXF1aXJlZCkgdGhlIGlkIG9mIHRoZSBIVE1MIGVsZW1lbnQgdG8gZmluZFxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFdpbmRvd3xIVE1MRG9jdW1lbnR9IFtwYXJdIFRoZSBwYXJlbnQgZWxlbWVudCxkb2N1bWVudCx3aW5kb3cgdG8gbG9vayBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICBlbHQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIGFyZ3MsIGRjLCBsZW47XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICBkYyA9IHZvaWQgMDtcbiAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgIGRjID0gZG9jKGFyZ3NbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGMgPSB0aGVEb2N1bWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZGMgJiYgZGMuZ2V0RWxlbWVudEJ5SWQoaWQpKSB8fCBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBhcm91bmQgcmV0cmlldmluZyB0aGUgdGFnTmFtZSBvZiBhbiBIVE1MIGVsZW1lbnQgKG5vcm1hbGl6ZXMgdmFsdWVzIHRvIGxvd2VyIGNhc2Ugc3RyaW5ncykuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdGFnTmFtZSBhcyAkc2YubGliLmRvbS50YWdOYW1lXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTCBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIHRhZyBuYW1lLlxuICAgIEByZXR1cm4ge1N0cmluZ30gVGhlIHRhZyBuYW1lIGluIGFsbCBsb3dlciBjYXNlIG9mIGFuIEhUTUwgZWxlbWVudCwgaWYgaXQgY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQsIGFsd2FzeXMgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgKHdoaWNoIHdpbGwgZXZhbHVhdGUgdG8gZmFsc2UpLlxuICAgICAqL1xuICAgIHRhZ05hbWUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCI7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIGFyb3VuZCByZXRyaWV2aW5nIGEgbGlzdCBvZiB0YWdzIGJ5IG5hbWUuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdGFncyBhcyAkc2YubGliLmRvbS50YWdzXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFncyB0aGF0IHlvdSB3aXNoIHRvIGxvb2sgZm9yLCBub3RlIHRoYXQgeW91IGNhbiBwYXNzIGluIFwiKlwiIHRvIGZpbmQgYWxsLlxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9IFtwYXJOb2RlXSB0aGUgcGFyZW50IG5vZGUgdGhhdCB5b3Ugd2lzaCB0byBsb29rIGluXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnRDb2xsZWN0aW9ufSBMaXN0IG9mIHRhZ3MgZm91bmQuIE5vdGUgdGhhdCBpcyBOT1QgYSByZWFsIEphdmFTY3JpcHQgQXJyYXlcbiAgICAgKi9cbiAgICB0YWdzID0gZnVuY3Rpb24obmFtZSwgcGFyTm9kZSkge1xuICAgICAgdmFyIGUsIHJldDtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJOb2RlICYmIHBhck5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICByZXQgPSBwYXJOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpIHx8IHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSB0aGVEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSB8fCByZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cml2ZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcGFyIGFzICRzZi5saWIuZG9tLnBhclxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBjaGVja1xuICAgIHJldHVybiB7SFRNTEVsZW1lbnR9IHRoZSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBvciBudWxsXG4gICAgICovXG4gICAgcGFyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbCAmJiAoZWwucGFyZW50Tm9kZSB8fCBlbC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZS9TZXQvRGVsZXRlIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUuIE5vdGUgdGhhdCB0aGlzIGhhbmRsZSdzXG4gICAgc2xpZ2h0IGRpZmZlcmVuY2VzIGluIHRoZSB3YXkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBoYW5kbGVkIGFjcm9zcyBicm93c2Vyc1xuICAgIGFzIHdlbGwgYXMgYmVpbmcgc2hvcnRoYW5kXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXR0ciBhcyAkc2YubGliLmRvbS5hdHRyXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgdGhlIGF0dHJpYnV0ZSB0byBzZXQvZ2V0XG4gICAgQHBhcmFtIHtTdHJpbmd9IFthdHRyVmFsXSwgaWYgc3BlY2lmaWVkIHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGZvciB0aGlzIGVsZW1lbnQuICBQYXNzaW5nIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBjb21wbGV0ZWx5XG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBub3JtYWxpemVkIHRvIGEgc3RyaW5nIChtYXkgYmUgZW1wdHkpXG4gICAgICovXG4gICAgYXR0ciA9IGZ1bmN0aW9uKGVsLCBhdHRyTmFtZSwgYXR0clZhbCkge1xuICAgICAgdmFyIGU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgaWYgKGF0dHJWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1c2VPbGRTdHlsZUF0dHJNZXRob2RzKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoYXR0clZhbCk7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJWYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCwgMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSwgMCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgYXR0clZhbCA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0clZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZXQvR2V0IHRoZSBDU1MgdGV4dCBvZiBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBjc3MgYXMgJHNmLmxpYi5kb20uY3NzXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gW3ZhbF0gdGhlIENTUyBzdHJpbmcgdG8gc2V0IGlmIHNwZWNpZmllZCAoZS5nLiBcImJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjBweDtsZWZ0OjBweFwiKS5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG5vcm1hbGl6ZWQgdG8gYSBzdHJpbmcgKG1heSBiZSBlbXB0eSlcbiAgICAgKi9cbiAgICBjc3MgPSBmdW5jdGlvbihlbCwgdmFsKSB7XG4gICAgICB2YXIgZSwgc3Q7XG4gICAgICBzdCA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ID0gZWwuc3R5bGU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN0LmNzc1RleHQgPSBfY3N0cih2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHN0LmNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNYWtlIGEgbmV3IGVsZW1lbnRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5tYWtlXG4gICAgQGV4cG9ydHMgbWFrZV9lbGVtZW50IGFzICRzZi5saWIuZG9tLm1ha2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lXG4gICAgQHBhcmFtIHtEb2N1bWVudHxIVE1MRWxlbWVudHxXaW5kb3d9IFtwYXJlbnRdIGVsZW1lbnQsIGRvY3VtZW50LCBvciB3aW5kb3cgdG8gbWFrZSB0aGUgdGFnIGluLCBvcHRpb25hbC5cbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBtYWtlX2VsZW1lbnQgPSBmdW5jdGlvbih0YWdOYW1lLCBwYXIpIHtcbiAgICAgIHJldHVybiAoKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGRvYyhwYXIpKSB8fCB0aGVEb2N1bWVudCkuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBcHBlbmQgYW5kIEhUTUxFbGVtZW50IHRvIGFub3RoZXIgSFRNTEVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBhcHBlbmQgYXMgJHNmLmxpYi5kb20uYXBwZW5kXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJOb2RlIHRoZSBIVE1MIGVsZW1lbnQgdG8gbWFuaXB1bGF0ZVxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNoaWxkIChSZXF1aXJlZCkgdGhlIG5ldyBIVE1MIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBwYXJlbnRcbiAgICByZXR1cm4ge0hUTUxFbGVtZW50fEJvb2xlYW59IHRoZSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBlbGVtZW50IHRoYXQgd2FzIGFwcGVuZGVkLCBvciBmYWxzZSBpZiBmYWlsdXJlXG4gICAgICovXG4gICAgYXBwZW5kID0gZnVuY3Rpb24ocGFyTm9kZSwgY2hpbGQpIHtcbiAgICAgIHZhciBlLCBzdWNjZXNzO1xuICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJOb2RlKSB7XG4gICAgICAgICAgc3VjY2VzcyA9IHBhck5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIG1ldGhvZCBmb3IgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSBhIGRvY3VtZW50IHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCByYXcuXG4gICAgSGFzIHNwZWNpYWwgcHJvY2Vzc2luZyB0byBlbnN1cmUgdGhhdCBjb250ZW50cyBvZiBJRlJBTUUgdGFncyBnZXRzIHJlbGVhc2VkIGZyb20gbWVtb3J5IGFzIHdlbGxcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBwdXJnZSBhcyAkc2YubGliLmRvbS5wdXJnZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgSFRNTCBlbGVtZW50IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkXG4gICAgICovXG4gICAgcHVyZ2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZSwgaXNJRnJhbWUsIHBhck5vZGUsIHN1Y2Nlc3M7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICBwYXJOb2RlID0gdm9pZCAwO1xuICAgICAgaXNJRnJhbWUgPSB0YWdOYW1lKG5vZGUpID09PSBJRlJBTUU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgaWYgKGlzSUZyYW1lKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdChcImRldGFjaFwiLCBub2RlKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKG5vZGUpO1xuICAgICAgICBpZiAoIWlzSUUpIHtcbiAgICAgICAgICBhdHRyKG5vZGUsIFwic3JjXCIsIEJMQU5LX1VSTCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHBhck5vZGUgPSBwYXIobm9kZSk7XG4gICAgICAgIGlmIChwYXJOb2RlKSB7XG4gICAgICAgICAgcGFyTm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNJRSAmJiBpc0lGcmFtZSkge1xuICAgICAgICAgICAgZ2MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIG5vZGUgPSBwYXJOb2RlID0gbnVsbDtcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEF0dGFjaCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIEhUTUxFbGVtZW50LiAgTm90ZSBub3JtYWxpemUgZXZlbnQgbmFtZXMgdG8gbG93ZXIgY2FzZSAvIHczYyBzdGFuZGFyZHMuXG4gICAgU2VlIGV4YW1wbGUuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXR0YWNoIGFzICRzZi5saWIuZG9tLmF0dGFjaFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBhdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0b29cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGhhbmRsZSB0aGUgcGFydGljdWxhciBldmVudFxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIGVsID0gJHNmLmxpYi5kb20uZWx0KFwibXlfZWxlbWVudFwiKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVfY2xpY2soZXZ0KVxuICAgIHtcbiAgICBhbGVydCgnaSB3YXMgY2xpY2tlZCcpO1xuICAgIH1cbiAgICBcbiAgICAkc2YubGliLmRvbS5hdHRhY2goZWwsXCJjbGlja1wiLGhhbmRsZV9jbGljayk7XG4gICAgICovXG4gICAgYXR0YWNoID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVzZV9pZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgb2JqW3VzZV9hdHRhY2hdKFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpbdXNlX2F0dGFjaF0obmFtZSwgY2IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgb2JqID0gY2IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERldGFjaCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZGV0YWNoIGFzICRzZi5saWIuZG9tLmRldGFjaFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBhdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0b29cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZXRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9vXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoZSBwYXJ0aWN1bGFyIGV2ZW50XG4gICAgICovXG4gICAgZGV0YWNoID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVzZV9pZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgb2JqLmRldGFjaEV2ZW50KFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBvYmogPSBjYiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgRE9NIGlzIHJlYWR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcmVhZHkgYXMgJHNmLmxpYi5kb20ucmVhZHlcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgcmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBycztcbiAgICAgIHJzID0gdm9pZCAwO1xuICAgICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrKCk7XG4gICAgICBpZiAoZG9tX2lzX3JlYWR5KSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJzID0gdGhlRG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgIGlmIChycykge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHJzID09PSBcImxvYWRlZFwiIHx8IHJzID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgPSBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgICAgX3JlYWR5X3N0YXRlX2NoZWNrKCk7XG4gICAgICByZXR1cm4gISFkb21faXNfcmVhZHk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRmlyZSBvZmYgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIHdoZW4gaXQgaXMgZGV0ZWN0ZWQgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG4gICAgVXNlZnVsIHdoZW4geW91IGRvbid0IGtub3cgZm9yIHN1cmUgaWYgdGhlIERPTSBvZiB0aGUgYnJvd3NlciBpcyByZWFkeSBvciBub3QsIHNvIHRoaXMgd2lsbCBkZXRlY3QgYW5kIGZpcmVcbiAgICB5b3VyIGZ1bmN0aW9uIGZvciB5b3UuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgd2FpdCBhcyAkc2YubGliLmRvbS53YWl0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBBIGZ1bmN0aW9uIHJlZmVyZW5jZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICovXG4gICAgd2FpdCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgZSwgcmR5O1xuICAgICAgcmR5ID0gcmVhZHkoKTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBpZiAocmR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGxhbmcuY2FsbGFibGUoY2IpKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgd2FpdChjYik7XG4gICAgICAgIGNiID0gbnVsbDtcbiAgICAgIH0pLCBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCArIDEpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENhbmNlbCB0aGUgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIGEgcGFydGljdWxhciBET00gZXZlbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBldnRDbmNsIGFzICRzZi5saWIuZG9tLmV2dENuY2xcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgIFRoZSByYXcgSFRNTCBldmVudFxuICAgICAqL1xuICAgIGV2dENuY2wgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlLCBwcm9wO1xuICAgICAgcHJvcCA9IFwiXCI7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgZXZ0ID0gZXZ0IHx8IHdpbi5ldmVudDtcbiAgICAgIGlmIChldnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZ0LnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIGZvciAocHJvcCBpbiBFVlRfQ05DTF9NRVRIT0RTKSB7XG4gICAgICAgICAgaWYgKEVWVF9DTkNMX01FVEhPRFNbcHJvcF0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGV2dFtwcm9wXSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgdGFyZ2V0L3NyY0VsZW1lbnQgb2YgYW4gZXZlbnQgZnJvbSBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBldnRUZ3QgYXMgJHNmLmxpYi5kb20uZXZ0VGd0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgSFRNTCBldmVudFxuICAgICAqL1xuICAgIGV2dFRndCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGUsIHRndDtcbiAgICAgIHRndCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBldnQgPSBldnQgfHwgd2luLmV2ZW50O1xuICAgICAgICB0Z3QgPSAoZXZ0ID8gZXZ0W2V2dF90Z3RfcHJvcF9hXSB8fCBldnRbZXZ0X3RndF9wcm9wX2JdIDogbnVsbCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGd0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0Z3Q7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQG5hbWVzcGFjZSAkc2YubGliLmRvbS5pZnJhbWVzIERlZmluZXMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZGVhbGluZyBzcGVjaWZpY2FsbHkgd2l0aCBJRlJBTUUgdGFncywgd2hpY2ggaXMga2V5IHRvIFNhZmVGcmFtZXMgdGVjaCBpbiBhIGJyb3dzZXIuXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lc1xuICAgIEByZXF1aXJlcyAkc2YubGliLmxhbmdcbiAgICAgKi9cblxuICAgIC8qXG4gICAgQ2xvbmVzIGFuIGlmcmFtZS4gLiAuXG4gICAgVGhpcyBjb2RlIGNyZWF0ZXMgLyBjbG9uZXMgaWZyYW1lIHRhZ3MgaW4gYSB2ZXJ5IHNwZWNpZmljIHdheSB0byBlbnN1cmUgYm90aCBvcHRpbWFsIHBlcmZvcm1hbmNlIGFuZCBzdGFiaWxpdHkuXG4gICAgV2UgdXNlIHN0cmluZyBidWZmZXJzIHRvIGJ1aWxkIG1hcmt1cCBpbnRlcm5hbGx5LCB3aGljaCBpcyB0eXBpY2FsbHkgZmFzdGVyIHRoYW4gdXNpbmcgYWxsIERPTSBBUElzLiAgQWxzb1xuICAgIHdlIGFsbG93IHRoZSB1c2FnZSBvZiB0aGUgXCJuYW1lXCIgYXR0cmlidXRlIGFzIGEgZGF0YSBwaXBlbGluZSwgd2hpY2ggaW4gdHVybiBhbGxvd3MgZm9yIHN5bmNocm9ub3VzIGRvd253YXJkXG4gICAgeC1kb21haW4gbWVzc2FnaW5nLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMuY2xvbmVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnQvU3RyaW5nfSBlbCAgQW4gaWZyYW1lIGVsZW1lbnQgb3IgaWQgb2YgYW4gaWZyYW1lIGVsZW1lbnQgdG8gY2xvbmVcbiAgICBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSAgQSBoYXNoIG1hcCBvZiBvdGhlciBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgaWZyYW1lLiAgRG8gbm90IHNldCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZnJhbWUgaGVyZSwgc2VlIHRoZSBuZXh0IGFyZ3VtZW50IGZvciB0aGF0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbY3NzVGV4dF0gIFRoZSBzdHlsZSBzdHJpbmcgKGFzIGluIHdoYXQgeW91IHdvdWxkIHVzZSBpbiBIVE1MIG1hcmt1cCwgZS5nLiBcImJhY2tncm91bmQtY29sb3I6cmVkO2JvcmRlcjpzb2xpZCAzcHggYmx1ZTtcIiksIHRvIHVzZSBmb3IgdGhpcyBpZnJhbWVcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gb3B0aW9uYWwgY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9ICB0aGUgaWZyYW1lIG5vZGUgaWYgc3VjY2VzZnVsbHkgY3JlYXRlZCBvciBudWxsLiAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgaW5zZXJ0IHRoZSBpZnJhbWUgaW50byB0aGUgZG9jdW1lbnQgZm9yIHlvdS4gLiAuXG4gICAgICovXG4gICAgY2xvbmVfaWZyYW1lID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKSB7XG4gICAgICByZXR1cm4gX2Nsb25lX2lmcmFtZShlbCwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBfY2xvbmVfaWZyYW1lID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCLCBpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgdmFyIGF0dHJTdHIsIGJ1ZmZlckhUTUwsIGNsLCBodG1sLCBuZXdDbCwgcHJvcCwgdGVtcCwgeG1zZ1BpcGU7XG4gICAgICBidWZmZXJIVE1MID0gW1wiPFwiLCBJRlJBTUUsIFwiIFwiXTtcbiAgICAgIHhtc2dQaXBlID0gXCJcIjtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICB0ZW1wID0gdm9pZCAwO1xuICAgICAgY2wgPSB2b2lkIDA7XG4gICAgICBuZXdDbCA9IHZvaWQgMDtcbiAgICAgIGh0bWwgPSB2b2lkIDA7XG4gICAgICBhdHRyU3RyID0gdm9pZCAwO1xuICAgICAgaWYgKCFpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgICBlbCA9IF9ieUlEKGVsKTtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBJRlJBTUUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjbCA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbCA9IGVsO1xuICAgICAgfVxuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIGlmIChcInNyY1wiIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIoY2wsIFwic3JjXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuc3JjID0gYXR0cihlbCwgXCJzcmNcIikgfHwgQkxBTktfVVJMO1xuICAgICAgfVxuICAgICAgaWYgKFwibmFtZVwiIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIoY2wsIFwibmFtZVwiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLm5hbWUgPSBhdHRyKGVsLCBcIm5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzLnNyYykge1xuICAgICAgICBhdHRycy5zcmMgPSBCTEFOS19VUkw7XG4gICAgICB9XG4gICAgICB4bXNnUGlwZSA9IHhtc2dDQiAmJiBfY2FsbF94bXNnX2hvc3QoXCJwcmVwXCIsIGF0dHJzKTtcbiAgICAgIGlmICghaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgICAgYXR0cihjbCwgXCJ3aWR0aFwiLCBudWxsKTtcbiAgICAgICAgYXR0cihjbCwgXCJoZWlnaHRcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICB0ZW1wID0gY3NzKGNsKTtcbiAgICAgICAgaWYgKHRlbXAgJiYgdGVtcC5jaGFyQXQodGVtcC5sZW5ndGggLSAxKSAhPT0gXCI7XCIpIHtcbiAgICAgICAgICB0ZW1wICs9IFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIGNzcyhjbCwgW3RlbXAsIF9jc3RyKGNzc1RleHQpXSk7XG4gICAgICB9XG4gICAgICB0ZW1wID0gbWFrZV9lbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYXBwZW5kKHRlbXAsIGNsKTtcbiAgICAgIGh0bWwgPSB0ZW1wLmlubmVySFRNTDtcbiAgICAgIGF0dHJTdHIgPSBodG1sLnJlcGxhY2UoLzxpZnJhbWUoLio/KT4oLio/KTxcXC9pZnJhbWU+L2csIFwiJDFcIik7XG4gICAgICBidWZmZXJIVE1MLnB1c2goXCJuYW1lPVxcXCJcIiwgYXR0cnMubmFtZSwgXCJcXFwiIFwiLCBhdHRyU3RyLCBcIj48L1wiLCBJRlJBTUUsIFwiPlwiKTtcbiAgICAgIGRlbGV0ZSBhdHRycy5uYW1lO1xuICAgICAgdGVtcC5pbm5lckhUTUwgPSBfY3N0cihidWZmZXJIVE1MKTtcbiAgICAgIG5ld0NsID0gdGVtcC5maXJzdENoaWxkO1xuICAgICAgZm9yIChwcm9wIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIobmV3Q2wsIHByb3AsIGF0dHJzW3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cihuZXdDbCwgXCJpZFwiKSkge1xuICAgICAgICBhdHRyKG5ld0NsLCBcImlkXCIsIFwic2ZfXCIgKyBJRlJBTUUgKyBcIl9cIiArIGlmcmFtZV9uZXh0X2lkKTtcbiAgICAgICAgaWZyYW1lX25leHRfaWQrKztcbiAgICAgIH1cbiAgICAgIGF0dHIobmV3Q2wsIFwiRlJBTUVCT1JERVJcIiwgXCJub1wiKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiU0NST0xMSU5HXCIsIFwibm9cIik7XG4gICAgICBhdHRyKG5ld0NsLCBcIkFMTE9XVFJBTlNQQVJFTkNZXCIsIHRydWUpO1xuICAgICAgYXR0cihuZXdDbCwgXCJISURFRk9DVVNcIiwgdHJ1ZSk7XG4gICAgICBhdHRyKG5ld0NsLCBcIlRBQklOREVYXCIsIC0xKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiTUFSR0lOV0lEVEhcIiwgMCk7XG4gICAgICBhdHRyKG5ld0NsLCBcIk1BUkdJTkhFSUdIVFwiLCAwKTtcbiAgICAgIF9iaW5kX2lmcmFtZV9vbmxvYWQobmV3Q2wsIGNiKTtcbiAgICAgIGlmICh4bXNnUGlwZSkge1xuICAgICAgICBfY2FsbF94bXNnX2hvc3QoXCJhdHRhY2hcIiwgbmV3Q2wsIHhtc2dQaXBlLCB4bXNnQ0IpO1xuICAgICAgfVxuICAgICAgeG1zZ1BpcGUgPSB4bXNnQ0IgPSBjbCA9IGNiID0gZWwgPSB0ZW1wID0gbnVsbDtcbiAgICAgIHJldHVybiBuZXdDbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNYWtlIGEgbmV3IGlmcmFtZVxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMubWFrZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBIGhhc2ggbWFwIG9mIG90aGVyIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBpZnJhbWUuICBEbyBub3Qgc2V0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSBmcmFtZSBoZXJlLCBzZWUgdGhlIG5leHQgYXJndW1lbnQgZm9yIHRoYXQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjc3NUZXh0XSAgVGhlIHN0eWxlIHN0cmluZyAoYXMgaW4gd2hhdCB5b3Ugd291bGQgdXNlIGluIEhUTUwgbWFya3VwLCBlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7Ym9yZGVyOnNvbGlkIDNweCBibHVlO1wiKSwgdG8gdXNlIGZvciB0aGlzIGlmcmFtZVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gIHRoZSBpZnJhbWUgbm9kZSBpZiBzdWNjZXNmdWxseSBjcmVhdGVkIG9yIG51bGwuICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBpbnNlcnQgdGhlIGlmcmFtZSBpbnRvIHRoZSBkb2N1bWVudCBmb3IgeW91LiAuIC5cbiAgICAgKi9cbiAgICBtYWtlX2lmcmFtZSA9IGZ1bmN0aW9uKGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKSB7XG4gICAgICByZXR1cm4gX2Nsb25lX2lmcmFtZShtYWtlX2VsZW1lbnQoSUZSQU1FKSwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgbWV0aG9kIHRvIGluc2VydCBvciByZXBsYWNlIGFuIEhUTUwgdGFnIHdpdGggYW4gSUZSQU1FIHRhZywgd2l0aCBhIG5ldyBVUkwgYW5kIGF0dHJpYnV0ZXMuXG4gICAgXG4gICAgVXNlZCBmb3IgMyByZWFzb25zOlxuICAgIDxvbD5cbiAgICA8bGk+SXQgYXZvaWRzIGNsaWNrIHNvdW5kcyBvbiBJRS48L2xpPlxuICAgIDxsaT5JdCBhbGxvd3MgYWx3YXlzIHJlc2V0dGluZyB0aGUgd2luZG93Lm5hbWUgcHJvcGVydHkgb2YgdGhlIGlmcmFtZXMgdW5kZXJseWluZyBIVE1MV2luZG93IG9iamVjdCwgdW5mb3J1bmF0ZWx5IElFIHdpbGwgbm90IGxldCB5b3Ugc2V0IHRoaXMgYXR0cmlidXRlIG9uIGEgY2xvbmUuPC9saT5cbiAgICA8bGk+SXQgZW5zdXJlcyB0aGF0IGV2ZW50IGhhbmRsZXJzIGluIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50IGZvciB1bmxvYWRpbmcgYXJlIGV4ZWN1dGVkLjwvbGk+XG4gICAgPGxpPkNoYW5naW5nIHRoZSBzcmMgYXR0cmlidXRlIGRpcmVjdGx5IHdpbGwgcmVzdWx0IGluIGEgYnJvd3NlciBoaXN0b3J5IHVwZGF0ZSwgd2hpY2ggd2UgZG8gbm90IHdhbnQuPC9saT5cbiAgICA8L29sPlxuICAgIFxuICAgIFdlIGNvdWxkIGp1c3QgY2hhbmdlIGxvY2F0aW9uLmhyZWYgcHJvcGVydHkgb3IgY2FsbCBsb2NhdGlvbi5yZXBsYWNlLCBob3dldmVyIHRoYXQgaXMgbm90IGFsd2F5cyAgcG9zc2libGUgc2luY2VcbiAgICB0aGUgZnJhbWUgY291bGQgYmUgeC1kb21haW4uXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy5yZXBsYWNlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAcGFyYW0ge09iamVjdH0gYXR0cnMgIEEgaGFzaCBtYXAgb2Ygb3RoZXIgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIGlmcmFtZS4gIERvIG5vdCBzZXQgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGZyYW1lIGhlcmUsIHNlZSB0aGUgbmV4dCBhcmd1bWVudCBmb3IgdGhhdC5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2Nzc1RleHRdICBUaGUgc3R5bGUgc3RyaW5nIChhcyBpbiB3aGF0IHlvdSB3b3VsZCB1c2UgaW4gSFRNTCBtYXJrdXAsIGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtib3JkZXI6c29saWQgM3B4IGJsdWU7XCIpLCB0byB1c2UgZm9yIHRoaXMgaWZyYW1lXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IFtwYXJSZWZdICBBbiBwYXJlbnQgZWxlbWVudCBvciBwYXJlbnQgZWxlbWVudCBpZCwgdG8gYmUgdXNlZCBvbmx5IGlmIGEgbmV3IGlmcmFtZSBpcyBjcmVhdGVkLCB0aGUgaWZyYW1lIHdpbGwgYmUgYXBwZW5kIHRvIHRoYXQgcGFyZW50LCBpZiBub3Qgc3BlY2lmaWVkIGRvY3VtZW50IGJvZHkgaXMgdXNlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gYSByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgaWZyYW1lIGVsZW1lbnQgaWYgc3VjY2Vzc2Z1bGx5IGluc2VydGVkLCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKi9cbiAgICByZXBsYWNlX2lmcmFtZSA9IGZ1bmN0aW9uKGF0dHJzLCBjc3NUZXh0LCBwYXJSZWYsIGNiLCB4bXNnQ0IpIHtcbiAgICAgIHZhciBjbCwgZSwgZWwsIGVsSUQsIGZyYW1lRWwsIHBhck5vZGUsIHRnbjtcbiAgICAgIGNsID0gdm9pZCAwO1xuICAgICAgZWwgPSB2b2lkIDA7XG4gICAgICBmcmFtZUVsID0gdm9pZCAwO1xuICAgICAgZWxJRCA9IHZvaWQgMDtcbiAgICAgIHRnbiA9IHZvaWQgMDtcbiAgICAgIHBhck5vZGUgPSB2b2lkIDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIGVsSUQgPSBhdHRycy5pZDtcbiAgICAgIGVsID0gZWxJRCAmJiBfYnlJRChlbElEKTtcbiAgICAgIHRnbiA9IHRhZ05hbWUoZWwpO1xuICAgICAgZWwgPSAodGduID8gZWwgOiBudWxsKTtcbiAgICAgIGZyYW1lRWwgPSAodGduID09PSBJRlJBTUUgPyBlbCA6IG51bGwpO1xuICAgICAgaWYgKGZyYW1lRWwpIHtcbiAgICAgICAgX2NhbGxfeG1zZ19ob3N0KFwiZGV0YWNoXCIsIGZyYW1lRWwpO1xuICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQoZnJhbWVFbCk7XG4gICAgICAgIHBhck5vZGUgPSBwYXIoZnJhbWVFbCk7XG4gICAgICAgIGNsID0gY2xvbmVfaWZyYW1lKGZyYW1lRWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKTtcbiAgICAgICAgYXR0cihjbCwgXCJvbmxvYWRcIiwgbnVsbCk7XG4gICAgICAgIGF0dHIoY2wsIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhclJlZikge1xuICAgICAgICAgIHBhclJlZiA9IF9ieUlEKHBhclJlZik7XG4gICAgICAgICAgaWYgKHRhZ05hbWUocGFyUmVmKSkge1xuICAgICAgICAgICAgcGFyTm9kZSA9IHBhclJlZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJOb2RlICYmIGVsKSB7XG4gICAgICAgICAgcGFyTm9kZSA9IHBhcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IF9jc3RyKGNzc1RleHQpIHx8IGNzcyhlbCkgfHwgXCJcIjtcbiAgICAgICAgY2wgPSBtYWtlX2lmcmFtZShhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXBhck5vZGUpIHtcbiAgICAgICAgICBhcHBlbmQodGhlRG9jdW1lbnQuYm9keSwgY2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmcmFtZUVsKSB7XG4gICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChjbCwgZnJhbWVFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChjbCwgZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwZW5kKHBhck5vZGUsIGNsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIGNsID0gZWwgPSBhdHRycyA9IGZyYW1lRWwgPSBwYXJOb2RlID0gY2IgPSBudWxsO1xuICAgICAgcmV0dXJuIGVsdChlbElEKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSB0aGUgd2luZG93IHJlZmVyZW5jZSBpbnNpZGUgb2YgYW4gSUZSQU1FLiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCAkc2YubGliLmRvbS52aWV3IHdoaWNoXG4gICAgcmV0dXJucyB0aGUgcGFyZW50IHdpbmRvdyByZWZlcmVuY2Ugb2YgYW4gZWxlbWVudC5cbiAgICBcbiAgICBOb3RlIHRoYXQgZXZlbiBpbiBjcm9zcy1kb21haW4gc2NlbmFyaW9zLCB5b3UgYXJlIHN1cHBvc2VkIHRvIGFibGUgdG8gZ2V0IGFjY2VzcyB0byB0aGUgd2luZG93IHJlZmVyZW5jZS5cbiAgICBJbiBhIGNyb3NzLWRvbWFpbiBzY2VuYXJpbywgeW91IHdvdWxkIG5vdCBiZSBhYmxlIHRvIHRoZW4gYWNlc3NzIG1vc3QgcHJvcGVydGllcyAvIG1ldGhvZHMgLyBvYmplY3RzIG9mIHRoYXRcbiAgICB3aW5kb3csIGJ1dCB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBhbGxvd2VkLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMudmlld1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGlmcmFtZSBlbGVtZW50IHRvIHNhZmVseSBnZXQgYmFjayB0aGUgd2luZG93XG4gICAgQHJldHVybiB7SFRNTFdpbmRvd30gdGhlIHdpbmRvdyByZWZlcmVuY2UgaW5zaWRlIHRoZSBpZnJhbWUuXG4gICAgICovXG4gICAgaWZyYW1lX3ZpZXcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGVsRG9jLCBlbFdpbiwgZXJyLCBmZSwgZnJhbWUsIGZyYW1lX2xpc3QsIGlkeCwgbG9jYWxXaW47XG4gICAgICBsb2NhbFdpbiA9IHZvaWQgMDtcbiAgICAgIGVsV2luID0gdm9pZCAwO1xuICAgICAgZWxEb2MgPSB2b2lkIDA7XG4gICAgICBmcmFtZV9saXN0ID0gdm9pZCAwO1xuICAgICAgZnJhbWUgPSB2b2lkIDA7XG4gICAgICBmZSA9IHZvaWQgMDtcbiAgICAgIGlkeCA9IDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgZXJyID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxXaW4gPSBlbC5jb250ZW50V2luZG93IHx8IG51bGw7XG4gICAgICAgIGlmICghd2luKSB7XG4gICAgICAgICAgZWxEb2MgPSBkb2MoZWwpO1xuICAgICAgICAgIGVsV2luID0gZWxEb2MgJiYgdmlldyhlbERvYyk7XG4gICAgICAgICAgZnJhbWVfbGlzdCA9IChlbFdpbiAmJiBlbFdpbi5mcmFtZXMpIHx8IFtdO1xuICAgICAgICAgIHdoaWxlIChmcmFtZSA9IGZyYW1lX2xpc3RbaWR4KytdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZSA9IGZyYW1lLmZyYW1lRWxlbWVudDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIGZlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZSAmJiBmZSA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgbG9jYWxXaW4gPSBmcmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgbG9jYWxXaW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsV2luO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBnYyA9IF9sYW5nLm5vb3A7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEFUVFJfTkFNRSwgQ1JFQVRFX0VWRU5ULCBFVlRfVFlQRSwgZXJyLCBvYmosIHByb3A7XG4gICAgICBvYmogPSB2b2lkIDA7XG4gICAgICBBVFRSX05BTUUgPSBcIlNDUk9MTElOR1wiO1xuICAgICAgQ1JFQVRFX0VWRU5UID0gXCJjcmVhdGVFdmVudFwiO1xuICAgICAgRVZUX1RZUEUgPSBcIlVJRXZlbnRcIjtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICBlcnIgPSB2b2lkIDA7XG4gICAgICBpZiAoaXNJRSkge1xuICAgICAgICBldnRfdGd0X3Byb3BfYSA9IFwic3JjRWxlbWVudFwiO1xuICAgICAgICBldnRfdGd0X3Byb3BfYiA9IFwidGFyZ2V0XCI7XG4gICAgICAgIG9iaiA9IG1ha2VfZWxlbWVudChJRlJBTUUpO1xuICAgICAgICBhdHRyKG9iaiwgQVRUUl9OQU1FLCBcIm5vXCIpO1xuICAgICAgICB1c2VPbGRTdHlsZUF0dHJNZXRob2RzID0gYXR0cihvYmosIEFUVFJfTkFNRSkgIT09IFwibm9cIjtcbiAgICAgICAgaWYgKEdDIGluIHdpbikge1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICBAaWdub3JlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZ2MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChnY190aW1lcl9pZCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2NfdGltZXJfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2NfdGltZXJfaWcoc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5bR0NdKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICAgIH0sIElFX0dDX0lOVEVSVkFMKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYyA9IF9sYW5nLm5vb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9hID0gXCJ0YXJnZXRcIjtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2IgPSBcImN1cnJlbnRUYXJnZXRcIjtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5bdzNjX2F0dGFjaF0gJiYgIWlzSUUpIHtcbiAgICAgICAgdXNlX2F0dGFjaCA9IHczY19hdHRhY2g7XG4gICAgICAgIHVzZV9kZXRhY2ggPSB3M2NfZGV0YWNoO1xuICAgICAgfSBlbHNlIGlmIChpc0lFKSB7XG4gICAgICAgIHVzZV9pZV9vbGRfYXR0YWNoID0gdHJ1ZTtcbiAgICAgICAgdXNlX2F0dGFjaCA9IGllX2F0dGFjaDtcbiAgICAgICAgdXNlX2RldGFjaCA9IGllX2RldGFjaDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBvYmogPSB0aGVEb2N1bWVudFtDUkVBVEVfRVZFTlRdKEVWVF9UWVBFKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgIG9iaiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9iaiA9IHRoZURvY3VtZW50W0NSRUFURV9FVkVOVF0oRVZUX1RZUEUgKyBcInNcIik7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBFVlRfQ05DTF9NRVRIT0RTKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSkge1xuICAgICAgICAgICAgRVZUX0NOQ0xfTUVUSE9EU1twcm9wXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmogPSBudWxsO1xuICAgICAgYXR0YWNoKHdpbiwgXCJsb2FkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIHJldHVybiBhdHRhY2god2luLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGRvbSA9IHtcbiAgICAgIGRvYzogZG9jLFxuICAgICAgdmlldzogdmlldyxcbiAgICAgIGVsdDogZWx0LFxuICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICBwYXI6IHBhcixcbiAgICAgIG1ha2U6IG1ha2VfZWxlbWVudCxcbiAgICAgIGNzczogY3NzLFxuICAgICAgYXR0cjogYXR0cixcbiAgICAgIGdjOiBnYyxcbiAgICAgIGFwcGVuZDogYXBwZW5kLFxuICAgICAgcHVyZ2U6IHB1cmdlLFxuICAgICAgYXR0YWNoOiBhdHRhY2gsXG4gICAgICBkZXRhY2g6IGRldGFjaCxcbiAgICAgIHJlYWR5OiByZWFkeSxcbiAgICAgIHdhaXQ6IHdhaXQsXG4gICAgICBldnRDbmNsOiBldnRDbmNsLFxuICAgICAgZXZ0VGd0OiBldnRUZ3QsXG4gICAgICBpZnJhbWVzOiB7XG4gICAgICAgIG1ha2U6IG1ha2VfaWZyYW1lLFxuICAgICAgICBjbG9uZTogY2xvbmVfaWZyYW1lLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlX2lmcmFtZSxcbiAgICAgICAgdmlldzogaWZyYW1lX3ZpZXdcbiAgICAgIH1cbiAgICB9O1xuICB9KSh3aW5kb3csIGxhbmcsIGVudik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgbGFuZyxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGNhY2hlZF91YSwgaXNJRSwgaXNJRTExLCBuYXZpZ2F0b3IsIHRoZURvY3VtZW50LCB1YSwgdXNlckFnZW50LCB3aW47XG4gICAgd2luID0gd2luZG93O1xuICAgIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgdGhlRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdXNlckFnZW50ID0gKG5hdmlnYXRvciAhPSBudWxsID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6IHZvaWQgMCkgfHwgXCJcIjtcbiAgICBpc0lFMTEgPSAhd2luZG93LkFjdGl2ZVhPYmplY3QgJiYgX19pbmRleE9mLmNhbGwod2luZG93LCBcIkFjdGl2ZVhPYmplY3RcIikgPj0gMDtcbiAgICBpc0lFID0gIWlzSUUxMSAmJiAod2luICYmIChfX2luZGV4T2YuY2FsbCh3aW4sIFwiQWN0aXZlWE9iamVjdFwiKSA+PSAwKSk7XG4gICAgY2FjaGVkX3VhID0gbnVsbDtcbiAgICB1YSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIENvbnZlcnQgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGEgbnVtZXJpYyB2YWx1ZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLV9udW1iZXJpZnlcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzIFRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdmVyc2lvbiBudW1iZXIgKGUuZy4gJ21ham9yLm1pbm9yLnJldmlzaW9uJylcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBwYXJzZV91YSwgX21hdGNoSXQsIF9udW1iZXJpZnksIF90ZXN0SXQ7XG4gICAgICBfbnVtYmVyaWZ5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgYyA9IDA7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHMucmVwbGFjZSgvXFwuL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjKysgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgV3JhcHBlciBtZXRob2QgZm9yIHJldHVybmluZyB2YWx1ZXMgZnJvbSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBzYWZlbHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEtX21hdGNoSXRcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICBAcGFyYW0ge1JlZ0V4cH0gcmVnRXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgZm9yIG1hdGNoaW5nXG4gICAgICBAcGFyYW0ge051bWJlcn0gW2lkeF0gVGhlIGluZGV4IG51bWJlciBvZiBhIG1hdGNoIHRvIHB1bGwgZnJvbVxuICAgICAgQHJldHVybnMge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgX21hdGNoSXQgPSBmdW5jdGlvbihzdHIsIHJlZ0V4LCBpZHgpIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIG0gPSBzdHIgJiYgc3RyLm1hdGNoKHJlZ0V4KTtcbiAgICAgICAgaWYgKCEoaWR4ICE9IG51bGwpKSB7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChtICYmIG1baWR4XSkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFdyYXBwZXIgbWV0aG9kIGZvciB0ZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS1fdGVzdEl0XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1JlZ0V4cH0gcmVnRXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IHdpdGhcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3Rlc3RJdCA9IGZ1bmN0aW9uKHJlZ0V4LCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ0V4LnRlc3Qoc3RyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBQYXJzZSBhIHVzZXItYWdlbnQgc3RyaW5nIGZyb20gdGhlIGJyb3dzZXIgYW5kIGdhdGhlciBwZXJ0aW5lbnQgYnJvd3NlciwgYW5kIE9TIGluZm9ybWF0aW9uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEucGFyc2VcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtzdWJVQV0gQW4gYWx0ZXJuYXRlIHVzZXItYWdlbnQgc3RyaW5nIHRvIHBhcnNlLiBJZiBubyB2YWxpZCBzdHJpbmcgaXMgcGFzc2VkIGluLCBmdW5jdGlvbiB3aWxsIHJldHVybiBhbiBvYmplY3QgYmFzZWQgb24gdGhlIGtub3duIHVzZXItYWdlbnRcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IDxiPnBhcnNlZDwvYj4gQnJvd3NlciBhbmQgT1MgaW5mb3JtYXRpb248YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaWUgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ub3BlcmEgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBPcGVyYSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5nZWNrbyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEdlY2tvIChGaXJlZm94KSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi53ZWJraXQgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJLaXQgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uc2FmYXJpIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2FmYXJpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmNocm9tZSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENocm9tZSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5haXIgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBSVIgU0RLIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pcG9kIFdoZXRoZXIgb3Igbm90IGFuIGlQb2QgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmlwYWQgV2hldGhlciBvciBub3QgYW4gaVBhZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaXBob25lIFdoZXRoZXIgb3Igbm90IGFuIGlQaG9uZSBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uYW5kcm9pZCBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFuZHJvaWQgT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LndlYm9zIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnNpbGsgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBTaWxrIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+Lm5vZGVqcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE5vZGVKUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ucGhhbnRvbWpzIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgUGhhbnRvbUpTIGVudmlyb25tZW50IGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge1N0cmluZ30gPGI+cGFyc2VkPC9iPi5tb2JpbGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gb3MgaXMgYSBtb2JpbGUgZGV2aWNlICBhbmQgaXQncyB0eXBlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd3aW5kb3dzJywgJ2FuZHJvaWQnLCAnc3ltYm9zJywgJ2xpbnV4JywgJ21hY2ludG9zaCcsICdyaGlubycsICdnZWNrbycsICdBcHBsZScsICdjaHJvbWUnLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pb3MgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBpT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7Qm9vbGVhbn0gPGI+cGFyc2VkPC9iPi5hY2NlbCBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIGVudmlyb25tZW50IGluIHF1ZXN0aW9uIGlzIGhhcmR3YXJlIGFjY2VsZXJhdGVkLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5jYWphVmVyc2lvbiBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENBSkEgZW52aXJvbm1lbnQgb3IgMCBpZiBub3QuXG4gICAgICAgKi9cbiAgICAgIHBhcnNlX3VhID0gZnVuY3Rpb24oc3ViVUEpIHtcbiAgICAgICAgdmFyIGRhdGUsIGUsIG1hdGNoLCByZXQ7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKCFzdWJVQSAmJiBjYWNoZWRfdWEpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkX3VhO1xuICAgICAgICB9XG4gICAgICAgIHJldC5pZSA9IHJldC5vcGVyYSA9IHJldC5nZWNrbyA9IHJldC53ZWJraXQgPSByZXQuc2FmYXJpID0gcmV0LmNocm9tZSA9IHJldC5haXIgPSByZXQuaXBvZCA9IHJldC5pcGFkID0gcmV0LmlwaG9uZSA9IHJldC5hbmRyb2lkID0gcmV0LndlYm9zID0gcmV0LnNpbGsgPSByZXQubm9kZWpzID0gcmV0LnBoYW50b21qcyA9IDA7XG4gICAgICAgIHJldC5tb2JpbGUgPSByZXQuaW9zID0gcmV0Lm9zID0gbnVsbDtcbiAgICAgICAgcmV0LmFjY2VsID0gZmFsc2U7XG4gICAgICAgIHJldC5jYWphID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5jYWphVmVyc2lvbjtcbiAgICAgICAgcmV0LmNrcyA9IGZhbHNlO1xuICAgICAgICBzdWJVQSA9IHN1YlVBIHx8IHVzZXJBZ2VudCB8fCBcIlwiO1xuICAgICAgICBpZiAoc3ViVUEpIHtcbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvd2luZG93c3x3aW4zMi9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwid2luZG93c1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvbWFjaW50b3NofG1hY19wb3dlcnBjL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJtYWNpbnRvc2hcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL2FuZHJvaWQvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcImFuZHJvaWRcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL3N5bWJvcy9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwic3ltYm9zXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9saW51eC9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwibGludXhcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF90ZXN0SXQoL3JoaW5vL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgICByZXQub3MgPSBcInJoaW5vXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9LSFRNTC8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0LndlYmtpdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9JRU1vYmlsZXxYQkxXUDcvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIndpbmRvd3NcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL0Zlbm5lYy8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiZ2Vja29cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL0FwcGxlV2ViS2l0XFwvKFteXFxzXSopLywgMSk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXQud2Via2l0ID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICByZXQuc2FmYXJpID0gcmV0LndlYmtpdDtcbiAgICAgICAgICAgIGlmIChfdGVzdEl0KC9QaGFudG9tSlMvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL1BoYW50b21KU1xcLyhbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQucGhhbnRvbWpzID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGVzdEl0KFJlZ0V4cChcIiBNb2JpbGVcXFxcL1wiKSwgc3ViVUEpIHx8IF90ZXN0SXQoL2lQYWR8aVBvZHxpUGhvbmUvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiQXBwbGVcIjtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09TIChbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoICYmIF9udW1iZXJpZnkobWF0Y2gucmVwbGFjZShcIl9cIiwgXCIuXCIpKTtcbiAgICAgICAgICAgICAgcmV0LmlvcyA9IG1hdGNoO1xuICAgICAgICAgICAgICByZXQuaXBhZCA9IHJldC5pcG9kID0gcmV0LmlwaG9uZSA9IDA7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9pUGFkfGlQb2R8aVBob25lLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldFttYXRjaC50b0xvd2VyQ2FzZSgpXSA9IHJldC5pb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9Ob2tpYU5bXlxcL10qfEFuZHJvaWQgXFxkXFwuXFxkfHdlYk9TXFwvXFxkXFwuXFxkLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvd2ViT1MvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gXCJXZWJPU1wiO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC93ZWJPU1xcLyhbXlxcc10qKTsvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC53ZWJvcyA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdChSZWdFeHAoXCIgQW5kcm9pZFwiKSwgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiQW5kcm9pZFwiO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BbmRyb2lkIChbXlxcc10qKTsvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hbmRyb2lkID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGVzdEl0KC9TaWxrLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL1NpbGtcXC8oW15cXHNdKilcXCkvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5zaWxrID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmV0LmFuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hbmRyb2lkID0gMi4zNDtcbiAgICAgICAgICAgICAgICAgIHJldC5vcyA9IFwiQW5kcm9pZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvQWNjZWxlcmF0ZWQ9dHJ1ZS8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgICAgcmV0LmFjY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoID0gc3ViVUEubWF0Y2goLyhDaHJvbWV8Q3JNbylcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICByZXQuY2hyb21lID0gX251bWJlcmlmeShtYXRjaFsyXSk7XG4gICAgICAgICAgICAgIHJldC5zYWZhcmkgPSAwO1xuICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwiQ3JNb1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiY2hyb21lXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BZG9iZUFJUlxcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQuYWlyID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXQud2Via2l0KSB7XG4gICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT3BlcmFbXFxzXFwvXShbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHJldC5vcGVyYSA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT3BlcmEgTWluaVteO10qLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL01TSUVcXHMoW147XSopLywgMSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5pZSA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9HZWNrb1xcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgcmV0LmdlY2tvID0gMTtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9ydjooW15cXHNcXCldKikvLCAxKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXQuZ2Vja28gPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgICAgICB0aGVEb2N1bWVudC5jb29raWUgPSBsYW5nLmNzdHIoW1wic2ZfY2tfdHN0PXRlc3Q7IGV4cGlyZXM9XCIsIGRhdGUudG9HTVRTdHJpbmcoKSwgXCI7IHBhdGg9L1wiXSk7XG4gICAgICAgICAgaWYgKHRoZURvY3VtZW50LmNvb2tpZS5pbmRleE9mKFwic2ZfY2tfdHN0XCIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0LmNrcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJldC5ja3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgICAgICAgICAgIHJldC5vcyA9IHByb2Nlc3MucGxhdGZvcm07XG4gICAgICAgICAgICAgIHJldC5ub2RlanMgPSBudW1iZXJpZnkocHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgcmV0Lm5vZGVqcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaWVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgT3BlcmEgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEBuYW1lICRzZi5lbnYudWEub3BlcmFcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgR2Vja28gKEZpcmVmb3gpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmdlY2tvXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYktpdCBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS53ZWJraXRcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2FmYXJpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnNhZmFyaVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDaHJvbWUgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuY2hyb21lXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFJUiBTREsgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmFpclxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgYW4gaVBvZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCwgMCBmb3IgZmFsc2UsICZndDsgMCA9PSB0cnVlXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlwb2RcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IGFuIGlQYWQgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcGFkXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCBhbiBpUGhvbmUgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcGhvbmVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQW5kcm9pZCBPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuYW5kcm9pZFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEud2Vib3NcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2lsayBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5zaWxrXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE5vZGVKUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEubm9kZWpzXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFBoYW50b21KUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEucGhhbnRvbWpzXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBvcyBpcyBhIG1vYmlsZSBkZXZpY2UgIGFuZCBpdCdzIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3dpbmRvd3MnLCAnYW5kcm9pZCcsICdzeW1ib3MnLCAnbGludXgnLCAnbWFjaW50b3NoJywgJ3JoaW5vJywgJ2dlY2tvJywgJ0FwcGxlJywgJ2Nocm9tZScuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEubW9iaWxlXG4gICAgICBAdHlwZSB7U3RyaW5nfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIGlPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaW9zXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIGVudmlyb25tZW50IGluIHF1ZXN0aW9uIGlzIGhhcmR3YXJlIGFjY2VsZXJhdGVkLlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5hY2NlbFxuICAgICAgQHR5cGUge0Jvb2xlYW59XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ0FKQSBlbnZpcm9ubWVudCBvciAwIGlmIG5vdFxuICAgICAgQG5hbWUgJHNmLmVudi51YS5jYWphVmVyc2lvblxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuICAgICAgY2FjaGVkX3VhID0gcGFyc2VfdWEoKTtcbiAgICAgIGNhY2hlZF91YS5wYXJzZSA9IHBhcnNlX3VhO1xuICAgICAgcmV0dXJuIGNhY2hlZF91YTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICB1YTogdWEsXG4gICAgICBpc0lFOiBpc0lFXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgUGFyYW1IYXNoLCBiYWNrU2xhc2gsIGNhbGxhYmxlLCBjYm9vbCwgY251bSwgY3N0ciwgZGVmLCBlbnRpdHlNYXAsIGVudGl0eVJlZ2V4ZXMsIGd1aWQsIGlzQXJyYXksIGpzc2FmZV9odG1sLCBsYW5nLCBtaXgsIG5leHRfaWQsIG5vb3AsIG5zLCBwcm90bywgcmFuZCwgc2NyaXBfc3RyLCB0aW1lLCB0b1N0cmluZywgdHJpbSwgd2luLCB3cmFwLCBfZXMsIF9rZXlzLCBfdWU7XG4gICAgbmV4dF9pZCA9IDA7XG4gICAgd2luID0gd2luZG93O1xuICAgIGJhY2tTbGFzaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTIpO1xuICAgIHNjcmlwX3N0ciA9ICdzY3JcIitcImlwdCc7XG4gICAgX2VzID0gd2luLmVzY2FwZTtcbiAgICBfdWUgPSB3aW4udW5lc2NhcGU7XG5cbiAgICAvKlxuICAgIEEgZnVuY3Rpb24gcmVmZXJlbmNlIHRoYXQgZG9lcyBub3RoaW5nLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBub29wIGFzICRzZi5saWIubGFuZy5ub29wXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwdWJsaWNcbiAgICBAcmV0dXJuIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIG5vb3AgPSBmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBOb3RlIHRoYXQgXCJmYWxzeVwiIHZhbHVlcyBvciB2YWx1ZXMgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgIGFzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikuXG4gICAgICBcbiAgICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICAgIEBleHBvcnRzIGNzdHIgYXMgJHNmLmxpYi5sYW5nLmNzdHJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHsqfSBzdHIgIEFueSBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9ICBUaGUgbm9ybWFsaXplZCBzdHJpbmcgdmFsdWUuXG4gICAgICAgKi9cbiAgICB9O1xuICAgIGNzdHIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciB0eXA7XG4gICAgICB0eXAgPSB0eXBlb2Ygc3RyO1xuICAgICAgaWYgKHR5cCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJudW1iZXJcIiAmJiAhc3RyKSB7XG4gICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwib2JqZWN0XCIgJiYgc3RyICYmIHN0ci5qb2luKSB7XG4gICAgICAgIHJldHVybiBzdHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIGJvb2xlYW4uXG4gICAgXCJGYWxzeVwiIHZhbHVlcyBzdWNoIGFzIFwiXCIsIDAsIG51bGwsIGFuZCB1bmRlZmluZWQgYWxsIHJldHVybiBmYWxzZVxuICAgIFN0cmluZyB2YWx1ZXMgb2YgIFwiMFwiLCBcImZhbHNlXCIsIFwibm9cIiwgXCJ1bmRlZmluZWRcIiwgXCJudWxsXCIgYWxzbyByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY2Jvb2wgYXMgJHNmLmxpYi5sYW5nLmNib29sXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyp9IHZhbCBBbnkgSmF2YVNjcmlwdCByZWZlcmVuY2UgLyB2YWx1ZVxuICAgIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub3JtYWxpemVkIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBjYm9vbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKCF2YWwgfHwgdmFsID09PSBcIjBcIiB8fCB2YWwgPT09IFwiZmFsc2VcIiB8fCB2YWwgPT09IFwibm9cIiB8fCB2YWwgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgaywgX3Y7XG4gICAgICByZXR1cm4gKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmtleXMob2JqKSA6IHZvaWQgMCkgfHwgKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgX3YgPSBvYmpba107XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBGb3JjZXMgdHlwZSBjb252ZXJzaW9uIG9mIGFueSBKYXZhU2NyaXB0IHZhcmlhYmxlIHRvIGEgbnVtYmVyLlxuICAgIFZhbHVlcyAvIG9iamVjdHMgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkLCB3aWxsIGJlIHJldHVybmVkIGFzIE5hTiwgdW5sZXNzXG4gICAgYSBkZWZhdWx0IHZhbHVlIGlzIHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyB1c2VkLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjbnVtIGFzICRzZi5saWIubGFuZy5jbnVtXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyp9IHZhbCBBbnkgSmF2YVNjcmlwdCByZWZlcmVuY2UgLyB2YWx1ZVxuICAgIEBwYXJhbSB7Kn0gW2RlZlZhbF0gdXNlIHRoaXMgdmFsdWUgaWYgb3JpZ2luYWwgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgb3IgaWYgdmFsdWUgaXMgbGVzcyB0aGFuIG1pbiB2YWx1ZSwgb3IgaWYgdmFsdWUgaXMgbGVzcyB0aGFuIG1heCB2YWx1ZS5cbiAgICBAcGFyYW0ge051bWJlcn0gW21pblZhbF0gc3BlY2lmaWVzIHRoZSBsb3dlc3QgbnVtZXJpY2FsIHZhbHVlLCBpZiBvcmlnaW5hbCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGRlZlZhbCB3aWxsIGJlIHJldHVybmVkLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbbWF4VmFsXSBzcGVjaWZpZXMgdGhlIGdyZWF0ZXN0IG51bWVyaWNhbCB2YWx1ZSwgaWYgb3JpZ2luYWwgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBkZWZWYWwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICBAcmV0dXJuIHtOdW1iZXJ8TmFOfCp9IHRoZSBjb252ZXJ0ZWQgdmFsdWUsIG90aGVyd2lzZSBOYU4gb3IgZGVmYXVsdCB2YWx1ZVxuICAgICAqL1xuICAgIGNudW0gPSBmdW5jdGlvbih2YWwsIGRlZlZhbCwgbWluVmFsLCBtYXhWYWwpIHtcbiAgICAgIHZhciBlO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgdmFsID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICB2YWwgPSBOdW1iZXIuTmFOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF4VmFsID09IG51bGwpIHtcbiAgICAgICAgbWF4VmFsID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5WYWwgPT0gbnVsbCkge1xuICAgICAgICBtaW5WYWwgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIGlmICgoaXNOYU4odmFsKSB8fCB2YWwgPCBtaW5WYWwgfHwgdmFsID4gbWF4VmFsKSAmJiAoZGVmVmFsICE9IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBkZWZWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyB0aGF0IGEgZnVuY3Rpb24gcmVmZXJlbmNlIGNhbiBiZSBjYWxsZWQgc2FmZWx5LiAgU29tZXRpbWVzIGZ1bmN0aW9uIHJlZmVyZW5jZXMgYXJlIHBhcnRcbiAgICBvZiBvYmplY3RzIHRoYXQgbWF5IGhhdmUgYmVlbiBnYXJiYWdlIGNvbGxlY3RlZCAoc3VjaCBhcyBhIGZ1bmN0aW9uIHJlZmVyZW5jZSBmcm9tIGFub3RoZXIgd2luZG93IG9yIGRvbSBlbGVtZW50KS5cbiAgICBUaGlzIG1ldGhvZCBjaGVja3MgdGhlIHJlZmVyZW5jZSBieSBtYWtpbmcgc3VyZSBpdCBoYXMgYSBjb25zdHJ1Y3RvciBhbmQgdG9TdHJpbmcgcHJvcGVydGllcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgZnVuY3Rpb24gaXRzZWxmIHdoZW4gY2FsbGVkIChvciBpdHMgc3Vic3F1ZW50IGNhbGwgc3RhY2spLCBjYW4ndCB0aHJvdyBhbiBlcnJvci4gLiAuXG4gICAgc2ltcGx5IHRoYXQgeW91IGFyZSBhYmxlIHRvIGNhbGwgaXQuIC4gLlxuICAgIFxuICAgIHRoaXMgY2FuIHByb2JsZW0gYmUgcmVtb3ZlZCBpbiBsaWV1IG9mIGZ1bmM/KCkgaW4gY3NcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY2FsbGFibGUgYXMgJHNmLmxpYi5sYW5nLmNhbGxhYmxlXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBBIHJlZmVyZW5jZSB0byBhIEphdmFTY3JpcHQgZnVuY3Rpb25cbiAgICBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgc2FmZWx5LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgY2FsbGFibGUgPSBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGYgPSAoZiAmJiB0eXBlb2YgZiA9PT0gXCJmdW5jdGlvblwiICYmIGYudG9TdHJpbmcoKSAmJiAobmV3IGYuY29uc3RydWN0b3IoKSkgPyBmIDogbnVsbCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgZiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFmO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdlbmVyYXRlIGEgdW5pcXVlIGlkIHN0cmluZ1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBndWlkIGFzICRzZi5saWIubGFuZy5ndWlkXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeF0gYSBzdWJzdHJpbmcgdG8gdXNlIGEgcHJlZml4XG4gICAgQHJldHVybiB7U3RyaW5nfSB1bmlxdWUgaWQgc3RyaW5nXG4gICAgICovXG4gICAgZ3VpZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgICAgcmV0dXJuIGNzdHIoW3ByZWZpeCB8fCBcIlwiLCBcIl9cIiwgdGltZSgpLCBcIl9cIiwgcmFuZCgpLCBcIl9cIiwgbmV4dF9pZCsrXSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWl4ZWQgdGhlIHByb3BlcnRpZXMgb2Ygb25lIG9iamVjdCBpbnRvIGFub3RoZXIgb2JqZWN0LlxuICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHJlY3Vyc2l2ZVxuICAgIFxuICAgIFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBtaXggYXMgJHNmLmxpYi5sYW5nLm1peFxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtPYmplY3R9ICByICBUaGUgb2JqZWN0IHRoYXQgd2lsbCByZWNlaXZlIHByb3BlcnRpZXNcbiAgICBAcGFyYW0ge09iamVjdH0gIHMgIFRoZSBvYmplY3QgdGhhdCB3aWxsIGRlbGlldmVyIHByb3BlcnRpZXNcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtvd25lZF0gV2hldGhlciBvciBub3QgdG8gc2tpcCBvdmVyIHByb3BlcnRpZXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgb2JqZWN0IHByb3RvdHlwZVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBGdW5jc10gV2hldGhlciBvciBub3QgdG8gc2tpcCBvdmVyIGZ1bmN0aW9uIHJlZmVyZW5jZXNcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtub19vdnJdIFdoZXRoZXIgb3Igbm90IHRvIG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIHRoYXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGZpbGxlZCBvdXRcbiAgICBAcmV0dXJuIHtPYmplY3R9IFRoZSByZWNlaXZlciBvYmplY3QgcGFzc2VkIGluIHdpdGggcG90ZW50aWFsbHkgbmV3IHByb3BlcnRpZXMgYWRkZWRcbiAgICAgKi9cbiAgICBtaXggPSBmdW5jdGlvbihyLCBzLCBvd25lZCwgc2tpcEZ1bmNzLCBub19vdnIpIHtcbiAgICAgIHZhciBpdGVtLCBwLCB0eXA7XG4gICAgICBpZiAoIXMgfHwgIXIpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgICBmb3IgKHAgaW4gcykge1xuICAgICAgICBpdGVtID0gc1twXTtcbiAgICAgICAgdHlwID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmIChvd25lZCAmJiAhcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub19vdnIgJiYgKHAgaW4gcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcEZ1bmNzICYmIHR5cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cCA9PT0gXCJvYmplY3RcIiAmJiBpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uc2xpY2UpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtaXgoW10sIGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gbWl4KHt9LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcltwXSA9IGl0ZW07XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMsIGZyb20gdGhlIGVwb2NoXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIHRpbWUgYXMgJHNmLmxpYi5sYW5nLnRpbWVcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEByZXR1cm4ge051bWJlcn0gY3VycmVudCB0aW1lXG4gICAgICovXG4gICAgdGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYW55d2hlcmUgZnJvbSAwIHRvIDk5XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIHJhbmQgYXMgJHNmLmxpYi5sYW5nLnJhbmRcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEByZXR1cm4ge051bWJlcn0gcmFuZG9tIG51bWJlclxuICAgICAqL1xuICAgIHJhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFRyaW0gdGhlIGJlZ2luaW5nIGFuZCBlbmRpbmcgd2hpdGVzcGFjZSBmcm9tIGEgc3RyaW5nLlxuICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhbiBhcmd1bWVudCB0byBhIHN0cmluZyBmaXJzdFxuICAgIGZvciB0eXBlIHNhZmV0eSBwdXJwb3Nlcy4gSWYgc3RyaW5nIGNhbm5vdCBiZSBjb252ZXJ0ZWQsIGFuZCBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgdHJpbSBhcyAkc2YubGliLmxhbmcudHJpbVxuICAgIEByZXR1cm4ge1N0cmluZ30gdHJpbW1lZCBzdHJpbmdcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgICAqL1xuICAgIHRyaW0gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICByZXQgPSBjc3RyKHN0cik7XG4gICAgICByZXR1cm4gcmV0ICYmIHJldC5yZXBsYWNlKC9eXFxzXFxzKi8sIFwiXCIpLnJlcGxhY2UoL1xcc1xccyokLywgXCJcIik7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRGVmaW5lIGEgSmF2YVNjcmlwdCBOYW1lc3BhY2Ugd2l0aGluIGEgZ2l2ZW4gY29udGV4dFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBkZWYgYXMgJHNmLmxpYi5sYW5nLmRlZlxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJfbnMgIFRoZSBuYW1lIG9mIHRoZSBuYW1lc3BhY2UgaW4gZG90IG5vdGF0aW9uIGFzIGEgc3RyaW5nIChlLmcuIFwiRm9vLmJhclwiKVxuICAgIEBwYXJhbSB7T2JqZWN0fSBbYXVnXSBkZWZpbmVzIHRoZSBvYmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZXNwYWNlLiAgSWYgbmFtZXNwYWNlIGlzIGFscmVhZHkgc3BlY2lmaWVkLCBhbmQgdGhpcyBvYmplY3QgaXMgcHJvdmlkZWQsIHRoZSBuYW1lc3BhY2Ugd2lsbCBiZSBhdWdtZW50ZWQgd2l0aCBwcm9wZXJ0aWVzIGZyb20gdGhpcyBvYmplY3QuIElmIG5vdGhpbmcgaXMgcGFzc2VkIGluLCBkZWZhdWx0cyB0byB1c2luZyBhbiBlbXB0eSBvYmplY3QuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtyb290XSB0aGUgcm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgbmFtZXNwYWNlIGlzIGRlZmluZWQuICBJZiBub3QgcGFzc2VkIGluIGRlZmF1bHRzIHRvIHRoZSBnbG9iYWwvd2luZG93IG9iamVjdFxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW25vX292cl0gaWYgdHJ1ZSwgcHJvcGVydGllcyBhbHJlYWR5IGRlZmluZWQgb24gcm9vdCB3aXRoIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBpZ25vcmVkXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZXNwYWNlXG4gICAgICovXG4gICAgZGVmID0gZnVuY3Rpb24oc3RyX25zLCBhdWcsIHJvb3QsIG5vX292cikge1xuICAgICAgdmFyIGFyLCBpZHgsIGl0ZW0sIG9iaiwgcGVyLCByZXQ7XG4gICAgICBvYmogPSAocm9vdCAmJiB0eXBlb2Ygcm9vdCA9PT0gXCJvYmplY3RcIiA/IHJvb3QgOiB3aW4pO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHBlciA9IFwiLlwiO1xuICAgICAgcmV0ID0gbnVsbDtcbiAgICAgIGlmIChzdHJfbnMpIHtcbiAgICAgICAgc3RyX25zID0gY3N0cihzdHJfbnMpO1xuICAgICAgICBhdWcgPSAoYXVnICYmIHR5cGVvZiBhdWcgPT09IFwib2JqZWN0XCIgPyBhdWcgOiBudWxsKTtcbiAgICAgICAgaWYgKHN0cl9ucy5pbmRleE9mKHBlcikpIHtcbiAgICAgICAgICBhciA9IHN0cl9ucy5zcGxpdChwZXIpO1xuICAgICAgICAgIHdoaWxlIChpdGVtID0gYXJbaWR4KytdKSB7XG4gICAgICAgICAgICBpdGVtID0gdHJpbShpdGVtKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IGFyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAob2JqW2l0ZW1dICYmIGF1Zykge1xuICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXSA9IG1peChvYmpbaXRlbV0sIGF1ZywgZmFsc2UsIG51bGwsIG5vX292cik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vX292ciAmJiAoaXRlbSBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXSA9IG9ialtpdGVtXSB8fCBhdWcgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobm9fb3ZyICYmIChpdGVtIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gb2JqW2l0ZW1dIHx8IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvYmpbc3RyX25zXSAmJiBhdWcpIHtcbiAgICAgICAgICAgIHJldCA9IG9ialtzdHJfbnNdID0gbWl4KG9ialtzdHJfbnNdLCBhdWcsIGZhbHNlLCBudWxsLCBub19vdnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBvYmpbc3RyX25zXSA9IG9ialtzdHJfbnNdIHx8IGF1ZyB8fCB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgSmF2YVNjcmlwdCBuYW1lc3BhY2VcbiAgICBhcyBvcHBvc2VkIHRvIGRlZiwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRlZmluZSB0aGUgbmFtZXNwYWNlXG4gICAgd2l0aCBhIGdpdmVuIGNvbnRleHQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG5zIGFzICRzZi5saWIubGFuZy5uc1xuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHJfbnMgIEEgc3RyaW5nIHdpdGggLiBvciBbXSBub3RhdGlvbiBvZiBhIEphdmFTY3JpcHQgbmFtZXNhY2UgKGUuZy4gXCJmb28uYmFyLnNob3dcIiwgb3IgXCJmb29bJ2JhciddWydzaG93J11cIikuXG4gICAgQHBhcmFtIHtPYmplY3R9IFtyb290XSB0aGUgcm9vdCBvYmplY3QgdG8gY2hlY2sgd2l0aGluLiAuZGVmYXVsdHMgdG8gZ2xvYmFsIC8gd2luZG93XG4gICAgQHJldHVybiB7Kn0gVGhlIGVuZHBvaW50IHJlZmVyZW5jZSBvZiB0aGUgbmFtZXNwYWNlIG9yIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgbnMgPSBmdW5jdGlvbihzdHJfbnMsIHJvb3QpIHtcbiAgICAgIHZhciBleGlzdHMsIGV4cCwgZXhwMiwgZXhwMywgZXhwNCwgaWR4LCBtYXRjaGVzLCBvYmosIHByb3AsIHJvb3RTdHI7XG4gICAgICBleHAgPSAvKFxcWyguezEsfSlcXF0pfChcXC5cXHcrKS9nO1xuICAgICAgZXhwMiA9IC9cXFsoKCd8XCIpPykoKFxcc3wuKSo/KSgoJ3xcIik/KVxcXS9nO1xuICAgICAgZXhwMyA9IC8oXFxbLiopfChcXC4uKikvZztcbiAgICAgIGV4cDQgPSAvXFwuL2c7XG4gICAgICBpZHggPSAwO1xuICAgICAgcm9vdFN0ciA9IFwiXCI7XG4gICAgICBleGlzdHMgPSB0cnVlO1xuICAgICAgb2JqID0gcm9vdCA9IHJvb3QgfHwgd2luO1xuICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICBzdHJfbnMgPSBjc3RyKHN0cl9ucyk7XG4gICAgICAgIGlmIChzdHJfbnMpIHtcbiAgICAgICAgICBzdHJfbnMgPSB0cmltKHN0cl9ucyk7XG4gICAgICAgICAgbWF0Y2hlcyA9IHN0cl9ucy5tYXRjaChleHApO1xuICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByb290U3RyID0gc3RyX25zLnJlcGxhY2UoZXhwMywgXCJcIik7XG4gICAgICAgICAgICBtYXRjaGVzLnVuc2hpZnQocm9vdFN0cik7XG4gICAgICAgICAgICB3aGlsZSAocHJvcCA9IG1hdGNoZXNbaWR4KytdKSB7XG4gICAgICAgICAgICAgIHByb3AgPSBwcm9wLnJlcGxhY2UoZXhwMiwgXCIkM1wiKS5yZXBsYWNlKGV4cDQsIFwiXCIpO1xuICAgICAgICAgICAgICBpZiAoIW9ialtwcm9wXSkge1xuICAgICAgICAgICAgICAgIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcCA9IHN0cl9ucztcbiAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChleGlzdHMgJiYgb2JqKSB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAZnVuY3Rpb25cbiAgICBUZXN0cyB0byBzZWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaXMgYW4gYXJyYXlcbiAgICAgKi9cbiAgICBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChvYmoubGVuZ3RoICE9IG51bGwpICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgSmF2YVNjcmlwdCBuYW1lc3BhY2VcbiAgICBhcyBvcHBvc2VkIHRvIGRlZiwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRlZmluZSB0aGUgbmFtZXNwYWNlXG4gICAgd2l0aCBhIGdpdmVuIGNvbnRleHQuICAgICAgICAgdmlhIHVuZGVyc2NvcmUuanNcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgbnMgYXMgJHNmLmxpYi5sYW5nLndyYXBcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgd3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgIGFyZ3MgPSBbZnVuY107XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBHaXZlbiBhIHN0cmluZyBvZiBIVE1MIGVzY2FwZSBxdW90ZSBtYXJrcyBhbmQgc2VwZXJhdGUgc2NyaXB0IHRhZ3Mgc28gdGhhdCBicm93c2VycyBkb24ndCBnZXQgdHJpcHBlZCB1cFxuICAgIGR1cmluZyBwcm9jZXNzaW5nLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBqc3NhZmVfaHRtbCBhcyAkc2YubGliLmxhbmcuanNzYWZlX2h0bWxcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyIEEgc3RyaW5nIG9mIEhUTUwgbWFya3VwIHRvIGJlIHByb2Nlc3NlZFxuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgICAqL1xuICAgIGVudGl0eU1hcCA9IHtcbiAgICAgIGVzY2FwZToge1xuICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgIFwiJ1wiOiAnJiN4Mjc7J1xuICAgICAgfVxuICAgIH07XG4gICAgZW50aXR5UmVnZXhlcyA9IHtcbiAgICAgIGVzY2FwZTogbmV3IFJlZ0V4cCgnWycgKyBfa2V5cyhlbnRpdHlNYXAuZXNjYXBlKS5qb2luKCcnKSArICddJywgJ2cnKVxuICAgIH07XG4gICAganNzYWZlX2h0bWwgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXMuZXNjYXBlLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW50aXR5TWFwLmVzY2FwZVttYXRjaF07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAY2xhc3MgSW50YW50aWFibGUgY2xhc3MgdXNlZCB0byBjb252ZXJ0IGEgZGVsaW1pdGVkIHN0cmluZyBpbnRvIGFuIG9iamVjdC48YnIgLz5cbiAgICBGb3IgZXhhbXBsZSBxdWVyeXN0cmluZ3M6IFwibmFtZV8xPXZhbHVlXzEmbmFtZV8yPXZhbHVlXzJcIiA9PT4ge25hbWVfMTp2YWx1ZV8xLG5hbWVfMjp2YWx1ZV8yfTs8YnIvPjxiciAvPlxuICAgIFxuICAgIE5vdGUgdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgY291bGQgYWxzbyBjb250YWluIHRoZSBzYW1lIHNQcm9wRGVsaW0gYW5kIHNWYWx1ZURlbGltIHN0cmluZ3MuICBQcm9wZXIgc3RyaW5nIGVuY29kaW5nIHNob3VsZCBvY2N1clxuICAgIHRvIG5vdCB0cmlwIHVwIHRoZSBwYXJzaW5nIG9mIHRoZSBzdHJpbmcuICBTYWlkIHZhbHVlcyBtYXkgYmUgYXNjaWkgZXNjYXBlZCwgYW5kIGluIHR1cm4sIGFsb25nIHdpdGggdGhlIDxpPjxiPmJSZWN1cnNlPC9iPjwvaT4gY29uc3RydWN0b3IgcGFyYW1ldGVyIHNldCB0byB0cnVlLCB3aWxsIGNhdXNlIG5lc3RlZCBQYXJhbUhhc2ggb2JqZWN0cyB0byBiZSBjcmVhdGVkLlxuICAgIFxuICAgIEBjb25zdHJ1Y3RvclxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBQYXJhbUhhc2ggYXMgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1N0cmluZ10gIFRoZSBkZWxpbWl0ZWQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1Byb3BEZWxpbT1cIiZcIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVyIHVzZWQgdG8gc2VwZXJhdGUgcHJvcGVydGllcy4gRGVmYXVsdCBpcyBcIiZcIi5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NWYWx1ZURlbGltPVwiPVwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZWQgdXNlZCB0byBzZXBlcmF0ZSB2YWx1ZXMuICBEZWZhdWx0IGlzIFwiPVwiLlxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2JOb092ZXJ3cml0ZT1mYWxzZV0gIElmIHRydWUsIHdoZW4gYSBuYW1lIGlzIGVuY291bnRlcmVkIG1vcmUgdGhhbiAxIHRpbWUgaW4gdGhlIHN0cmluZyBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgQHBhcmFtIHtCb29sZWFufSBbYlJlY3Vyc2U9ZmFsc2VdICBJZiB0cnVlLCB3aGVuIGEgdmFsdWUgb2YgYSBwcm9wZXJ0eSB0aGF0IGlzIHBhcnNlZCBhbHNvIGhhcyBib3RoIHRoZSBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSBpbnNpZGUsIGNvbnZlcnQgdGhhdCB2YWx1ZSB0byBhbm90aGVyIFBhcmFtSGFzaCBvYmplY3QgYXV0b21hdGljYWxseVxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4PTEmeT0xJno9MVwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueik7IC8vID09IDFcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieDoxO3k6Mjt6OjNcIiwgXCI7XCIsIFwiOlwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyA9PSAyXG4gICAgYWxlcnQocGgueik7IC8vID09IDNcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieD0xJnk9MSZ6PTEmej0yXCIpO1xuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vIDFcbiAgICBhbGVydChwaC56KTsgLy9Ob3RlIHRoYXQgeiA9PSAyIGIvYyBvZiAyIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng9MSZ5PTEmej0xJno9MlwiLG51bGwsbnVsbCx0cnVlKTsgLy9udWxsIGZvciBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSA9PSB1c2UgZGVmYXVsdCB2YWx1ZXMgb2YgXCImXCIgYW5kIFwiPVwiIHJlc3BlY3RpdmVseVxuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vIDFcbiAgICBhbGVydChwaC56KTsgLy9Ob3RlIHRoYXQgeiA9PSAxIGIvYyBiTm9PdmVyd3JpdGUgd2FzIHNldCB0byB0cnVlXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICAvL1lvdSBjYW4gYWxzbyBkbyByZWN1cnNpdmUgcHJvY2Vzc2luZyBpZiBuZWVkIGJlXG4gICAgdmFyIHBvaW50c1x0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpLFxuICAgIHBvaW50XzFcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKSxcbiAgICBwb2ludF8yXHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKCk7XG4gICAgXG4gICAgcG9pbnRfMS54ID0gMTAwO1xuICAgIHBvaW50XzEueSA9IDc1O1xuICAgIFxuICAgIHBvaW50XzIueCA9IDIwMDtcbiAgICBwb2ludF8yLnkgPSAxNTA7XG4gICAgXG4gICAgcG9pbnRzLnBvaW50XzFcdD0gcG9pbnRfMTtcbiAgICBwb2ludHMucG9pbnRfMlx0PSBwb2ludF8yO1xuICAgIFxuICAgIHZhciBwb2ludF9zdHJcdD0gcG9pbnRzLnRvU3RyaW5nKCk7ICAvLyA9PSBcInBvaW50XzE9eCUzRDEwMCUyNnklM0Q3NSUyNiZwb2ludF8yPXglM0QyMDAlMjZ5JTNEMTUwJTI2JlwiO1xuICAgIHZhciBwb2ludHNfY29weVx0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChwb2ludF9zdHIsIG51bGwsIG51bGwsIHRydWUsIHRydWUpOyAvL25vdGUgcGFzc2luZyB0cnVlLCBiL2Mgd2Ugd2FudCB0byByZWN1cnNlXG4gICAgXG4gICAgYWxlcnQocG9pbnRzX2NvcHkucG9pbnRfMS54KSAvLyA9PSBcIjEwMFwiO1xuICAgICAqL1xuICAgIFBhcmFtSGFzaCA9IGZ1bmN0aW9uKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKSB7XG4gICAgICB2YXIgYWRkZWQsIGNudCwgZG9BZGQsIGlkeCwgaWR4MiwgaWR4MywgaW8sIGxlbiwgbGVuMiwgbWUsIG5tLCBudiwgb2JqLCBwYWlycywgc1RlbXAsIHNUZW1wMiwgc1RlbXAzLCBzcztcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIGlvID0gXCJpbmRleE9mXCI7XG4gICAgICBzcyA9IFwic3Vic3RyaW5nXCI7XG4gICAgICBkb0FkZCA9IGZhbHNlO1xuICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQYXJhbUhhc2gpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1IYXNoKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWU7XG4gICAgICB9XG4gICAgICBpZiAoc1N0cmluZyAmJiB0eXBlb2Ygc1N0cmluZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gbWl4KG5ldyBQYXJhbUhhc2goXCJcIiwgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpLCBzU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHNTdHJpbmcgPSBjc3RyKHNTdHJpbmcpO1xuICAgICAgc1Byb3BEZWxpbSA9IGNzdHIoc1Byb3BEZWxpbSkgfHwgXCImXCI7XG4gICAgICBzVmFsdWVEZWxpbSA9IGNzdHIoc1ZhbHVlRGVsaW0pIHx8IFwiPVwiO1xuICAgICAgaWYgKCFzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtZTtcbiAgICAgIH1cbiAgICAgIGlmIChzUHJvcERlbGltICE9PSBcIj9cIiAmJiBzVmFsdWVEZWxpbSAhPT0gXCI/XCIgJiYgc1N0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXSgxKTtcbiAgICAgIH1cbiAgICAgIGlkeCA9IHNTdHJpbmdbaW9dKFwiP1wiKTtcbiAgICAgIGlkeDIgPSBzU3RyaW5nW2lvXShzVmFsdWVEZWxpbSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSAmJiBpZHgyICE9PSAtMSAmJiBpZHggPiBpZHgyKSB7XG4gICAgICAgIHNUZW1wID0gX2VzKHNTdHJpbmdbc3NdKGlkeDIgKyAxKSk7XG4gICAgICAgIHNUZW1wMiA9IHNTdHJpbmcuc3Vic3RyKDAsIGlkeDIgKyAxKTtcbiAgICAgICAgc1N0cmluZyA9IHNUZW1wMiArIHNUZW1wO1xuICAgICAgfSBlbHNlIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXShpZHggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbUhhc2goc1N0cmluZywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc1N0cmluZy5jaGFyQXQoMCkgPT09IHNQcm9wRGVsaW0pIHtcbiAgICAgICAgc1N0cmluZyA9IHNTdHJpbmdbc3NdKDEpO1xuICAgICAgfVxuICAgICAgcGFpcnMgPSBzU3RyaW5nLnNwbGl0KHNQcm9wRGVsaW0pO1xuICAgICAgY250ID0gcGFpcnMubGVuZ3RoO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHdoaWxlIChjbnQtLSkge1xuICAgICAgICBzVGVtcCA9IHBhaXJzW2lkeCsrXTtcbiAgICAgICAgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgZG9BZGQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNUZW1wKSB7XG4gICAgICAgICAgbnYgPSBzVGVtcC5zcGxpdChzVmFsdWVEZWxpbSk7XG4gICAgICAgICAgbGVuID0gbnYubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgICBubSA9IF91ZShudlswXSk7XG4gICAgICAgICAgICBudi5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGJSZWN1cnNlKSB7XG4gICAgICAgICAgICAgIHNUZW1wMiA9IG5tICsgc1ZhbHVlRGVsaW07XG4gICAgICAgICAgICAgIGlkeDIgPSBzU3RyaW5nW2lvXShzVGVtcDIpO1xuICAgICAgICAgICAgICBsZW4gPSBzVGVtcDJbTEVOXTtcbiAgICAgICAgICAgICAgc1RlbXAzID0gc1N0cmluZ1tzc10oaWR4MiArIGxlbik7XG4gICAgICAgICAgICAgIHNUZW1wMiA9IHNQcm9wRGVsaW0gKyBzUHJvcERlbGltO1xuICAgICAgICAgICAgICBsZW4yID0gc1RlbXAyW0xFTl07XG4gICAgICAgICAgICAgIGlkeDMgPSBzVGVtcDNbaW9dKHNUZW1wMik7XG4gICAgICAgICAgICAgIGlmIChpZHgzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNUZW1wMyA9IHNTdHJpbmcuc3Vic3RyKGlkeDIgKyBsZW4sIGlkeDMgKyBsZW4yKTtcbiAgICAgICAgICAgICAgICBvYmogPSBuZXcgUGFyYW1IYXNoKHNUZW1wMywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgIHNUZW1wMyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHNUZW1wMyBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWR4ICs9IGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNUZW1wID0gb2JqO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNUZW1wID0gX3VlKG52LmpvaW4oc1ZhbHVlRGVsaW0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc1RlbXAgPSBfdWUobnYuam9pbihzVmFsdWVEZWxpbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9BZGQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICBubSA9IF91ZShudlswXSk7XG4gICAgICAgICAgICBzVGVtcCA9IF91ZShudlsxXSk7XG4gICAgICAgICAgICBkb0FkZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb0FkZCkge1xuICAgICAgICAgICAgaWYgKGJOb092ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICBpZiAoIShubSBpbiBtZSkpIHtcbiAgICAgICAgICAgICAgICBtZVtubV0gPSBzVGVtcDtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lW25tXSA9IHNUZW1wO1xuICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYlJlY3Vyc2UgJiYgYWRkZWQgJiYgbm0gJiYgc1RlbXAgJiYgdHlwZW9mIHNUZW1wICE9PSBcIm9iamVjdFwiICYmIChzVGVtcFtpb10oc1Byb3BEZWxpbSkgPj0gMCB8fCBzVGVtcFtpb10oc1ZhbHVlRGVsaW0pID49IDApKSB7XG4gICAgICAgICAgICAgIG1lW25tXSA9IG5ldyBQYXJhbUhhc2goc1RlbXAsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBDb252ZXJ0cyBhIFBhcmFtSGFzaCBvYmplY3QgYmFjayBpbnRvIGEgc3RyaW5nIHVzaW5nIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVsaW1pdGVycyBzcGVjaWZlZCAoZGVmYXVsdHMgdG8gXCImXCIgYW5kIFwiPVwiKS5cbiAgICBBZ2FpbiB0aGlzIG1ldGhvZCB3b3JrcyByZWN1cnNpdmVseS4gIElmIGFuIG9iamVjdCBpcyBmb3VuZCBhcyBhIHByb3BlcnR5LCBpdCB3aWxsIGNvbnZlcnQgdGhhdCBvYmplY3QgaW50byBhIFBhcmFtSGFzaCBzdHJpbmdcbiAgICBhbmQgdGhlbiBlc2NhcGUgaXQuIE5vdGUgYWxzbyB0aGF0IHRoaXMgY2xhc3MncyB2YWx1ZU9mIG1ldGhvZCBpcyBlcXVhbCB0byB0aGlzIG1ldGhvZC5cbiAgICBcbiAgICBAbWV0aG9kT2YgUGFyYW1IYXNoI1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NQcm9wRGVsaW09XCImXCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlciB1c2VkIHRvIHNlcGVyYXRlIHByb3BlcnRpZXMuIERlZmF1bHQgaXMgXCImXCIuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzVmFsdWVEZWxpbT1cIj1cIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVkIHVzZWQgdG8gc2VwZXJhdGUgdmFsdWVzLiAgRGVmYXVsdCBpcyBcIj1cIi5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtlc2NhcGVQcm9wPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBhc2NpaSBlc2NhcGUgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2RvbnRFc2NhcGVWYWx1ZT1mYWxzZV0gRG8gbm90IGVzY2FwZSB2YWx1ZXMgb3IgcHJvcGVydGllcyBhdXRvbWF0aWNhbGx5XG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA9IGZ1bmN0aW9uKHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBlc2NhcGVQcm9wLCBkb250RXNjYXBlVmFsdWUpIHtcbiAgICAgIHZhciBidWZmZXIsIGl0ZW0sIGl0ZW1UeXBlLCBtZSwgcHJvcDtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICBidWZmZXIgPSBbXTtcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIGl0ZW1UeXBlID0gdm9pZCAwO1xuICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgIHNQcm9wRGVsaW0gPSBzUHJvcERlbGltIHx8IFwiJlwiO1xuICAgICAgc1ZhbHVlRGVsaW0gPSBzVmFsdWVEZWxpbSB8fCBcIj1cIjtcbiAgICAgIGZvciAocHJvcCBpbiBtZSkge1xuICAgICAgICBpdGVtID0gbWVbcHJvcF07XG4gICAgICAgIGl0ZW1UeXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW1UeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGl0ZW0gPSB0b1N0cmluZy5hcHBseShpdGVtLCBbc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGVzY2FwZVByb3AsIGRvbnRFc2NhcGVWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlc2NhcGVQcm9wKSB7XG4gICAgICAgICAgcHJvcCA9IF9lcyhwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRFc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGl0ZW0gPSBfZXMoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2gocHJvcCwgc1ZhbHVlRGVsaW0sIGl0ZW0sIHNQcm9wRGVsaW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzdHIoYnVmZmVyKTtcbiAgICB9O1xuICAgIHByb3RvID0gUGFyYW1IYXNoLnByb3RvdHlwZTtcbiAgICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gdHJpbTtcbiAgICB9XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBwcm90by50b1N0cmluZyA9IHByb3RvLnZhbHVlT2YgPSB0b1N0cmluZztcbiAgICBsYW5nID0ge1xuICAgICAgUGFyYW1IYXNoOiBQYXJhbUhhc2gsXG4gICAgICBjc3RyOiBjc3RyLFxuICAgICAgY251bTogY251bSxcbiAgICAgIGNib29sOiBjYm9vbCxcbiAgICAgIG5vb3A6IG5vb3AsXG4gICAgICB0cmltOiB0cmltLFxuICAgICAgY2FsbGFibGU6IGNhbGxhYmxlLFxuICAgICAgZ3VpZDogZ3VpZCxcbiAgICAgIG1peDogbWl4LFxuICAgICAgdGltZTogdGltZSxcbiAgICAgIHJhbmQ6IHJhbmQsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIG5zOiBucyxcbiAgICAgIGpzc2FmZV9odG1sOiBqc3NhZmVfaHRtbCxcbiAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICB3cmFwOiB3cmFwXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgZXhwb3J0cyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMubGFuZyA9IGxhbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGxvZ0Vycm9yLCBsb2dJbmZvLCB3aW47XG4gICAgd2luID0gd2luZG93O1xuXG4gICAgLypcbiAgICBXcml0ZSBhbiBlbnRyeSB0byB0aGUgY29uc29sZSBsb2cgYW5kIGZpcmUgYW55IGxvZyBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbWVzc2FnZSAgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nSW5mbyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh3aW4uY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBXcml0ZSBhbiBlbnRyeSB0byB0aGUgY29uc29sZSBlcnJvciBsb2cgYW5kIGZpcmUgYW55IGxvZyBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbWVzc2FnZSAgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBpZiAod2luLmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdpbi5jb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBpbmZvOiBsb2dJbmZvLFxuICAgICAgZXJyb3I6IGxvZ0Vycm9yXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihhKSAmJiBCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQpID8gc2VsZi5sZW5ndGggOiBOdW1iZXIoZW5kKVxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaGFzaDogaGFzaCB9O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBzaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgcm5nID0gcmVxdWlyZSgnLi9ybmcnKVxudmFyIG1kNSA9IHJlcXVpcmUoJy4vbWQ1JylcblxudmFyIGFsZ29yaXRobXMgPSB7XG4gIHNoYTE6IHNoYSxcbiAgc2hhMjU2OiBzaGEyNTYsXG4gIG1kNTogbWQ1XG59XG5cbnZhciBibG9ja3NpemUgPSA2NFxudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKVxuZnVuY3Rpb24gaG1hYyhmbiwga2V5LCBkYXRhKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG5cbiAgaWYoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGZuKGtleSlcbiAgfSBlbHNlIGlmKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIHplcm9CdWZmZXJdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKSwgb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB2YXIgaGFzaCA9IGZuKEJ1ZmZlci5jb25jYXQoW2lwYWQsIGRhdGFdKSlcbiAgcmV0dXJuIGZuKEJ1ZmZlci5jb25jYXQoW29wYWQsIGhhc2hdKSlcbn1cblxuZnVuY3Rpb24gaGFzaChhbGcsIGtleSkge1xuICBhbGcgPSBhbGcgfHwgJ3NoYTEnXG4gIHZhciBmbiA9IGFsZ29yaXRobXNbYWxnXVxuICB2YXIgYnVmcyA9IFtdXG4gIHZhciBsZW5ndGggPSAwXG4gIGlmKCFmbikgZXJyb3IoJ2FsZ29yaXRobTonLCBhbGcsICdpcyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgICAgICAgXG4gICAgICBidWZzLnB1c2goZGF0YSlcbiAgICAgIGxlbmd0aCArPSBkYXRhLmxlbmd0aFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmcylcbiAgICAgIHZhciByID0ga2V5ID8gaG1hYyhmbiwga2V5LCBidWYpIDogZm4oYnVmKVxuICAgICAgYnVmcyA9IG51bGxcbiAgICAgIHJldHVybiBlbmMgPyByLnRvU3RyaW5nKGVuYykgOiByXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7IHJldHVybiBoYXNoKGFsZykgfVxuZXhwb3J0cy5jcmVhdGVIbWFjID0gZnVuY3Rpb24gKGFsZywga2V5KSB7IHJldHVybiBoYXNoKGFsZywga2V5KSB9XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIG5ldyBCdWZmZXIocm5nKHNpemUpKSlcbiAgICB9IGNhdGNoIChlcnIpIHsgY2FsbGJhY2soZXJyKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIocm5nKHNpemUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYSwgZikge1xuICBmb3IodmFyIGkgaW4gYSlcbiAgICBmKGFbaV0sIGkpXG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlQ2lwaGVyJ1xuLCAnY3JlYXRlQ2lwaGVyaXYnXG4sICdjcmVhdGVEZWNpcGhlcidcbiwgJ2NyZWF0ZURlY2lwaGVyaXYnXG4sICdjcmVhdGVTaWduJ1xuLCAnY3JlYXRlVmVyaWZ5J1xuLCAnY3JlYXRlRGlmZmllSGVsbG1hbidcbiwgJ3Bia2RmMiddLCBmdW5jdGlvbiAobmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdzb3JyeSwnLCBuYW1lLCAnaXMgbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cbn0pXG4iLCIvKlxyXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXHJcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXHJcbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cclxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxyXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcclxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cclxuICovXHJcblxyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5cclxuLypcclxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBtZDVfdm1fdGVzdCgpXHJcbntcclxuICByZXR1cm4gaGV4X21kNShcImFiY1wiKSA9PSBcIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCI7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcclxuICovXHJcbmZ1bmN0aW9uIGNvcmVfbWQ1KHgsIGxlbilcclxue1xyXG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXHJcbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XHJcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xyXG5cclxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xyXG4gIHZhciBiID0gLTI3MTczMzg3OTtcclxuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xyXG4gIHZhciBkID0gIDI3MTczMzg3ODtcclxuXHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxyXG4gIHtcclxuICAgIHZhciBvbGRhID0gYTtcclxuICAgIHZhciBvbGRiID0gYjtcclxuICAgIHZhciBvbGRjID0gYztcclxuICAgIHZhciBvbGRkID0gZDtcclxuXHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcclxuXHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcclxuXHJcbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XHJcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XHJcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XHJcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcclxuXHJcbn1cclxuXHJcbi8qXHJcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcclxufVxyXG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcclxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cclxuICovXHJcbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXHJcbntcclxuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xyXG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcclxuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcclxufVxyXG5cclxuLypcclxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxyXG4gKi9cclxuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcclxue1xyXG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZDUoYnVmKSB7XHJcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XHJcbn07XHJcbiIsIi8vIE9yaWdpbmFsIGNvZGUgYWRhcHRlZCBmcm9tIFJvYmVydCBLaWVmZmVyLlxuLy8gZGV0YWlscyBhdCBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgdmFyIG1hdGhSTkcsIHdoYXR3Z1JORztcblxuICAvLyBOT1RFOiBNYXRoLnJhbmRvbSgpIGRvZXMgbm90IGd1YXJhbnRlZSBcImNyeXB0b2dyYXBoaWMgcXVhbGl0eVwiXG4gIG1hdGhSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciByO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBieXRlc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICBpZiAoX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHdoYXR3Z1JORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aGF0d2dSTkcgfHwgbWF0aFJORztcblxufSgpKVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX3NoYTEoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuXG4gIHZhciB3ID0gQXJyYXkoODApO1xuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcbiAgdmFyIGUgPSAtMTAwOTU4OTc3NjtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgdmFyIG9sZGUgPSBlO1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspXG4gICAge1xuICAgICAgaWYoaiA8IDE2KSB3W2pdID0geFtpICsgal07XG4gICAgICBlbHNlIHdbal0gPSByb2wod1tqLTNdIF4gd1tqLThdIF4gd1tqLTE0XSBeIHdbai0xNl0sIDEpO1xuICAgICAgdmFyIHQgPSBzYWZlX2FkZChzYWZlX2FkZChyb2woYSwgNSksIHNoYTFfZnQoaiwgYiwgYywgZCkpLFxuICAgICAgICAgICAgICAgICAgICAgICBzYWZlX2FkZChzYWZlX2FkZChlLCB3W2pdKSwgc2hhMV9rdChqKSkpO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSByb2woYiwgMzApO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgZSA9IHNhZmVfYWRkKGUsIG9sZGUpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcblxufVxuXG4vKlxuICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAqIGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpXG57XG4gIGlmKHQgPCAyMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpO1xuICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgcmV0dXJuIGIgXiBjIF4gZDtcbn1cblxuLypcbiAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgYWRkaXRpdmUgY29uc3RhbnQgZm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2t0KHQpXG57XG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTEoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX3NoYTEsIDIwLCB0cnVlKTtcbn07XG4iLCJcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgc2FmZV9hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59O1xuXG52YXIgUyA9IGZ1bmN0aW9uKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKSB8IChYIDw8ICgzMiAtIG4pKTtcbn07XG5cbnZhciBSID0gZnVuY3Rpb24oWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pO1xufTtcblxudmFyIENoID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKTtcbn07XG5cbnZhciBNYWogPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopKTtcbn07XG5cbnZhciBTaWdtYTAyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCAyKSBeIFMoeCwgMTMpIF4gUyh4LCAyMikpO1xufTtcblxudmFyIFNpZ21hMTI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSk7XG59O1xuXG52YXIgR2FtbWEwMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgNykgXiBTKHgsIDE4KSBeIFIoeCwgMykpO1xufTtcblxudmFyIEdhbW1hMTI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDE3KSBeIFMoeCwgMTkpIF4gUih4LCAxMCkpO1xufTtcblxudmFyIGNvcmVfc2hhMjU2ID0gZnVuY3Rpb24obSwgbCkge1xuICB2YXIgSyA9IG5ldyBBcnJheSgweDQyOEEyRjk4LDB4NzEzNzQ0OTEsMHhCNUMwRkJDRiwweEU5QjVEQkE1LDB4Mzk1NkMyNUIsMHg1OUYxMTFGMSwweDkyM0Y4MkE0LDB4QUIxQzVFRDUsMHhEODA3QUE5OCwweDEyODM1QjAxLDB4MjQzMTg1QkUsMHg1NTBDN0RDMywweDcyQkU1RDc0LDB4ODBERUIxRkUsMHg5QkRDMDZBNywweEMxOUJGMTc0LDB4RTQ5QjY5QzEsMHhFRkJFNDc4NiwweEZDMTlEQzYsMHgyNDBDQTFDQywweDJERTkyQzZGLDB4NEE3NDg0QUEsMHg1Q0IwQTlEQywweDc2Rjk4OERBLDB4OTgzRTUxNTIsMHhBODMxQzY2RCwweEIwMDMyN0M4LDB4QkY1OTdGQzcsMHhDNkUwMEJGMywweEQ1QTc5MTQ3LDB4NkNBNjM1MSwweDE0MjkyOTY3LDB4MjdCNzBBODUsMHgyRTFCMjEzOCwweDREMkM2REZDLDB4NTMzODBEMTMsMHg2NTBBNzM1NCwweDc2NkEwQUJCLDB4ODFDMkM5MkUsMHg5MjcyMkM4NSwweEEyQkZFOEExLDB4QTgxQTY2NEIsMHhDMjRCOEI3MCwweEM3NkM1MUEzLDB4RDE5MkU4MTksMHhENjk5MDYyNCwweEY0MEUzNTg1LDB4MTA2QUEwNzAsMHgxOUE0QzExNiwweDFFMzc2QzA4LDB4Mjc0ODc3NEMsMHgzNEIwQkNCNSwweDM5MUMwQ0IzLDB4NEVEOEFBNEEsMHg1QjlDQ0E0RiwweDY4MkU2RkYzLDB4NzQ4RjgyRUUsMHg3OEE1NjM2RiwweDg0Qzg3ODE0LDB4OENDNzAyMDgsMHg5MEJFRkZGQSwweEE0NTA2Q0VCLDB4QkVGOUEzRjcsMHhDNjcxNzhGMik7XG4gIHZhciBIQVNIID0gbmV3IEFycmF5KDB4NkEwOUU2NjcsIDB4QkI2N0FFODUsIDB4M0M2RUYzNzIsIDB4QTU0RkY1M0EsIDB4NTEwRTUyN0YsIDB4OUIwNTY4OEMsIDB4MUY4M0Q5QUIsIDB4NUJFMENEMTkpO1xuICAgIHZhciBXID0gbmV3IEFycmF5KDY0KTtcbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgajtcbiAgICB2YXIgVDEsIFQyO1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICBtW2wgPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsICUgMzIpO1xuICBtWygobCArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIGEgPSBIQVNIWzBdOyBiID0gSEFTSFsxXTsgYyA9IEhBU0hbMl07IGQgPSBIQVNIWzNdOyBlID0gSEFTSFs0XTsgZiA9IEhBU0hbNV07IGcgPSBIQVNIWzZdOyBoID0gSEFTSFs3XTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgV1tqXSA9IG1baiArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgV1tqXSA9IHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKEdhbW1hMTI1NihXW2ogLSAyXSksIFdbaiAtIDddKSwgR2FtbWEwMjU2KFdbaiAtIDE1XSkpLCBXW2ogLSAxNl0pO1xuICAgICAgfVxuICAgICAgVDEgPSBzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChoLCBTaWdtYTEyNTYoZSkpLCBDaChlLCBmLCBnKSksIEtbal0pLCBXW2pdKTtcbiAgICAgIFQyID0gc2FmZV9hZGQoU2lnbWEwMjU2KGEpLCBNYWooYSwgYiwgYykpO1xuICAgICAgaCA9IGc7IGcgPSBmOyBmID0gZTsgZSA9IHNhZmVfYWRkKGQsIFQxKTsgZCA9IGM7IGMgPSBiOyBiID0gYTsgYSA9IHNhZmVfYWRkKFQxLCBUMik7XG4gICAgfVxuICAgIEhBU0hbMF0gPSBzYWZlX2FkZChhLCBIQVNIWzBdKTsgSEFTSFsxXSA9IHNhZmVfYWRkKGIsIEhBU0hbMV0pOyBIQVNIWzJdID0gc2FmZV9hZGQoYywgSEFTSFsyXSk7IEhBU0hbM10gPSBzYWZlX2FkZChkLCBIQVNIWzNdKTtcbiAgICBIQVNIWzRdID0gc2FmZV9hZGQoZSwgSEFTSFs0XSk7IEhBU0hbNV0gPSBzYWZlX2FkZChmLCBIQVNIWzVdKTsgSEFTSFs2XSA9IHNhZmVfYWRkKGcsIEhBU0hbNl0pOyBIQVNIWzddID0gc2FmZV9hZGQoaCwgSEFTSFs3XSk7XG4gIH1cbiAgcmV0dXJuIEhBU0g7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTI1NihidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfc2hhMjU2LCAzMiwgdHJ1ZSk7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iXX0=
