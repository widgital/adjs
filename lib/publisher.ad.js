(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var AdJS, AdRequest, Page, config, engagement, sf, utils;

  if (!window["$sf"]) {
    sf = require('safeframe');
  }

  engagement = require('./shared/engagement');

  Page = require('./shared/page');

  AdJS = require('./publisher/slot');

  config = require('./shared/config');

  utils = require('./shared/utils');

  AdRequest = require('./shared/ad_request');

  (function(window) {
    var controllerUrl, doRender, initSafeFrame, pageDuration, pageLoadMs, renderController, safeframeUrl, sessionObj, sfDom, startTicks;
    sessionObj = new Page();
    startTicks = utils.now();
    pageLoadMs = 0;
    pageDuration = 0;
    safeframeUrl = config.cdn_url;
    controllerUrl = config.controller_url;
    sfDom = $sf.lib.dom;
    sfDom.attach("beforeunload", function() {
      pageDuration = utils.now() - startTicks;
      return true;
    });
    doRender = function(cb) {
      var d, div, divs, sfPositions, _i, _len;
      sfPositions = {};
      if (!sfDom.ready()) {
        sfDom.wait(function() {
          var args;
          pageLoadMs = utils.now() - startTicks;
          doRender.apply(null, args);
          return args = null;
        });
      } else {
        renderController();
        divs = (function() {
          var _i, _len, _ref, _results;
          _ref = document.getElementsByTagName("div");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            div = _ref[_i];
            _results.push(div);
          }
          return _results;
        })();
        for (_i = 0, _len = divs.length; _i < _len; _i++) {
          d = divs[_i];
          if (sfDom.attr(d, "data-adjs")) {
            (function(d) {
              return AdJS.create(d, sessionObj);
            })(d);
          }
        }
        return typeof cb === "function" ? cb() : void 0;
      }
    };
    initSafeFrame = function() {
      return $sf.host.Config({
        renderFile: window === window.top ? safeframeUrl : adframeUrl,
        positions: {},
        onStartPosRender: function() {},
        onFailure: function() {},
        onAdLoad: function(id) {
          return AdJS(id).load();
        },
        onBeforePosMsg: function() {},
        onPosMsg: function(id, msg, content) {
          return AdJS(id).handleMessage(msg, content);
        }
      });
    };
    renderController = function() {
      var div, parent;
      div = document.createElement("div");
      parent = document.createElement("div");
      parent.appendChild(div);
      parent.style.display = "none";
      div.id = sf.lib.lang.guid("controller");
      document.body.appendChild(parent);
      return AdJS("controller").create(div, '', {
        width: 10,
        height: 10,
        supports: ["write-cookie", "read-cookie"],
        renderFile: controllerUrl,
        page: sessionObj.serializedAttributes(),
        pageReferrer: document.referrer,
        ignoreEvents: true
      });
    };
    AdJS.render = function(cb) {
      var adJsScript, clientId, s;
      adJsScript = ((function() {
        var _i, _len, _ref, _results;
        _ref = document.getElementsByTagName("script");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (sfDom.attr(s, "data-adjs")) {
            _results.push(s);
          }
        }
        return _results;
      })())[0];
      clientId = sfDom.attr(adJsScript, "data-client-id");
      sessionObj.set({
        client_id: clientId
      });
      initSafeFrame();
      return doRender(cb);
    };
    engagement.onEngagement(function() {
      var ad, _, _ref, _results;
      _ref = AdJS.slots;
      _results = [];
      for (_ in _ref) {
        ad = _ref[_];
        if (ad.currentlyInview() && !ad.engaged) {
          _results.push(ad.engage());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    (function() {
      return AdJS.render();
    })();
    window.$ad = AdJS;
    return AdJS;
  })(window);

}).call(this);

},{"./publisher/slot":2,"./shared/ad_request":3,"./shared/config":5,"./shared/engagement":6,"./shared/page":8,"./shared/utils":10,"safeframe":16}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var events, sizes, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sizes = require('../shared/sizes');

  utils = require('../shared/utils');

  events = require('../shared/event')(["request", "click", "load", "view", "unload", "focus", "engage", "unfocus", "expand", "collapse", "refreshed", "cookie", "receive", "unview", "timeout"]);

  module.exports = (function($sf) {
    var SCRIPT_REGEX, Slot, oldTrigger, sfDom, slots;
    sfDom = $sf.lib.dom;
    slots = {};
    SCRIPT_REGEX = /<!--([\s\S]*)-->/;
    Slot = (function() {
      function Slot(adId) {
        this.trigger = __bind(this.trigger, this);
        if (this instanceof Slot) {
          return this.init(adId);
        } else {
          return new Slot(adId);
        }
      }

      Slot.prototype.init = function(adId) {
        if (slots[adId]) {
          return slots[adId];
        }
        this.id = adId;
        this.count = 1;
        slots[adId] = this;
        return this.initEvents();
      };

      Slot.prototype.startAutoRefresh = function(delay, cb) {
        if (delay == null) {
          delay = 60;
        }
        if (!this._isAutoRefreshing) {
          this._isAutoRefreshing = true;
          this._refreshInterval = setTimeout((function(_this) {
            return function() {
              _this._isAutoRefreshing = false;
              if (_this.loadTime) {
                return _this.refresh(cb);
              }
            };
          })(this), delay * 1000);
        }
        return this;
      };

      Slot.prototype.stopAutoRefresh = function() {
        clearTimeout(this._refreshInterval);
        this._isAutoRefreshing = false;
        this._refreshInterval = null;
        return this;
      };

      Slot.prototype.refresh = function(cb) {
        this.remove();
        this.count++;
        this.posMeta.setValue("load_n", "extended", this.count);
        $sf.host.render(this.pos);
        this.frame = document.getElementById(this.posConfig.dest);
        if (typeof cb === "function") {
          cb(this);
        }
        this.refreshed();
        return this;
      };

      Slot.prototype.trigger = function(event) {
        var _ref;
        if (!((_ref = this.options) != null ? _ref.ignoreEvents : void 0)) {
          events.trigger.apply(this, arguments);
          Slot.trigger(event, this, arguments[1]);
        }
        return this;
      };

      Slot.prototype.handleMessage = function(msg, content) {
        switch (msg) {
          case "focus-change":
            if (content) {
              return this.focus();
            } else {
              return this.unfocus();
            }
            break;
          case "geom-update":
            return function() {};
          case "expand":
            return this.expand(content);
          case "collapse":
            return this.collapse(content);
          case "viewed":
            if (!this.viewed) {
              return this.view();
            }
            break;
          case "unviewed":
            if (!(this.unviewed && this.viewed)) {
              return this.unview();
            }
            break;
          case "clicked":
            if (!this.clicked) {
              return this.click();
            }
            break;
          case "requested":
            return this.request();
          case "cookie-write":
            return this.cookie({
              cookie: "write",
              content: content
            });
          case "cookie-read":
            return this.cookie({
              cookie: "read",
              content: content
            });
          case "reload":
            return this.reload();
          case "msg":
            return this.receive(decodeURIComponent(content));
          default:
            return null;
        }
      };

      Slot.prototype.initEvents = function() {
        this.request(function() {
          return this.requestTime = utils.now();
        });
        this.load(function() {
          this.loadChain = utils.countFrames(this.frame.contentWindow);
          return this.loadTime = utils.now();
        });
        this.view(function() {
          this.viewed = true;
          return this.viewTime = utils.now();
        });
        this.engage(function() {
          if (!this.engaged) {
            this.engaged = true;
            this.engageTime = utils.now();
            return this.notifyFrame("engaged");
          }
        });
        this.unview(function() {
          this.unviewed = true;
          return this.unviewTime = utils.now();
        });
        this.unload(function() {
          return this.unloadTime = utils.now();
        });
        return this.click(function() {
          return this.clicked = true;
        });
      };

      Slot.prototype.loadChain = 0;

      Slot.prototype.notifyFrame = function(cmd, data) {
        var msgObj;
        msgObj = $sf.lib.lang.ParamHash();
        if (this.posConfig) {
          msgObj.pos = this.posConfig.id;
          msgObj.cmd = cmd;
          msgObj.value = escape(data);
          return sfDom.msghost.send(this.posConfig.dest, msgObj.toString());
        }
      };

      Slot.prototype.create = function(elem, html, options) {
        var height, s, supports, width, _i, _j, _len, _len1, _ref, _ref1;
        this.options = options != null ? options : {};
        width = this.options.width || elem.offsetWidth;
        height = this.options.height || elem.offsetHeight;
        supports = {};
        _ref = this.options.supports || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          supports[s] = true;
        }
        _ref1 = this.options.disables || [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          s = _ref1[_j];
          supports[s] = false;
        }
        if (this.elem) {
          return;
        }
        this.elem = elem;
        elem.id || (elem.id = $sf.lib.lang.guid("pos"));
        this.posMeta = new $sf.host.PosMeta(null, "extended", {
          inview: this.options.inview,
          page: this.options.page,
          host: document.location.hostname,
          referrer: this.options.referrer,
          location: document.location.href,
          slot_id: this.id,
          load_n: this.count
        });
        this.posConfig = new $sf.host.PosConfig({
          id: this.id,
          dest: elem.id,
          w: width,
          h: height,
          supports: supports,
          renderFile: this.options.renderFile
        });
        this.pos = new $sf.host.Position(this.posConfig.id, html, this.posMeta);
        if (this.options.refresh_oov) {
          this.unview(function() {
            return setTimeout((function(_this) {
              return function() {
                return _this.refresh();
              };
            })(this), 1);
          });
        }
        if (this.options.refresh_time != null) {
          this.refreshTime = $sf.lib.lang.cnum(this.options.refresh_time, 0);
          if (this.refreshTime > 0) {
            this.load(function() {
              return this.startAutoRefresh(this.refreshTime);
            });
            this.timeout(function() {
              this.stopAutoRefresh();
              return this.refresh();
            });
          }
        }
        $sf.host.render(this.pos);
        this.frame = document.getElementById(elem.id);
        return this;
      };

      Slot.prototype.remove = function(dontFire) {
        if (!dontFire) {
          this.unload();
        }
        clearTimeout(this._refreshInterval);
        this.viewed = false;
        this.engaged = false;
        this.unviewed = false;
        this.frame = null;
        this.frameCount = 0;
        this.requestTime = null;
        this.loadTime = null;
        this.viewTime = null;
        this.engageTime = null;
        this.unviewTime = null;
        this.unloadTime = null;
        $sf.host.nuke(this.id);
        return this;
      };

      Slot.prototype.destroy = function() {
        this.stopAutoRefresh();
        this.remove();
        delete this.events;
        return delete slots[this.id];
      };

      Slot.prototype.reload = function() {
        if (this.options.inview) {
          this.remove(true);
          $sf.host.render(this.pos);
          return this.frame = document.getElementById(this.posConfig.dest);
        }
      };

      Slot.prototype.currentlyInview = function() {
        return $sf.host.inViewPercentage(this.id) > 50 && this.viewed;
      };

      Slot.prototype.inviewPercentage = function() {
        return $sf.host.inViewPercentage(this.id);
      };

      return Slot;

    })();
    Slot.destroy = function() {
      var ad, _, _results;
      _results = [];
      for (_ in slots) {
        ad = slots[_];
        _results.push(ad.destroy());
      }
      return _results;
    };
    Slot.events = {};
    oldTrigger = Slot.prototype.trigger;
    $sf.lib.lang.mix(Slot.prototype, events);
    Slot.prototype.trigger = oldTrigger;
    $sf.lib.lang.mix(Slot, events);
    Slot.create = function(d, page) {
      var adId, disables, div, height, isEscaped, posId, size, supports, template, width, _base, _base1, _ref;
      template = ((_ref = d.innerHTML.match(SCRIPT_REGEX)) != null ? _ref[1] : void 0) || d.innerHTML;
      isEscaped = $sf.lib.lang.cbool(sfDom.attr(d, "data-escaped"));
      if (isEscaped) {
        template = $sf.lib.lang.jsunsafe_html(template);
      }
      posId = $sf.lib.lang.guid("pos");
      adId = d.id || posId;
      div = document.createElement("div");
      div.id = posId;
      d.appendChild(div);
      supports = [];
      disables = [];
      if (size = sizes[sfDom.attr(d, "data-ad-type")]) {
        width = size[0], height = size[1];
      }
      Slot(adId).create(div, template, {
        width: width || sfDom.attr(d, "data-width"),
        height: height || sfDom.attr(d, "data-height"),
        supports: typeof (_base = sfDom.attr(d, "data-supports")).split === "function" ? _base.split(",") : void 0,
        disables: typeof (_base1 = sfDom.attr(d, "data-disables")).split === "function" ? _base1.split(",") : void 0,
        inview: $sf.lib.lang.cbool(sfDom.attr(d, "data-inview")),
        refresh_time: sfDom.attr(d, "data-refresh-time"),
        refresh_oov: $sf.lib.lang.cbool(sfDom.attr(d, "data-refresh-oov")),
        page: page != null ? page.serialize() : void 0,
        referrer: sfDom.attr(d, "data-referrer"),
        ignoreEvents: $sf.lib.lang.cbool(sfDom.attr(d, "data-ignore-events"))
      });
      return Slot(adId);
    };
    Slot.slots = slots;
    Slot.sizes = sizes;
    return Slot;
  })($sf);

}).call(this);

},{"../shared/event":7,"../shared/sizes":9,"../shared/utils":10}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, config,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require('./base');

  config = require('./config');

  module.exports = (function(window) {
    var AdRequest;
    AdRequest = (function(_super) {
      __extends(AdRequest, _super);

      function AdRequest(serializedParams) {
        AdRequest.__super__.constructor.apply(this, arguments);
        if (serializedParams) {
          this.deserialize(serializedParams);
        } else {
          this.set({
            url: window.document.location.href,
            ref: window.document.referrer,
            v_js: config.version
          }, {
            silent: true
          });
        }
      }

      AdRequest.prototype.serializedAttributes = function() {
        var k, outAttrs, v, _ref;
        outAttrs = {};
        _ref = this.attributes;
        for (k in _ref) {
          v = _ref[k];
          outAttrs[k] = v;
        }
        outAttrs.url = encodeURIComponent(outAttrs.url);
        outAttrs.ref = encodeURIComponent(outAttrs.ref);
        return outAttrs;
      };

      AdRequest.prototype.deserialize = function(params) {
        AdRequest.__super__.deserialize.call(this, params);
        return this.set({
          url: decodeURIComponent(this.attributes.url),
          ref: decodeURIComponent(this.attributes.ref)
        }, {
          silent: true
        });
      };

      AdRequest.prototype.path = "/ad";

      AdRequest.prototype.constantFields = ["site_user_id", "page_id", "visit_id", "ad_id"];

      return AdRequest;

    })(Base);
    return AdRequest;
  })(window);

}).call(this);

},{"./base":4,"./config":5}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils, uuid;

  uuid = require('node-uuid');

  utils = require('./utils');

  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.id = uuid.v4();
        this.attributes || (this.attributes = {});
        this._events = [];
        this._dirty = {};
      }

      Base.prototype.set = function(attrs, options) {
        var changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        if (typeof attrs !== "object") {
          throw "attrs must be an object";
        }
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
            this._dirty[k] = v;
            this.attributes[k] = v;
          }
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      Base.prototype._cleanDirty = function() {
        return this._dirty = {};
      };

      Base.prototype.changedFields = function() {
        var field, k, params, v, _i, _len, _ref, _ref1;
        params = {};
        _ref = this._dirty;
        for (k in _ref) {
          v = _ref[k];
          params[k] = v;
        }
        if (this.constantFields) {
          _ref1 = this.constantFields;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            field = _ref1[_i];
            if (this.attributes[field]) {
              params[field] = this.attributes[field];
            }
          }
        }
        this._cleanDirty();
        return params;
      };

      Base.prototype.serialize = function() {
        return utils.toQuery(this.attributes);
      };

      Base.prototype.deserialize = function(str) {
        return this.set(utils.fromQuery(str), {
          silent: true
        });
      };

      return Base;

    })();
  })();

}).call(this);

},{"./utils":10,"node-uuid":14}],5:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html',
        controller_url: "base/lib/html/controllerframe.html",
        ad_url: "base/lib/html/adframe.html",
        visit_expiry: 0.03,
        version: "0.0.1",
        domain: "localhost"
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//api.adjs.net/1",
        cdn_url: "//cdn.adjs.net/html/adjsframe.html",
        visit_expiry: 30,
        version: "0.0.1",
        domain: "adjs.net",
        controller_url: "//cdn.adjs.net/html/controllerframe.html",
        ad_url: "//cdn.adjs.net/html/adframe.html"
      };
    } else if (process.env.ENV === "staging") {
      return {
        api: "//api.adjs.net/1",
        cdn_url: "//s3.amazonaws.com/js.adjsdemo.com/html/adjsframe.html",
        visit_expiry: 30,
        version: "0.0.1",
        domain: "s3.amazonaws.com",
        controller_url: "//s3.amazonaws.com/js.adjsdemo.com/html/controllerframe.html",
        ad_url: "//s3.amazonaws.com/js.adjsdemo.com/html/adframe.html"
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html',
        visit_expiry: 3,
        version: "0.0.1",
        domain: "localhost",
        controller_url: "../lib/html/controllerframe.html",
        ad_url: "../lib/html/adframe.html"
      };
    }
  })();

}).call(this);

}).call(this,require("8DwohR"))
},{"8DwohR":33}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils;

  utils = require('./utils');

  module.exports = (function(window, $sf) {
    var ENGAGEMENT_RESET, activityHandler, attach, disengageEvents, doc, engageEvents, engagement, engagementTimeout, lastEngaged, resetEngagement;
    attach = $sf.lib.dom.attach;
    engagement = {
      isEngaged: false
    };
    doc = window.document;
    engageEvents = [];
    disengageEvents = [];
    ENGAGEMENT_RESET = 3000;
    lastEngaged = void 0;
    engagement.onEngagement = function(f) {
      return engageEvents.push(f);
    };
    engagement.onDisengagement = function(f) {
      return disengageEvents.push(f);
    };
    activityHandler = function() {
      var f, _i, _len;
      engagement.isEngaged = true;
      engagement.lastEngaged = utils.now();
      for (_i = 0, _len = engageEvents.length; _i < _len; _i++) {
        f = engageEvents[_i];
        f();
      }
      resetEngagement();
      return true;
    };
    engagementTimeout = null;
    resetEngagement = function() {
      clearTimeout(engagementTimeout);
      return engagementTimeout = setTimeout(function() {
        var f, _i, _len;
        engagement.isEngaged = false;
        for (_i = 0, _len = disengageEvents.length; _i < _len; _i++) {
          f = disengageEvents[_i];
          f();
        }
        return disengageEvents = [];
      }, ENGAGEMENT_RESET);
    };
    attach(doc, 'click', activityHandler);
    attach(doc, 'mouseup', activityHandler);
    attach(doc, 'mousedown', activityHandler);
    attach(doc, 'mousemove', activityHandler);
    attach(doc, 'mousewheel', activityHandler);
    attach(doc, 'keypress', activityHandler);
    attach(doc, 'keydown', activityHandler);
    attach(doc, 'keyup', activityHandler);
    attach(window, 'DOMMouseScroll', activityHandler);
    attach(window, 'scroll', activityHandler);
    attach(window, 'resize', activityHandler);
    attach(window, 'focus', activityHandler);
    attach(window, 'blur', activityHandler);
    return engagement;
  })(window, $sf);

}).call(this);

},{"./utils":10}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(eventNames) {
    return (function() {
      var event, events, _i, _len;
      events = {
        on: function(event, cb) {
          var eventList;
          this.events || (this.events = {});
          eventList = this.events[event] || [];
          eventList.push(cb);
          this.events[event] = eventList;
          return this;
        },
        trigger: function(event, data, optionalData) {
          var e, ex, _i, _len, _ref;
          this.events || (this.events = {});
          _ref = this.events[event] || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            try {
              e.call(this, data, optionalData);
            } catch (_error) {
              ex = _error;
            }
          }
          return this;
        }
      };
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        event = eventNames[_i];
        events[event] = (function(event) {
          var f;
          return f = function(data) {
            if (typeof data === "function") {
              return this.on(event, data);
            } else {
              return this.trigger(event, data);
            }
          };
        })(event);
      }
      return events;
    })();
  };

}).call(this);

},{}],8:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, config, cookies, moment, utils, uuid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  cookies = require('cookies-js');

  uuid = require('node-uuid');

  Base = require('./base');

  utils = require('./utils');

  config = require('./config');

  moment = require('moment');

  module.exports = (function($sf, window) {
    var COOKIE_KEY, Page;
    COOKIE_KEY = "_ajsk";
    Page = (function(_super) {
      __extends(Page, _super);

      function Page(serializedParams) {
        Page.__super__.constructor.call(this);
        if (serializedParams) {
          this.deserialize(serializedParams);
        } else {
          this.loadCookieData();
          this.initDefaultAttributes();
        }
      }

      Page.prototype.storeCookie = function() {
        var _ref;
        if (($sf != null ? (_ref = $sf.ext) != null ? _ref.cookie : void 0 : void 0) != null) {
          if (this.attributes.site_user_id) {
            $sf.ext.cookie("" + COOKIE_KEY + "_suid", {
              value: this.attributes.site_user_id,
              expires: moment().add("years", 1).toDate()
            });
          }
          if (this.attributes.visit_id) {
            return $sf.ext.cookie("" + COOKIE_KEY + "_vid", {
              value: this.attributes.visit_id,
              expires: moment().add("seconds", config.visit_expiry * 60).toDate()
            });
          }
        } else {
          if (this.attributes.site_user_id) {
            cookies.set("" + COOKIE_KEY + "_suid", this.attributes.site_user_id, {
              expires: moment().add("years", 1).toDate()
            });
          }
          if (this.attributes.visit_id) {
            return cookies.set("" + COOKIE_KEY + "_vid", this.attributes.visit_id, {
              expires: moment().add("seconds", config.visit_expiry * 60).toDate()
            });
          }
        }
      };

      Page.prototype.loadCookieData = function() {
        var _ref;
        if (($sf != null ? (_ref = $sf.ext) != null ? _ref.cookie : void 0 : void 0) != null) {
          return this.set({
            site_user_id: $sf.ext.cookie("" + COOKIE_KEY + "_suid"),
            visit_id: $sf.ext.cookie("" + COOKIE_KEY + "_vid")
          }, {
            silent: true
          });
        } else {
          return this.set({
            site_user_id: cookies.get("" + COOKIE_KEY + "_suid"),
            visit_id: cookies.get("" + COOKIE_KEY + "_vid")
          }, {
            silent: true
          });
        }
      };

      Page.prototype.set = function(attrs, options) {
        if (options == null) {
          options = {};
        }
        Page.__super__.set.call(this, attrs, options);
        return this.storeCookie();
      };

      Page.prototype.initDefaultAttributes = function() {
        if (window === window.top) {
          return this.set({
            url: window.document.location.href,
            ref: window.document.referrer,
            v_js: config.version
          }, {
            silent: true
          });
        } else if (window.parent === window.top) {
          return this.set({
            url: window.document.referrer,
            v_js: config.version
          });
        }
      };

      Page.prototype.verifyUrl = function() {
        if (window.parent === window.top && window.document.referrer) {
          return true;
        }
      };

      Page.prototype.serializedAttributes = function() {
        var k, outAttrs, v, _ref;
        outAttrs = {};
        _ref = this.attributes;
        for (k in _ref) {
          v = _ref[k];
          outAttrs[k] = v;
        }
        outAttrs.url = encodeURIComponent(outAttrs.url);
        outAttrs.ref = encodeURIComponent(outAttrs.ref);
        return outAttrs;
      };

      Page.prototype.deserialize = function(params) {
        Page.__super__.deserialize.call(this, params);
        return this.set({
          url: decodeURIComponent(this.attributes.url),
          ref: decodeURIComponent(this.attributes.ref)
        }, {
          silent: true
        });
      };

      Page.prototype.path = "/page";

      Page.prototype.constantFields = ["site_user_id", "page_id", "visit_id", "url"];

      return Page;

    })(Base);
    if (process.env.ENV === "test" || ((typeof _TEST !== "undefined" && _TEST !== null) && _TEST)) {
      Page._COOKIE_KEY = COOKIE_KEY;
      Page.clearCookie = function() {
        cookies.set(COOKIE_KEY + "_suid", void 0);
        return cookies.set(COOKIE_KEY + "_vid", void 0);
      };
    }
    return Page;
  })($sf, window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./base":4,"./config":5,"./utils":10,"8DwohR":33,"cookies-js":11,"moment":13,"node-uuid":14}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    return {
      leaderboard: [728, 90],
      "medium-rectangle": [300, 250]
    };
  })();

}).call(this);

},{}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var reqwest;

  window.JSON || (window.JSON = require('json'));

  reqwest = require('reqwest');

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf) {
    var capitalizeString, countFrames, defineProperty, findController, fromQuery, getFramePosition, keys, nativeReduce, now, reduce, reduceError, reqId, sendRequest, toNumber, toQuery;
    reqId = 0;
    sendRequest = function(options) {
      reqId++;
      if (options.type === "jsonp") {
        options.jsonpCallbackName = "adjs_" + (now()) + "_" + reqId;
      }
      return reqwest(options);
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        } else {
          if (descriptor.value) {
            return obj[prop] = descriptor.value;
          }
        }
      } catch (_error) {
        e = _error;
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    getFramePosition = function(win) {
      var count;
      count = 0;
      if (win.parent !== win.top) {
        count = 1 + getFramePosition(win.parent);
      }
      return count;
    };
    nativeReduce = Array.prototype.reduce;
    reduceError = 'Reduce of empty array with no initial value';
    reduce = function(obj, iterator, memo) {
      var index, initial, value, _fn, _i, _len;
      initial = arguments.length > 2;
      if (obj == null) {
        obj = [];
      }
      if (nativeReduce && obj.reduce === nativeReduce) {
        return (initial ? obj.reduce(iterator, memo) : obj.reduce(iterator));
      }
      _fn = function(value, index, obj) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(this, memo, value, index, obj);
        }
      };
      for (index = _i = 0, _len = obj.length; _i < _len; index = ++_i) {
        value = obj[index];
        _fn(value, index, obj);
      }
      if (!initial) {
        throw new TypeError(reduceError);
      }
      return memo;
    };
    keys = function(obj) {
      return $sf != null ? $sf.lib.lang.keys(obj) : void 0;
    };
    findController = function(cb, retry) {
      var controller, frame, _i, _len, _ref, _ref1;
      if (retry == null) {
        retry = 3;
      }
      controller = null;
      _ref = window.top.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        try {
          if ((_ref1 = frame.$ad) != null ? _ref1.isController : void 0) {
            controller = frame.$ad;
            break;
          }
        } catch (_error) {

        }
      }
      if (controller) {
        return cb(controller);
      } else {
        if (!(retry < 0)) {
          return setTimeout((function() {
            return findController(cb, retry - 1);
          }), 100);
        }
      }
    };
    capitalizeString = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return {
      sendRequest: sendRequest,
      toQuery: toQuery,
      fromQuery: fromQuery,
      toNumber: toNumber,
      now: now,
      defineProperty: defineProperty,
      countFrames: countFrames,
      capitalizeString: capitalizeString,
      keys: keys,
      getFramePosition: getFramePosition,
      reduce: reduce,
      findController: findController
    };
  })($sf);

}).call(this);

},{"json":12,"reqwest":15}],11:[function(require,module,exports){
/*!
 * Cookies.js - 0.3.1
 * Wednesday, April 24 2013 @ 2:28 AM EST
 *
 * Copyright (c) 2013, Scott Hamper
 * Licensed under the MIT license,
 * http://www.opensource.org/licenses/MIT
 */
(function (undefined) {
    'use strict';

    var Cookies = function (key, value, options) {
        return arguments.length === 1 ?
            Cookies.get(key) : Cookies.set(key, value, options);
    };

    // Allows for setter injection in unit tests
    Cookies._document = document;
    Cookies._navigator = navigator;

    Cookies.defaults = {
        path: '/'
    };

    Cookies.get = function (key) {
        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
            Cookies._renewCache();
        }

        return Cookies._cache[key];
    };

    Cookies.set = function (key, value, options) {
        options = Cookies._getExtendedOptions(options);
        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

        return Cookies;
    };

    Cookies.expire = function (key, options) {
        return Cookies.set(key, undefined, options);
    };

    Cookies._getExtendedOptions = function (options) {
        return {
            path: options && options.path || Cookies.defaults.path,
            domain: options && options.domain || Cookies.defaults.domain,
            expires: options && options.expires || Cookies.defaults.expires,
            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
        };
    };

    Cookies._isValidDate = function (date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    };

    Cookies._getExpiresDate = function (expires, now) {
        now = now || new Date();
        switch (typeof expires) {
            case 'number': expires = new Date(now.getTime() + expires * 1000); break;
            case 'string': expires = new Date(expires); break;
        }

        if (expires && !Cookies._isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    };

    Cookies._generateCookieString = function (key, value, options) {
        key = encodeURIComponent(key);
        value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toGMTString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    };

    Cookies._getCookieObjectFromString = function (documentCookie) {
        var cookieObject = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieObject[cookieKvp.key] === undefined) {
                cookieObject[cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieObject;
    };

    Cookies._getKeyValuePairFromCookieString = function (cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        return {
            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
        };
    };

    Cookies._renewCache = function () {
        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);
        Cookies._cachedDocumentCookie = Cookies._document.cookie;
    };

    Cookies._areEnabled = function () {
        return Cookies._navigator.cookieEnabled ||
            Cookies.set('cookies.js', 1).get('cookies.js') === '1';
    };

    Cookies.enabled = Cookies._areEnabled();

    // AMD support
    if (typeof define === 'function' && define.amd) {
        define(function () { return Cookies; });
    // CommonJS and Node.js module support.
    } else if (typeof exports !== 'undefined') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Cookies;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = Cookies;
    } else {
        window.Cookies = Cookies;
    }
})();
},{}],12:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],13:[function(require,module,exports){
(function (global){
//! moment.js
//! version : 2.7.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.7.0",
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _tzm : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
          s: 45,   //seconds to minutes
          m: 45,   //minutes to hours
          h: 22,   //hours to days
          dd: 25,  //days to month (month == 1)
          dm: 45,  //days to months (months > 1)
          dy: 345  //days to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error("Implement me");
        }
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = getLangDefinition(config._l).weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, lang;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            lang = getLangDefinition(config._l);
            dow = lang._week.dow;
            doy = lang._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < relativeTimeThresholds.s  && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= relativeTimeThresholds.dd && ['dd', days] ||
                days <= relativeTimeThresholds.dm && ['M'] ||
                days < relativeTimeThresholds.dy && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
        config._d = new Date(config._i);
    });

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function(threshold, limit) {
      if (relativeTimeThresholds[threshold] === undefined) {
        return false;
      }
      relativeTimeThresholds[threshold] = limit;
      return true;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string' && typeof val === 'string') {
                dur = moment.duration(isNaN(+val) ? +input : +val, isNaN(+val) ? val : input);
            } else if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string' && typeof val === 'string') {
                dur = moment.duration(isNaN(+val) ? +input : +val, isNaN(+val) ? val : input);
            } else if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: deprecate(
                 "moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                "moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    "Accessing Moment through the global scope is " +
                    "deprecated, and will be removed in an upcoming " +
                    "release.",
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
(function (Buffer){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

}).call(this,require("buffer").Buffer)
},{"buffer":24,"crypto":28}],15:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require("./host/host")(false);

  (function(window, sf) {
    return window["$sf"] = sf;
  })(window, sf);

  module.exports = sf;

}).call(this);

},{"./host/host":18}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require('../shared/base');

  module.exports = (function(window, sf) {
    var AUTO_BOOT_MAX_RETRIES, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, SF_TAG_TYPE, boot, boot_retries, d, doing_auto_boot, dom, has_booted, inline_tags_processed, lang, lib, win, _attr, _auto_boot, _clean_up_booted_tags, _create_pos_markup, _cstr, _elt, _guid, _log, _par, _purge, _ready, _tags;
    win = window != null ? window : this;
    _log = function(msg, is_err) {
      var err_tag, head_el, lib;
      try {
        lib = sf.lib;
        if (lib && lib.logger && win === top) {
          if (is_err) {
            lib.logger.error(msg);
          } else {
            lib.logger.log(msg);
          }
        } else {
          head_el = d.getElementsByTagName("head")[0];
          err_tag = d.createElement("script");
          err_tag.type = "text/plain";
          err_tag.text = "<!-- SafeFrame " + (is_err ? "error" : "log") + ": " + (msg || "unknown") + " -->";
          head_el.appendChild(head_el, err_tag);
        }
      } catch (_error) {}
    };

    /*
    Create the HTML markup for a position if a src property was used
    
    @name $sf.host-_create_pos_markup
    @function
    @private
    @static
    @return {String}
     */
    _create_pos_markup = function(src) {
      return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
    };
    _auto_boot = function() {
      var config, do_auto, doing_auto_boot, e, head, host_file, scr_tag, sf_host;
      do_auto = true;
      config = void 0;
      sf_host = void 0;
      host_file = void 0;
      head = void 0;
      scr_tag = void 0;
      if (has_booted) {
        return;
      }
      sf_host = sf && sf.host;
      if (win === top) {
        if (sf_host && !sf_host.boot) {
          sf_host.boot = boot;
        }
        try {
          config = sf_host && sf_host.Config();
        } catch (_error) {
          e = _error;
          config = null;
        }
        if (!config) {
          try {
            config = sf_host && sf_host.conf;
          } catch (_error) {
            e = _error;
            config = null;
          }
        }
        if (config) {
          if (("auto" in config) && config.auto === false) {
            do_auto = false;
          }
          if (!sf_host.render || !sf_host.Config) {
            host_file = config.hostFile;
            if (host_file) {
              head = _tags("head")[0];
              scr_tag = dom.make("script");
              scr_tag.id = "sf_host_lib";
              scr_tag.type = "text/javascript";
              scr_tag.className = "sf_lib";
              scr_tag.src = host_file;
              if (win.ActiveXObject) {
                scr_tag.onreadystatechange = function() {
                  var doing_auto_boot, rs;
                  rs = scr_tag.readyState;
                  if (rs === "loaded" || rs === "complete") {
                    doing_auto_boot = false;
                    if (do_auto) {
                      boot();
                    }
                    scr_tag.onreadystatechange = null;
                    scr_tag = head = sf_host = config = null;
                  }
                };
              } else {
                scr_tag.onload = function() {
                  var doing_auto_boot;
                  doing_auto_boot = false;
                  if (do_auto) {
                    boot();
                  }
                  scr_tag.onload = null;
                  scr_tag = head = sf_host = config = null;
                };
              }
              doing_auto_boot = true;
              head.appendChild(scr_tag);
              return;
            }
          }
        }
        if (do_auto) {
          if (config) {
            doing_auto_boot = true;
            boot();
            doing_auto_boot = false;
          } else {
            if (boot_retries++ <= AUTO_BOOT_MAX_RETRIES) {
              setTimeout(_auto_boot, 50);
            }
          }
        }
      } else {
        boot();
      }
    };

    /*
    Go through and remove any inline script tags that are our data-islands , which have already been boostrapped
    
    @name $sf.host-_clean_up_booted_tags
    @private
    @function
    @static
     */
    _clean_up_booted_tags = function() {
      var script_tag, script_tag_id;
      script_tag_id = void 0;
      script_tag = void 0;
      if (dom) {
        for (script_tag_id in inline_tags_processed) {
          script_tag = _elt(script_tag_id);
          if (script_tag) {
            _purge(script_tag);
            delete inline_tags_processed[script_tag_id];
          }
        }
      }
    };

    /*
    Search for SafeFrames tags and render them. This function is called
    automatically whenever the SafeFrames publisher library is loaded. However a configuration
    can be applied to not have SafeFrames tags automatically be rendered, requiring a controlled
    call to this function.
    
    @name $sf.host.boot
    @public
    @function
    @static
     */
    boot = function() {
      var boot_positions, data, e, err, errMsg, has_booted, html, idx, lib, meta_key, pos_conf, pos_dest_el, pos_meta, pos_meta_item, pos_obj, prv_meta, prv_meta_key, ret, script_tag, script_tag_id, script_tag_par, script_tags, sf_conf, sf_host, sf_inline_conf, sf_ocnf, shared_meta, typ;
      script_tags = (_tags && _tags("script")) || [];
      boot_positions = [];
      idx = 0;
      ret = false;
      errMsg = void 0;
      sf_host = sf && sf.host;
      sf_inline_conf = sf_host && sf_host.conf;
      script_tag = void 0;
      script_tag_par = void 0;
      script_tag_id = void 0;
      data = void 0;
      html = void 0;
      pos_obj = void 0;
      pos_conf = void 0;
      pos_dest_el = void 0;
      pos_meta = void 0;
      pos_meta_item = void 0;
      typ = void 0;
      shared_meta = void 0;
      prv_meta = void 0;
      prv_meta_key = void 0;
      meta_key = void 0;
      sf_ocnf = void 0;
      err = void 0;
      if (!sf || !lang || !dom) {
        _log("SafeFrame base library not found", true);
        return ret;
      }
      if (!lib) {
        lib = sf && sf.lib;
      }
      if (doing_auto_boot && has_booted) {
        _log("Automatic boot already invoked");
        return ret;
      }
      if (win === top) {
        try {
          sf_conf = sf_host.Config();
        } catch (_error) {
          err = _error;
          sf_conf = null;
        }
        if (sf_inline_conf && !sf_conf) {
          try {
            sf_conf = sf_host.Config(sf_inline_conf);
          } catch (_error) {
            e = _error;
            sf_conf = null;
          }
        }
        if (!sf_conf) {
          _log("No configuration found");
          return ret;
        }
      }
      while (script_tag = script_tags[idx++]) {
        if (script_tag.className === SF_DATATAG_CLASS || _attr(script_tag, "type") === SF_TAG_TYPE) {
          has_booted = true;
          script_tag_id = _attr(script_tag, "id");
          if (!script_tag_id) {
            script_tag_id = _guid("sf_data_element");
            _attr(script_tag, "id", script_tag_id);
          }
          if (inline_tags_processed[script_tag_id]) {
            continue;
          }
          data = script_tag.text || script_tag.innerHTML || script_tag.innerText;
          try {
            data = lang.trim(data);
            data = new Function("return " + data);
            data = data();
          } catch (_error) {
            err = _error;
            data = null;
            errMsg = "Error parsing tag configuration " + (err && err.message || "");
            _log(errMsg, true);
            continue;
          }
          if (data && data.id && (data.html || data.src)) {
            if (win !== top) {
              html = data.html || "";
              html = html || _create_pos_markup(data.src);
              if (!_ready()) {
                d.write(html);
              } else {
                _log("cannot write html content into already loaded document");
              }
            } else {
              script_tag_par = _par(script_tag);
              if (!script_tag_par) {
                _log("can't find parent element for script tag", true);
                continue;
              }
              pos_conf = sf_conf && sf_conf.positions[data.id];
              if (!pos_conf) {
                pos_conf = data.conf;
                pos_conf.id = data.id;
                if (pos_conf) {
                  pos_conf = new sf_host.PosConfig(pos_conf);
                }
              }
              if (!pos_conf) {
                _log("no position conf found pre-defined or inline for position " + data.id, true);
                continue;
              }
              if (!pos_conf.dest) {
                pos_conf = new sf_host.PosConfig(pos_conf, _guid(SF_POSELEM_WRAPPER_CLASS));
              }
              if (data.meta) {
                pos_meta = data.meta;
                meta_key = "";
                shared_meta = {};
                for (meta_key in pos_meta) {
                  pos_meta_item = pos_meta[meta_key];
                  typ = typeof pos_meta_item;
                  if (!prv_meta && typ === "object" && pos_meta_item) {
                    prv_meta = pos_meta_item;
                    prv_meta_key = meta_key;
                  }
                  if (typ !== "object" && typ !== "function") {
                    shared_meta[meta_key] = pos_meta_item;
                  }
                }
                pos_meta = new sf_host.PosMeta(shared_meta, prv_meta_key || "", (prv_meta_key && prv_meta ? prv_meta : null));
              }
              pos_obj = new sf_host.Position(data, null, pos_meta, pos_conf);
              inline_tags_processed[script_tag_id] = script_tag_id;
              pos_dest_el = _elt(pos_conf.dest);
              if (!pos_dest_el) {
                if (_ready()) {
                  pos_dest_el = dom.make("div");
                  _attr(pos_dest_el, "id", pos_conf.dest);
                  try {
                    script_tag_par.insertBefore(pos_dest_el);
                  } catch (_error) {
                    err = _error;
                    _log("failed auto-adding destination element " + err.message, true);
                    continue;
                  }
                } else {
                  d.write("<div id='", pos_conf.dest, "'></div>");
                }
              }
              boot_positions.push(pos_obj);
            }
          } else {
            _log("no content or id property found in the inline position object", true);
          }
        }
      }
      if (boot_positions.length) {
        try {
          sf_host.render(boot_positions);
        } catch (_error) {
          e = _error;
          _log("failed during rendering " + e.message);
        }
      } else {
        _log("no positions to boot");
      }
      dom.wait(_clean_up_booted_tags);
    };
    SF_DATATAG_CLASS = "sf_data";
    SF_TAG_TYPE = "text/x-safeframe";
    AUTO_BOOT_MAX_RETRIES = 100;
    SF_POSELEM_WRAPPER_CLASS = "sf_position";
    d = win && win.document;
    lib = sf.lib;
    lang = lib.lang;
    dom = lib.dom;
    _cstr = lang.cstr;
    _guid = lang.guid;
    _elt = dom.elt;
    _par = dom.par;
    _tags = dom.tags;
    _attr = dom.attr;
    _purge = dom.purge;
    _ready = dom.ready;
    inline_tags_processed = {};
    boot_retries = 0;
    has_booted = false;
    doing_auto_boot = false;
    setTimeout(_auto_boot, 50);
    return sf;
  })(window, sf);

}).call(this);

},{"../shared/base":19}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@namespace $sf.host Defines the Publisher side api, and helper functions
@name $sf.host
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.2
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require('./boot');

  module.exports = function(allowNotTop) {
    if (allowNotTop == null) {
      allowNotTop = false;
    }
    return (function(window, sf) {
      var ATTACH, AUTO, AUTO_BOOT_MAX_RETRIES, BF_POS_MSG, CLIP, COLLAPSE_COMMAND, COMPARE_DOC_POS, COMPAT_MODE, CONTAINS, Config, DEFAULT_RENDER_TIMEOUT, DEFAULT_ZINDEX, DETACH, DOC, DOC_EL, EL_FROM_PT, ERROR_COMMAND, EXPAND_COMMAND, FLASH_MIME, GEOM_UPDATE_INTRVAL, GUID, HEIGHT, HIDDEN, IE_BORDER_ADJ, INTERSECT_FACTOR, LEN, M, MSG, NODE_TYPE, NOTIFY_COLLAPSE, NOTIFY_EXPAND, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, OBJ, ONSCROLL, OVER, PMSG, POS_ID_AUTO_PREFIX, POS_MSG, POS_REL_BOX_ID_PREFIX, PX, ParamHash, PosConfig, PosMeta, Position, SCROLL, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, ST, STR, SUPPORTS_FEATURES, TFXD, VERSION, WIDTH, XCOM_RESP_DELAY, attach_iframe_msging, bounds, canUseHTML5, complete_ifrs, config, contains, currentStyle, current_status, dc, detach_iframe_msging, docRect, dom, env, flashActiveXVersions, flash_ver, focus_update_timer, geckVer, geom_update_timer, get, html5Bound, ieVer, ifr_dest_id_map, iframes, inViewPercentage, initID, isIE, lang, lib, loc, locHost, mgr_bounds_details, msg_pipes, msghostfb, nuke, operaVer, overlaps, pending_ifrs, prep_iframe_msging, render, rendered_ifrs, scroll_parents_attached, send_msg_to_child_iframe, status, ua, usingHTML5, wbVer, win, winRect, win_events_attached, _attr, _build_geom, _calcBorders, _call_xmsg_host_fb, _callable, _cbool, _check_html5_init, _clear_focus_update_timer, _clear_geom_update_timer, _cnum, _collapse_safeframe, _cookieHash, _cookies_enabled_test, _create_pos_markup, _cstr, _doc, _docNode, _elt, _es, _expand_safeframe, _fire_pub_callback, _getClip, _getGeom, _getRectIE, _getRectNonIE, _get_doc_scroll, _get_flash_version, _guid, _handle_frame_load, _handle_msg_evt, _handle_msg_from_outside, _handle_node_scroll, _handle_render_timeout, _handle_unload, _handle_win_blur, _handle_win_focus, _handle_win_geom_resize, _handle_win_geom_scroll, _has_pending_renders, _ifr_view, _isPX, _max, _min, _mix, _noop, _par, _purge, _read_cookie, _ready, _record_error, _rect, _round, _send_generic_response, _send_response, _set_focus_update_timer, _set_geom_update_timer, _shim_frame, _strippedEncodedLocation, _tagName, _tags, _update_focus, _update_geom, _update_geom_win_resize, _update_geom_win_scroll, _view, _write_cookie;
      win = window;
      DEFAULT_RENDER_TIMEOUT = 60000;
      POS_ID_AUTO_PREFIX = "sf_pos";
      POS_REL_BOX_ID_PREFIX = "sf_pos_rel_el";
      SF_DATATAG_CLASS = "sf_data";
      SF_POSELEM_WRAPPER_CLASS = "sf_position";
      AUTO_BOOT_MAX_RETRIES = 100;
      GEOM_UPDATE_INTRVAL = 100;
      XCOM_RESP_DELAY = 1;
      IE_BORDER_ADJ = 2;
      INTERSECT_FACTOR = 10;
      BF_POS_MSG = "onBeforePosMsg";
      POS_MSG = "onPosMsg";
      SUPPORTS_FEATURES = {
        "exp-ovr": 1,
        "exp-push": 0,
        bg: 0,
        pin: 0,
        "read-cookie": 0,
        "write-cookie": 0
      };
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_EXPAND = "expand";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_FOCUS_CHANGE = "focus-change";
      DEFAULT_ZINDEX = 3000;
      OBJ = "object";
      STR = "string";
      ST = "style";
      LEN = "length";
      WIDTH = "width";
      HEIGHT = "height";
      PX = "PX";
      CLIP = "clip";
      SCROLL = "scroll";
      ONSCROLL = "onscroll";
      COMPAT_MODE = "compatMode";
      DOC_EL = "documentElement";
      DOC = "document";
      NODE_TYPE = "nodeType";
      CONTAINS = "contains";
      COMPARE_DOC_POS = "compareDocumentPosition";
      EL_FROM_PT = "elementFromPoint";
      AUTO = "auto";
      HIDDEN = "hidden";
      OVER = "overflow";
      TFXD = "toFixed";
      ATTACH = "attach";
      DETACH = "detach";
      MSG = "message";
      PMSG = "postMessage";
      GUID = "guid";
      FLASH_MIME = "application/x-shockwave-flash";
      VERSION = sf.ver;
      env = sf.env;
      ua = env.ua;
      lib = sf.lib;
      lang = lib.lang;
      dom = lib.dom;
      iframes = dom.iframes;
      _cbool = lang.cbool;
      _cnum = lang.cnum;
      _cstr = lang.cstr;
      _callable = lang.callable;
      _noop = lang.noop;
      _guid = lang[GUID];
      _mix = lang.mix;
      _elt = dom.elt;
      _par = dom.par;
      _tags = dom.tags;
      _attr = dom.attr;
      _doc = dom.doc;
      _tagName = dom.tagName;
      _view = dom.view;
      _ifr_view = iframes.view;
      _purge = dom.purge;
      _ready = dom.ready;
      _es = win && win.escape;
      M = win && win.Math;
      _max = M.max;
      _min = M.min;
      _round = M.round;
      _rect = null;
      ParamHash = lang && lang.ParamHash;
      dc = win && win[DOC];
      isIE = env && env.isIE;
      ieVer = (ua && ua.ie) || 0;
      wbVer = (ua && ua.webkit) || 0;
      geckVer = (ua && ua.gecko) || 0;
      operaVer = (ua && ua.opera) || 0;
      loc = win.location;
      locHost = loc && ((loc.protocol + "//" + (loc.host || loc.hostname)) || "");
      rendered_ifrs = {};
      msg_pipes = {};
      ifr_dest_id_map = {};
      pending_ifrs = {};
      complete_ifrs = {};
      scroll_parents_attached = {};
      mgr_bounds_details = false;
      canUseHTML5 = false;
      html5Bound = false;
      win_events_attached = false;
      geom_update_timer = 0;
      focus_update_timer = 0;
      current_status = null;
      msghostfb = null;
      flash_ver = null;
      config = null;
      flashActiveXVersions = ["ShockwaveFlash.ShockwaveFlash.11", "ShockwaveFlash.ShockwaveFlash.8", "ShockwaveFlash.ShockwaveFlash.7", "ShockwaveFlash.ShockwaveFlash.6", "ShockwaveFlash.ShockwaveFlash"];
      initID = void 0;

      /*
      Configure the base-level settings for the SafeFrames library
      Note that only one configuration can be active at a given time.
      Therefore you cannot change the configuration by creating a new $sf.host.Config while
      the SafeFrames library is busy (however you can add new position configurations).
      Instatiating a new config, when the library is not busy will destroy / remove all currently
      managed positions and there configurations.
      
      @name $sf.host.Config
      @constructor
      @public
      @param {Object} conf An object containing properties for configuration
      @param {Boolean} [conf.auto] Whether or not to have SafeFrames automatically boostrap an render any SafeFrames tags within the page
      @param {String} conf.cdn The protocol,host name, and port parts of a URI, that is a 2ndary origin, used with SafeFrames to render content. For example JS files would be loaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/[filename]"
      @param {Boolean} [conf.debug] Whether or not debug mode is on or off
      @param {String} conf.root The root path part of the URI that is a 2ndary origin, used with SafeFrames to render content. For example the HTML file for rendering content into would beloaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/"+conf.renderFile
      @param {String} conf.renderFile The filename (may also include path info), for which to render content into via a SafeFrame.
      @param {String} [conf.msgFile] The filename (may also include path info), for which to use as a proxy for x-domain messaging whenever HTML5 messaging is not available. Only required if supporting older browsers.
      @param {Number} [conf.to] The maximum amount of time in milliseconds to wait for a SafeFrame to finish rendering, defaults to 60 seconds.
      @param {Function} [conf.onBeforePosMsg] A callback function that gets fired before any cancellable action is requested to be peformed from a a SafeFrame, such as expansion, etc.  Return true out of this callback function to cancel/disallow the action in question.
      @param {Function} [conf.onPosMsg] A callback function that gets fired when an action requested by a SafeFrame is performed
      @param {Function} [conf.onStartPosRender] A callback function that gets fired when a SafeFrame starts to render 3rd party content.
      @param {Function} [conf.onEndPosRender] A callback function that gets fired when a SafeFrame finishes rendering 3rd party content.
      @param {Object} [conf.positions] A map of positions to automatically configure, where each key equals the id of the $sf.host.PosConfig object, and the value is an object containing said object's settings.
       */
      Config = function(conf) {
        var boot_up, conf_pos_map, me, posID, pos_conf, pos_id, pos_map;
        me = this;
        if (!arguments.length) {
          return (config ? _mix({}, config) : null);
        }
        if (!(me instanceof Config)) {
          return new Config(conf);
        }
        if (!conf) {
          config = null;
          return null;
        }
        boot_up = !!config;
        me.auto = ("auto" in conf ? _cbool(conf.auto) : true);
        me.cdn = _cstr(conf.cdn);
        me.debug = _cbool(conf.debug);
        me.root = _cstr(conf.root);
        me.renderFile = _cstr(conf.renderFile);
        me.msgFile = _cstr(conf.msgFile);
        me.to = _cnum(conf.to, DEFAULT_RENDER_TIMEOUT);
        me.ver = _cstr(conf.ver) || VERSION;
        me.onBeforePosMsg = (_callable(conf.onBeforePosMsg) ? conf.onBeforePosMsg : _noop);
        me.onPosMsg = (_callable(conf.onPosMsg) ? conf.onPosMsg : _noop);
        me.onStartPosRender = (_callable(conf.onStartPosRender) ? conf.onStartPosRender : _noop);
        me.onEndPosRender = (_callable(conf.onEndPosRender) ? conf.onEndPosRender : _noop);
        me.onFailure = (_callable(conf.onFailure) ? conf.onFailure : _noop);
        me.onAdLoad = (_callable(conf.onAdLoad) ? conf.onAdLoad : _noop);
        me.onReadCookie = (_callable(conf.onReadCookie) ? conf.onReadCookie : _noop);
        me.onWriteCookie = (_callable(conf.onWriteCookie) ? conf.onWriteCookie : _noop);
        conf_pos_map = conf.positions;
        me.positions = pos_map = {};
        if (conf_pos_map) {
          for (posID in conf_pos_map) {
            pos_conf = conf_pos_map[posID];
            if (pos_conf && typeof pos_conf === OBJ) {
              pos_id = posID || pos_conf.id || _guid(POS_ID_AUTO_PREFIX);
              pos_map[pos_id] = new PosConfig(pos_conf);
            }
          }
        }
        config = me;
        boot_up = !!(boot_up && me.auto && (sf.host.boot != null));
        try {
          if (boot_up) {
            sf.host.boot();
          }
        } catch (_error) {}
        return _mix({}, config);
      };

      /*
      Configure a particualar position for rendering a SafeFrame
      Each $sf.host.PosConfig object has an id property that should be unique.  Creating a new $sf.host.PosConfig with an id, that has already been
      used results in changing the old $sf.host.PosConfig settings, and can only be done if the SafeFrames library is not busy.
      Automatically ads to the position map of the $sf.host.Config object if said config has already been created.
      
      @name $sf.host.PosConfig
      @public
      @constructor
      @param {Object|String} posIDorObj The id of the $sf.host.PosConfig instance, or an object containing all settings that are to be used for the instance.
      @param {String} [posIDorObj.id] The id of the $sf.host.PosConfig instance, if not specified one will be generated automatically.
      @param {String} [posIDorObj.dest] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
      @param {String} [posIDorObj.bg] The color of the background to be used inside the SafeFrame. Default equals "transparent".
      @param {String} [posIDorObj.tgt] The name of the target window where hyperlinks inside a SafeFrame will navigate too...Note that "_self" is not allowed and always converted to "_top". Allowed values are any string value not prefixed with "_", or "_top" or "_blank".
      @param {String} [posIDorObj.css] A string of CSS rules, or a URL that points to a CSS style sheet to be used inside the SafeFrame
      @param {Number} [posIDorObj.w] The width of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
      @param {Number} [posIDorObj.h] The height of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
      @param {String} [posIDorObj.size] A string formated as "widthXheight", that defines the width and height of the SafeFrame. The delimiter character "X" is can be specified as lower or upper case.
      @param {String} [posIDorObj.z] The z-index of the SafeFrame.
      @param {Object} [posIDorObj.supports] An object containing key/value pairs for what features/actions are supported by the SafeFrame, and its corresponding value represents a boolean detereming whether that feature can be used.  Currently supported keys are "exp-ovr" == SafeFrame can expand in overlay mode, "exp-push" == SafeFrame can expand in push mode, and "bg" == SafeFrame can change the background of the publisher / host.
      @param {String} [destID] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
      @param {Object} [baseConf] An object representing a $sf.host.Config object to automatically use / create for the SafeFrames library. Note that baseConf can only be used one time, otherwise you have to use the $sf.host.Config object directly.
       */
      PosConfig = function(posIDorObj, destID, baseConf) {
        var me, sz, sz_split, typ;
        me = this;
        typ = (posIDorObj && typeof posIDorObj) || "";
        if (!(me instanceof PosConfig)) {
          return new PosConfig(posIDorObj, destID, baseConf);
        }
        if (typ === OBJ) {
          me.id = _cstr(posIDorObj.id);
          me.dest = _cstr(posIDorObj.dest || destID);
          me.bg = _cstr(posIDorObj.bg) || "transparent";
          me.tgt = _cstr(posIDorObj.tgt) || "_top";
          me.css = _cstr(posIDorObj.css);
          me.w = _cnum(posIDorObj.w, 0);
          me.h = _cnum(posIDorObj.h, 0);
          me.z = _cnum(posIDorObj.z, 0);
          me.renderFile = _cstr(posIDorObj.renderFile) || null;
          me.supports = _mix({}, posIDorObj.supports || SUPPORTS_FEATURES, true, true, true);
          if (!me.w || !me.h) {
            sz = _cstr(posIDorObj.size);
            if (sz) {
              sz_split = sz.split(/x/g);
              me.w = _cnum(sz_split[0], 0);
              me.h = _cnum(sz_split[1], 0);
              me.size = sz;
            } else {
              me.size = "";
            }
          } else {
            me.size = me.w + "x" + me.h;
          }
        } else if (typ === "string") {
          me.id = _cstr(posIDorObj);
          me.dest = _cstr(destID);
        } else {
          me.dest = "";
          me.bg = "transparent";
          me.tgt = "_top";
          me.css = "";
          me.w = 0;
          me.h = 0;
          me.size = "";
          me.z = 0;
          me.supports = {};
        }
        me.id = me.id || _guid(POS_ID_AUTO_PREFIX);
        if (!config && baseConf) {
          Config(baseConf);
        }
        if (config) {
          config.positions[me.id] = me;
        }
        return _mix({}, me);
      };

      /*
      Construct a set of dynamic key/value pairs that can be shared as meta-data with the 3rd party content inside a SafeFrame.
      All data is treated as protected, and can only be specfied during construction of this object.
      
      @exports PosMeta as $sf.host.PosMeta#
      @public
      @constructor
      @class
      @param {Object} shared_object An object containing keys and values to be shared as meta-data inside the SafeFrame
      @param {String} [owner_key] A key name to be used to hold pseudo private keys / values of meta data.
      @param {Object} [owned_obj] An object containing psuedo private keys and values to be shared as meta-data inside the SafeFrame.
      @example
      var shared_data 		 = {content_id:8978098,partner_id:99},
      private_data_key	 = "rmx",
      private_data      = {section_id:2342,site_id:23904},
      meta_data		 = new $sf.host.PosMeta(shared_data, private_data_key, private_data);
      
      //show section id on host side
      alert(meta_data.value("rmx", "site_id")); //== 23904
      
      @example
      //now retrieve this information inside the safe frame
      
      var content_id = $sf.vend.meta("content_id"); //== 8978098
      
      var rmx_section_id = $sf.vend.meta("rmx", "section_id") //== 2342, but note that vendor side code must know the "owner_key" upfront.
       */
      PosMeta = function(shared_obj, owner_key, owned_obj) {

        /*
        A method retrieves a meta data value from this object.
        
        @exports get_value as $sf.host.PosMeta#value
        @param {String} propKey The name of the value to retrieve
        @param {String} [owner_key] The name of the owner key of the meta data value. By default, it is assumed to be shared, so nothing needs to be passed in unless looking for a specific proprietary value
        @return {String|Number|Boolean}
        @default {String} ""
        @public
        @function
         */
        var get_value, me, non_shared, old, posConf, serialize, set_value, shared;
        get_value = function(propKey, owner_key) {
          var ret;
          ret = "";
          if (!propKey || typeof propKey !== STR) {
            return ret;
          }
          if (!owner_key || typeof owner_key !== STR) {
            owner_key = "shared";
          }
          if (owner_key === "shared") {
            ret = shared[propKey] || "";
          } else {
            ret = (propKey in non_shared ? non_shared[prop_key] || "" : "");
          }
          return ret;
        };

        /*
        Return a serialized string representation (in url query string format) of the meta data object
        
        @exports serialize as $sf.host.PosMeta#toString
        @function
        @public
         */
        serialize = function() {
          var obj;
          obj = new ParamHash();
          obj.shared = shared;
          obj.non_shared = non_shared;
          return obj.toString();
        };
        set_value = function(propKey, ownerKey, value) {
          non_shared[ownerKey] || (non_shared[ownerKey] = {});
          return non_shared[ownerKey][propKey] = value;
        };
        me = this;
        shared = void 0;
        non_shared = void 0;
        old = void 0;
        posConf = void 0;
        if (!(me instanceof PosMeta)) {
          return new PosMeta(key, owned_obj, pos, shared_obj);
        }
        shared = {};
        non_shared = {};
        if (!owner_key || typeof owner_key !== STR) {
          return me;
        }
        if (shared_obj && typeof shared_obj === OBJ) {
          shared = _mix(shared, shared_obj);
        }
        if (owned_obj && typeof owned_obj === OBJ) {
          non_shared[owner_key] = owned_obj;
        }
        me.toString = serialize;
        me.value = get_value;
        me.setValue = set_value;
      };

      /*
      Create the HTML markup for a position if a src property was used
      
      @name $sf.host-_create_pos_markup
      @function
      @private
      @static
      @return {String}
       */
      _create_pos_markup = function(src) {
        var ckVal, fVer;
        if (src) {
          if (src.indexOf("${sf_ver}") > -1) {
            src = src.replace(/\${sf_ver}/g, $sf.ver);
          }
          if (src.indexOf("${ck_on}") > -1) {
            ckVal = (_cookies_enabled_test() ? "1" : "0");
            src = src.replace(/\${ck_on}/g, ckVal);
          }
          if (src.indexOf("${flash_ver}") > -1) {
            fVer = _get_flash_version();
            src = src.replace(/\${flash_ver}/g, fVer);
          }
        }
        return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
      };

      /*
      Get the falsh version number
       */
      _get_flash_version = function() {
        var err, getActiveXVersion, i, mimeTypes, obj, p, tmpVer;
        if (flash_ver !== null) {
          return flash_ver;
        }
        if (navigator.plugins && navigator.plugins.length > 0) {
          mimeTypes = navigator.mimeTypes;
          if (mimeTypes && mimeTypes[FLASH_MIME] && mimeTypes[FLASH_MIME].enabledPlugin && mimeTypes[FLASH_MIME].enabledPlugin.description) {
            flash_ver = mimeTypes[FLASH_MIME].enabledPlugin.version;
          }
        } else if (sf.env.isIE) {
          i = 0;
          while (i < flashActiveXVersions.length) {
            try {
              obj = new ActiveXObject(flashActiveXVersions[i]);
              tmpVer = obj.GetVariable("$version");
              p = tmpVer.indexOf(" ");
              if (p > -1) {
                flash_ver = tmpVer.substr(p + 1).replace(/,/g, ".");
              } else {
                flash_ver = tmpVer.replace(/,/g, ".");
              }
              break;
            } catch (_error) {
              err = _error;
              obj = null;
              flash_ver = 0;
              continue;
            }
            i++;
          }
        } else {
          flash_ver = 0;
        }
        return flash_ver;
        getActiveXVersion = function(activeXObj) {
          var version;
          version = -1;
          try {
            version = activeXObj.GetVariable("$version");
          } catch (_error) {}
          return version;
        };
      };

      /*
      Test to see if cookies are enabled
       */
      _cookies_enabled_test = function() {
        var cookieEnabled;
        cookieEnabled = (navigator.cookieEnabled ? true : false);
        if (typeof navigator.cookieEnabled === "undefined" && !cookieEnabled) {
          document.cookie = "testcookie";
          cookieEnabled = (document.cookie.indexOf("testcookie") !== -1 ? true : false);
          if (navigator) {
            navigator.cookieEnabled = cookieEnabled;
          }
        }
        return cookieEnabled;
      };

      /*
      Construction a postion content object that contains HTML, optionally meta-data, and optionally a position configuration to use.
      The id specified must match an id for a $sf.host.PosConfig (although said config could be specfied directly here via arguments).
      
      @name $sf.host.Position
      @constructor
      @public
      @param {Object|String} posIDorObj The id of the position which maps to its configuration, or an object represeting the various values of an $sf.host.Position instance.
      @param {String} [posIDorObj.id] The id of the position which maps to its configuration.
      @param {String} [posIDorObj.html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
      @param {String} [posIDorObj.src] An optional URL to be used for redering inside the SafeFrame which will automatically generate a SCRIPT tag with the specified URL.
      @param {$sf.host.PosMeta} [posIDorObj.meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
      @param {Object} [posIDorObj.conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
      @param {String} [html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
      @param {$sf.host.PosMeta} [meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
      @param {Object} [conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
       */
      Position = function(posIDorObj, html, meta, conf) {
        var id, me, msg, origHtml, typ;
        me = this;
        typ = posIDorObj && typeof posIDorObj;
        origHtml = html;
        if (!(me instanceof Position)) {
          return new Position(posIDorObj, html, meta, conf);
        }
        if (config == null) {
          msg = "Publisher Config not initialized - abort";
          sf.lib.logger.error(msg);
          sf.info.errs.push(msg);
          return;
        }
        if (typ === OBJ) {
          _mix(me, posIDorObj);
        } else {
          id = me.id = _cstr(posIDorObj) || _guid(POS_ID_AUTO_PREFIX);
        }
        if (!html) {
          if (me.src) {
            me.html = _create_pos_markup(me.src);
          } else {
            me.html = me.html || "";
            me.src = "";
          }
        } else {
          me.html = html;
          me.src = "";
        }
        if (!me.html) {
          me.html = "";
        }
        me.meta = meta || me.meta || {};
        me.conf = conf || me.conf || {};
        if (id) {
          if (config && config.positions[id]) {
            me.conf = config.positions[id];
          } else {
            if (conf) {
              conf.id = id;
              me.conf = new PosConfig(conf);
            }
          }
        }
      };

      /*
      @namespace $sf.lib.dom.msghost Contains functionality to reside in the top level page for sending and receiving x-domain messages to SafeFrame containers
      @name $sf.lib.dom.msghost
       */

      /*
      Returns the root document HTMLElement / node
      @name $sf.lib.dom-_docNode
      @private
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as a reference for finding the root document element.
      @returns {HTMLElement}
       */
      _docNode = function(el) {
        var compatMode, d, root;
        d = (el && _doc(el)) || dc;
        compatMode = d[COMPAT_MODE];
        root = d[DOC_EL];
        if (compatMode && !operaVer && compatMode !== "CSS1Compat") {
          root = d.body;
        }
        return root;
      };

      /*
      Returns whether or not a value is specified in pixels
      @name $sf.lib.dom-_isPX
      @private
      @static
      @function
      @param {String} val A css value of size
      @returns {Boolean}
       */
      _isPX = function(val) {
        val = _cstr(val);
        if (val && val.search(/\D+/g) === -1) {
          return true;
        }
        if (val && val.search(/px/g) !== -1) {
          return true;
        }
      };

      /*
      Return an array of values of clipping region information. Array represents top, right, bottom, left values respectively.
      If values are not specified in pixels, or no clip region is defined for that element, -1 is returned for each value.
      
      @name $sf.lib.dom-_getClip
      @private
      @function
      @static
      @param {HTMLStyleObject} curSt The current style object of an HTMLElement
      @return {Array}
       */
      _getClip = function(curSt) {
        var clipVal, idx, len, prop, props, ret, val;
        ret = [-1, -1, -1, -1];
        props = [CLIP + "Top", CLIP + "Right", CLIP + "Bottom", CLIP + "Left"];
        idx = 0;
        clipVal = void 0;
        prop = void 0;
        val = void 0;
        len = void 0;
        if (!curSt) {
          return ret;
        }
        if (ieVer) {
          while (prop = props[idx]) {
            clipVal = curSt[prop];
            if (_isPX(clipVal)) {
              clipVal = _cnum(clipVal, -1);
              if (clipVal >= 0) {
                ret[idx] = clipVal;
              }
            }
            idx++;
          }
        } else {
          clipVal = curSt[CLIP];
          if (clipVal && clipVal.search(/\d+/g) !== -1) {
            clipVal = clipVal.replace(/\w+\(([^\)]*?)\)/g, "$1");
            ret = clipVal.split(" ");
            ret = (ret[LEN] <= 1 ? ret.split(",") : ret);
            len = ret[LEN];
            idx = 0;
            while (len--) {
              val = ret[idx];
              if (!_isPX(val)) {
                ret[idx] = -1;
              } else {
                ret[idx] = _cnum(val, -1);
              }
              idx++;
            }
          }
        }
        return ret;
      };

      /*
      Returns border values in pixels if possible to help calculate geometry of an element
      
      @name $sf.lib.dom-_calcBorders
      @private
      @static
      @function
      @param {HTMLElement} el The HTMLElement for which to look at. . .
      @param {Object} rect The rect object generated for the HTMLElement in question to be adjusted
      @returns {Object} rect
       */
      _calcBorders = function(el, rect) {
        var l, re, st, t;
        t = 0;
        l = 0;
        st = void 0;
        re = /^t(?:able|d|h|r|head|foot)$/i;
        st = currentStyle(el);
        if (st) {
          t = st["borderTopWidth"];
          l = st["borderLeftWidth"];
          t = (_isPX(t) ? _cnum(t, 0) : 0);
          l = (_isPX(l) ? _cnum(l, 0) : 0);
          if (geckVer && re.test(_tagName(el))) {
            t = l = 0;
          }
        }
        rect = rect || {
          t: 0,
          l: 0
        };
        rect.t += t;
        rect.l += l;
        return rect;
      };

      /*
      Retrieve scroll values of a document
      
      @name $sf.lib.dom-_get_doc_scroll
      @private
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as a reference document rather than the default main document
      @return {Object} Contains x, y, w, h properties for scrolling
       */
      _get_doc_scroll = function(el) {
        var d, db, de, def, dv, offsetX, offsetY, pos;
        pos = {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        };
        def = {
          scrollLeft: 0,
          scrollTop: 0,
          scrollWidth: 0,
          scrollHeight: 0
        };
        d = void 0;
        de = void 0;
        dv = void 0;
        db = void 0;
        offsetX = 0;
        offsetY = 0;
        d = _doc(el) || dc;
        de = d[DOC_EL] || def;
        db = d.body || def;
        dv = d.defaultView;
        if (dv) {
          offsetX = _cnum(dv.pageXOffset, 0);
          offsetY = _cnum(dv.pageYOffset, 0);
        }
        pos.x = _max(de.scrollLeft, db.scrollLeft, offsetX);
        pos.y = _max(de.scrollTop, db.scrollTop, offsetY);
        pos.w = _max(de.scrollWidth, db.scrollWidth, 0);
        pos.h = _max(de.scrollHeight, db.scrollHeight, 0);
        return pos;
      };

      /*
      Calculate a geometric rectangle for a given element. Note that for IE browsers
      we can use the "getBoundingClientRect" function which saves us some time / increases
      peformance. . however it really can only be called if the DOM is completely loaded,
      and if that is the case we fallback to the brute-force / non-IE method.
      
      @name $sf.lib.dom-_getRectIE
      @private
      @static
      @function
      @param {HTMLElement} el  The element for which to derive a rectangle object
      @returns {Object} An object representing the rectangle for the given HTMLElement
       */
      _getRectIE = function(el) {
        var adjustX, adjustY, bLeft, bTop, box, compatMode, d, de, e, rect, scroll, st, _back;
        rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          w: 0,
          h: 0,
          z: 0
        };
        _back = "BackCompat";
        scroll = void 0;
        box = void 0;
        d = void 0;
        de = void 0;
        compatMode = void 0;
        st = void 0;
        adjustX = void 0;
        adjustY = void 0;
        bLeft = void 0;
        bTop = void 0;
        if (el && el[NODE_TYPE] === 1) {
          try {
            d = _doc(el) || dc;
            if (!dom.ready()) {
              return _getRectNonIE(el);
            }
            scroll = _get_doc_scroll(el);
            box = el.getBoundingClientRect();
            rect.t = box.top;
            rect.l = box.left;
            adjustX = adjustY = IE_BORDER_ADJ;
            compatMode = d[COMPAT_MODE];
            de = d[DOC_EL];
            st = currentStyle(de);
            bLeft = st["borderLeftWidth"];
            bTop = st["borderTopWidth"];
            if (ieVer === 6) {
              if (compatMode !== _back) {
                adjustX = adjustY = 0;
              }
            }
            if (compatMode === _back) {
              bLeft = (_isPX(bLeft) ? _cnum(bLeft, 0) : 0);
              adjustX = bLeft;
              bTop = (_isPX(bTop) ? _cnum(bTop, 0) : 0);
              adjustY = bTop;
              rect.t -= adjustX;
              rect.l -= adjustY;
            }
            rect.t += scroll.y;
            rect.l += scroll.x;
            rect.b = rect.t + el.offsetHeight;
            rect.r = rect.l + el.offsetWidth;
            rect.w = _max(rect.r - rect.l, 0);
            rect.h = _max(rect.b - rect.t, 0);
            rect.z = currentStyle(el, "zIndex");
          } catch (_error) {
            e = _error;
            rect = {
              t: 0,
              l: 0,
              r: 0,
              b: 0,
              w: 0,
              h: 0,
              z: 0
            };
          }
        }
        return rect;
      };

      /*
      Calculate a geometric rectangle for a given element. For non-IE browsers, we must use
      brute-force and walk up the offsetParent tree. Also takes in consideration for some
      other slight variations in browsers.
      
      @name $sf.lib.dom-_getRectNonIE
      @private
      @static
      @function
      @param {HTMLElement} el  The element for which to derive a rectangle object
      @returns {Object} An object representing the rectangle for the given HTMLElement
       */
      _getRectNonIE = function(el) {
        var bCheck, e, h, parentNode, rect, root, scroll, scrollLeft, scrollTop, w;
        rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          w: 0,
          h: 0,
          z: 0
        };
        scrollTop = 0;
        scrollLeft = 0;
        bCheck = false;
        root = _docNode(el);
        scroll = _get_doc_scroll(el);
        parentNode = void 0;
        w = void 0;
        h = void 0;
        if (el && el[NODE_TYPE] === 1) {
          try {
            rect.l = el.offsetLeft || 0;
            rect.t = el.offsetTop || 0;
            parentNode = el;
            bCheck = geckVer || wbVer > 519;
            while (parentNode = parentNode.offsetParent) {
              rect.t += parentNode.offsetTop || 0;
              rect.l += parentNode.offsetLeft || 0;
              if (bCheck) {
                _calcBorders(parentNode, rect);
              }
              if (parentNode === root) {
                break;
              }
            }
            parentNode = el;
            if (currentStyle(parentNode, "position") !== "fixed") {
              parentNode = el;
              while (parentNode = _par(parentNode)) {
                if (parentNode[NODE_TYPE] === 1) {
                  scrollTop = parentNode.scrollTop || 0;
                  scrollLeft = parentNode.scrollLeft || 0;
                  if (geckVer && currentStyle(parentNode, OVER) !== "visible") {
                    _calcBorders(parentNode, rect);
                  }
                  rect.l -= scrollLeft;
                  rect.t -= scrollTop;
                }
                if (parentNode === root) {
                  break;
                }
              }
              rect.t += scroll.y;
              rect.l += scroll.x;
            } else {
              rect.t += scroll.y;
              rect.l += scroll.x;
            }
            if (!ieVer && el === _docNode(el)) {
              h = el.clientHeight;
              w = el.clientWidth;
            } else {
              h = el.offsetHeight;
              w = el.offsetWidth;
            }
            rect.b = rect.t + h;
            rect.r = rect.l + w;
            rect.w = _max(rect.r - rect.l, 0);
            rect.h = _max(rect.b - rect.t, 0);
            rect.z = currentStyle(el, "zIndex");
          } catch (_error) {
            e = _error;
            rect = {
              t: 0,
              l: 0,
              r: 0,
              b: 0,
              w: 0,
              h: 0,
              z: 0
            };
          }
        }
        return rect;
      };

      /*
      Returns an object that represents a rectangle with the geometric information of an HTMLDocument
      (includes scroll width / height)
      
      @name $sf.lib.dom.docRect
      @public
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as the reference for an HTMLDocument
      @returns {Object}
       */
      docRect = function(el) {
        var h, root, w;
        root = _docNode(el);
        w = 0;
        h = 0;
        if (root) {
          w = root.scrollWidth || 0;
          h = root.scrollHeight || 0;
        }
        return {
          t: 0,
          l: 0,
          b: h,
          r: w,
          w: w,
          h: h
        };
      };

      /*
      Returns an object that represents a rectangle with the geometric information of an HTMLWindow
      (does not include scroll width / height)
      
      @name $sf.lib.dom.winRect
      @public
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as the references for an HTMLWindow
      @returns {Object}
       */
      winRect = function(el) {
        var b, h, l, r, root, t, w, wi;
        wi = (el && _view(el)) || win;
        h = wi.innerHeight || 0;
        w = wi.innerWidth || 0;
        t = wi.screenY || wi.screenTop || 0;
        b = h + t;
        l = wi.screenX || wi.screenLeft || 0;
        r = w + l;
        root = _docNode(el);
        if (!h && !w && root) {
          h = root.clientHeight || 0;
          w = root.clientWidth || 0;
          r = l + w;
          b = t + h;
        }
        return {
          t: t,
          l: l,
          b: b,
          r: r,
          w: w,
          h: h
        };
      };

      /*
      Returns whether or not an HTMLElement is contained within another HTMLElement
      
      @name $sf.lib.dom.contains
      @public
      @static
      @function
      @param {HTMLElement} element The HTMLElement reference to search within
      @param {HTMLElement} needle The HTMLElement for which you want to check if its contained by the 1st parameter
      @returns {Boolean}
       */
      contains = function(element, needle) {
        var el_node_type, needle_node_type, ret;
        ret = false;
        el_node_type = (element && element[NODE_TYPE]) || -1;
        needle_node_type = (needle && needle[NODE_TYPE]) || -1;
        if (el_node_type === 1 && needle_node_type !== -1) {
          if (element[CONTAINS]) {
            if (operaVer || needle_node_type === 1) {
              ret = element[CONTAINS](needle);
            } else {
              while (needle) {
                if (element === needle) {
                  ret = true;
                  break;
                }
                needle = needle.parentNode;
              }
            }
          } else {
            if (element[COMPARE_DOC_POS]) {
              ret = element === needle || !!(element[COMPARE_DOC_POS](needle) & 16);
            }
          }
        }
        return ret;
      };

      /*
      Returns the current value of a style attribute, or the current style object in its entirety depending on whether an attribute parameter is specified
      
      @name $sf.lib.dom.currentStyle
      @public
      @static
      @function
      @param {HTMLElement} el The HTMLElement for which to retrieve style information
      @param {String} [attr] The style attribute (in JavaScript notation, e.g. 'backgroundColor' rather than 'background-color') to fetch.
      @return {HTMLStyleObject} An HTMLStyleObject containing all current style attribute values
      @return {String} The value of an style attribute (only if attr parameter is specified).
       */
      currentStyle = function(el, attr) {
        var comp, e, hasAttr, val;
        val = "";
        hasAttr = !!(arguments.length && attr);
        comp = "getComputedStyle";
        e = void 0;
        if (hasAttr) {
          if (ieVer) {
            try {
              val = el.currentStyle[attr];
            } catch (_error) {
              e = _error;
              val = "";
            }
          } else {
            try {
              val = _view(el)[comp](el, null)[attr];
            } catch (_error) {
              e = _error;
              val = "";
            }
          }
        } else {
          if (ieVer) {
            try {
              val = el.currentStyle;
            } catch (_error) {
              e = _error;
              val = null;
            }
          } else {
            try {
              val = _view(el)[comp](el, null);
            } catch (_error) {
              e = _error;
              val = null;
            }
          }
        }
        return val;
      };

      /*
      Calculate the surrounding boundaries of an HTMLElement, and whether or not the HTMLElement is "in-view" of the user
      
      @name $sf.lib.dom.bounds
      @public
      @static
      @function
      @param {HTMLElement} el The element for which to calculate information
      @param {Object} [details] An object reference used as an output parameter in which further details about the boundaries of the element are specified
      @param {Boolean} [check_3D] Check the element within 3 dimensional space such that any elements covering said element are also take into consideration
      @returns {Object} info An object containing information about the element boundaries
       */
      bounds = function(el, details, check_3D) {
        var b, client_height, client_width, clip, clip_rect, cur_st, doc_rect, el_rect, exp_rect, h, is_scroll_node, is_using_doc_root_b, is_using_doc_root_r, l, offset_height, offset_width, over_x_val, over_y_val, par, r, ref_node, root, root_rect, root_scroll, scroll_height, scroll_left, scroll_top, scroll_width, t, temp_rect, w, x_hidden, xsb_h, y_hidden, ysb_w;
        par = el && _par(el);
        root = _docNode(el);
        el_rect = _rect(el);
        root_rect = _rect(root);
        root_scroll = _get_doc_scroll(root);
        doc_rect = docRect(el);
        clip_rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          w: 0,
          h: 0
        };
        exp_rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          xs: 0,
          ys: 0,
          xiv: 0,
          yiv: 0,
          iv: 0,
          w: 0,
          h: 0
        };
        xsb_h = 0;
        ysb_w = 0;
        is_scroll_node = false;
        is_using_doc_root_r = false;
        is_using_doc_root_b = false;
        cur_st = void 0;
        w = void 0;
        h = void 0;
        t = void 0;
        l = void 0;
        r = void 0;
        b = void 0;
        scroll_width = void 0;
        offset_width = void 0;
        client_width = void 0;
        scroll_height = void 0;
        offset_height = void 0;
        client_height = void 0;
        over_x_val = void 0;
        scroll_left = void 0;
        scroll_top = void 0;
        over_y_val = void 0;
        clip = void 0;
        x_hidden = void 0;
        y_hidden = void 0;
        ref_node = void 0;
        temp_rect = void 0;
        is_scroll_node = false;
        details = (details && typeof details === OBJ ? details : {});
        if (par) {
          while (cur_st = currentStyle(par)) {
            if (cur_st["display"] === "block" || cur_st["position"] === "absolute" || cur_st["float"] !== "none" || cur_st["clear"] !== "none") {
              over_x_val = cur_st[OVER + "X"];
              over_y_val = cur_st[OVER + "Y"];
              clip = _getClip(cur_st);
              if (par === root) {
                scroll_width = root_scroll.w;
                scroll_height = root_scroll.h;
              } else {
                scroll_width = par.scrollWidth;
                scroll_height = par.scrollHeight;
              }
              offset_width = par.offsetWidth;
              offset_height = par.offsetHeight;
              client_width = par.clientWidth;
              client_height = par.clientHeight;
              if (over_x_val === HIDDEN || clip[1] > 0 || clip[3] > 0) {
                if (!ref_node) {
                  x_hidden = 1;
                  ref_node = par;
                }
              }
              if (over_y_val === HIDDEN || clip[0] > 0 || clip[2] > 0) {
                if (!ref_node) {
                  y_hidden = 1;
                  ref_node = par;
                }
              }
              if (over_x_val === SCROLL) {
                ref_node = par;
                xsb_h = offset_height - client_height;
                is_scroll_node = true;
              }
              if (over_y_val === SCROLL) {
                if (!ref_node) {
                  ref_node = par;
                }
                ysb_w = offset_width - client_width;
                is_scroll_node = true;
              }
              if (over_x_val === AUTO) {
                if (!ref_node) {
                  ref_node = par;
                }
                if (scroll_width > client_width) {
                  xsb_h = offset_height - client_height;
                }
                is_scroll_node = true;
              }
              if (over_y_val === AUTO) {
                if (!ref_node) {
                  ref_node = par;
                }
                if (scroll_height > client_height) {
                  ysb_w = offset_width - client_width;
                }
                is_scroll_node = true;
              }
              if (ref_node) {
                break;
              }
            }
            if (par === root) {
              if (scroll_width > client_width) {
                h = (win.innerHeight || 0) || offset_height;
                xsb_h = h - client_height;
              }
              if (scroll_height > client_height) {
                w = (win.innerWidth || 0) || offset_width;
                ysb_w = w - client_width;
              }
              is_scroll_node = true;
            }
            par = _par(par);
            if (!par || par[NODE_TYPE] !== 1) {
              break;
            }
          }
        }
        if (el_rect.w && el_rect.h) {
          if (!ref_node || ref_node === root) {
            exp_rect.t = _max(el_rect.t, 0);
            exp_rect.l = _max(el_rect.l, 0);
            if (ieVer && dc[COMPAT_MODE] === "BackCompat" && _attr(root, SCROLL) === "no") {
              y_hidden = x_hidden = 1;
            } else {
              cur_st = currentStyle(root);
              if (cur_st) {
                x_hidden = cur_st[OVER + "X"] === HIDDEN;
                y_hidden = cur_st[OVER + "Y"] === HIDDEN;
              }
            }
            if (root_scroll.h > root.clientHeight) {
              if (y_hidden) {
                exp_rect.b = 0;
              } else {
                is_using_doc_root_b = true;
                exp_rect.b = _max(((doc_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
              }
            } else {
              exp_rect.b = _max(((root_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
            }
            if (root_scroll.w > root.clientWidth) {
              if (x_hidden) {
                exp_rect.r = 0;
              } else {
                is_using_doc_root_r = true;
                exp_rect.r = _max(((doc_rect.w - el_rect.w) - ysb_w) - el_rect.l, 0);
              }
            } else {
              exp_rect.r = _max(((root_rect.r - el_rect.w) - ysb_w) - el_rect.l, 0);
            }
          } else {
            cur_st = currentStyle(ref_node);
            if (_tagName(ref_node) === "body") {
              ref_node = root;
              t = el_rect.t;
              l = el_rect.l;
            } else {
              t = l = 0;
            }
            clip_rect = _rect(ref_node);
            if (clip[1] > 0) {
              clip_rect.w = clip[1];
              clip_rect.r = clip_rect.l + clip_rect.w;
            }
            if (clip[3] > 0) {
              clip_rect.l = clip_rect.l + clip[3];
              clip_rect.w = clip_rect.w - clip[3];
            }
            if (clip[2] > 0) {
              clip_rect.h = clip[2];
              clip_rect.b = clip_rect.t + clip_rect.h;
            }
            if (clip[0] > 0) {
              clip_rect.t = clip_rect.t + clip[0];
              clip_rect.h = clip_rect.h - clip[0];
            }
            if (el_rect.t > clip_rect.t && clip_rect.t > 0) {
              t = el_rect.t - clip_rect.t;
            }
            if (el_rect.l > clip_rect.l && clip_rect.l > 0) {
              l = el_rect.l - clip_rect.l;
            }
            scroll_top = ref_node.scrollTop;
            scroll_left = ref_node.scrollLeft;
            scroll_height = ref_node.scrollHeight;
            scroll_width = ref_node.scrollWidth;
            exp_rect.t = _max(t, 0);
            exp_rect.l = _max(l, 0);
            if (cur_st) {
              x_hidden = cur_st[OVER + "X"] === HIDDEN || clip[1] > 0 || clip[3] > 0;
              y_hidden = cur_st[OVER + "Y"] === HIDDEN || clip[0] > 0 || clip[2] > 0;
            }
            if (el_rect.t >= clip_rect.b) {
              exp_rect.b = 0;
            } else {
              if (!y_hidden && el_rect.t >= clip_rect.b) {
                y_hidden = 1;
              }
              if (scroll_height > ref_node.clientHeight) {
                if (y_hidden) {
                  exp_rect.b = 0;
                } else {
                  exp_rect.b = _max(((scroll_height - el_rect.h) - xsb_h) - t, 0);
                }
              } else {
                exp_rect.b = _max(((clip_rect.h - el_rect.h) - xsb_h) - t, 0);
              }
            }
            if (el_rect.l >= clip_rect.r) {
              exp_rect.r = 0;
            } else {
              if (!x_hidden && el_rect.l >= clip_rect.r) {
                x_hidden = 1;
              }
              if (scroll_width > ref_node.clientWidth) {
                if (x_hidden) {
                  exp_rect.r = 0;
                } else {
                  exp_rect.r = _max(((scroll_width - el_rect.w) - ysb_w) - l, 0);
                }
              } else {
                exp_rect.r = _max(((clip_rect.w - el_rect.w) - ysb_w) - l, 0);
              }
            }
          }
          exp_rect.xs = (xsb_h ? 1 : 0);
          exp_rect.ys = (ysb_w ? 1 : 0);
          exp_rect.w = exp_rect.r + exp_rect.l;
          exp_rect.h = exp_rect.t + exp_rect.b;
          if (!ref_node || ref_node === root) {
            temp_rect = root_rect;
            ref_node = root;
          } else {
            temp_rect = clip_rect;
          }
          l = _max(el_rect.l, temp_rect.l);
          r = _min(el_rect.r, (is_using_doc_root_r ? _min(doc_rect.r, temp_rect.r) : temp_rect.r));
          w = _max(r - l, 0);
          t = _max(el_rect.t, temp_rect.t);
          b = _min(el_rect.b, (is_using_doc_root_b ? _min(doc_rect.b, temp_rect.b) : temp_rect.b));
          h = _max(b - t, 0);
          exp_rect.xiv = _cnum((w / el_rect.w)[TFXD](2));
          exp_rect.yiv = _cnum((h / el_rect.h)[TFXD](2));
          exp_rect.iv = _cnum(((w * h) / (el_rect.w * el_rect.h))[TFXD](2));
        }
        details.refNode = ref_node || root;
        details.isRoot = ref_node === root;
        details.canScroll = is_scroll_node;
        details.refRect = (!ref_node || ref_node === root ? root_rect : clip_rect);
        details.expRect = exp_rect;
        details.rect = el_rect;
        if (check_3D) {
          (function() {
            var arOvrlaps, el_area, el_h, el_w, idx, len, new_iv, new_xiv, new_yiv, ovr_area, ovr_node, ovr_node_rect;
            idx = 0;
            len = 0;
            arOvrlaps = void 0;
            el_w = void 0;
            el_h = void 0;
            el_area = void 0;
            ovr_node = void 0;
            ovr_node_rect = void 0;
            t = void 0;
            b = void 0;
            l = void 0;
            r = void 0;
            h = void 0;
            w = void 0;
            ovr_area = void 0;
            new_iv = void 0;
            new_xiv = void 0;
            new_yiv = void 0;
            if (exp_rect.iv > .5) {
              mgr_bounds_details = details;
              arOvrlaps = overlaps(el, _cnum(check_3D, 1, 1));
              mgr_bounds_details = null;
              len = arOvrlaps[LEN];
              el_w = el_rect.w;
              el_h = el_rect.h;
              el_area = el_w * el_h;
              if (len) {
                while (ovr_node = arOvrlaps[idx++]) {
                  ovr_node_rect = _rect(ovr_node);
                  l = _max(el_rect.l, ovr_node_rect.l);
                  r = _min(el_rect.r, ovr_node_rect.r);
                  t = _max(el_rect.t, ovr_node_rect.t);
                  b = _min(el_rect.b, ovr_node_rect.b);
                  w = r - l;
                  h = b - t;
                  ovr_area = w * h;
                  new_xiv = (1 - (w / el_w))[TFXD](2);
                  new_yiv = (1 - (h / el_h))[TFXD](2);
                  new_iv = (1 - (ovr_area / el_area))[TFXD](2);
                  if ((new_xiv > 0 && new_xiv < exp_rect.xiv) || (new_yiv > 0 && new_yiv < exp_rect.yiv)) {
                    exp_rect.xiv = new_xiv;
                    exp_rect.yiv = new_yiv;
                    exp_rect.iv = new_iv;
                  }
                }
              }
            }
          })();
        }
        return exp_rect;
      };

      /*
      Find any HTMLElements that are covering a given HTMLElement.
      
      @name $sf.lib.dom.overlaps
      @public
      @static
      @function
      @param {HTMLElement} el The HTMLElement for which to find any other elements that may be covering it.
      @param {Number} [limit] The maximum number of covering elements to return
      @returns {Array} An array of elements that are covering the given element
       */
      overlaps = function(el, limit) {
        var baseH, baseW, checkEl, curH, curW, doc, factor, h, id, idx, l, maxX, maxY, par_details, points, pt, rect, ref_par_node, ref_par_rect, ret, root, seen, t, w, x, y;
        rect = _rect(el);
        doc = _doc(el);
        root = _docNode(doc);
        t = rect.t;
        l = rect.l;
        w = rect.r - rect.l;
        h = rect.b - rect.t;
        factor = INTERSECT_FACTOR;
        ret = [];
        baseW = _round(w / factor);
        baseH = _round(h / factor);
        curW = baseW;
        curH = baseH;
        seen = {};
        par_details = {};
        points = [];
        idx = 0;
        x = void 0;
        y = void 0;
        pt = void 0;
        id = void 0;
        checkEl = void 0;
        ref_par_node = void 0;
        ref_par_rect = void 0;
        maxX = void 0;
        maxY = void 0;
        if (mgr_bounds_details) {
          par_details = mgr_bounds_details;
        } else {
          bounds(el, par_details, true);
        }
        ref_par_node = par_details.refNode;
        ref_par_rect = par_details.refRect;
        if (ref_par_rect && ref_par_node && ref_par_node !== root) {
          maxX = ref_par_rect.r;
          maxY = ref_par_rect.b;
        } else {
          maxX = l + w;
          maxY = t + h;
        }
        if (doc && root && doc[EL_FROM_PT]) {
          while (curW < w) {
            curH = baseH;
            while (curH < h) {
              x = l + curW;
              y = t + curH;
              if (x < maxX && y < maxY) {
                points.push([x, y]);
              }
              curH += baseH;
            }
            curW += baseW;
          }
          limit = _cnum(limit, points[LEN]);
          while (pt = points[idx++]) {
            checkEl = doc[EL_FROM_PT](pt[0], pt[1]);
            try {
              if (checkEl && checkEl.nodeType === 1 && checkEl !== root && checkEl !== el && !contains(el, checkEl)) {
                id = _attr(checkEl, "id");
                if (!id) {
                  id = lang.guid("geom_inter");
                  _attr(checkEl, "id", id);
                }
                if (!seen[id] && ret[LEN] < limit) {
                  seen[id] = 1;
                  ret.push(checkEl);
                }
              }
            } catch (_error) {}
          }
        }
        id = "";
        for (id in seen) {
          if (id.indexOf("geom_inter") === 0) {
            checkEl = _elt(id);
            if (checkEl) {
              _attr(checkEl, "id", null);
            }
          }
        }
        return ret;
      };

      /*
      A proxy wrapper for calling into the cross-domain messaging host fall back library
      Looks for namespace will be $sf.lib.dom.msghost_fb
      Said library is used in cases where there is not HTML5 style messaging (i.e. no postMessage method available).
      
      @name $sf.lib.dom.msghost-_call_xmsg_host_fb
      @private
      @static
      @function
      @param {String} methName The method name in the msg host library to call
      @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
      @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
      @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
      @returns {*} whatever comes back from the method
       */
      _call_xmsg_host_fb = function(methName, arg1, arg2, arg3) {
        if (!msghostfb) {
          msghostfb = dom.msghost_fb;
        }
        return methName && msghostfb && msghostfb[methName] && msghostfb[methName](arg1, arg2, arg3);
      };

      /*
      Listen for an initial HTML5 postMessage event, to validate that HTML5 style
      messaging can be used
      
      @name $sf.lib.dom.msghost-_check_html5_init
      @private
      @static
      @function
      @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
       */
      _check_html5_init = function(evt) {
        if (!canUseHTML5 && evt && evt.data === initID) {
          canUseHTML5 = true;
          dom.evtCncl(evt);
          dom[DETACH](win, MSG, _check_html5_init);
        }
      };

      /*
      Listen for onmessage events in the main window. Validate that message is for us, and if so
      pass it through to the rest of the code and cancel further handling.
      
      @name $sf.lib.dom.msghost-_handle_msg_from_outside
      @private
      @static
      @function
      @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
       */
      _handle_msg_from_outside = function(evt) {
        var cb, data, dataGUID, e, fr_win, ifr, msg_win, params, pipe, pipeGUID, ret, tgtID;
        data = evt && evt.data;
        msg_win = evt && evt.source;
        params = data && (data.indexOf(GUID) !== -1) && ParamHash(data);
        tgtID = params && params.id;
        ifr = tgtID && _elt(tgtID);
        fr_win = ifr && _ifr_view(ifr);
        pipe = tgtID && msg_pipes[tgtID];
        dataGUID = params && params[GUID];
        pipeGUID = pipe && pipe[GUID];
        cb = pipe && pipe._xmsgcb;
        ret = false;
        if (pipeGUID && dataGUID && dataGUID === pipeGUID && msg_win && fr_win && fr_win === msg_win) {
          try {
            ret = cb(params.msg);
          } catch (_error) {
            e = _error;
            ret = false;
          }
        }
        if (ret) {
          dom.evtCncl(evt);
        }
        return ret;
      };

      /*
      Send a message to a child iframe.
      
      @name $sf.lib.dom.msghost.send
      @public
      @static
      @function
      @param {String} tgtID The HTML id attribute of the iframe element for which to send a message
      @param {String} data The string of data to send to the given iframe
      @returns {Boolean} Whether or not message was send succesfully (note that this does not mean message was handled / recevied, only that sending was ok).
       */
      send_msg_to_child_iframe = function(tgtID, data) {
        var e, el, msgObj, pipe, success, w;
        pipe = tgtID && msg_pipes[tgtID];
        success = false;
        msgObj = void 0;
        w = void 0;
        el = void 0;
        e = void 0;
        if (!pipe) {
          success = _call_xmsg_host_fb("send", tgtID, data);
        } else {
          if (pipe) {
            msgObj = ParamHash();
            msgObj.msg = data;
            msgObj.guid = pipe.guid;
            if (usingHTML5()) {
              el = _elt(tgtID);
              w = _ifr_view(el);
              try {
                w[PMSG](_cstr(msgObj), pipe.srcHost || "*");
                success = true;
              } catch (_error) {
                e = _error;
                success = false;
              }
            } else {
              success = _call_xmsg_host_fb("send", tgtID, data);
            }
          }
        }
        msgObj = w = el = null;
        return success;
      };

      /*
      Get whether or not HTML5 style messaging can be used
      
      @name $sf.lib.dom.msghost.usingHTML5
      @public
      @static
      @function
      @returns {Boolean}
       */
      usingHTML5 = function() {
        return canUseHTML5;
      };

      /*
      Gets a location of the hosting page, stripped of the search hash,
      but leaving query parameters, port, host, path, etc.
       */
      _strippedEncodedLocation = function() {
        var cleaned, pos;
        cleaned = void 0;
        pos = loc.href.indexOf("#");
        if (pos > -1) {
          cleaned = loc.href.substr(0, pos);
        } else {
          cleaned = loc.href;
        }
        pos = cleaned.indexOf("?");
        if (pos > -1) {
          cleaned = cleaned.substr(0, pos);
        }
        return escape(cleaned);
      };

      /*
      Prepare an iframe in the top level window to be able to send / receive cross-domain messages
      Generally this method is called from $sf.lib.iframes.  The attrs object in question should
      represent key/value pairs of HTML attributes for the iframe. Note that the attrs object passed
      in will be modified with a new "name" property, to send information into the iframe and setup
      messaging.
      
      @name $sf.lib.dom.msghost.prep
      @public
      @static
      @function
      @param {Object} attrs Information required to set up the cross-domain messaging channel
      @param {String} attrs.id The IFRAME HTML id attribute
      @param {String} attrs.src The URL / src attribute of the IFRAME
      @param {String} [attrs.guid] The guid / signature to use to validate that messages sent/ received can be accepted. If not specified, one will be created automatically.
      @param {String} [attrs.name] The IFRAME HTML name attribute which will be used to send an intial message to the HTML document inside the IFRAME.
      @returns {Object} An object with various properties detailing the messaging pipe-line.
       */
      prep_iframe_msging = function(attrs) {
        var iframeName, locStripped, nameParams, newPipe, pipe, src, srcHost;
        pipe = null;
        iframeName = void 0;
        nameParams = void 0;
        src = void 0;
        srcHost = void 0;
        newPipe = void 0;
        locStripped = _strippedEncodedLocation();
        if (attrs) {
          iframeName = attrs.name;
          nameParams = ParamHash(iframeName);
          src = _cstr(attrs.src);
          srcHost = src && src.substring(0, src.indexOf("/", 9));
          srcHost = (srcHost.search(/http/g) !== 0 ? "" : srcHost);
          pipe = ParamHash(nameParams);
          pipe.id = attrs.id || ("iframe_" + _guid());
          pipe.src = src;
          pipe.srcHost = srcHost;
          pipe[GUID] = pipe[GUID] || _guid();
          pipe.host = locHost;
          pipe.loc = locStripped;
          pipe.proxyID = "";
          if (usingHTML5()) {
            pipe.html5 = 1;
            pipe.proxyPath = "";
          } else {
            newPipe = _call_xmsg_host_fb("prep", pipe);
            if (newPipe) {
              pipe = newPipe;
            }
          }
          attrs.name = pipe;
        }
        return pipe;
      };

      /*
      Listen for messages from an IFRAME. Note that on the host / publisher side
      this library only allows for one message handler to be attached to a given
      IFRAME.
      
      @name $sf.lib.dom.msghost.attach
      @public
      @static
      @function
      @param {HTMLElement} el The IFRAME reference to attach a listener callback too. .
      @param {Object} pipe The message pipe object created from $sf.lib.dom.msghost.prep
      @param {Function} cb The callback function to fire when a message is received
       */
      attach_iframe_msging = function(el, pipe, cb) {
        var tgtID;
        tgtID = void 0;
        if (_tagName(el) === "iframe") {
          tgtID = _attr(el, "id");
          if (tgtID && pipe && (pipe instanceof ParamHash) && tgtID === pipe.id) {
            if (usingHTML5()) {
              msg_pipes[tgtID] = pipe;
              pipe._xmsgcb = cb;
              if (!html5Bound) {
                dom[ATTACH](win, MSG, _handle_msg_from_outside);
                html5Bound = true;
              }
            } else {
              _call_xmsg_host_fb(ATTACH, el, pipe, cb);
            }
          }
        }
      };

      /*
      Detach listening for messages from an IFRAME
      
      @name $sf.lib.dom.msghost.detach
      @public
      @static
      @function
      @param {HTMLElement} el The IFRAME reference to detach a listener
       */
      detach_iframe_msging = function(el) {
        var empty, id, pipe, w;
        id = _attr(el, "id");
        pipe = id && msg_pipes[id];
        w = null;
        empty = true;
        if (!pipe) {
          _call_xmsg_host_fb(DETACH, el);
          return;
        }
        if (pipe) {
          pipe._xmsgcb = msg_pipes[id] = null;
          pipe = null;
          delete msg_pipes[id];
        }
        id = "";
        for (id in msg_pipes) {
          pipe = msg_pipes[id];
          if (pipe && pipe[GUID]) {
            empty = false;
            break;
          }
        }
        if (empty && usingHTML5() && html5Bound) {
          html5Bound = false;
          dom[DETACH](win, MSG, _handle_msg_from_outside);
        }
        el = w = pipe = null;
      };

      /*
      Fire the specifed callback out to the publisher. Note that other arguments beyond the 1st argument are passed throug to the callback.
      
      @name $sf.host-_fire_pub_callback
      @static
      @private
      @function
      @param {String} cb_name The callback name to fire
       */
      _fire_pub_callback = function(cb_name) {
        var a, args, cb_args, e, f, idx, len, ret;
        cb_args = [];
        args = arguments;
        len = args[LEN];
        idx = 0;
        f = void 0;
        ret = false;
        e = void 0;
        a = void 0;
        if (config) {
          f = config[cb_name];
          if (f) {
            while (len--) {
              a = args[idx++];
              if (a !== cb_name) {
                cb_args.push(a);
              }
            }
            try {
              ret = f.apply(null, cb_args);
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Nuke the position an report that said position took too long to render
      
      @name $sf.host-_handle_render_timeout
      @static
      @private
      @function
      @param {String} pos_id The position id that has taken too long
       */
      _handle_render_timeout = function(pos_id) {
        var pend;
        pend = pos_id && pending_ifrs[pos_id];
        if (pend) {
          clearTimeout(pend);
          nuke(pos_id);
          _fire_pub_callback(POS_MSG, "render-timeout", pos_id);
        }
        if (!_has_pending_renders()) {
          current_status = "";
        }
      };

      /*
      Clear the timer that fires every so often to update the geometry in side
      of SafeFrames
      
      @name $sf.host-_clear_geom_update_timer
      @static
      @private
      @function
       */
      _clear_geom_update_timer = function() {
        if (geom_update_timer) {
          clearTimeout(geom_update_timer);
          geom_update_timer = 0;
        }
      };

      /*
      +	 * Clear the timer that fires every so often to update the geometry in side
      +	 * of SafeFrames
      +	 *
      +	 * @name $sf.host-_clear_geom_update_timer
      +	 * @static
      +	 * @private
      +	 * @function
      +	 *
      +
       */
      _clear_focus_update_timer = function() {
        if (focus_update_timer) {
          clearTimeout(focus_update_timer);
          focus_update_timer = 0;
        }
      };
      _set_focus_update_timer = function(in_focus) {
        _clear_focus_update_timer();
        focus_update_timer = setTimeout(function() {
          _update_focus(in_focus);
        }, 2);
      };

      /*
      Set up the timer function that updates each SafeFrame with up to date geometric information
      
      @name $sf.host-_set_geom_update_timer
      @static
      @private
      @function
       */
      _set_geom_update_timer = function(is_win_scroll) {
        _clear_geom_update_timer();
        if (is_win_scroll) {
          geom_update_timer = setTimeout(_update_geom_win_scroll, GEOM_UPDATE_INTRVAL);
        } else {
          geom_update_timer = setTimeout(_update_geom_win_resize, GEOM_UPDATE_INTRVAL);
        }
      };

      /*
      Update all SafeFrames with updated geometric information
      
      @name $sf.host-_update_geom
      @static
      @private
      @function
      @param {Boolean} is_win_scroll Whether or not we are updating due to the main window being scrolled
       */
      _update_geom = function(is_win_scroll) {
        var g, id, ifr, msgObj, params, posID;
        posID = void 0;
        params = void 0;
        msgObj = void 0;
        id = void 0;
        ifr = void 0;
        g = void 0;
        for (posID in rendered_ifrs) {
          if (is_win_scroll && (posID in scroll_parents_attached)) {
            continue;
          }
          params = rendered_ifrs[posID];
          id = params && params.dest;
          ifr = id && _elt(id);
          if (ifr && params) {
            g = _build_geom(posID, ifr, true);
            msgObj = ParamHash();
            msgObj.pos = posID;
            msgObj.cmd = NOTIFY_GEOM_UPDATE;
            msgObj.geom = _es(g);
            _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
            _send_response(params, msgObj);
          }
        }
        _clear_geom_update_timer();
      };

      /*
      Update all SafeFrames with updated geometric information due to a window resize
      event.
      
      @name $sf.host-_update_geom_win_resize
      @static
      @private
      @function
       */
      _update_geom_win_resize = function() {
        _update_geom();
      };

      /*
      Update all SafeFrames with updated geometric information due to a window scroll event
      
      @name $sf.host-_update_geom_win_scroll
      @static
      @private
      @function
       */
      _update_geom_win_scroll = function() {
        _update_geom(true);
      };

      /*
      Update a SafeFrame that has new geometric information due to its parent HTML element
      scrolling.
      
      @name $sf.host-_handle_node_scroll
      @static
      @private
      @function
       */
      _handle_node_scroll = function(evt, posID, node) {
        var g, scr_handle;
        scr_handle = scroll_parents_attached[posID];
        g = void 0;
        if (scr_handle) {
          if (scr_handle.tID) {
            clearTimeout(scr_handle.tID);
            delete scr_handle.tID;
          }
          scr_handle.tID = setTimeout(function() {
            var id, ifr, msgObj, params;
            params = rendered_ifrs[posID];
            id = params && params.dest;
            ifr = id && _elt(id);
            g = void 0;
            msgObj = void 0;
            if (ifr && params) {
              g = _build_geom(posID, ifr, true);
              msgObj = ParamHash();
              msgObj.pos = posID;
              msgObj.cmd = NOTIFY_GEOM_UPDATE;
              msgObj.geom = _es(g);
              _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
              _send_response(params, msgObj);
            }
            delete scr_handle.tID;
          }, GEOM_UPDATE_INTRVAL);
        }
      };

      /*
      Handle the window onscroll event, eventually leading to a geometric update
      
      @name $sf.host-_handle_win_geom_scroll
      @static
      @private
      @function
      @param {HTMLEvent} evt The raw event object
       */
      _handle_win_geom_scroll = function(evt) {
        _set_geom_update_timer(1);
      };

      /*
      Handle the window onresize event, eventually leading to a geometric update
      once the window events are slowed down
      
      @name $sf.host-_handle_win_geom_resize
      @static
      @private
      @function
      @param {HTMLEvent} evt The raw event object
       */
      _handle_win_geom_resize = function(evt) {
        _set_geom_update_timer();
      };

      /*
      Update all SafeFrames with updated focus information
      
      @name $sf.host-_update_focus
      @static
      @private
      @function
      @param {Boolean} in_focus True when the window has gained focus
       */
      _update_focus = function(in_focus) {
        var data, id, ifr, msgObj, params, posID;
        posID = void 0;
        params = void 0;
        msgObj = void 0;
        id = void 0;
        ifr = void 0;
        for (posID in rendered_ifrs) {
          params = rendered_ifrs[posID];
          id = params && params.dest;
          ifr = id && _elt(id);
          if (ifr && params) {
            msgObj = ParamHash();
            data = ParamHash();
            msgObj.pos = posID;
            msgObj.cmd = data.cmd = NOTIFY_FOCUS_CHANGE;
            msgObj.value = in_focus;
            _fire_pub_callback(POS_MSG, posID, NOTIFY_FOCUS_CHANGE, in_focus);
            _send_response(params, msgObj);
          }
        }
        _clear_focus_update_timer();
      };

      /*
      Handle the window focus event, which notifies ads of the change
       */
      _handle_win_focus = function(evt) {
        _set_focus_update_timer(true);
      };

      /*
      Handle the window blur event, which notifies ads of the change
       */
      _handle_win_blur = function(evt) {
        _set_focus_update_timer(false);
      };

      /*
      Handle the window unload event, clearing up our state
      
      @name $sf.host-_handle_unload
      @static
      @private
      @function
      @param {HTMLEvent} evt The raw event object
       */
      _handle_unload = function(evt) {
        var e, prop, scr_handle;
        prop = void 0;
        scr_handle = void 0;
        e = void 0;
        _clear_geom_update_timer();
        try {
          dom.detach(win, SCROLL, _handle_win_geom_scroll);
          dom.detach(win, "resize", _handle_win_geom_resize);
          dom.detach(win, "unload", _handle_unload);
          dom.detach(win, "focus", _handle_win_focus);
          dom.detach(win, "blur", _handle_win_blur);
          for (prop in scroll_parents_attached) {
            scr_handle = scroll_parents_attached[prop];
            if (scr_handle) {
              if (scr_handle.tID) {
                clearTimeout(scr_handle.tID);
              }
              dom.detach(scroll_parents_attached[prop], SCROLL, scr_handle[ONSCROLL]);
              scr_handle[ONSCROLL] = scr_handle.node = null;
            }
            scroll_parents_attached[prop] = null;
            delete scroll_parents_attached[prop];
          }
          win_events_attached = false;
        } catch (_error) {}
      };

      /*
      Handle the window message event, passed from raw event handling of the msghost code.
      Pass through the data to our format handling functions for expand, etc.
      
      @name $sf.host-_handle_msg_evt
      @static
      @private
      @function
      @param {String|Object} data the message to be handled
      @return {Boolean} return whether or not the message was handled
       */
      _handle_msg_evt = function(data) {
        var canRead, canWrite, info, msgObj, ret;
        msgObj = void 0;
        ret = false;
        info = void 0;
        msgObj = ParamHash(data, null, null, true, true);
        if (msgObj && msgObj.pos) {
          info = rendered_ifrs[msgObj.pos];
          if (info) {
            ret = (function() {
              switch (msgObj.cmd) {
                case "exp-push":
                  _expand_safeframe(msgObj, true);
                  return true;
                case "exp-ovr":
                  _expand_safeframe(msgObj);
                  return true;
                case "collapse":
                  _collapse_safeframe(msgObj);
                  return true;
                case "msg":
                case "clicked":
                case "viewed":
                case "requested":
                case "unviewed":
                case "reload":
                  _fire_pub_callback(POS_MSG, msgObj.pos, msgObj.cmd, msgObj.msg);
                  _send_generic_response(msgObj.pos, msgObj.cmd);
                  return true;
                case "loaded":
                  _fire_pub_callback("onAdLoad", msgObj.pos, msgObj);
                  _send_generic_response(msgObj.pos, msgObj.cmd);
                  return true;
                case ERROR_COMMAND:
                  _record_error(msgObj);
                  return true;
                case NOTIFY_GEOM_UPDATE:
                  sf.lib.logger.log("Geom update complete: " + msgObj.pos);
                  return true;
                case "read-cookie":
                  canRead = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                  if (canRead) {
                    _read_cookie(msgObj);
                    _fire_pub_callback("onCookieRead", msgObj.pos, msgObj.cookie);
                    return true;
                  } else {
                    return false;
                  }
                  break;
                case "write-cookie":
                  canWrite = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                  if (canWrite) {
                    _write_cookie(msgObj);
                    _fire_pub_callback("onCookieWrite", msgObj.pos, msgObj.cookie);
                    return true;
                  } else {
                    return false;
                  }
              }
            })();
          }
        }
        return ret;
      };

      /*
      Check whether or not there are any SafeFrames being rendered
      
      @name $sf.host-_has_pending_renders
      @static
      @private
      @function
       */
      _has_pending_renders = function() {
        var all_renders_done, pos_id;
        all_renders_done = true;
        pos_id = void 0;
        for (pos_id in pending_ifrs) {
          all_renders_done = false;
          break;
        }
        return all_renders_done;
      };

      /*
      Send a response back down to the SafeFrame after a message was handled
      
      @name $sf.host-_send_response
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} params The parameters object stored for a rendered SafeFrame holding state information
      @param {$sf.lib.lang.ParamHash} msgObj The message to send back down into the SafeFrame
       */
      _send_response = function(params, msgObj) {

        /*
        @ignore
         */
        current_status = "sending-msg-down-" + msgObj.cmd;
        setTimeout((function() {
          var id;
          id = params && params.dest;
          if (id && msgObj) {
            send_msg_to_child_iframe(id, msgObj.toString());
          }
          current_status = "";
          msgObj = id = params = null;
        }), XCOM_RESP_DELAY);
      };

      /*
      Handle the onload event from the IFRAME tag created for a SafeFrame.
      Note that b/c we used our own library to create the IFRAME ($sf.lib.dom.iframes),
      the "this" keyword will now properly point to the IFRAME in question.
      
      @name $sf.host-_handle_frame_load
      @private
      @static
      @function
       */
      _handle_frame_load = function() {
        var all_renders_done, el, pos_id;
        el = this;
        pos_id = dom.attr(el, "_pos_id");
        all_renders_done = true;
        if (pending_ifrs[pos_id]) {
          clearTimeout(pending_ifrs[pos_id]);
          delete pending_ifrs[pos_id];
          complete_ifrs[pos_id] = pos_id;
          dom.attr(el, "_pos_id", null);
          dom.attr(el, "name", null);
          el[ST].visibility = "inherit";
          el[ST].display = "block";
          _fire_pub_callback("onEndPosRender", pos_id);
        }
        if (!_has_pending_renders()) {
          current_status = "";
        }
      };

      /*
      Build an extra IFRAME to put behind any iframe that is expanding, to protect
      against painting issues in IE with window'd mode flash.
      
      @name $sf.host-_shim_frame
      @private
      @static
      @function
       */
      _shim_frame = function(id, showIt, w, h, z) {
        var ifr, shmFrm, shmID;
        if (!isIE) {
          return;
        }
        ifr = _elt(id);
        shmID = "shm_" + id;
        shmFrm = _elt(shmID);
        if (showIt) {
          if (shmFrm) {
            shmFrm[ST].visibility = "visible";
            return;
          }
          shmFrm = iframes.clone(ifr, {
            id: shmID,
            src: "",
            name: shmID
          }, [WIDTH, ":", w, PX, ";position:absolute;", HEIGHT, ":", h, PX, ";z-index:", z - 1, ";filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0)"]);
          dom.append(_par(ifr), shmFrm);
        } else {
          if (!showIt && shmFrm) {
            shmFrm[ST].visibility = "hidden";
          }
        }
      };

      /*
      Build a geometry info object for a particular SafeFrame position, and also
      may attach an onscroll event listener to a parent HTML element if said parent element
      is scrollable but not the root document node / body
      
      @name $sf.host-_build_geom
      @private
      @static
      @function
      @return {Object} With information about the geometry around a given SafeFrame
       */
      _build_geom = function(posID, dest, dont_attach_scroll_evt) {
        var details, e, ex, info, new_ref_node, node, s, scr_handle;
        bounds = void 0;
        info = ParamHash();
        details = {};
        scr_handle = void 0;
        node = void 0;
        new_ref_node = void 0;
        ex = void 0;
        s = void 0;
        e = void 0;
        try {
          bounds = dom.bounds(dest, details, true);
          if (!dont_attach_scroll_evt && !details.isRoot && details.canScroll) {
            ex = details.expRect;
            if (ex.xs || ex.ys) {
              scr_handle = scroll_parents_attached[posID];
              new_ref_node = details.refNode;
              if (scr_handle && scr_handle.node !== new_ref_node) {
                if (scr_handle.tID) {
                  clearTimeout(scr_handle.tID);
                }
                dom.detach(node, SCROLL, scr_handle[ONSCROLL]);
                scr_handle.node = scr_handle[ONSCROLL] = null;
                scroll_parents_attached[posID] = null;
                delete scroll_parents_attached[posID];
              }
              if (!scroll_parents_attached[posID]) {
                scr_handle = {};
                scr_handle.node = new_ref_node;

                /*
                @ignore
                 */
                scr_handle[ONSCROLL] = function(evt) {
                  _handle_node_scroll(evt, posID);
                };
                scroll_parents_attached[posID] = scr_handle;
                dom.attach(new_ref_node, SCROLL, scr_handle[ONSCROLL]);
              }
            }
          }
        } catch (_error) {
          e = _error;
          info = null;
        }
        try {
          if (info) {
            info.win = ParamHash(dom.winRect());
            info.par = ParamHash(details.refRect);
            ex = ParamHash(details.expRect);
            s = ParamHash(details.rect);
            s.iv = ex.iv;
            s.xiv = ex.xiv;
            s.yiv = ex.yiv;
            delete ex.iv;
            delete ex.xiv;
            delete ex.yiv;
            info.exp = ex;
            info.self = s;
          }
        } catch (_error) {
          e = _error;
          info = null;
        }
        return info;
      };

      /*
      Expands a given SafeFrame based on a command from the 3rd party content
      
      @name $sf.host-_expand_safeframe
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj Details about how to do the expansion
      
      TODO, handle omni-directional and push
       */
      _expand_safeframe = function(msgObj, push) {
        var b, delta, dx, dy, exp, id, ifr, ifrSt, l, nHt, nWd, orHt, orWd, par, parSt, params, params_conf, posID, r, scr_handle, t, xn, yn, z;
        xn = false;
        yn = false;
        posID = msgObj && msgObj.pos;
        params = void 0;
        params_conf = void 0;
        ifr = void 0;
        par = void 0;
        ifrSt = void 0;
        parSt = void 0;
        orWd = void 0;
        orHt = void 0;
        dx = void 0;
        dy = void 0;
        nWd = void 0;
        nHt = void 0;
        id = void 0;
        t = void 0;
        l = void 0;
        r = void 0;
        b = void 0;
        exp = void 0;
        z = void 0;
        delta = void 0;
        scr_handle = void 0;
        if (!posID) {
          return;
        }
        params = rendered_ifrs[posID];
        params_conf = params && params.conf;
        if (!params || !params_conf) {
          return;
        }
        id = params.dest;
        ifr = _elt(id);
        par = _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
        if (!ifr || !par) {
          return;
        }
        ifrSt = ifr[ST];
        parSt = par[ST];
        if (!ifrSt) {
          return;
        }
        scr_handle = scroll_parents_attached[posID];
        if (scr_handle && scr_handle.tID) {
          clearTimeout(scr_handle.tID);
        }
        _clear_geom_update_timer();
        exp = msgObj.exp_obj;
        orWd = params_conf.w;
        orHt = params_conf.h;
        if (!exp) {
          dx = params.dx = _cnum(msgObj.dx);
          dy = params.dy = _cnum(msgObj.dy);
          xn = dx < 0;
          yn = dy < 0;
          nWd = (xn ? orWd + (dx * -1) : orWd + dx);
          nHt = (yn ? orHt + (dy * -1) : orHt + dy);
        } else {
          t = _cnum(exp.t, 0, 0);
          l = _cnum(exp.l, 0, 0);
          r = _cnum(exp.r, 0, 0);
          b = _cnum(exp.b, 0, 0);
          nWd = _cnum(orWd + l + r, 0, 0);
          nHt = _cnum(orHt + t + b, 0, 0);
          if (t) {
            dy = t * -1;
            yn = true;
          } else {
            dy = 0;
          }
          if (l) {
            dx = l * -1;
            xn = true;
          } else {
            dx = 0;
          }
        }
        if (nWd <= orWd && nHt <= orHt) {
          return;
        }
        if (_fire_pub_callback(BF_POS_MSG, posID, EXPAND_COMMAND, dx, dy)) {
          return;
        }
        ifrSt[WIDTH] = nWd + PX;
        ifrSt[HEIGHT] = nHt + PX;
        if (xn) {
          ifrSt.left = dx + PX;
        }
        if (yn) {
          ifrSt.top = dy + PX;
        }
        z = _cnum(params.z, 0);
        if (!z) {
          z = DEFAULT_ZINDEX;
        }
        ifrSt.zIndex = z;
        _shim_frame(id, true, nWd, nHt, z - 1);
        if (push) {
          parSt[WIDTH] = nWd + PX;
          parSt[HEIGHT] = nHt + PX;
        } else {
          parSt[WIDTH] = orWd + PX;
          parSt[HEIGHT] = orHt + PX;
        }
        params.expanded = true;
        msgObj.dx = dx;
        msgObj.dy = dy;
        msgObj.w = nWd;
        msgObj.h = nHt;
        msgObj.cmd = "expand";
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        _fire_pub_callback(POS_MSG, posID, EXPAND_COMMAND, dx, dy);
        _send_response(params, msgObj);
        ifrSt = par = ifr = params = msgObj = null;
      };

      /*
      Collapse a SafeFrame after it has been expanded
      
      @name $sf.host-_collapse_safeframe
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame to collapse
      @param {Boolean} [isOutside] Whether or not the collapse command came from the publisher
      @param {Boolean} [noMsging] Whether or not to send a message of response back to the SafeFrame being collapsed
       */
      _collapse_safeframe = function(msgObj, isOutside, noMsging) {
        var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
        ifrSt = ifr && ifr[ST];
        parSt = par && par[ST];
        scr_handle = void 0;
        if (!posID || !params || !ifr || !par) {
          return;
        }
        if (!params.expanded) {
          return;
        }
        scr_handle = scroll_parents_attached[posID];
        if (scr_handle && scr_handle.tID) {
          clearTimeout(scr_handle.tID);
        }
        _clear_geom_update_timer();
        if (!noMsging) {
          if (_fire_pub_callback(BF_POS_MSG, posID, COLLAPSE_COMMAND, 0, 0)) {
            return;
          }
        }
        ifrSt.left = ifrSt.top = "0px";
        parSt[WIDTH] = ifrSt[WIDTH] = params_conf.w + PX;
        parSt[HEIGHT] = ifrSt[HEIGHT] = params_conf.h + PX;
        ifrSt.zIndex = params.dx = params.dy = 0;
        _shim_frame(id);
        if (!noMsging) {
          _fire_pub_callback(POS_MSG, posID, COLLAPSE_COMMAND, 0, 0);
          msgObj.cmd = (isOutside ? "collapsed" : "collapse");
          msgObj.geom = _es(_build_geom(posID, ifr, true));
          _send_response(params, msgObj);
        }
        ifr = ifrSt = par = parSt = params = msgObj = null;
      };

      /*
      Records a reported error message to $sf.info.errors and fires any listeners
      
      @name $sf.host-_record_error
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame having an error
       */
      _record_error = function(msgObj) {
        var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
        ifrSt = ifr && ifr[ST];
        parSt = par && par[ST];
        scr_handle = void 0;
        if (sf && sf.info && sf.info.errs) {
          sf.info.errs.push(msgObj);
        }
        _fire_pub_callback(POS_MSG, posID, ERROR_COMMAND, msgObj);
      };

      /*
      Returns the current document cookies as a hash
      @name $sf.lib._cookieHash
      @private
      @static
      @function
      @returns {Object}
       */
      _cookieHash = function() {
        var c, cookies, cooks, i, key;
        cooks = void 0;
        key = void 0;
        i = void 0;
        cookies = {};
        c = void 0;
        cooks = document.cookie.split("; ");
        i = cooks.length - 1;
        while (i >= 0) {
          c = cooks[i].split("=");
          cookies[c[0]] = c[1];
          i--;
        }
        return cookies;
      };

      /*
      Read a host domain cookie
      
      @name $sf.host-_read_cookie
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
      @param {Boolean} [isOutside] Whether or not the read-cookie command came from the publisher
       */
      _read_cookie = function(msgObj, isOutside) {
        var canRead, command, cookies, id, ifr, key, params, params_conf, posID;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        key = void 0;
        cookies = void 0;
        command = "read-cookie";
        canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
        if (!canRead) {
          return;
        }
        if (!posID || !params || !ifr) {
          return;
        }
        key = msgObj.cookie;
        if (!key) {
          return;
        }
        cookies = _cookieHash();
        _fire_pub_callback(POS_MSG, command, posID, 0, 0);
        msgObj.cmd = command;
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        msgObj.value = cookies[key];
        _send_response(params, msgObj);
        ifr = params = msgObj = null;
      };

      /*
      Write a host domain cookie
      
      @name $sf.host-_write_cookie
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
      @param {Boolean} [isOutside] Whether or not the write-cookie command came from the publisher
       */
      _write_cookie = function(msgObj, isOutside) {
        var c_value, canRead, command, cookies, exdate, id, ifr, key, newCookies, newValue, params, params_conf, posID;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        key = void 0;
        newValue = void 0;
        cookies = void 0;
        newCookies = void 0;
        command = "write-cookie";
        canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
        if (!canRead) {
          return;
        }
        if (!posID || !params || !ifr) {
          return;
        }
        key = msgObj.cookie;
        if (!key) {
          return;
        }
        newValue = escape(msgObj.value);
        if (msgObj.expires) {
          exdate = new Date(_cnum(msgObj.expires));
        } else {
          exdate = new Date();
          exdate.setDate(exdate.getDate() + 1);
        }
        c_value = newValue + "; path=/; expires=" + exdate.toUTCString();
        document.cookie = key + "=" + c_value;
        _fire_pub_callback(POS_MSG, command, posID, 0, 0);
        msgObj.cmd = command;
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        msgObj.info = newValue;
        msgObj.value = "";
        _send_response(params, msgObj);
        ifr = params = msgObj = null;
      };

      /*
      Remove / destroy one or more SafeFrames from the publisher page
      
      @name $sf.host.nuke
      @static
      @function
      @public
      @param {String} pos_id* One or more position ids to remove from the page. If no arguments are specifed, all positions currently rendered are removed.
       */
      nuke = function() {
        var args, el, el_id, empty, idx, par, pos, pos_id, sb_rel;
        idx = 0;
        empty = true;
        args = arguments;
        pos_id = void 0;
        pos = void 0;
        el_id = void 0;
        el = void 0;
        sb_rel = void 0;
        par = void 0;
        if (!args[LEN] || args[idx] === "*") {
          args = [];
          for (pos_id in rendered_ifrs) {
            args.push(pos_id);
          }
        }
        while (pos_id = args[idx++]) {
          pos = rendered_ifrs[pos_id];
          if (pos) {
            if (pos_id in pending_ifrs) {
              clearTimeout(pending_ifrs[pos_id]);
              delete pending_ifrs[pos_id];
            }
            if (pos_id in complete_ifrs) {
              delete complete_ifrs[pos_id];
            }
            el_id = pos.dest;
            el = el_id && _elt(el_id);
            par = el && _par(el);
            if (dom.attr(par, "id").indexOf(POS_REL_BOX_ID_PREFIX) !== -1) {
              sb_rel = par;
              par = _par(sb_rel);
            }
            dom.purge(el);
            if (sb_rel) {
              dom.purge(sb_rel);
            }
            rendered_ifrs[pos_id] = null;
            delete rendered_ifrs[pos_id];
            el = dom.make("div");
            dom.attr(el, "id", el_id);
            dom.append(par, el);
          }
        }
        pos_id = "";
        for (pos_id in rendered_ifrs) {
          empty = false;
          break;
        }
        if (empty) {
          current_status = "";
          _handle_unload();
        }
      };

      /*
      Render one or more $sf.host.Position objects into the page
      
      @name $sf.host.render
      @public
      @static
      @function
      @param {$sf.host.Position} pos* An instance of an $sf.host.Position object to render. Note that said object must have a corresponding $sf.host.PosConfig, as well as $sf.host.Config must have been set
       */
      render = function() {
        var args, css_txt, dest_el, dest_id, dest_rel_id, e, finalCSSEnd, finalCSSPos, firstCSSPos, h, idx, name_params, new_dest_el, par_el, pend, pos, pos_conf, pos_id, rel_el, st, w;
        idx = 0;
        args = arguments;
        firstCSSPos = "relative";
        finalCSSPos = "absolute";
        finalCSSEnd = "top:0px;left:0px;visibility:hidden;display:none;";
        pos = void 0;
        pos_id = void 0;
        pos_conf = void 0;
        dest_el = void 0;
        new_dest_el = void 0;
        rel_el = void 0;
        par_el = void 0;
        name_params = void 0;
        dest_id = void 0;
        dest_rel_id = void 0;
        css_txt = void 0;
        w = void 0;
        h = void 0;
        st = void 0;
        e = void 0;
        pend = void 0;
        if (!config) {
          return false;
        }
        if (!dom.ready()) {
          dom.wait(function() {
            render.apply(null, args);
            args = null;
          });
          return null;
        }
        if ((args[0] instanceof Array) && args[LEN] === 1) {
          args = args[0];
        }
        while (pos = args[idx++]) {
          pos_id = pos.id;
          pos_conf = (pos_id ? config.positions[pos_id] : null);
          if (pos_conf) {
            dest_id = pos_conf.dest;
            dest_el = dest_id && _elt(dest_id);
            if (dest_el) {
              w = pos_conf.w;
              h = pos_conf.h;
              if (!w) {
                try {
                  w = dest_el.offsetWidth;
                } catch (_error) {
                  e = _error;
                  w = 0;
                }
                if (w) {
                  pos_conf.w = w;
                }
              }
              if (!h) {
                try {
                  h = dest_el.offsetHeight;
                } catch (_error) {
                  e = _error;
                  h = 0;
                }
                if (h) {
                  pos_conf.h = h;
                }
              }
              if (w && h) {
                name_params = new ParamHash();
                dest_rel_id = POS_REL_BOX_ID_PREFIX + "_" + pos_id;
                rel_el = _elt(dest_rel_id);
                par_el = _par(dest_el);
                if (rel_el && par_el === rel_el) {
                  par_el = _par(rel_el);
                }
                _shim_frame(dest_id);

                /*
                @ignore
                 */
                pend = pending_ifrs[pos_id];
                if (pend) {
                  clearTimeout(pend);
                }
                pend = complete_ifrs[pos_id];
                if (pend) {
                  delete complete_ifrs[pos_id];
                }
                pending_ifrs[pos_id] = setTimeout(function() {
                  _handle_render_timeout(pos_id);
                }, config.to);
                current_status = "rendering";
                _fire_pub_callback("onStartPosRender", pos_id, pos_conf, pos);
                css_txt = ["position:", "", ";z-index:0;", WIDTH, ":", w, PX, ";", HEIGHT, ":", h, PX, ";", "visibility:inherit;"];
                if (!rel_el) {
                  css_txt[1] = firstCSSPos;
                  rel_el = dom.make("div");
                  rel_el.id = dest_rel_id;
                  rel_el.className = "iab_sf";
                  new_dest_el = dest_el.cloneNode(false);
                  dom.css(new_dest_el, css_txt);
                  rel_el.appendChild(new_dest_el);
                  dom.css(rel_el, css_txt);
                  par_el.replaceChild(rel_el, dest_el);
                  dest_el = _elt(dest_id);
                } else {
                  st = rel_el[ST];
                  st.width = w + PX;
                  st.height = h + PX;
                  st = dest_el && dest_el[ST];
                  st.width = w + PX;
                  st.height = h + PX;
                }
                name_params.id = pos_id;
                name_params.dest = dest_id;
                name_params.conf = ParamHash(pos_conf);
                name_params.meta = pos.meta.toString();
                name_params.html = _es(pos.html);
                name_params.geom = _es(_build_geom(pos_id, dest_el));
                name_params.src = pos_conf.renderFile || config.renderFile;
                name_params.has_focus = lang.cstr(document.hasFocus());
                css_txt[1] = finalCSSPos;
                css_txt[13] = finalCSSEnd;
                if (!win_events_attached) {
                  dom.attach(win, SCROLL, _handle_win_geom_scroll);
                  dom.attach(win, "resize", _handle_win_geom_resize);
                  dom.attach(win, "unload", _handle_unload);
                  dom.attach(win, "focus", _handle_win_focus);
                  dom.attach(win, "blur", _handle_win_blur);
                  win_events_attached = true;
                }
                iframes.replace({
                  id: dest_id,
                  name: name_params,
                  src: pos_conf.renderFile || config.renderFile,
                  _pos_id: pos_id
                }, css_txt, rel_el, _handle_frame_load, _handle_msg_evt);
                rendered_ifrs[pos_id] = name_params;
              }
            }
          }
        }
      };

      /*
      Gets a copy of the Position configuration, content, and meta data for a given SafeFrame
      
      @name $sf.host.get
      @public
      @function
      @static
      @return {Object}
       */
      get = function(positionId) {
        var obj;
        obj = rendered_ifrs[positionId];
        if (!obj) {
          return null;
        }
        return _mix({}, obj);
      };

      /*
      Returns a string as to whether or not the library is busy, empty string is returned on idle
      
      @name $sf.host.status
      @public
      @function
      @static
      @return {String}
       */
      status = function() {
        return current_status;
      };
      _send_generic_response = function(posID, command) {
        var msgObj, params;
        msgObj = new ParamHash();
        params = posID && rendered_ifrs[posID];
        msgObj.cmd = command;
        msgObj.pos = posID;
        return _send_response(params, msgObj);
      };
      _getGeom = function(posID) {
        var g, id, ifr, params;
        params = rendered_ifrs[posID];
        id = params && params.dest;
        ifr = id && _elt(id);
        g = _build_geom(posID, ifr, true);
        return g;
      };
      inViewPercentage = function(posID) {
        var geom_info, iv, tv, _ref;
        geom_info = _getGeom(posID);
        iv = _cnum(geom_info != null ? (_ref = geom_info.self) != null ? _ref.iv : void 0 : void 0, -1, 0);
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      if (lang) {
        if (win === top || allowNotTop) {
          _rect = (ieVer ? _getRectIE : _getRectNonIE);
          _mix(dom, {
            rect: _rect,
            currentStyle: currentStyle,
            contains: contains,
            docRect: docRect,
            winRect: winRect,
            bounds: bounds,
            overlaps: overlaps
          });

          /*
          @ignore
           */
          (function() {
            var e;
            e = void 0;
            dom.msghost = {
              prep: prep_iframe_msging,
              attach: attach_iframe_msging,
              detach: detach_iframe_msging,
              usingHTML5: usingHTML5,
              send: send_msg_to_child_iframe
            };
            dom[ATTACH](win, MSG, _check_html5_init);
            initID = "xdm-html5-init-" + _guid();
            locHost = (locHost.indexOf("file") === 0 ? locHost = "file" : locHost);
            try {
              win[PMSG](initID, (locHost === "file" ? "*" : locHost));
            } catch (_error) {
              e = _error;
              dom[DETACH](win, MSG, _check_html5_init);
            }
          })();
          _mix(sf.host, {
            Config: Config,
            PosConfig: PosConfig,
            PosMeta: PosMeta,
            Position: Position,
            nuke: nuke,
            get: get,
            render: render,
            status: status,
            inViewPercentage: inViewPercentage
          });
        }
      }
      if (allowNotTop) {
        window["$sf"] = sf;
      }
      return sf;
    })(window, sf);
  };

}).call(this);

},{"./boot":17}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":20,"./env":21,"./lang":22,"./logger":23}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":21,"./lang":22}],21:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./lang":22,"8DwohR":33}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, jsunsafe_html, k, keys, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, v, win, wrap, _es, _ref, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityMap.unescape = {};
    _ref = entityMap.escape;
    for (k in _ref) {
      v = _ref[k];
      entityMap.unescape[v] = k;
    }
    entityRegexes = {
      escape: new RegExp('[' + keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + keys(entityMap.unescape).join('|') + ')', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ("" + str).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };
    jsunsafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ("" + str).replace(entityRegexes.unescape, function(match) {
        return entityMap.unescape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      jsunsafe_html: jsunsafe_html,
      isArray: isArray,
      wrap: wrap,
      keys: keys
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],24:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":25,"ieee754":26}],25:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],26:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],27:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":24}],28:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":29,"./rng":30,"./sha":31,"./sha256":32,"buffer":24}],29:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":27}],30:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],31:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":27}],32:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":27}],33:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3B1Ymxpc2hlci5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3B1Ymxpc2hlci9zbG90LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL2FkX3JlcXVlc3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvYmFzZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9jb25maWcuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvZW5nYWdlbWVudC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9ldmVudC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9wYWdlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL3NpemVzLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL3V0aWxzLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvY29va2llcy1qcy9zcmMvY29va2llcy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL2pzb24vanNvbjIuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvbm9kZS11dWlkL3V1aWQuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9yZXF3ZXN0L3JlcXdlc3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL2hvc3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL2hvc3QvYm9vdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvaG9zdC9ob3N0LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvYmFzZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2RvbS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2Vudi5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2xhbmcuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9sb2dnZXIuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9oZWxwZXJzLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvbWQ1LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3NoYS5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhMjU2LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqK0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1akNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBBZEpTLCBBZFJlcXVlc3QsIFBhZ2UsIGNvbmZpZywgZW5nYWdlbWVudCwgc2YsIHV0aWxzO1xuXG4gIGlmICghd2luZG93W1wiJHNmXCJdKSB7XG4gICAgc2YgPSByZXF1aXJlKCdzYWZlZnJhbWUnKTtcbiAgfVxuXG4gIGVuZ2FnZW1lbnQgPSByZXF1aXJlKCcuL3NoYXJlZC9lbmdhZ2VtZW50Jyk7XG5cbiAgUGFnZSA9IHJlcXVpcmUoJy4vc2hhcmVkL3BhZ2UnKTtcblxuICBBZEpTID0gcmVxdWlyZSgnLi9wdWJsaXNoZXIvc2xvdCcpO1xuXG4gIGNvbmZpZyA9IHJlcXVpcmUoJy4vc2hhcmVkL2NvbmZpZycpO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi9zaGFyZWQvdXRpbHMnKTtcblxuICBBZFJlcXVlc3QgPSByZXF1aXJlKCcuL3NoYXJlZC9hZF9yZXF1ZXN0Jyk7XG5cbiAgKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBjb250cm9sbGVyVXJsLCBkb1JlbmRlciwgaW5pdFNhZmVGcmFtZSwgcGFnZUR1cmF0aW9uLCBwYWdlTG9hZE1zLCByZW5kZXJDb250cm9sbGVyLCBzYWZlZnJhbWVVcmwsIHNlc3Npb25PYmosIHNmRG9tLCBzdGFydFRpY2tzO1xuICAgIHNlc3Npb25PYmogPSBuZXcgUGFnZSgpO1xuICAgIHN0YXJ0VGlja3MgPSB1dGlscy5ub3coKTtcbiAgICBwYWdlTG9hZE1zID0gMDtcbiAgICBwYWdlRHVyYXRpb24gPSAwO1xuICAgIHNhZmVmcmFtZVVybCA9IGNvbmZpZy5jZG5fdXJsO1xuICAgIGNvbnRyb2xsZXJVcmwgPSBjb25maWcuY29udHJvbGxlcl91cmw7XG4gICAgc2ZEb20gPSAkc2YubGliLmRvbTtcbiAgICBzZkRvbS5hdHRhY2goXCJiZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBwYWdlRHVyYXRpb24gPSB1dGlscy5ub3coKSAtIHN0YXJ0VGlja3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBkb1JlbmRlciA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgZCwgZGl2LCBkaXZzLCBzZlBvc2l0aW9ucywgX2ksIF9sZW47XG4gICAgICBzZlBvc2l0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFzZkRvbS5yZWFkeSgpKSB7XG4gICAgICAgIHNmRG9tLndhaXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgICAgcGFnZUxvYWRNcyA9IHV0aWxzLm5vdygpIC0gc3RhcnRUaWNrcztcbiAgICAgICAgICBkb1JlbmRlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gYXJncyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyQ29udHJvbGxlcigpO1xuICAgICAgICBkaXZzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBkaXYgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGl2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGRpdnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBkID0gZGl2c1tfaV07XG4gICAgICAgICAgaWYgKHNmRG9tLmF0dHIoZCwgXCJkYXRhLWFkanNcIikpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBBZEpTLmNyZWF0ZShkLCBzZXNzaW9uT2JqKTtcbiAgICAgICAgICAgIH0pKGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIgPyBjYigpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gICAgaW5pdFNhZmVGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICRzZi5ob3N0LkNvbmZpZyh7XG4gICAgICAgIHJlbmRlckZpbGU6IHdpbmRvdyA9PT0gd2luZG93LnRvcCA/IHNhZmVmcmFtZVVybCA6IGFkZnJhbWVVcmwsXG4gICAgICAgIHBvc2l0aW9uczoge30sXG4gICAgICAgIG9uU3RhcnRQb3NSZW5kZXI6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIG9uRmFpbHVyZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb25BZExvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEFkSlMoaWQpLmxvYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVQb3NNc2c6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIG9uUG9zTXNnOiBmdW5jdGlvbihpZCwgbXNnLCBjb250ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIEFkSlMoaWQpLmhhbmRsZU1lc3NhZ2UobXNnLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW5kZXJDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGl2LCBwYXJlbnQ7XG4gICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgcGFyZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIGRpdi5pZCA9IHNmLmxpYi5sYW5nLmd1aWQoXCJjb250cm9sbGVyXCIpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYXJlbnQpO1xuICAgICAgcmV0dXJuIEFkSlMoXCJjb250cm9sbGVyXCIpLmNyZWF0ZShkaXYsICcnLCB7XG4gICAgICAgIHdpZHRoOiAxMCxcbiAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgc3VwcG9ydHM6IFtcIndyaXRlLWNvb2tpZVwiLCBcInJlYWQtY29va2llXCJdLFxuICAgICAgICByZW5kZXJGaWxlOiBjb250cm9sbGVyVXJsLFxuICAgICAgICBwYWdlOiBzZXNzaW9uT2JqLnNlcmlhbGl6ZWRBdHRyaWJ1dGVzKCksXG4gICAgICAgIHBhZ2VSZWZlcnJlcjogZG9jdW1lbnQucmVmZXJyZXIsXG4gICAgICAgIGlnbm9yZUV2ZW50czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBBZEpTLnJlbmRlciA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgYWRKc1NjcmlwdCwgY2xpZW50SWQsIHM7XG4gICAgICBhZEpzU2NyaXB0ID0gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBzID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKHNmRG9tLmF0dHIocywgXCJkYXRhLWFkanNcIikpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpWzBdO1xuICAgICAgY2xpZW50SWQgPSBzZkRvbS5hdHRyKGFkSnNTY3JpcHQsIFwiZGF0YS1jbGllbnQtaWRcIik7XG4gICAgICBzZXNzaW9uT2JqLnNldCh7XG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50SWRcbiAgICAgIH0pO1xuICAgICAgaW5pdFNhZmVGcmFtZSgpO1xuICAgICAgcmV0dXJuIGRvUmVuZGVyKGNiKTtcbiAgICB9O1xuICAgIGVuZ2FnZW1lbnQub25FbmdhZ2VtZW50KGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFkLCBfLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSBBZEpTLnNsb3RzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoXyBpbiBfcmVmKSB7XG4gICAgICAgIGFkID0gX3JlZltfXTtcbiAgICAgICAgaWYgKGFkLmN1cnJlbnRseUludmlldygpICYmICFhZC5lbmdhZ2VkKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChhZC5lbmdhZ2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSk7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFkSlMucmVuZGVyKCk7XG4gICAgfSkoKTtcbiAgICB3aW5kb3cuJGFkID0gQWRKUztcbiAgICByZXR1cm4gQWRKUztcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50cywgc2l6ZXMsIHV0aWxzLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgc2l6ZXMgPSByZXF1aXJlKCcuLi9zaGFyZWQvc2l6ZXMnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4uL3NoYXJlZC91dGlscycpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4uL3NoYXJlZC9ldmVudCcpKFtcInJlcXVlc3RcIiwgXCJjbGlja1wiLCBcImxvYWRcIiwgXCJ2aWV3XCIsIFwidW5sb2FkXCIsIFwiZm9jdXNcIiwgXCJlbmdhZ2VcIiwgXCJ1bmZvY3VzXCIsIFwiZXhwYW5kXCIsIFwiY29sbGFwc2VcIiwgXCJyZWZyZXNoZWRcIiwgXCJjb29raWVcIiwgXCJyZWNlaXZlXCIsIFwidW52aWV3XCIsIFwidGltZW91dFwiXSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oJHNmKSB7XG4gICAgdmFyIFNDUklQVF9SRUdFWCwgU2xvdCwgb2xkVHJpZ2dlciwgc2ZEb20sIHNsb3RzO1xuICAgIHNmRG9tID0gJHNmLmxpYi5kb207XG4gICAgc2xvdHMgPSB7fTtcbiAgICBTQ1JJUFRfUkVHRVggPSAvPCEtLShbXFxzXFxTXSopLS0+LztcbiAgICBTbG90ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gU2xvdChhZElkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlciA9IF9fYmluZCh0aGlzLnRyaWdnZXIsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNsb3QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0KGFkSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgU2xvdChhZElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBTbG90LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYWRJZCkge1xuICAgICAgICBpZiAoc2xvdHNbYWRJZF0pIHtcbiAgICAgICAgICByZXR1cm4gc2xvdHNbYWRJZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IGFkSWQ7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICBzbG90c1thZElkXSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRFdmVudHMoKTtcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLnN0YXJ0QXV0b1JlZnJlc2ggPSBmdW5jdGlvbihkZWxheSwgY2IpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICBkZWxheSA9IDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNBdXRvUmVmcmVzaGluZykge1xuICAgICAgICAgIHRoaXMuX2lzQXV0b1JlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3JlZnJlc2hJbnRlcnZhbCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9pc0F1dG9SZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5sb2FkVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZWZyZXNoKGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSh0aGlzKSwgZGVsYXkgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLnN0b3BBdXRvUmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaEludGVydmFsKTtcbiAgICAgICAgdGhpcy5faXNBdXRvUmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWZyZXNoSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihjYikge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIHRoaXMucG9zTWV0YS5zZXRWYWx1ZShcImxvYWRfblwiLCBcImV4dGVuZGVkXCIsIHRoaXMuY291bnQpO1xuICAgICAgICAkc2YuaG9zdC5yZW5kZXIodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5wb3NDb25maWcuZGVzdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNiKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICBpZiAoISgoX3JlZiA9IHRoaXMub3B0aW9ucykgIT0gbnVsbCA/IF9yZWYuaWdub3JlRXZlbnRzIDogdm9pZCAwKSkge1xuICAgICAgICAgIGV2ZW50cy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgU2xvdC50cmlnZ2VyKGV2ZW50LCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZywgY29udGVudCkge1xuICAgICAgICBzd2l0Y2ggKG1zZykge1xuICAgICAgICAgIGNhc2UgXCJmb2N1cy1jaGFuZ2VcIjpcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZ2VvbS11cGRhdGVcIjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgIGNhc2UgXCJleHBhbmRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZChjb250ZW50KTtcbiAgICAgICAgICBjYXNlIFwiY29sbGFwc2VcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlKGNvbnRlbnQpO1xuICAgICAgICAgIGNhc2UgXCJ2aWV3ZWRcIjpcbiAgICAgICAgICAgIGlmICghdGhpcy52aWV3ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInVudmlld2VkXCI6XG4gICAgICAgICAgICBpZiAoISh0aGlzLnVudmlld2VkICYmIHRoaXMudmlld2VkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjbGlja2VkXCI6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpY2tlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlcXVlc3RlZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgpO1xuICAgICAgICAgIGNhc2UgXCJjb29raWUtd3JpdGVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvb2tpZSh7XG4gICAgICAgICAgICAgIGNvb2tpZTogXCJ3cml0ZVwiLFxuICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwiY29va2llLXJlYWRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvb2tpZSh7XG4gICAgICAgICAgICAgIGNvb2tpZTogXCJyZWFkXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJyZWxvYWRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgIGNhc2UgXCJtc2dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmUoZGVjb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmluaXRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5sb2FkQ2hhaW4gPSB1dGlscy5jb3VudEZyYW1lcyh0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy52aWV3ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVuZ2FnZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZW5nYWdlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmdhZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW5nYWdlVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5RnJhbWUoXCJlbmdhZ2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudW52aWV3ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnVudmlld1RpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVubG9hZFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmxvYWRDaGFpbiA9IDA7XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLm5vdGlmeUZyYW1lID0gZnVuY3Rpb24oY21kLCBkYXRhKSB7XG4gICAgICAgIHZhciBtc2dPYmo7XG4gICAgICAgIG1zZ09iaiA9ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKTtcbiAgICAgICAgaWYgKHRoaXMucG9zQ29uZmlnKSB7XG4gICAgICAgICAgbXNnT2JqLnBvcyA9IHRoaXMucG9zQ29uZmlnLmlkO1xuICAgICAgICAgIG1zZ09iai5jbWQgPSBjbWQ7XG4gICAgICAgICAgbXNnT2JqLnZhbHVlID0gZXNjYXBlKGRhdGEpO1xuICAgICAgICAgIHJldHVybiBzZkRvbS5tc2dob3N0LnNlbmQodGhpcy5wb3NDb25maWcuZGVzdCwgbXNnT2JqLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihlbGVtLCBodG1sLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBoZWlnaHQsIHMsIHN1cHBvcnRzLCB3aWR0aCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZiwgX3JlZjE7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgd2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgZWxlbS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcHRpb25zLmhlaWdodCB8fCBlbGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgc3VwcG9ydHMgPSB7fTtcbiAgICAgICAgX3JlZiA9IHRoaXMub3B0aW9ucy5zdXBwb3J0cyB8fCBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcyA9IF9yZWZbX2ldO1xuICAgICAgICAgIHN1cHBvcnRzW3NdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfcmVmMSA9IHRoaXMub3B0aW9ucy5kaXNhYmxlcyB8fCBbXTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgcyA9IF9yZWYxW19qXTtcbiAgICAgICAgICBzdXBwb3J0c1tzXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgZWxlbS5pZCB8fCAoZWxlbS5pZCA9ICRzZi5saWIubGFuZy5ndWlkKFwicG9zXCIpKTtcbiAgICAgICAgdGhpcy5wb3NNZXRhID0gbmV3ICRzZi5ob3N0LlBvc01ldGEobnVsbCwgXCJleHRlbmRlZFwiLCB7XG4gICAgICAgICAgaW52aWV3OiB0aGlzLm9wdGlvbnMuaW52aWV3LFxuICAgICAgICAgIHBhZ2U6IHRoaXMub3B0aW9ucy5wYWdlLFxuICAgICAgICAgIGhvc3Q6IGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICAgIHJlZmVycmVyOiB0aGlzLm9wdGlvbnMucmVmZXJyZXIsXG4gICAgICAgICAgbG9jYXRpb246IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgc2xvdF9pZDogdGhpcy5pZCxcbiAgICAgICAgICBsb2FkX246IHRoaXMuY291bnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9zQ29uZmlnID0gbmV3ICRzZi5ob3N0LlBvc0NvbmZpZyh7XG4gICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgZGVzdDogZWxlbS5pZCxcbiAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICBoOiBoZWlnaHQsXG4gICAgICAgICAgc3VwcG9ydHM6IHN1cHBvcnRzLFxuICAgICAgICAgIHJlbmRlckZpbGU6IHRoaXMub3B0aW9ucy5yZW5kZXJGaWxlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvcyA9IG5ldyAkc2YuaG9zdC5Qb3NpdGlvbih0aGlzLnBvc0NvbmZpZy5pZCwgaHRtbCwgdGhpcy5wb3NNZXRhKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZyZXNoX29vdikge1xuICAgICAgICAgIHRoaXMudW52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkodGhpcyksIDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmcmVzaF90aW1lICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlZnJlc2hUaW1lID0gJHNmLmxpYi5sYW5nLmNudW0odGhpcy5vcHRpb25zLnJlZnJlc2hfdGltZSwgMCk7XG4gICAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRpbWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0QXV0b1JlZnJlc2godGhpcy5yZWZyZXNoVGltZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICRzZi5ob3N0LnJlbmRlcih0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihkb250RmlyZSkge1xuICAgICAgICBpZiAoIWRvbnRGaXJlKSB7XG4gICAgICAgICAgdGhpcy51bmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaEludGVydmFsKTtcbiAgICAgICAgdGhpcy52aWV3ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmdhZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW52aWV3ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5nYWdlVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMudW52aWV3VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5sb2FkVGltZSA9IG51bGw7XG4gICAgICAgICRzZi5ob3N0Lm51a2UodGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5ldmVudHM7XG4gICAgICAgIHJldHVybiBkZWxldGUgc2xvdHNbdGhpcy5pZF07XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnZpZXcpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSh0cnVlKTtcbiAgICAgICAgICAkc2YuaG9zdC5yZW5kZXIodGhpcy5wb3MpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5wb3NDb25maWcuZGVzdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmN1cnJlbnRseUludmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJHNmLmhvc3QuaW5WaWV3UGVyY2VudGFnZSh0aGlzLmlkKSA+IDUwICYmIHRoaXMudmlld2VkO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuaW52aWV3UGVyY2VudGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJHNmLmhvc3QuaW5WaWV3UGVyY2VudGFnZSh0aGlzLmlkKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTbG90O1xuXG4gICAgfSkoKTtcbiAgICBTbG90LmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhZCwgXywgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfIGluIHNsb3RzKSB7XG4gICAgICAgIGFkID0gc2xvdHNbX107XG4gICAgICAgIF9yZXN1bHRzLnB1c2goYWQuZGVzdHJveSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICAgIFNsb3QuZXZlbnRzID0ge307XG4gICAgb2xkVHJpZ2dlciA9IFNsb3QucHJvdG90eXBlLnRyaWdnZXI7XG4gICAgJHNmLmxpYi5sYW5nLm1peChTbG90LnByb3RvdHlwZSwgZXZlbnRzKTtcbiAgICBTbG90LnByb3RvdHlwZS50cmlnZ2VyID0gb2xkVHJpZ2dlcjtcbiAgICAkc2YubGliLmxhbmcubWl4KFNsb3QsIGV2ZW50cyk7XG4gICAgU2xvdC5jcmVhdGUgPSBmdW5jdGlvbihkLCBwYWdlKSB7XG4gICAgICB2YXIgYWRJZCwgZGlzYWJsZXMsIGRpdiwgaGVpZ2h0LCBpc0VzY2FwZWQsIHBvc0lkLCBzaXplLCBzdXBwb3J0cywgdGVtcGxhdGUsIHdpZHRoLCBfYmFzZSwgX2Jhc2UxLCBfcmVmO1xuICAgICAgdGVtcGxhdGUgPSAoKF9yZWYgPSBkLmlubmVySFRNTC5tYXRjaChTQ1JJUFRfUkVHRVgpKSAhPSBudWxsID8gX3JlZlsxXSA6IHZvaWQgMCkgfHwgZC5pbm5lckhUTUw7XG4gICAgICBpc0VzY2FwZWQgPSAkc2YubGliLmxhbmcuY2Jvb2woc2ZEb20uYXR0cihkLCBcImRhdGEtZXNjYXBlZFwiKSk7XG4gICAgICBpZiAoaXNFc2NhcGVkKSB7XG4gICAgICAgIHRlbXBsYXRlID0gJHNmLmxpYi5sYW5nLmpzdW5zYWZlX2h0bWwodGVtcGxhdGUpO1xuICAgICAgfVxuICAgICAgcG9zSWQgPSAkc2YubGliLmxhbmcuZ3VpZChcInBvc1wiKTtcbiAgICAgIGFkSWQgPSBkLmlkIHx8IHBvc0lkO1xuICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5pZCA9IHBvc0lkO1xuICAgICAgZC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgc3VwcG9ydHMgPSBbXTtcbiAgICAgIGRpc2FibGVzID0gW107XG4gICAgICBpZiAoc2l6ZSA9IHNpemVzW3NmRG9tLmF0dHIoZCwgXCJkYXRhLWFkLXR5cGVcIildKSB7XG4gICAgICAgIHdpZHRoID0gc2l6ZVswXSwgaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICAgIH1cbiAgICAgIFNsb3QoYWRJZCkuY3JlYXRlKGRpdiwgdGVtcGxhdGUsIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoIHx8IHNmRG9tLmF0dHIoZCwgXCJkYXRhLXdpZHRoXCIpLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCBzZkRvbS5hdHRyKGQsIFwiZGF0YS1oZWlnaHRcIiksXG4gICAgICAgIHN1cHBvcnRzOiB0eXBlb2YgKF9iYXNlID0gc2ZEb20uYXR0cihkLCBcImRhdGEtc3VwcG9ydHNcIikpLnNwbGl0ID09PSBcImZ1bmN0aW9uXCIgPyBfYmFzZS5zcGxpdChcIixcIikgOiB2b2lkIDAsXG4gICAgICAgIGRpc2FibGVzOiB0eXBlb2YgKF9iYXNlMSA9IHNmRG9tLmF0dHIoZCwgXCJkYXRhLWRpc2FibGVzXCIpKS5zcGxpdCA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2UxLnNwbGl0KFwiLFwiKSA6IHZvaWQgMCxcbiAgICAgICAgaW52aWV3OiAkc2YubGliLmxhbmcuY2Jvb2woc2ZEb20uYXR0cihkLCBcImRhdGEtaW52aWV3XCIpKSxcbiAgICAgICAgcmVmcmVzaF90aW1lOiBzZkRvbS5hdHRyKGQsIFwiZGF0YS1yZWZyZXNoLXRpbWVcIiksXG4gICAgICAgIHJlZnJlc2hfb292OiAkc2YubGliLmxhbmcuY2Jvb2woc2ZEb20uYXR0cihkLCBcImRhdGEtcmVmcmVzaC1vb3ZcIikpLFxuICAgICAgICBwYWdlOiBwYWdlICE9IG51bGwgPyBwYWdlLnNlcmlhbGl6ZSgpIDogdm9pZCAwLFxuICAgICAgICByZWZlcnJlcjogc2ZEb20uYXR0cihkLCBcImRhdGEtcmVmZXJyZXJcIiksXG4gICAgICAgIGlnbm9yZUV2ZW50czogJHNmLmxpYi5sYW5nLmNib29sKHNmRG9tLmF0dHIoZCwgXCJkYXRhLWlnbm9yZS1ldmVudHNcIikpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTbG90KGFkSWQpO1xuICAgIH07XG4gICAgU2xvdC5zbG90cyA9IHNsb3RzO1xuICAgIFNsb3Quc2l6ZXMgPSBzaXplcztcbiAgICByZXR1cm4gU2xvdDtcbiAgfSkoJHNmKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIEJhc2UsIGNvbmZpZyxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbiAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgQWRSZXF1ZXN0O1xuICAgIEFkUmVxdWVzdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhBZFJlcXVlc3QsIF9zdXBlcik7XG5cbiAgICAgIGZ1bmN0aW9uIEFkUmVxdWVzdChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgICAgIEFkUmVxdWVzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRQYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICAgIHVybDogd2luZG93LmRvY3VtZW50LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICByZWY6IHdpbmRvdy5kb2N1bWVudC5yZWZlcnJlcixcbiAgICAgICAgICAgIHZfanM6IGNvbmZpZy52ZXJzaW9uXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgQWRSZXF1ZXN0LnByb3RvdHlwZS5zZXJpYWxpemVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaywgb3V0QXR0cnMsIHYsIF9yZWY7XG4gICAgICAgIG91dEF0dHJzID0ge307XG4gICAgICAgIF9yZWYgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAoayBpbiBfcmVmKSB7XG4gICAgICAgICAgdiA9IF9yZWZba107XG4gICAgICAgICAgb3V0QXR0cnNba10gPSB2O1xuICAgICAgICB9XG4gICAgICAgIG91dEF0dHJzLnVybCA9IGVuY29kZVVSSUNvbXBvbmVudChvdXRBdHRycy51cmwpO1xuICAgICAgICBvdXRBdHRycy5yZWYgPSBlbmNvZGVVUklDb21wb25lbnQob3V0QXR0cnMucmVmKTtcbiAgICAgICAgcmV0dXJuIG91dEF0dHJzO1xuICAgICAgfTtcblxuICAgICAgQWRSZXF1ZXN0LnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBBZFJlcXVlc3QuX19zdXBlcl9fLmRlc2VyaWFsaXplLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICB1cmw6IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmF0dHJpYnV0ZXMudXJsKSxcbiAgICAgICAgICByZWY6IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmF0dHJpYnV0ZXMucmVmKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgQWRSZXF1ZXN0LnByb3RvdHlwZS5wYXRoID0gXCIvYWRcIjtcblxuICAgICAgQWRSZXF1ZXN0LnByb3RvdHlwZS5jb25zdGFudEZpZWxkcyA9IFtcInNpdGVfdXNlcl9pZFwiLCBcInBhZ2VfaWRcIiwgXCJ2aXNpdF9pZFwiLCBcImFkX2lkXCJdO1xuXG4gICAgICByZXR1cm4gQWRSZXF1ZXN0O1xuXG4gICAgfSkoQmFzZSk7XG4gICAgcmV0dXJuIEFkUmVxdWVzdDtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIHV0aWxzLCB1dWlkO1xuXG4gIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgQmFzZTtcbiAgICByZXR1cm4gQmFzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEJhc2UoKSB7XG4gICAgICAgIHRoaXMuaWQgPSB1dWlkLnY0KCk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyB8fCAodGhpcy5hdHRyaWJ1dGVzID0ge30pO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB7fTtcbiAgICAgIH1cblxuICAgICAgQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNoYW5nZWRBdHRyaWJ1dGVzLCBmLCBrLCB2LCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IFwiYXR0cnMgbXVzdCBiZSBhbiBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gYXR0cnMpIHtcbiAgICAgICAgICB2ID0gYXR0cnNba107XG4gICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlc1trXSAhPT0gdikge1xuICAgICAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXMucHVzaChrKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5W2tdID0gdjtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1trXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQgJiYgY2hhbmdlZEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF9yZWYgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGYgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZi5hcHBseSh0aGlzLCBbdGhpcywgY2hhbmdlZEF0dHJpYnV0ZXNdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuY2hhbmdlID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBpZiAoZiAmJiB0eXBlb2YgZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5wdXNoKGYpO1xuICAgICAgICB9IGVsc2UgaWYgKCFmKSB7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIEJhc2UucHJvdG90eXBlLl9jbGVhbkRpcnR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eSA9IHt9O1xuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuY2hhbmdlZEZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmllbGQsIGssIHBhcmFtcywgdiwgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgX3JlZiA9IHRoaXMuX2RpcnR5O1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICAgIHBhcmFtc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uc3RhbnRGaWVsZHMpIHtcbiAgICAgICAgICBfcmVmMSA9IHRoaXMuY29uc3RhbnRGaWVsZHM7XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZmllbGQgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW2ZpZWxkXSkge1xuICAgICAgICAgICAgICBwYXJhbXNbZmllbGRdID0gdGhpcy5hdHRyaWJ1dGVzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYW5EaXJ0eSgpO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50b1F1ZXJ5KHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICB9O1xuXG4gICAgICBCYXNlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQodXRpbHMuZnJvbVF1ZXJ5KHN0ciksIHtcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQmFzZTtcblxuICAgIH0pKCk7XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuRU5WID09PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBpOiAnLy9lbmRwb2ludC5hZGpzLmRldjo4MDgwLzEnLFxuICAgICAgICBjZG5fdXJsOiAnYmFzZS9saWIvaHRtbC9hZGpzZnJhbWUuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXJfdXJsOiBcImJhc2UvbGliL2h0bWwvY29udHJvbGxlcmZyYW1lLmh0bWxcIixcbiAgICAgICAgYWRfdXJsOiBcImJhc2UvbGliL2h0bWwvYWRmcmFtZS5odG1sXCIsXG4gICAgICAgIHZpc2l0X2V4cGlyeTogMC4wMyxcbiAgICAgICAgdmVyc2lvbjogXCIwLjAuMVwiLFxuICAgICAgICBkb21haW46IFwibG9jYWxob3N0XCJcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcGk6IFwiLy9hcGkuYWRqcy5uZXQvMVwiLFxuICAgICAgICBjZG5fdXJsOiBcIi8vY2RuLmFkanMubmV0L2h0bWwvYWRqc2ZyYW1lLmh0bWxcIixcbiAgICAgICAgdmlzaXRfZXhwaXJ5OiAzMCxcbiAgICAgICAgdmVyc2lvbjogXCIwLjAuMVwiLFxuICAgICAgICBkb21haW46IFwiYWRqcy5uZXRcIixcbiAgICAgICAgY29udHJvbGxlcl91cmw6IFwiLy9jZG4uYWRqcy5uZXQvaHRtbC9jb250cm9sbGVyZnJhbWUuaHRtbFwiLFxuICAgICAgICBhZF91cmw6IFwiLy9jZG4uYWRqcy5uZXQvaHRtbC9hZGZyYW1lLmh0bWxcIlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gXCJzdGFnaW5nXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogXCIvL2FwaS5hZGpzLm5ldC8xXCIsXG4gICAgICAgIGNkbl91cmw6IFwiLy9zMy5hbWF6b25hd3MuY29tL2pzLmFkanNkZW1vLmNvbS9odG1sL2FkanNmcmFtZS5odG1sXCIsXG4gICAgICAgIHZpc2l0X2V4cGlyeTogMzAsXG4gICAgICAgIHZlcnNpb246IFwiMC4wLjFcIixcbiAgICAgICAgZG9tYWluOiBcInMzLmFtYXpvbmF3cy5jb21cIixcbiAgICAgICAgY29udHJvbGxlcl91cmw6IFwiLy9zMy5hbWF6b25hd3MuY29tL2pzLmFkanNkZW1vLmNvbS9odG1sL2NvbnRyb2xsZXJmcmFtZS5odG1sXCIsXG4gICAgICAgIGFkX3VybDogXCIvL3MzLmFtYXpvbmF3cy5jb20vanMuYWRqc2RlbW8uY29tL2h0bWwvYWRmcmFtZS5odG1sXCJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJy4uL2xpYi9odG1sL2FkanNmcmFtZS5odG1sJyxcbiAgICAgICAgdmlzaXRfZXhwaXJ5OiAzLFxuICAgICAgICB2ZXJzaW9uOiBcIjAuMC4xXCIsXG4gICAgICAgIGRvbWFpbjogXCJsb2NhbGhvc3RcIixcbiAgICAgICAgY29udHJvbGxlcl91cmw6IFwiLi4vbGliL2h0bWwvY29udHJvbGxlcmZyYW1lLmh0bWxcIixcbiAgICAgICAgYWRfdXJsOiBcIi4uL2xpYi9odG1sL2FkZnJhbWUuaHRtbFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgdXRpbHM7XG5cbiAgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93LCAkc2YpIHtcbiAgICB2YXIgRU5HQUdFTUVOVF9SRVNFVCwgYWN0aXZpdHlIYW5kbGVyLCBhdHRhY2gsIGRpc2VuZ2FnZUV2ZW50cywgZG9jLCBlbmdhZ2VFdmVudHMsIGVuZ2FnZW1lbnQsIGVuZ2FnZW1lbnRUaW1lb3V0LCBsYXN0RW5nYWdlZCwgcmVzZXRFbmdhZ2VtZW50O1xuICAgIGF0dGFjaCA9ICRzZi5saWIuZG9tLmF0dGFjaDtcbiAgICBlbmdhZ2VtZW50ID0ge1xuICAgICAgaXNFbmdhZ2VkOiBmYWxzZVxuICAgIH07XG4gICAgZG9jID0gd2luZG93LmRvY3VtZW50O1xuICAgIGVuZ2FnZUV2ZW50cyA9IFtdO1xuICAgIGRpc2VuZ2FnZUV2ZW50cyA9IFtdO1xuICAgIEVOR0FHRU1FTlRfUkVTRVQgPSAzMDAwO1xuICAgIGxhc3RFbmdhZ2VkID0gdm9pZCAwO1xuICAgIGVuZ2FnZW1lbnQub25FbmdhZ2VtZW50ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGVuZ2FnZUV2ZW50cy5wdXNoKGYpO1xuICAgIH07XG4gICAgZW5nYWdlbWVudC5vbkRpc2VuZ2FnZW1lbnQgPSBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZGlzZW5nYWdlRXZlbnRzLnB1c2goZik7XG4gICAgfTtcbiAgICBhY3Rpdml0eUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmLCBfaSwgX2xlbjtcbiAgICAgIGVuZ2FnZW1lbnQuaXNFbmdhZ2VkID0gdHJ1ZTtcbiAgICAgIGVuZ2FnZW1lbnQubGFzdEVuZ2FnZWQgPSB1dGlscy5ub3coKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZW5nYWdlRXZlbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGYgPSBlbmdhZ2VFdmVudHNbX2ldO1xuICAgICAgICBmKCk7XG4gICAgICB9XG4gICAgICByZXNldEVuZ2FnZW1lbnQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgZW5nYWdlbWVudFRpbWVvdXQgPSBudWxsO1xuICAgIHJlc2V0RW5nYWdlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGVuZ2FnZW1lbnRUaW1lb3V0KTtcbiAgICAgIHJldHVybiBlbmdhZ2VtZW50VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmLCBfaSwgX2xlbjtcbiAgICAgICAgZW5nYWdlbWVudC5pc0VuZ2FnZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBkaXNlbmdhZ2VFdmVudHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBmID0gZGlzZW5nYWdlRXZlbnRzW19pXTtcbiAgICAgICAgICBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc2VuZ2FnZUV2ZW50cyA9IFtdO1xuICAgICAgfSwgRU5HQUdFTUVOVF9SRVNFVCk7XG4gICAgfTtcbiAgICBhdHRhY2goZG9jLCAnY2xpY2snLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaChkb2MsICdtb3VzZXVwJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2goZG9jLCAnbW91c2Vkb3duJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2goZG9jLCAnbW91c2Vtb3ZlJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2goZG9jLCAnbW91c2V3aGVlbCcsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ2tleXByZXNzJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2goZG9jLCAna2V5ZG93bicsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ2tleXVwJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAnRE9NTW91c2VTY3JvbGwnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaCh3aW5kb3csICdzY3JvbGwnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaCh3aW5kb3csICdyZXNpemUnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaCh3aW5kb3csICdmb2N1cycsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKHdpbmRvdywgJ2JsdXInLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIHJldHVybiBlbmdhZ2VtZW50O1xuICB9KSh3aW5kb3csICRzZik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXZlbnROYW1lcykge1xuICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIGV2ZW50cywgX2ksIF9sZW47XG4gICAgICBldmVudHMgPSB7XG4gICAgICAgIG9uOiBmdW5jdGlvbihldmVudCwgY2IpIHtcbiAgICAgICAgICB2YXIgZXZlbnRMaXN0O1xuICAgICAgICAgIHRoaXMuZXZlbnRzIHx8ICh0aGlzLmV2ZW50cyA9IHt9KTtcbiAgICAgICAgICBldmVudExpc3QgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgW107XG4gICAgICAgICAgZXZlbnRMaXN0LnB1c2goY2IpO1xuICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IGV2ZW50TGlzdDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGRhdGEsIG9wdGlvbmFsRGF0YSkge1xuICAgICAgICAgIHZhciBlLCBleCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICAgICAgdGhpcy5ldmVudHMgfHwgKHRoaXMuZXZlbnRzID0ge30pO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLmV2ZW50c1tldmVudF0gfHwgW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBlID0gX3JlZltfaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlLmNhbGwodGhpcywgZGF0YSwgb3B0aW9uYWxEYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBleCA9IF9lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGV2ZW50TmFtZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZXZlbnQgPSBldmVudE5hbWVzW19pXTtcbiAgICAgICAgZXZlbnRzW2V2ZW50XSA9IChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIHJldHVybiBmID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9KSgpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIEJhc2UsIGNvbmZpZywgY29va2llcywgbW9tZW50LCB1dGlscywgdXVpZCxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBjb29raWVzID0gcmVxdWlyZSgnY29va2llcy1qcycpO1xuXG4gIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKTtcblxuICBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbiAgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbiAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuICBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigkc2YsIHdpbmRvdykge1xuICAgIHZhciBDT09LSUVfS0VZLCBQYWdlO1xuICAgIENPT0tJRV9LRVkgPSBcIl9hanNrXCI7XG4gICAgUGFnZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhQYWdlLCBfc3VwZXIpO1xuXG4gICAgICBmdW5jdGlvbiBQYWdlKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgUGFnZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRQYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9hZENvb2tpZURhdGEoKTtcbiAgICAgICAgICB0aGlzLmluaXREZWZhdWx0QXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFBhZ2UucHJvdG90eXBlLnN0b3JlQ29va2llID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICBpZiAoKCRzZiAhPSBudWxsID8gKF9yZWYgPSAkc2YuZXh0KSAhPSBudWxsID8gX3JlZi5jb29raWUgOiB2b2lkIDAgOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLnNpdGVfdXNlcl9pZCkge1xuICAgICAgICAgICAgJHNmLmV4dC5jb29raWUoXCJcIiArIENPT0tJRV9LRVkgKyBcIl9zdWlkXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXR0cmlidXRlcy5zaXRlX3VzZXJfaWQsXG4gICAgICAgICAgICAgIGV4cGlyZXM6IG1vbWVudCgpLmFkZChcInllYXJzXCIsIDEpLnRvRGF0ZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy52aXNpdF9pZCkge1xuICAgICAgICAgICAgcmV0dXJuICRzZi5leHQuY29va2llKFwiXCIgKyBDT09LSUVfS0VZICsgXCJfdmlkXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXR0cmlidXRlcy52aXNpdF9pZCxcbiAgICAgICAgICAgICAgZXhwaXJlczogbW9tZW50KCkuYWRkKFwic2Vjb25kc1wiLCBjb25maWcudmlzaXRfZXhwaXJ5ICogNjApLnRvRGF0ZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy5zaXRlX3VzZXJfaWQpIHtcbiAgICAgICAgICAgIGNvb2tpZXMuc2V0KFwiXCIgKyBDT09LSUVfS0VZICsgXCJfc3VpZFwiLCB0aGlzLmF0dHJpYnV0ZXMuc2l0ZV91c2VyX2lkLCB7XG4gICAgICAgICAgICAgIGV4cGlyZXM6IG1vbWVudCgpLmFkZChcInllYXJzXCIsIDEpLnRvRGF0ZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy52aXNpdF9pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZXMuc2V0KFwiXCIgKyBDT09LSUVfS0VZICsgXCJfdmlkXCIsIHRoaXMuYXR0cmlidXRlcy52aXNpdF9pZCwge1xuICAgICAgICAgICAgICBleHBpcmVzOiBtb21lbnQoKS5hZGQoXCJzZWNvbmRzXCIsIGNvbmZpZy52aXNpdF9leHBpcnkgKiA2MCkudG9EYXRlKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgUGFnZS5wcm90b3R5cGUubG9hZENvb2tpZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgIGlmICgoJHNmICE9IG51bGwgPyAoX3JlZiA9ICRzZi5leHQpICE9IG51bGwgPyBfcmVmLmNvb2tpZSA6IHZvaWQgMCA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBzaXRlX3VzZXJfaWQ6ICRzZi5leHQuY29va2llKFwiXCIgKyBDT09LSUVfS0VZICsgXCJfc3VpZFwiKSxcbiAgICAgICAgICAgIHZpc2l0X2lkOiAkc2YuZXh0LmNvb2tpZShcIlwiICsgQ09PS0lFX0tFWSArIFwiX3ZpZFwiKVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBzaXRlX3VzZXJfaWQ6IGNvb2tpZXMuZ2V0KFwiXCIgKyBDT09LSUVfS0VZICsgXCJfc3VpZFwiKSxcbiAgICAgICAgICAgIHZpc2l0X2lkOiBjb29raWVzLmdldChcIlwiICsgQ09PS0lFX0tFWSArIFwiX3ZpZFwiKVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBQYWdlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIFBhZ2UuX19zdXBlcl9fLnNldC5jYWxsKHRoaXMsIGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVDb29raWUoKTtcbiAgICAgIH07XG5cbiAgICAgIFBhZ2UucHJvdG90eXBlLmluaXREZWZhdWx0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93ID09PSB3aW5kb3cudG9wKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICAgIHVybDogd2luZG93LmRvY3VtZW50LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICByZWY6IHdpbmRvdy5kb2N1bWVudC5yZWZlcnJlcixcbiAgICAgICAgICAgIHZfanM6IGNvbmZpZy52ZXJzaW9uXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LnBhcmVudCA9PT0gd2luZG93LnRvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICB1cmw6IHdpbmRvdy5kb2N1bWVudC5yZWZlcnJlcixcbiAgICAgICAgICAgIHZfanM6IGNvbmZpZy52ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFBhZ2UucHJvdG90eXBlLnZlcmlmeVVybCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93LnBhcmVudCA9PT0gd2luZG93LnRvcCAmJiB3aW5kb3cuZG9jdW1lbnQucmVmZXJyZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgUGFnZS5wcm90b3R5cGUuc2VyaWFsaXplZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGssIG91dEF0dHJzLCB2LCBfcmVmO1xuICAgICAgICBvdXRBdHRycyA9IHt9O1xuICAgICAgICBfcmVmID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICAgIG91dEF0dHJzW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICBvdXRBdHRycy51cmwgPSBlbmNvZGVVUklDb21wb25lbnQob3V0QXR0cnMudXJsKTtcbiAgICAgICAgb3V0QXR0cnMucmVmID0gZW5jb2RlVVJJQ29tcG9uZW50KG91dEF0dHJzLnJlZik7XG4gICAgICAgIHJldHVybiBvdXRBdHRycztcbiAgICAgIH07XG5cbiAgICAgIFBhZ2UucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIFBhZ2UuX19zdXBlcl9fLmRlc2VyaWFsaXplLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICB1cmw6IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmF0dHJpYnV0ZXMudXJsKSxcbiAgICAgICAgICByZWY6IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmF0dHJpYnV0ZXMucmVmKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgUGFnZS5wcm90b3R5cGUucGF0aCA9IFwiL3BhZ2VcIjtcblxuICAgICAgUGFnZS5wcm90b3R5cGUuY29uc3RhbnRGaWVsZHMgPSBbXCJzaXRlX3VzZXJfaWRcIiwgXCJwYWdlX2lkXCIsIFwidmlzaXRfaWRcIiwgXCJ1cmxcIl07XG5cbiAgICAgIHJldHVybiBQYWdlO1xuXG4gICAgfSkoQmFzZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gXCJ0ZXN0XCIgfHwgKCh0eXBlb2YgX1RFU1QgIT09IFwidW5kZWZpbmVkXCIgJiYgX1RFU1QgIT09IG51bGwpICYmIF9URVNUKSkge1xuICAgICAgUGFnZS5fQ09PS0lFX0tFWSA9IENPT0tJRV9LRVk7XG4gICAgICBQYWdlLmNsZWFyQ29va2llID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvb2tpZXMuc2V0KENPT0tJRV9LRVkgKyBcIl9zdWlkXCIsIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb29raWVzLnNldChDT09LSUVfS0VZICsgXCJfdmlkXCIsIHZvaWQgMCk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gUGFnZTtcbiAgfSkoJHNmLCB3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjhEd29oUlwiKSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWFkZXJib2FyZDogWzcyOCwgOTBdLFxuICAgICAgXCJtZWRpdW0tcmVjdGFuZ2xlXCI6IFszMDAsIDI1MF1cbiAgICB9O1xuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgcmVxd2VzdDtcblxuICB3aW5kb3cuSlNPTiB8fCAod2luZG93LkpTT04gPSByZXF1aXJlKCdqc29uJykpO1xuXG4gIHJlcXdlc3QgPSByZXF1aXJlKCdyZXF3ZXN0Jyk7XG5cbiAgd2luZG93LkpTT04gfHwgKHdpbmRvdy5KU09OID0gcmVxdWlyZSgnanNvbicpKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigkc2YpIHtcbiAgICB2YXIgY2FwaXRhbGl6ZVN0cmluZywgY291bnRGcmFtZXMsIGRlZmluZVByb3BlcnR5LCBmaW5kQ29udHJvbGxlciwgZnJvbVF1ZXJ5LCBnZXRGcmFtZVBvc2l0aW9uLCBrZXlzLCBuYXRpdmVSZWR1Y2UsIG5vdywgcmVkdWNlLCByZWR1Y2VFcnJvciwgcmVxSWQsIHNlbmRSZXF1ZXN0LCB0b051bWJlciwgdG9RdWVyeTtcbiAgICByZXFJZCA9IDA7XG4gICAgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXFJZCsrO1xuICAgICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gXCJqc29ucFwiKSB7XG4gICAgICAgIG9wdGlvbnMuanNvbnBDYWxsYmFja05hbWUgPSBcImFkanNfXCIgKyAobm93KCkpICsgXCJfXCIgKyByZXFJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF3ZXN0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgZnJvbVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnksIGRlbGltKSB7XG4gICAgICB2YXIgaXRlbSwga2V5LCBwYXJhbXMsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAocXVlcnkgPT0gbnVsbCkge1xuICAgICAgICBxdWVyeSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoZGVsaW0gPT0gbnVsbCkge1xuICAgICAgICBkZWxpbSA9IFwiJlwiO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0ge307XG4gICAgICBfcmVmID0gcXVlcnkuc3BsaXQoZGVsaW0pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBfcmVmW19pXTtcbiAgICAgICAgX3JlZjEgPSBpdGVtLnNwbGl0KFwiPVwiKSwga2V5ID0gX3JlZjFbMF0sIHZhbHVlID0gX3JlZjFbMV07XG4gICAgICAgIHBhcmFtc1trZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgICB0b1F1ZXJ5ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIHJlcXdlc3QudG9RdWVyeVN0cmluZyhhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIHRvTnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJHNmICE9IG51bGwgPyAkc2YubGliLmxhbmcuY251bSh2YWwsIDApIDogdm9pZCAwO1xuICAgIH07XG4gICAgbm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcImRlZmluZVByb3BlcnR5XCIgaW4gT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiX19kZWZpbmVHZXR0ZXJfX1wiIGluIG9iaikge1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLndyaXRhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbFtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKHByb3AsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmouX19kZWZpbmVTZXR0ZXJfXyhwcm9wLCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgfVxuICAgIH07XG4gICAgY291bnRGcmFtZXMgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgIHZhciBjb3VudCwgZnJhbWUsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgY291bnQgPSB3aW4uZnJhbWVzLmxlbmd0aDtcbiAgICAgIF9yZWYgPSB3aW4uZnJhbWVzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGZyYW1lID0gX3JlZltfaV07XG4gICAgICAgIGlmIChmcmFtZSAhPT0gd2luKSB7XG4gICAgICAgICAgY291bnQgKz0gY291bnRGcmFtZXMoZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICBnZXRGcmFtZVBvc2l0aW9uID0gZnVuY3Rpb24od2luKSB7XG4gICAgICB2YXIgY291bnQ7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBpZiAod2luLnBhcmVudCAhPT0gd2luLnRvcCkge1xuICAgICAgICBjb3VudCA9IDEgKyBnZXRGcmFtZVBvc2l0aW9uKHdpbi5wYXJlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgbmF0aXZlUmVkdWNlID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZTtcbiAgICByZWR1Y2VFcnJvciA9ICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJztcbiAgICByZWR1Y2UgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICB2YXIgaW5kZXgsIGluaXRpYWwsIHZhbHVlLCBfZm4sIF9pLCBfbGVuO1xuICAgICAgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIG9iaiA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKG5hdGl2ZVJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgICAgcmV0dXJuIChpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKSk7XG4gICAgICB9XG4gICAgICBfZm4gPSBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iaikge1xuICAgICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwodGhpcywgbWVtbywgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChpbmRleCA9IF9pID0gMCwgX2xlbiA9IG9iai5sZW5ndGg7IF9pIDwgX2xlbjsgaW5kZXggPSArK19pKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2luZGV4XTtcbiAgICAgICAgX2ZuKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gICAga2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICRzZiAhPSBudWxsID8gJHNmLmxpYi5sYW5nLmtleXMob2JqKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGZpbmRDb250cm9sbGVyID0gZnVuY3Rpb24oY2IsIHJldHJ5KSB7XG4gICAgICB2YXIgY29udHJvbGxlciwgZnJhbWUsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMTtcbiAgICAgIGlmIChyZXRyeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHJ5ID0gMztcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgX3JlZiA9IHdpbmRvdy50b3AuZnJhbWVzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGZyYW1lID0gX3JlZltfaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKChfcmVmMSA9IGZyYW1lLiRhZCkgIT0gbnVsbCA/IF9yZWYxLmlzQ29udHJvbGxlciA6IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IGZyYW1lLiRhZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGNvbnRyb2xsZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEocmV0cnkgPCAwKSkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kQ29udHJvbGxlcihjYiwgcmV0cnkgLSAxKTtcbiAgICAgICAgICB9KSwgMTAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2FwaXRhbGl6ZVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kUmVxdWVzdDogc2VuZFJlcXVlc3QsXG4gICAgICB0b1F1ZXJ5OiB0b1F1ZXJ5LFxuICAgICAgZnJvbVF1ZXJ5OiBmcm9tUXVlcnksXG4gICAgICB0b051bWJlcjogdG9OdW1iZXIsXG4gICAgICBub3c6IG5vdyxcbiAgICAgIGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eSxcbiAgICAgIGNvdW50RnJhbWVzOiBjb3VudEZyYW1lcyxcbiAgICAgIGNhcGl0YWxpemVTdHJpbmc6IGNhcGl0YWxpemVTdHJpbmcsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZ2V0RnJhbWVQb3NpdGlvbjogZ2V0RnJhbWVQb3NpdGlvbixcbiAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgZmluZENvbnRyb2xsZXI6IGZpbmRDb250cm9sbGVyXG4gICAgfTtcbiAgfSkoJHNmKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIVxyXG4gKiBDb29raWVzLmpzIC0gMC4zLjFcclxuICogV2VkbmVzZGF5LCBBcHJpbCAyNCAyMDEzIEAgMjoyOCBBTSBFU1RcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBTY290dCBIYW1wZXJcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLFxyXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4gKi9cclxuKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgQ29va2llcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xyXG4gICAgICAgICAgICBDb29raWVzLmdldChrZXkpIDogQ29va2llcy5zZXQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFsbG93cyBmb3Igc2V0dGVyIGluamVjdGlvbiBpbiB1bml0IHRlc3RzXHJcbiAgICBDb29raWVzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgQ29va2llcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xyXG5cclxuICAgIENvb2tpZXMuZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgcGF0aDogJy8nXHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChDb29raWVzLl9jYWNoZWREb2N1bWVudENvb2tpZSAhPT0gQ29va2llcy5fZG9jdW1lbnQuY29va2llKSB7XHJcbiAgICAgICAgICAgIENvb2tpZXMuX3JlbmV3Q2FjaGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDb29raWVzLl9jYWNoZVtrZXldO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IENvb2tpZXMuX2dldEV4dGVuZGVkT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICBvcHRpb25zLmV4cGlyZXMgPSBDb29raWVzLl9nZXRFeHBpcmVzRGF0ZSh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gLTEgOiBvcHRpb25zLmV4cGlyZXMpO1xyXG5cclxuICAgICAgICBDb29raWVzLl9kb2N1bWVudC5jb29raWUgPSBDb29raWVzLl9nZW5lcmF0ZUNvb2tpZVN0cmluZyhrZXksIHZhbHVlLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIENvb2tpZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuZXhwaXJlID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBDb29raWVzLnNldChrZXksIHVuZGVmaW5lZCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dldEV4dGVuZGVkT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcGF0aDogb3B0aW9ucyAmJiBvcHRpb25zLnBhdGggfHwgQ29va2llcy5kZWZhdWx0cy5wYXRoLFxyXG4gICAgICAgICAgICBkb21haW46IG9wdGlvbnMgJiYgb3B0aW9ucy5kb21haW4gfHwgQ29va2llcy5kZWZhdWx0cy5kb21haW4sXHJcbiAgICAgICAgICAgIGV4cGlyZXM6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHBpcmVzIHx8IENvb2tpZXMuZGVmYXVsdHMuZXhwaXJlcyxcclxuICAgICAgICAgICAgc2VjdXJlOiBvcHRpb25zICYmIG9wdGlvbnMuc2VjdXJlICE9PSB1bmRlZmluZWQgPyAgb3B0aW9ucy5zZWN1cmUgOiBDb29raWVzLmRlZmF1bHRzLnNlY3VyZVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2lzVmFsaWREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09PSAnW29iamVjdCBEYXRlXScgJiYgIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5fZ2V0RXhwaXJlc0RhdGUgPSBmdW5jdGlvbiAoZXhwaXJlcywgbm93KSB7XHJcbiAgICAgICAgbm93ID0gbm93IHx8IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgZXhwaXJlcykge1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOiBleHBpcmVzID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIGV4cGlyZXMgKiAxMDAwKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IGV4cGlyZXMgPSBuZXcgRGF0ZShleHBpcmVzKTsgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXhwaXJlcyAmJiAhQ29va2llcy5faXNWYWxpZERhdGUoZXhwaXJlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZXhwaXJlc2AgcGFyYW1ldGVyIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSB2YWxpZCBEYXRlIGluc3RhbmNlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXhwaXJlcztcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5fZ2VuZXJhdGVDb29raWVTdHJpbmcgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGtleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlICsgJycpLnJlcGxhY2UoL1teISMkJi0rXFwtLTo8LVxcW1xcXS1+XS9nLCBlbmNvZGVVUklDb21wb25lbnQpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICB2YXIgY29va2llU3RyaW5nID0ga2V5ICsgJz0nICsgdmFsdWU7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMucGF0aCA/ICc7cGF0aD0nICsgb3B0aW9ucy5wYXRoIDogJyc7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMuZG9tYWluID8gJztkb21haW49JyArIG9wdGlvbnMuZG9tYWluIDogJyc7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMuZXhwaXJlcyA/ICc7ZXhwaXJlcz0nICsgb3B0aW9ucy5leHBpcmVzLnRvR01UU3RyaW5nKCkgOiAnJztcclxuICAgICAgICBjb29raWVTdHJpbmcgKz0gb3B0aW9ucy5zZWN1cmUgPyAnO3NlY3VyZScgOiAnJztcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvb2tpZVN0cmluZztcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5fZ2V0Q29va2llT2JqZWN0RnJvbVN0cmluZyA9IGZ1bmN0aW9uIChkb2N1bWVudENvb2tpZSkge1xyXG4gICAgICAgIHZhciBjb29raWVPYmplY3QgPSB7fTtcclxuICAgICAgICB2YXIgY29va2llc0FycmF5ID0gZG9jdW1lbnRDb29raWUgPyBkb2N1bWVudENvb2tpZS5zcGxpdCgnOyAnKSA6IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29va2llS3ZwID0gQ29va2llcy5fZ2V0S2V5VmFsdWVQYWlyRnJvbUNvb2tpZVN0cmluZyhjb29raWVzQXJyYXlbaV0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvb2tpZU9iamVjdFtjb29raWVLdnAua2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb29raWVPYmplY3RbY29va2llS3ZwLmtleV0gPSBjb29raWVLdnAudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb29raWVPYmplY3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dldEtleVZhbHVlUGFpckZyb21Db29raWVTdHJpbmcgPSBmdW5jdGlvbiAoY29va2llU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gXCI9XCIgaXMgYSB2YWxpZCBjaGFyYWN0ZXIgaW4gYSBjb29raWUgdmFsdWUgYWNjb3JkaW5nIHRvIFJGQzYyNjUsIHNvIGNhbm5vdCBgc3BsaXQoJz0nKWBcclxuICAgICAgICB2YXIgc2VwYXJhdG9ySW5kZXggPSBjb29raWVTdHJpbmcuaW5kZXhPZignPScpO1xyXG5cclxuICAgICAgICAvLyBJRSBvbWl0cyB0aGUgXCI9XCIgd2hlbiB0aGUgY29va2llIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgIHNlcGFyYXRvckluZGV4ID0gc2VwYXJhdG9ySW5kZXggPCAwID8gY29va2llU3RyaW5nLmxlbmd0aCA6IHNlcGFyYXRvckluZGV4O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXk6IGRlY29kZVVSSUNvbXBvbmVudChjb29raWVTdHJpbmcuc3Vic3RyKDAsIHNlcGFyYXRvckluZGV4KSksXHJcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQoY29va2llU3RyaW5nLnN1YnN0cihzZXBhcmF0b3JJbmRleCArIDEpKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX3JlbmV3Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgQ29va2llcy5fY2FjaGUgPSBDb29raWVzLl9nZXRDb29raWVPYmplY3RGcm9tU3RyaW5nKENvb2tpZXMuX2RvY3VtZW50LmNvb2tpZSk7XHJcbiAgICAgICAgQ29va2llcy5fY2FjaGVkRG9jdW1lbnRDb29raWUgPSBDb29raWVzLl9kb2N1bWVudC5jb29raWU7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2FyZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvb2tpZXMuX25hdmlnYXRvci5jb29raWVFbmFibGVkIHx8XHJcbiAgICAgICAgICAgIENvb2tpZXMuc2V0KCdjb29raWVzLmpzJywgMSkuZ2V0KCdjb29raWVzLmpzJykgPT09ICcxJztcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5lbmFibGVkID0gQ29va2llcy5fYXJlRW5hYmxlZCgpO1xyXG5cclxuICAgIC8vIEFNRCBzdXBwb3J0XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvb2tpZXM7IH0pO1xyXG4gICAgLy8gQ29tbW9uSlMgYW5kIE5vZGUuanMgbW9kdWxlIHN1cHBvcnQuXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFN1cHBvcnQgTm9kZS5qcyBzcGVjaWZpYyBgbW9kdWxlLmV4cG9ydHNgICh3aGljaCBjYW4gYmUgYSBmdW5jdGlvbilcclxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQ29va2llcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnV0IGFsd2F5cyBzdXBwb3J0IENvbW1vbkpTIG1vZHVsZSAxLjEuMSBzcGVjIChgZXhwb3J0c2AgY2Fubm90IGJlIGEgZnVuY3Rpb24pXHJcbiAgICAgICAgZXhwb3J0cy5Db29raWVzID0gQ29va2llcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2luZG93LkNvb2tpZXMgPSBDb29raWVzO1xyXG4gICAgfVxyXG59KSgpOyIsIi8qXG4gICAgaHR0cDovL3d3dy5KU09OLm9yZy9qc29uMi5qc1xuICAgIDIwMTEtMDItMjNcblxuICAgIFB1YmxpYyBEb21haW4uXG5cbiAgICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG5cbiAgICBTZWUgaHR0cDovL3d3dy5KU09OLm9yZy9qcy5odG1sXG5cblxuICAgIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4gICAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4gICAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbiAgICBOT1QgQ09OVFJPTC5cblxuXG4gICAgVGhpcyBmaWxlIGNyZWF0ZXMgYSBnbG9iYWwgSlNPTiBvYmplY3QgY29udGFpbmluZyB0d28gbWV0aG9kczogc3RyaW5naWZ5XG4gICAgYW5kIHBhcnNlLlxuXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG5cbiAgICAgICAgICAgIHJlcGxhY2VyICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRldGVybWluZXMgaG93IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFyZSBzdHJpbmdpZmllZCBmb3Igb2JqZWN0cy4gSXQgY2FuIGJlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG5cbiAgICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzICdcXHQnIG9yICcmbmJzcDsnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHByb2R1Y2VzIGEgSlNPTiB0ZXh0IGZyb20gYSBKYXZhU2NyaXB0IHZhbHVlLlxuXG4gICAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuICAgICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbiAgICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuICAgICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4gICAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWVcblxuICAgICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWic7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4gICAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4gICAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbiAgICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbiAgICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4gICAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4gICAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuICAgICAgICAgICAgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuICAgICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbiAgICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuICAgICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuICAgICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbiAgICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbiAgICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4gICAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXFxuXFx0XCJlXCIsXFxuXFx0e1xcblxcdFxcdFwicGx1cmlidXNcIjogXCJ1bnVtXCJcXG5cXHR9XFxuXSdcblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtuZXcgRGF0ZSgpXSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZSA/XG4gICAgICAgICAgICAgICAgICAgICdEYXRlKCcgKyB0aGlzW2tleV0gKyAnKScgOiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG5cbiAgICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuICAgICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuXG4gICAgICAgICAgICBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4gICAgICAgICAgICB0cmFuc2Zvcm0gdGhlIHJlc3VsdHMuIEl0IHJlY2VpdmVzIGVhY2ggb2YgdGhlIGtleXMgYW5kIHZhbHVlcyxcbiAgICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4gICAgICAgICAgICBJZiBpdCByZXR1cm5zIHVuZGVmaW5lZCB0aGVuIHRoZSBtZW1iZXIgaXMgZGVsZXRlZC5cblxuICAgICAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIGNvbnZlcnRlZCB0byBEYXRlIG9iamVjdHMuXG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhID1cbi9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgNSkgPT09ICdEYXRlKCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4gICAgcmVkaXN0cmlidXRlLlxuKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgcmVnZXhwOiBmYWxzZSAqL1xuXG4vKm1lbWJlcnMgXCJcIiwgXCJcXGJcIiwgXCJcXHRcIiwgXCJcXG5cIiwgXCJcXGZcIiwgXCJcXHJcIiwgXCJcXFwiXCIsIEpTT04sIFwiXFxcXFwiLCBhcHBseSxcbiAgICBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxudmFyIEpTT047XG5pZiAoIUpTT04pIHtcbiAgICBKU09OID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICAgICAgLCBKU09OID0gZ2xvYmFsLkpTT05cbiAgICAgIDtcblxuICAgIGlmICghSlNPTikge1xuICAgICAgSlNPTiA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSkgP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICAgKyAnLScgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyAnVCcgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyAnOicgK1xuICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyAnWicgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUudG9KU09OICAgICAgPVxuICAgICAgICAgICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gID1cbiAgICAgICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICBnYXAsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgfSxcbiAgICAgICAgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbi8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgICAgICBwYXJ0aWFsLFxuICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICB9XG5cbi8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4vLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcblxuLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4vLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuLy8gbnVsbC5cblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbi8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gJyc7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbi8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICAgICAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgSlNPTi5wYXJzZSA9IGZ1bmN0aW9uICh0ZXh0LCByZXZpdmVyKSB7XG5cbi8vIFRoZSBwYXJzZSBtZXRob2QgdGFrZXMgYSB0ZXh0IGFuZCBhbiBvcHRpb25hbCByZXZpdmVyIGZ1bmN0aW9uLCBhbmQgcmV0dXJuc1xuLy8gYSBKYXZhU2NyaXB0IHZhbHVlIGlmIHRoZSB0ZXh0IGlzIGEgdmFsaWQgSlNPTiB0ZXh0LlxuXG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuXG4vLyBUaGUgd2FsayBtZXRob2QgaXMgdXNlZCB0byByZWN1cnNpdmVseSB3YWxrIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlIHNvXG4vLyB0aGF0IG1vZGlmaWNhdGlvbnMgY2FuIGJlIG1hZGUuXG5cbiAgICAgICAgICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGN4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGN4LCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCAnKCknIGFuZCAnbmV3J1xuLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgJz0nIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoICdAJyAoYSBub24tSlNPTiBjaGFyYWN0ZXIpLiBTZWNvbmQsIHdlXG4vLyByZXBsYWNlIGFsbCBzaW1wbGUgdmFsdWUgdG9rZW5zIHdpdGggJ10nIGNoYXJhY3RlcnMuIFRoaXJkLCB3ZSBkZWxldGUgYWxsXG4vLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbi8vIHdlIGxvb2sgdG8gc2VlIHRoYXQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFyZSBvbmx5IHdoaXRlc3BhY2Ugb3IgJ10nIG9yXG4vLyAnLCcgb3IgJzonIG9yICd7JyBvciAnfScuIElmIHRoYXQgaXMgc28sIHRoZW4gdGhlIHRleHQgaXMgc2FmZSBmb3IgZXZhbC5cblxuICAgICAgICAgICAgaWYgKC9eW1xcXSw6e31cXHNdKiQvXG4gICAgICAgICAgICAgICAgICAgIC50ZXN0KHRleHQucmVwbGFjZSgvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csICddJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZywgJycpKSkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlICd7JyBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuLy8gaW4gSmF2YVNjcmlwdDogaXQgY2FuIGJlZ2luIGEgYmxvY2sgb3IgYW4gb2JqZWN0IGxpdGVyYWwuIFdlIHdyYXAgdGhlIHRleHRcbi8vIGluIHBhcmVucyB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eS5cblxuICAgICAgICAgICAgICAgIGogPSBldmFsKCcoJyArIHRleHQgKyAnKScpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgd2Fsayh7Jyc6IGp9LCAnJykgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSlNPTi5wYXJzZScpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdsb2JhbC5KU09OID0gSlNPTjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEpTT047XG59KCkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjcuMFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbihmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0YW50c1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBtb21lbnQsXG4gICAgICAgIFZFUlNJT04gPSBcIjIuNy4wXCIsXG4gICAgICAgIC8vIHRoZSBnbG9iYWwtc2NvcGUgdGhpcyBpcyBOT1QgdGhlIGdsb2JhbCBvYmplY3QgaW4gTm9kZS5qc1xuICAgICAgICBnbG9iYWxTY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpcyxcbiAgICAgICAgb2xkR2xvYmFsTW9tZW50LFxuICAgICAgICByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIGksXG5cbiAgICAgICAgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbGFuZ3VhZ2UgY29uZmlnIGZpbGVzXG4gICAgICAgIGxhbmd1YWdlcyA9IHt9LFxuXG4gICAgICAgIC8vIG1vbWVudCBpbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICAgIG1vbWVudFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBfaXNBTW9tZW50T2JqZWN0OiBudWxsLFxuICAgICAgICAgICAgX2kgOiBudWxsLFxuICAgICAgICAgICAgX2YgOiBudWxsLFxuICAgICAgICAgICAgX2wgOiBudWxsLFxuICAgICAgICAgICAgX3N0cmljdCA6IG51bGwsXG4gICAgICAgICAgICBfdHptIDogbnVsbCxcbiAgICAgICAgICAgIF9pc1VUQyA6IG51bGwsXG4gICAgICAgICAgICBfb2Zmc2V0IDogbnVsbCwgIC8vIG9wdGlvbmFsLiBDb21iaW5lIHdpdGggX2lzVVRDXG4gICAgICAgICAgICBfcGYgOiBudWxsLFxuICAgICAgICAgICAgX2xhbmcgOiBudWxsICAvLyBvcHRpb25hbFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBub2RlSlNcbiAgICAgICAgaGFzTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSxcblxuICAgICAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaSxcbiAgICAgICAgYXNwTmV0VGltZVNwYW5Kc29uUmVnZXggPSAvKFxcLSk/KD86KFxcZCopXFwuKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/KT8vLFxuXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgaXNvRHVyYXRpb25SZWdleCA9IC9eKC0pP1AoPzooPzooWzAtOSwuXSopWSk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilEKT8oPzpUKD86KFswLTksLl0qKUgpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopUyk/KT98KFswLTksLl0qKVcpJC8sXG5cbiAgICAgICAgLy8gZm9ybWF0IHRva2Vuc1xuICAgICAgICBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFF8WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98bW0/fHNzP3xTezEsNH18WHx6ej98Wlo/fC4pL2csXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVHxMTD9MP0w/fGx7MSw0fSkvZyxcblxuICAgICAgICAvLyBwYXJzaW5nIHRva2VuIHJlZ2V4ZXNcbiAgICAgICAgcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzID0gL1xcZFxcZD8vLCAvLyAwIC0gOTlcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHMgPSAvXFxkezEsM30vLCAvLyAwIC0gOTk5XG4gICAgICAgIHBhcnNlVG9rZW5PbmVUb0ZvdXJEaWdpdHMgPSAvXFxkezEsNH0vLCAvLyAwIC0gOTk5OVxuICAgICAgICBwYXJzZVRva2VuT25lVG9TaXhEaWdpdHMgPSAvWytcXC1dP1xcZHsxLDZ9LywgLy8gLTk5OSw5OTkgLSA5OTksOTk5XG4gICAgICAgIHBhcnNlVG9rZW5EaWdpdHMgPSAvXFxkKy8sIC8vIG5vbnplcm8gbnVtYmVyIG9mIGRpZ2l0c1xuICAgICAgICBwYXJzZVRva2VuV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pLCAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgcGFyc2VUb2tlblRpbWV6b25lID0gL1p8W1xcK1xcLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIHBhcnNlVG9rZW5UID0gL1QvaSwgLy8gVCAoSVNPIHNlcGFyYXRvcilcbiAgICAgICAgcGFyc2VUb2tlblRpbWVzdGFtcE1zID0gL1tcXCtcXC1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG4gICAgICAgIHBhcnNlVG9rZW5PcmRpbmFsID0gL1xcZHsxLDJ9LyxcblxuICAgICAgICAvL3N0cmljdCBwYXJzaW5nIHJlZ2V4ZXNcbiAgICAgICAgcGFyc2VUb2tlbk9uZURpZ2l0ID0gL1xcZC8sIC8vIDAgLSA5XG4gICAgICAgIHBhcnNlVG9rZW5Ud29EaWdpdHMgPSAvXFxkXFxkLywgLy8gMDAgLSA5OVxuICAgICAgICBwYXJzZVRva2VuVGhyZWVEaWdpdHMgPSAvXFxkezN9LywgLy8gMDAwIC0gOTk5XG4gICAgICAgIHBhcnNlVG9rZW5Gb3VyRGlnaXRzID0gL1xcZHs0fS8sIC8vIDAwMDAgLSA5OTk5XG4gICAgICAgIHBhcnNlVG9rZW5TaXhEaWdpdHMgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5LDk5OSAtIDk5OSw5OTlcbiAgICAgICAgcGFyc2VUb2tlblNpZ25lZE51bWJlciA9IC9bKy1dP1xcZCsvLCAvLyAtaW5mIC0gaW5mXG5cbiAgICAgICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAgICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgICAgIGlzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcblxuICAgICAgICBpc29Gb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onLFxuXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkezJ9LVxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkezJ9L10sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgICAgaXNvVGltZXMgPSBbXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvKFR8IClcXGRcXGQvXVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIHRpbWV6b25lIGNodW5rZXIgXCIrMTA6MDBcIiA+IFtcIjEwXCIsIFwiMDBcIl0gb3IgXCItMTUzMFwiID4gW1wiLTE1XCIsIFwiMzBcIl1cbiAgICAgICAgcGFyc2VUaW1lem9uZUNodW5rZXIgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2ksXG5cbiAgICAgICAgLy8gZ2V0dGVyIGFuZCBzZXR0ZXIgbmFtZXNcbiAgICAgICAgcHJveHlHZXR0ZXJzQW5kU2V0dGVycyA9ICdEYXRlfEhvdXJzfE1pbnV0ZXN8U2Vjb25kc3xNaWxsaXNlY29uZHMnLnNwbGl0KCd8JyksXG4gICAgICAgIHVuaXRNaWxsaXNlY29uZEZhY3RvcnMgPSB7XG4gICAgICAgICAgICAnTWlsbGlzZWNvbmRzJyA6IDEsXG4gICAgICAgICAgICAnU2Vjb25kcycgOiAxZTMsXG4gICAgICAgICAgICAnTWludXRlcycgOiA2ZTQsXG4gICAgICAgICAgICAnSG91cnMnIDogMzZlNSxcbiAgICAgICAgICAgICdEYXlzJyA6IDg2NGU1LFxuICAgICAgICAgICAgJ01vbnRocycgOiAyNTkyZTYsXG4gICAgICAgICAgICAnWWVhcnMnIDogMzE1MzZlNlxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaXRBbGlhc2VzID0ge1xuICAgICAgICAgICAgbXMgOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgcyA6ICdzZWNvbmQnLFxuICAgICAgICAgICAgbSA6ICdtaW51dGUnLFxuICAgICAgICAgICAgaCA6ICdob3VyJyxcbiAgICAgICAgICAgIGQgOiAnZGF5JyxcbiAgICAgICAgICAgIEQgOiAnZGF0ZScsXG4gICAgICAgICAgICB3IDogJ3dlZWsnLFxuICAgICAgICAgICAgVyA6ICdpc29XZWVrJyxcbiAgICAgICAgICAgIE0gOiAnbW9udGgnLFxuICAgICAgICAgICAgUSA6ICdxdWFydGVyJyxcbiAgICAgICAgICAgIHkgOiAneWVhcicsXG4gICAgICAgICAgICBEREQgOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgICAgIGUgOiAnd2Vla2RheScsXG4gICAgICAgICAgICBFIDogJ2lzb1dlZWtkYXknLFxuICAgICAgICAgICAgZ2c6ICd3ZWVrWWVhcicsXG4gICAgICAgICAgICBHRzogJ2lzb1dlZWtZZWFyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbWVsRnVuY3Rpb25zID0ge1xuICAgICAgICAgICAgZGF5b2Z5ZWFyIDogJ2RheU9mWWVhcicsXG4gICAgICAgICAgICBpc293ZWVrZGF5IDogJ2lzb1dlZWtkYXknLFxuICAgICAgICAgICAgaXNvd2VlayA6ICdpc29XZWVrJyxcbiAgICAgICAgICAgIHdlZWt5ZWFyIDogJ3dlZWtZZWFyJyxcbiAgICAgICAgICAgIGlzb3dlZWt5ZWFyIDogJ2lzb1dlZWtZZWFyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZvcm1hdCBmdW5jdGlvbiBzdHJpbmdzXG4gICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHt9LFxuXG4gICAgICAgIC8vIGRlZmF1bHQgcmVsYXRpdmUgdGltZSB0aHJlc2hvbGRzXG4gICAgICAgIHJlbGF0aXZlVGltZVRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgczogNDUsICAgLy9zZWNvbmRzIHRvIG1pbnV0ZXNcbiAgICAgICAgICBtOiA0NSwgICAvL21pbnV0ZXMgdG8gaG91cnNcbiAgICAgICAgICBoOiAyMiwgICAvL2hvdXJzIHRvIGRheXNcbiAgICAgICAgICBkZDogMjUsICAvL2RheXMgdG8gbW9udGggKG1vbnRoID09IDEpXG4gICAgICAgICAgZG06IDQ1LCAgLy9kYXlzIHRvIG1vbnRocyAobW9udGhzID4gMSlcbiAgICAgICAgICBkeTogMzQ1ICAvL2RheXMgdG8geWVhclxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRva2VucyB0byBvcmRpbmFsaXplIGFuZCBwYWRcbiAgICAgICAgb3JkaW5hbGl6ZVRva2VucyA9ICdEREQgdyBXIE0gRCBkJy5zcGxpdCgnICcpLFxuICAgICAgICBwYWRkZWRUb2tlbnMgPSAnTSBEIEggaCBtIHMgdyBXJy5zcGxpdCgnICcpLFxuXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge1xuICAgICAgICAgICAgTSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNTU0gIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1NTU0gOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEQgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERERCAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5T2ZZZWFyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZCAgIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRkZCAgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZGRkIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHcgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2VlaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFcgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2VlaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSAlIDEwMCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMueWVhcigpLCA0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWVlZWSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMueWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWVlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKSwgc2lnbiA9IHkgPj0gMCA/ICcrJyA6ICctJztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiArIGxlZnRaZXJvRmlsbChNYXRoLmFicyh5KSwgNik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2cgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSAlIDEwMCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2dnZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSwgNCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2dnZ2cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCksIDUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHR0cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCksIDQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHR0dHIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtkYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBFIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtkYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBBICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG0gICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHMgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFMgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvSW50KHRoaXMubWlsbGlzZWNvbmRzKCkgLyAxMDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNTICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTApLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTU1MgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5taWxsaXNlY29uZHMoKSwgMyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1NTUyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFogICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBcIitcIjtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICBiID0gXCItXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiICsgbGVmdFplcm9GaWxsKHRvSW50KGEgLyA2MCksIDIpICsgXCI6XCIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWlogICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IC10aGlzLnpvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgYiA9IFwiK1wiO1xuICAgICAgICAgICAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBcIi1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSAvIDYwKSwgMikgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56b25lQWJicigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHp6IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmVOYW1lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bml4KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFydGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlzdHMgPSBbJ21vbnRocycsICdtb250aHNTaG9ydCcsICd3ZWVrZGF5cycsICd3ZWVrZGF5c1Nob3J0JywgJ3dlZWtkYXlzTWluJ107XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuIGRmbCBjb21lcyBmcm9tXG4gICAgLy8gZGVmYXVsdC5cbiAgICBmdW5jdGlvbiBkZmwoYSwgYiwgYykge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGEgIT0gbnVsbCA/IGEgOiBiO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gYSAhPSBudWxsID8gYSA6IGIgIT0gbnVsbCA/IGIgOiBjO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW1wbGVtZW50IG1lXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LCBhbmQgZXM1IHN0YW5kYXJkIGlzIG5vdCB2ZXJ5XG4gICAgICAgIC8vIGhlbHBmdWwuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0IDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gICAgICAgIGZ1bmN0aW9uIHByaW50TXNnKCkge1xuICAgICAgICAgICAgaWYgKG1vbWVudC5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEZXByZWNhdGlvbiB3YXJuaW5nOiBcIiArIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRNc2coKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkVG9rZW4oZnVuYywgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgY291bnQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcmRpbmFsaXplVG9rZW4oZnVuYywgcGVyaW9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLm9yZGluYWwoZnVuYy5jYWxsKHRoaXMsIGEpLCBwZXJpb2QpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHdoaWxlIChvcmRpbmFsaXplVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBpID0gb3JkaW5hbGl6ZVRva2Vucy5wb3AoKTtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbaSArICdvJ10gPSBvcmRpbmFsaXplVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbaV0sIGkpO1xuICAgIH1cbiAgICB3aGlsZSAocGFkZGVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBpID0gcGFkZGVkVG9rZW5zLnBvcCgpO1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpICsgaV0gPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpXSwgMik7XG4gICAgfVxuICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zLkREREQgPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9ucy5EREQsIDMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIExhbmd1YWdlKCkge1xuXG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gRHVyYXRpb24gQ29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDM2ZTU7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgSGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlT2ZcIikpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lTW9tZW50KG0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9LCBpO1xuICAgICAgICBmb3IgKGkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgbW9tZW50UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IG1baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxlZnQgemVybyBmaWxsIGEgbnVtYmVyXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2xlZnQtemVyby1maWxsaW5nIGZvciBwZXJmb3JtYW5jZSBjb21wYXJpc29uXG4gICAgZnVuY3Rpb24gbGVmdFplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcblxuICAgICAgICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gJzAnICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICsgb3V0cHV0O1xuICAgIH1cblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgXy5hZGRUaW1lIGFuZCBfLnN1YnRyYWN0VGltZVxuICAgIGZ1bmN0aW9uIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBkdXJhdGlvbi5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLl9tb250aHM7XG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZSgrbW9tLl9kICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICByYXdTZXR0ZXIobW9tLCAnRGF0ZScsIHJhd0dldHRlcihtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHJhd01vbnRoU2V0dGVyKG1vbSwgcmF3R2V0dGVyKG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGlzIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHxcbiAgICAgICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgICAgIHZhciBsb3dlcmVkID0gdW5pdHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oLilzJC8sICckMScpO1xuICAgICAgICAgICAgdW5pdHMgPSB1bml0QWxpYXNlc1t1bml0c10gfHwgY2FtZWxGdW5jdGlvbnNbbG93ZXJlZF0gfHwgbG93ZXJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGlucHV0T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxpc3QoZmllbGQpIHtcbiAgICAgICAgdmFyIGNvdW50LCBzZXR0ZXI7XG5cbiAgICAgICAgaWYgKGZpZWxkLmluZGV4T2YoJ3dlZWsnKSA9PT0gMCkge1xuICAgICAgICAgICAgY291bnQgPSA3O1xuICAgICAgICAgICAgc2V0dGVyID0gJ2RheSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGQuaW5kZXhPZignbW9udGgnKSA9PT0gMCkge1xuICAgICAgICAgICAgY291bnQgPSAxMjtcbiAgICAgICAgICAgIHNldHRlciA9ICdtb250aCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtb21lbnRbZmllbGRdID0gZnVuY3Rpb24gKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpLCBnZXR0ZXIsXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbW9tZW50LmZuLl9sYW5nW2ZpZWxkXSxcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0dGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG1vbWVudCgpLnV0YygpLnNldChzZXR0ZXIsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChtb21lbnQuZm4uX2xhbmcsIG0sIGZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldHRlcihpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmNlaWwoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb21lbnQoW3llYXIsIDExLCAzMSArIGRvdyAtIGRveV0pLCBkb3csIGRveSkud2VlaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICBpZiAobS5fYSAmJiBtLl9wZi5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBtLl9hW01PTlRIXSA8IDAgfHwgbS5fYVtNT05USF0gPiAxMSA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBtLl9hW0RBVEVdIDwgMSB8fCBtLl9hW0RBVEVdID4gZGF5c0luTW9udGgobS5fYVtZRUFSXSwgbS5fYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgbS5fYVtIT1VSXSA8IDAgfHwgbS5fYVtIT1VSXSA+IDIzID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgbS5fYVtNSU5VVEVdIDwgMCB8fCBtLl9hW01JTlVURV0gPiA1OSA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgbS5fYVtTRUNPTkRdIDwgMCB8fCBtLl9hW1NFQ09ORF0gPiA1OSA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgbS5fYVtNSUxMSVNFQ09ORF0gPCAwIHx8IG0uX2FbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAobS5fcGYuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5fcGYub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIG0uX3BmLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtLl9wZi51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxhbmd1YWdlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBtYWtlQXMoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5faXNVVEMgPyBtb21lbnQoaW5wdXQpLnpvbmUobW9kZWwuX29mZnNldCB8fCAwKSA6XG4gICAgICAgICAgICBtb21lbnQoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBMYW5ndWFnZXNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGV4dGVuZChMYW5ndWFnZS5wcm90b3R5cGUsIHtcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21vbnRocyA6IFwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgbW9udGhzIDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNbbS5tb250aCgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbW9udGhzU2hvcnQgOiBcIkphbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjXCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb250aHNQYXJzZSA6IGZ1bmN0aW9uIChtb250aE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbSA9IG1vbWVudC51dGMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfd2Vla2RheXMgOiBcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICB3ZWVrZGF5cyA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWtkYXlzU2hvcnQgOiBcIlN1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdFwiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydCA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfd2Vla2RheXNNaW4gOiBcIlN1X01vX1R1X1dlX1RoX0ZyX1NhXCIuc3BsaXQoXCJfXCIpLFxuICAgICAgICB3ZWVrZGF5c01pbiA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla2RheXNQYXJzZSA6IGZ1bmN0aW9uICh3ZWVrZGF5TmFtZSkge1xuICAgICAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBtb20gPSBtb21lbnQoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xvbmdEYXRlRm9ybWF0IDoge1xuICAgICAgICAgICAgTFQgOiBcImg6bW0gQVwiLFxuICAgICAgICAgICAgTCA6IFwiTU0vREQvWVlZWVwiLFxuICAgICAgICAgICAgTEwgOiBcIk1NTU0gRCBZWVlZXCIsXG4gICAgICAgICAgICBMTEwgOiBcIk1NTU0gRCBZWVlZIExUXCIsXG4gICAgICAgICAgICBMTExMIDogXCJkZGRkLCBNTU1NIEQgWVlZWSBMVFwiXG4gICAgICAgIH0sXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgICAgICAgICBpZiAoIW91dHB1dCAmJiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0ucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tZXJpZGllbVBhcnNlIDogL1thcF1cXC4/bT9cXC4/L2ksXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NhbGVuZGFyIDoge1xuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGVuZGFyIDogZnVuY3Rpb24gKGtleSwgbW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nID8gb3V0cHV0LmFwcGx5KG1vbSkgOiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlbGF0aXZlVGltZSA6IHtcbiAgICAgICAgICAgIGZ1dHVyZSA6IFwiaW4gJXNcIixcbiAgICAgICAgICAgIHBhc3QgOiBcIiVzIGFnb1wiLFxuICAgICAgICAgICAgcyA6IFwiYSBmZXcgc2Vjb25kc1wiLFxuICAgICAgICAgICAgbSA6IFwiYSBtaW51dGVcIixcbiAgICAgICAgICAgIG1tIDogXCIlZCBtaW51dGVzXCIsXG4gICAgICAgICAgICBoIDogXCJhbiBob3VyXCIsXG4gICAgICAgICAgICBoaCA6IFwiJWQgaG91cnNcIixcbiAgICAgICAgICAgIGQgOiBcImEgZGF5XCIsXG4gICAgICAgICAgICBkZCA6IFwiJWQgZGF5c1wiLFxuICAgICAgICAgICAgTSA6IFwiYSBtb250aFwiLFxuICAgICAgICAgICAgTU0gOiBcIiVkIG1vbnRoc1wiLFxuICAgICAgICAgICAgeSA6IFwiYSB5ZWFyXCIsXG4gICAgICAgICAgICB5eSA6IFwiJWQgeWVhcnNcIlxuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRpbWUgOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHBhc3RGdXR1cmUgOiBmdW5jdGlvbiAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKFwiJWRcIiwgbnVtYmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgX29yZGluYWwgOiBcIiVkXCIsXG5cbiAgICAgICAgcHJlcGFyc2UgOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvc3Rmb3JtYXQgOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWsgOiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICAgICAgfSxcblxuICAgICAgICBfd2VlayA6IHtcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbnZhbGlkRGF0ZTogJ0ludmFsaWQgZGF0ZScsXG4gICAgICAgIGludmFsaWREYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExvYWRzIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBpbnRvIHRoZSBgbGFuZ3VhZ2VzYCBjYWNoZS4gIFRoZSBmdW5jdGlvblxuICAgIC8vIHRha2VzIGEga2V5IGFuZCBvcHRpb25hbGx5IHZhbHVlcy4gIElmIG5vdCBpbiB0aGUgYnJvd3NlciBhbmQgbm8gdmFsdWVzXG4gICAgLy8gYXJlIHByb3ZpZGVkLCBpdCB3aWxsIGxvYWQgdGhlIGxhbmd1YWdlIGZpbGUgbW9kdWxlLiAgQXMgYSBjb252ZW5pZW5jZSxcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGFsc28gcmV0dXJucyB0aGUgbGFuZ3VhZ2UgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIGxvYWRMYW5nKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5hYmJyID0ga2V5O1xuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBsYW5ndWFnZXNba2V5XSA9IG5ldyBMYW5ndWFnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxhbmd1YWdlc1trZXldLnNldCh2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tleV07XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGEgbGFuZ3VhZ2UgZnJvbSB0aGUgYGxhbmd1YWdlc2AgY2FjaGUuIE1vc3RseSB1c2VmdWwgaW4gdGVzdHMuXG4gICAgZnVuY3Rpb24gdW5sb2FkTGFuZyhrZXkpIHtcbiAgICAgICAgZGVsZXRlIGxhbmd1YWdlc1trZXldO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZXMgd2hpY2ggbGFuZ3VhZ2UgZGVmaW5pdGlvbiB0byB1c2UgYW5kIHJldHVybnMgaXQuXG4gICAgLy9cbiAgICAvLyBXaXRoIG5vIHBhcmFtZXRlcnMsIGl0IHdpbGwgcmV0dXJuIHRoZSBnbG9iYWwgbGFuZ3VhZ2UuICBJZiB5b3VcbiAgICAvLyBwYXNzIGluIGEgbGFuZ3VhZ2Uga2V5LCBzdWNoIGFzICdlbicsIGl0IHdpbGwgcmV0dXJuIHRoZVxuICAgIC8vIGRlZmluaXRpb24gZm9yICdlbicsIHNvIGxvbmcgYXMgJ2VuJyBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZCB1c2luZ1xuICAgIC8vIG1vbWVudC5sYW5nLlxuICAgIGZ1bmN0aW9uIGdldExhbmdEZWZpbml0aW9uKGtleSkge1xuICAgICAgICB2YXIgaSA9IDAsIGosIGxhbmcsIG5leHQsIHNwbGl0LFxuICAgICAgICAgICAgZ2V0ID0gZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmd1YWdlc1trXSAmJiBoYXNNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbGFuZy8nICsgayk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5fbGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsYW5nID0gZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAobGFuZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvL3BpY2sgdGhlIGxhbmd1YWdlIGZyb20gdGhlIGFycmF5XG4gICAgICAgIC8vdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAgICAgLy9zdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgICAgIHdoaWxlIChpIDwga2V5Lmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMYW5ndWFnZShrZXlbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxhbmd1YWdlKGtleVtpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFuZyA9IGdldChzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9tZW50LmZuLl9sYW5nO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRm9ybWF0dGluZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgXCJcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG5cbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubGFuZygpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxhbmcoKSk7XG5cbiAgICAgICAgaWYgKCFmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSkge1xuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsYW5nKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgUGFyc2luZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gZ2V0IHRoZSByZWdleCB0byBmaW5kIHRoZSBuZXh0IHRva2VuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGEsIHN0cmljdCA9IGNvbmZpZy5fc3RyaWN0O1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVEaWdpdDtcbiAgICAgICAgY2FzZSAnRERERCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRocmVlRGlnaXRzO1xuICAgICAgICBjYXNlICdZWVlZJzpcbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGNhc2UgJ2dnZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5Gb3VyRGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvRm91ckRpZ2l0cztcbiAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuU2lnbmVkTnVtYmVyO1xuICAgICAgICBjYXNlICdZWVlZWVknOlxuICAgICAgICBjYXNlICdZWVlZWSc6XG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgY2FzZSAnZ2dnZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5TaXhEaWdpdHMgOiBwYXJzZVRva2VuT25lVG9TaXhEaWdpdHM7XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgaWYgKHN0cmljdCkgeyByZXR1cm4gcGFyc2VUb2tlbk9uZURpZ2l0OyB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ1NTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHsgcmV0dXJuIHBhcnNlVG9rZW5Ud29EaWdpdHM7IH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnU1NTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHsgcmV0dXJuIHBhcnNlVG9rZW5UaHJlZURpZ2l0czsgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzO1xuICAgICAgICBjYXNlICdNTU0nOlxuICAgICAgICBjYXNlICdNTU1NJzpcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICBjYXNlICdkZGRkJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuV29yZDtcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmV0dXJuIGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCkuX21lcmlkaWVtUGFyc2U7XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaW1lc3RhbXBNcztcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNhc2UgJ1paJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXpvbmU7XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UO1xuICAgICAgICBjYXNlICdTU1NTJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuRGlnaXRzO1xuICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgIGNhc2UgJ0REJzpcbiAgICAgICAgY2FzZSAnWVknOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgIGNhc2UgJ2dnJzpcbiAgICAgICAgY2FzZSAnSEgnOlxuICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgY2FzZSAnc3MnOlxuICAgICAgICBjYXNlICd3dyc6XG4gICAgICAgIGNhc2UgJ1dXJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuVHdvRGlnaXRzIDogcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xuICAgICAgICBjYXNlICdEbyc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9yZGluYWw7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgYSA9IG5ldyBSZWdFeHAocmVnZXhwRXNjYXBlKHVuZXNjYXBlRm9ybWF0KHRva2VuLnJlcGxhY2UoJ1xcXFwnLCAnJykpLCBcImlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcgfHwgXCJcIjtcbiAgICAgICAgdmFyIHBvc3NpYmxlVHpNYXRjaGVzID0gKHN0cmluZy5tYXRjaChwYXJzZVRva2VuVGltZXpvbmUpIHx8IFtdKSxcbiAgICAgICAgICAgIHR6Q2h1bmsgPSBwb3NzaWJsZVR6TWF0Y2hlc1twb3NzaWJsZVR6TWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXSxcbiAgICAgICAgICAgIHBhcnRzID0gKHR6Q2h1bmsgKyAnJykubWF0Y2gocGFyc2VUaW1lem9uZUNodW5rZXIpIHx8IFsnLScsIDAsIDBdLFxuICAgICAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyAtbWludXRlcyA6IG1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdG8gY29udmVydCBzdHJpbmcgaW5wdXQgdG8gZGF0ZVxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBhLCBkYXRlUGFydEFycmF5ID0gY29uZmlnLl9hO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gUVVBUlRFUlxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1PTlRIXG4gICAgICAgIGNhc2UgJ00nIDogLy8gZmFsbCB0aHJvdWdoIHRvIE1NXG4gICAgICAgIGNhc2UgJ01NJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNTU0nIDogLy8gZmFsbCB0aHJvdWdoIHRvIE1NTU1cbiAgICAgICAgY2FzZSAnTU1NTScgOlxuICAgICAgICAgICAgYSA9IGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCkubW9udGhzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSBhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIERBWSBPRiBNT05USFxuICAgICAgICBjYXNlICdEJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBERFxuICAgICAgICBjYXNlICdERCcgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RvJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbREFURV0gPSB0b0ludChwYXJzZUludChpbnB1dCwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEQVkgT0YgWUVBUlxuICAgICAgICBjYXNlICdEREQnIDogLy8gZmFsbCB0aHJvdWdoIHRvIERERERcbiAgICAgICAgY2FzZSAnRERERCcgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFlFQVJcbiAgICAgICAgY2FzZSAnWVknIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbWUVBUl0gPSBtb21lbnQucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1lZWVknIDpcbiAgICAgICAgY2FzZSAnWVlZWVknIDpcbiAgICAgICAgY2FzZSAnWVlZWVlZJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFNIC8gUE1cbiAgICAgICAgY2FzZSAnYScgOiAvLyBmYWxsIHRocm91Z2ggdG8gQVxuICAgICAgICBjYXNlICdBJyA6XG4gICAgICAgICAgICBjb25maWcuX2lzUG0gPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLmlzUE0oaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIDI0IEhPVVJcbiAgICAgICAgY2FzZSAnSCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gaGhcbiAgICAgICAgY2FzZSAnSEgnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ2gnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ2hoJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1JTlVURVxuICAgICAgICBjYXNlICdtJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBtbVxuICAgICAgICBjYXNlICdtbScgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFQ09ORFxuICAgICAgICBjYXNlICdzJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBzc1xuICAgICAgICBjYXNlICdzcycgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1JTExJU0VDT05EXG4gICAgICAgIGNhc2UgJ1MnIDpcbiAgICAgICAgY2FzZSAnU1MnIDpcbiAgICAgICAgY2FzZSAnU1NTJyA6XG4gICAgICAgIGNhc2UgJ1NTU1MnIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBVTklYIFRJTUVTVEFNUCBXSVRIIE1TXG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUSU1FWk9ORVxuICAgICAgICBjYXNlICdaJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBaWlxuICAgICAgICBjYXNlICdaWicgOlxuICAgICAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXRUVLREFZIC0gaHVtYW5cbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICBjYXNlICdkZGRkJzpcbiAgICAgICAgICAgIGEgPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fd1snZCddID0gYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdFRUssIFdFRUsgREFZIC0gbnVtZXJpY1xuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgY2FzZSAnd3cnOlxuICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgY2FzZSAnV1cnOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHIoMCwgMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2dnZ2cnOlxuICAgICAgICBjYXNlICdHR0dHJzpcbiAgICAgICAgY2FzZSAnR0dHR0cnOlxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICAgICAgY29uZmlnLl93W3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnZyc6XG4gICAgICAgIGNhc2UgJ0dHJzpcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNvbmZpZy5fd1t0b2tlbl0gPSBtb21lbnQucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCBsYW5nO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGZsKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihtb21lbnQoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGZsKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGZsKHcuRSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYW5nID0gZ2V0TGFuZ0RlZmluaXRpb24oY29uZmlnLl9sKTtcbiAgICAgICAgICAgIGRvdyA9IGxhbmcuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gbGFuZy5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGZsKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihtb21lbnQoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRmbCh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICsrd2VlaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3ksIGRvdyk7XG5cbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGZsKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBtYWtlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IG1ha2VVVENEYXRlIDogbWFrZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgem9uZSBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgKyBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRlRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dDtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQueWVhcixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5tb250aCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5kYXksXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuaG91cixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taW51dGUsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuc2Vjb25kLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kXG4gICAgICAgIF07XG5cbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENEYXRlKClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IG1vbWVudC5JU09fODYwMSkge1xuICAgICAgICAgICAgcGFyc2VJU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgbGFuZyA9IGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGxhbmcpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgY29uZmlnLl9wZi5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBhbSBwbVxuICAgICAgICBpZiAoY29uZmlnLl9pc1BtICYmIGNvbmZpZy5fYVtIT1VSXSA8IDEyKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXMgMTIgYW0sIGNoYW5nZSBob3VycyB0byAwXG4gICAgICAgIGlmIChjb25maWcuX2lzUG0gPT09IGZhbHNlICYmIGNvbmZpZy5fYVtIT1VSXSA9PT0gMTIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlRnJvbUNvbmZpZyhjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gcmVnZXhwRXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBleHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBDb25maWcuX3BmLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZi5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBwYXJzZUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaXNvID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzVdIHNob3VsZCBiZSBcIlRcIiBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mID0gaXNvRGF0ZXNbaV1bMF0gKyAobWF0Y2hbNl0gfHwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2gocGFyc2VUb2tlblRpbWV6b25lKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgcGFyc2VJU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoaW5wdXQpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gaW5wdXQuc2xpY2UoMCk7XG4gICAgICAgICAgICBkYXRlRnJvbUNvbmZpZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGVGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxhbmd1YWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbGFuZ3VhZ2Uud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFJlbGF0aXZlIFRpbWVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsYW5nKSB7XG4gICAgICAgIHJldHVybiBsYW5nLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobWlsbGlzZWNvbmRzLCB3aXRob3V0U3VmZml4LCBsYW5nKSB7XG4gICAgICAgIHZhciBzZWNvbmRzID0gcm91bmQoTWF0aC5hYnMobWlsbGlzZWNvbmRzKSAvIDEwMDApLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKHNlY29uZHMgLyA2MCksXG4gICAgICAgICAgICBob3VycyA9IHJvdW5kKG1pbnV0ZXMgLyA2MCksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoaG91cnMgLyAyNCksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGRheXMgLyAzNjUpLFxuICAgICAgICAgICAgYXJncyA9IHNlY29uZHMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLnMgICYmIFsncycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA9PT0gMSAmJiBbJ20nXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgPT09IDEgJiYgWydoJ10gfHxcbiAgICAgICAgICAgICAgICBob3VycyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdIHx8XG4gICAgICAgICAgICAgICAgZGF5cyA9PT0gMSAmJiBbJ2QnXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPD0gcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5kZCAmJiBbJ2RkJywgZGF5c10gfHxcbiAgICAgICAgICAgICAgICBkYXlzIDw9IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuZG0gJiYgWydNJ10gfHxcbiAgICAgICAgICAgICAgICBkYXlzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5keSAmJiBbJ01NJywgcm91bmQoZGF5cyAvIDMwKV0gfHxcbiAgICAgICAgICAgICAgICB5ZWFycyA9PT0gMSAmJiBbJ3knXSB8fCBbJ3l5JywgeWVhcnNdO1xuICAgICAgICBhcmdzWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYXJnc1szXSA9IG1pbGxpc2Vjb25kcyA+IDA7XG4gICAgICAgIGFyZ3NbNF0gPSBsYW5nO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkoe30sIGFyZ3MpO1xuICAgIH1cblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBXZWVrIG9mIFllYXJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrICAgICAgIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRoYXQgc3RhcnRzIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKHVzdWFsbHkgc3VuZGF5IG9yIG1vbmRheSlcbiAgICAvLyBmaXJzdERheU9mV2Vla09mWWVhciAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IHdlZWsgaXMgdGhlIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIGRheSBvZiB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIChlZy4gSVNPIHdlZWtzIHVzZSB0aHVyc2RheSAoNCkpXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xuICAgICAgICB2YXIgZW5kID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBmaXJzdERheU9mV2VlayxcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gbW9tLmRheSgpLFxuICAgICAgICAgICAgYWRqdXN0ZWRNb21lbnQ7XG5cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrID4gZW5kKSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPCBlbmQgLSA3KSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdGVkTW9tZW50ID0gbW9tZW50KG1vbSkuYWRkKCdkJywgZGF5c1RvRGF5T2ZXZWVrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IE1hdGguY2VpbChhZGp1c3RlZE1vbWVudC5kYXlPZlllYXIoKSAvIDcpLFxuICAgICAgICAgICAgeWVhcjogYWRqdXN0ZWRNb21lbnQueWVhcigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICB2YXIgZCA9IG1ha2VVVENEYXRlKHllYXIsIDAsIDEpLmdldFVUQ0RheSgpLCBkYXlzVG9BZGQsIGRheU9mWWVhcjtcblxuICAgICAgICBkID0gZCA9PT0gMCA/IDcgOiBkO1xuICAgICAgICB3ZWVrZGF5ID0gd2Vla2RheSAhPSBudWxsID8gd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICBkYXlzVG9BZGQgPSBmaXJzdERheU9mV2VlayAtIGQgKyAoZCA+IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyID8gNyA6IDApIC0gKGQgPCBmaXJzdERheU9mV2VlayA/IDcgOiAwKTtcbiAgICAgICAgZGF5T2ZZZWFyID0gNyAqICh3ZWVrIC0gMSkgKyAod2Vla2RheSAtIGZpcnN0RGF5T2ZXZWVrKSArIGRheXNUb0FkZCArIDE7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBtYWtlTW9tZW50KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gZ2V0TGFuZ0RlZmluaXRpb24oKS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnID0gY2xvbmVNb21lbnQoaW5wdXQpO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQuX2QpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFrZURhdGVGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgbW9tZW50ID0gZnVuY3Rpb24gKGlucHV0LCBmb3JtYXQsIGxhbmcsIHN0cmljdCkge1xuICAgICAgICB2YXIgYztcblxuICAgICAgICBpZiAodHlwZW9mKGxhbmcpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc3RyaWN0ID0gbGFuZztcbiAgICAgICAgICAgIGxhbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMgPSB7fTtcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9sID0gbGFuZztcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBjLl9pc1VUQyA9IGZhbHNlO1xuICAgICAgICBjLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcblxuICAgICAgICByZXR1cm4gbWFrZU1vbWVudChjKTtcbiAgICB9O1xuXG4gICAgbW9tZW50LnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuXG4gICAgbW9tZW50LmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgXCJtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyBcIiArXG4gICAgICAgICAgICBcImRpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgXCIgK1xuICAgICAgICAgICAgXCJyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gXCIgK1xuICAgICAgICAgICAgXCJodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQwNyBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kpO1xuICAgIH0pO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgbW9tZW50Lm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgbW9tZW50Lm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvLyBjcmVhdGluZyB3aXRoIHV0Y1xuICAgIG1vbWVudC51dGMgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0KSB7XG4gICAgICAgIHZhciBjO1xuXG4gICAgICAgIGlmICh0eXBlb2YobGFuZykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsYW5nO1xuICAgICAgICAgICAgbGFuZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYyA9IHt9O1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGMuX2wgPSBsYW5nO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYy5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG5cbiAgICAgICAgcmV0dXJuIG1ha2VNb21lbnQoYykudXRjKCk7XG4gICAgfTtcblxuICAgIC8vIGNyZWF0aW5nIHdpdGggdW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpXG4gICAgbW9tZW50LnVuaXggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChpbnB1dCAqIDEwMDApO1xuICAgIH07XG5cbiAgICAvLyBkdXJhdGlvblxuICAgIG1vbWVudC5kdXJhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwYXJzZUlzbztcblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFRpbWVTcGFuSnNvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gXCItXCIpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtczogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29EdXJhdGlvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gXCItXCIpID8gLTEgOiAxO1xuICAgICAgICAgICAgcGFyc2VJc28gPSBmdW5jdGlvbiAoaW5wKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICAgICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzRdKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs1XSksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbNl0pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzddKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs4XSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbihpbnB1dCkgJiYgaW5wdXQuaGFzT3duUHJvcGVydHkoJ19sYW5nJykpIHtcbiAgICAgICAgICAgIHJldC5fbGFuZyA9IGlucHV0Ll9sYW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBtb21lbnQudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgICAvLyBkZWZhdWx0IGZvcm1hdFxuICAgIG1vbWVudC5kZWZhdWx0Rm9ybWF0ID0gaXNvRm9ybWF0O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIG1vbWVudC5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgbW9tZW50Lm1vbWVudFByb3BlcnRpZXMgPSBtb21lbnRQcm9wZXJ0aWVzO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIG1vbWVudC51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIG1vbWVudC5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICBpZiAocmVsYXRpdmVUaW1lVGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmVUaW1lVGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxhbmd1YWdlIGtleS5cbiAgICBtb21lbnQubGFuZyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZm4uX2xhbmcuX2FiYnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgbG9hZExhbmcobm9ybWFsaXplTGFuZ3VhZ2Uoa2V5KSwgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHVubG9hZExhbmcoa2V5KTtcbiAgICAgICAgICAgIGtleSA9ICdlbic7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBnZXRMYW5nRGVmaW5pdGlvbihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBtb21lbnQuZHVyYXRpb24uZm4uX2xhbmcgPSBtb21lbnQuZm4uX2xhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihrZXkpO1xuICAgICAgICByZXR1cm4gci5fYWJicjtcbiAgICB9O1xuXG4gICAgLy8gcmV0dXJucyBsYW5ndWFnZSBkYXRhXG4gICAgbW9tZW50LmxhbmdEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbGFuZyAmJiBrZXkuX2xhbmcuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbGFuZy5fYWJicjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICB9O1xuXG4gICAgLy8gY29tcGFyZSBtb21lbnQgb2JqZWN0XG4gICAgbW9tZW50LmlzTW9tZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8XG4gICAgICAgICAgICAob2JqICE9IG51bGwgJiYgIG9iai5oYXNPd25Qcm9wZXJ0eSgnX2lzQU1vbWVudE9iamVjdCcpKTtcbiAgICB9O1xuXG4gICAgLy8gZm9yIHR5cGVjaGVja2luZyBEdXJhdGlvbiBvYmplY3RzXG4gICAgbW9tZW50LmlzRHVyYXRpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9O1xuXG4gICAgZm9yIChpID0gbGlzdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWFrZUxpc3QobGlzdHNbaV0pO1xuICAgIH1cblxuICAgIG1vbWVudC5ub3JtYWxpemVVbml0cyA9IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIH07XG5cbiAgICBtb21lbnQuaW52YWxpZCA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IG1vbWVudC51dGMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChtLl9wZiwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbS5fcGYudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG5cbiAgICBtb21lbnQucGFyc2Vab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfTtcblxuICAgIG1vbWVudC5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIE1vbWVudCBQcm90b3R5cGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGV4dGVuZChtb21lbnQuZm4gPSBNb21lbnQucHJvdG90eXBlLCB7XG5cbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuX2QgKyAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bml4IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubGFuZygnZW4nKS5mb3JtYXQoXCJkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWlwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0RhdGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0lTT1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMpLnV0YygpO1xuICAgICAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b0FycmF5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgbS5kYXRlKCksXG4gICAgICAgICAgICAgICAgbS5ob3VycygpLFxuICAgICAgICAgICAgICAgIG0ubWludXRlcygpLFxuICAgICAgICAgICAgICAgIG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgICAgIG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNWYWxpZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRFNUU2hpZnRlZCA6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyh0aGlzLl9hLCAodGhpcy5faXNVVEMgPyBtb21lbnQudXRjKHRoaXMuX2EpIDogbW9tZW50KHRoaXMuX2EpKS50b0FycmF5KCkpID4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNpbmdGbGFncyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuX3BmKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnZhbGlkQXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZi5vdmVyZmxvdztcbiAgICAgICAgfSxcblxuICAgICAgICB1dGMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b25lKDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvY2FsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy56b25lKDApO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCBtb21lbnQuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgZHVyO1xuICAgICAgICAgICAgLy8gc3dpdGNoIGFyZ3MgdG8gc3VwcG9ydCBhZGQoJ3MnLCAxKSBhbmQgYWRkKDEsICdzJylcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlzTmFOKCt2YWwpID8gK2lucHV0IDogK3ZhbCwgaXNOYU4oK3ZhbCkgPyB2YWwgOiBpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oK3ZhbCwgaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsIGR1ciwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgZHVyO1xuICAgICAgICAgICAgLy8gc3dpdGNoIGFyZ3MgdG8gc3VwcG9ydCBzdWJ0cmFjdCgncycsIDEpIGFuZCBzdWJ0cmFjdCgxLCAncycpXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpc05hTigrdmFsKSA/ICtpbnB1dCA6ICt2YWwsIGlzTmFOKCt2YWwpID8gdmFsIDogaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKCt2YWwsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkT3JTdWJ0cmFjdER1cmF0aW9uRnJvbU1vbWVudCh0aGlzLCBkdXIsIC0xKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZmYgOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IG1ha2VBcyhpbnB1dCwgdGhpcyksXG4gICAgICAgICAgICAgICAgem9uZURpZmYgPSAodGhpcy56b25lKCkgLSB0aGF0LnpvbmUoKSkgKiA2ZTQsXG4gICAgICAgICAgICAgICAgZGlmZiwgb3V0cHV0O1xuXG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICAvLyBhdmVyYWdlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aHMgaW4gdGhlIGdpdmVuIGRhdGVzXG4gICAgICAgICAgICAgICAgZGlmZiA9ICh0aGlzLmRheXNJbk1vbnRoKCkgKyB0aGF0LmRheXNJbk1vbnRoKCkpICogNDMyZTU7IC8vIDI0ICogNjAgKiA2MCAqIDEwMDAgLyAyXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAoKHRoaXMueWVhcigpIC0gdGhhdC55ZWFyKCkpICogMTIpICsgKHRoaXMubW9udGgoKSAtIHRoYXQubW9udGgoKSk7XG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IGJ5IHRha2luZyBkaWZmZXJlbmNlIGluIGRheXMsIGF2ZXJhZ2UgbnVtYmVyIG9mIGRheXNcbiAgICAgICAgICAgICAgICAvLyBhbmQgZHN0IGluIHRoZSBnaXZlbiBtb250aHMuXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICgodGhpcyAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCdtb250aCcpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhhdCAtIG1vbWVudCh0aGF0KS5zdGFydE9mKCdtb250aCcpKSkgLyBkaWZmO1xuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdpdGggem9uZXMsIHRvIG5lZ2F0ZSBhbGwgZHN0XG4gICAgICAgICAgICAgICAgb3V0cHV0IC09ICgodGhpcy56b25lKCkgLSBtb21lbnQodGhpcykuc3RhcnRPZignbW9udGgnKS56b25lKCkpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGF0LnpvbmUoKSAtIG1vbWVudCh0aGF0KS5zdGFydE9mKCdtb250aCcpLnpvbmUoKSkpICogNmU0IC8gZGlmZjtcbiAgICAgICAgICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmYgPSAodGhpcyAtIHRoYXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHVuaXRzID09PSAnc2Vjb25kJyA/IGRpZmYgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnbWludXRlJyA/IGRpZmYgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRpZmYgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdkYXknID8gKGRpZmYgLSB6b25lRGlmZikgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkaWZmIC0gem9uZURpZmYpIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICAgICAgZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzUm91bmQob3V0cHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBmcm9tIDogZnVuY3Rpb24gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odGhpcy5kaWZmKHRpbWUpKS5sYW5nKHRoaXMubGFuZygpLl9hYmJyKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnJvbU5vdyA6IGZ1bmN0aW9uICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tKG1vbWVudCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxlbmRhciA6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgem9uZSdkIG9yIG5vdC5cbiAgICAgICAgICAgIHZhciBub3cgPSB0aW1lIHx8IG1vbWVudCgpLFxuICAgICAgICAgICAgICAgIHNvZCA9IG1ha2VBcyhub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmYoc29kLCAnZGF5cycsIHRydWUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLmxhbmcoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0xlYXBZZWFyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRFNUIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnpvbmUoKSA8IHRoaXMuY2xvbmUoKS5tb250aCgwKS56b25lKCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUoKSA8IHRoaXMuY2xvbmUoKS5tb250aCg1KS56b25lKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxhbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHsgZCA6IGlucHV0IC0gZGF5IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vbnRoIDogbWFrZUFjY2Vzc29yKCdNb250aCcsIHRydWUpLFxuXG4gICAgICAgIHN0YXJ0T2Y6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW5kT2Y6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cyksIDEpLnN1YnRyYWN0KCdtcycsIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWZ0ZXI6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gdHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJztcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpID4gK21vbWVudChpbnB1dCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNCZWZvcmU6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gdHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJztcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpIDwgK21vbWVudChpbnB1dCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTYW1lOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IHVuaXRzIHx8ICdtcyc7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSA9PT0gK21ha2VBcyhpbnB1dCwgdGhpcykuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiBkZXByZWNhdGUoXG4gICAgICAgICAgICAgICAgIFwibW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4XCIsXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBtb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICksXG5cbiAgICAgICAgbWF4OiBkZXByZWNhdGUoXG4gICAgICAgICAgICAgICAgXCJtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDhcIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBtb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICAgICAgLy8ga2VlcFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dCBhZmZlY3RpbmdcbiAgICAgICAgLy8gdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bem9uZSgyLCB0cnVlKV0tLT4gNTozMToyNiArMDIwMFxuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCBpbnQgem9uZSArMDIwMCwgc28gd2VcbiAgICAgICAgLy8gYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgICAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAgICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgICAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICAgICAgem9uZSA6IGZ1bmN0aW9uIChpbnB1dCwga2VlcFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMDtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHRpbWV6b25lTWludXRlc0Zyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbihvZmZzZXQgLSBpbnB1dCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogdGhpcy5fZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgem9uZUFiYnIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBcIlVUQ1wiIDogXCJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICB6b25lTmFtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IFwiQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWVcIiA6IFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2Vab25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZSh0aGlzLl90em0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUodGhpcy5faSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNBbGlnbmVkSG91ck9mZnNldCA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbW9tZW50KGlucHV0KS56b25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAodGhpcy56b25lKCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXlzSW5Nb250aCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXlPZlllYXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkYXlPZlllYXIgPSByb3VuZCgobW9tZW50KHRoaXMpLnN0YXJ0T2YoJ2RheScpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChcImRcIiwgKGlucHV0IC0gZGF5T2ZZZWFyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcXVhcnRlciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtZZWFyIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sYW5nKCkuX3dlZWsuZG93LCB0aGlzLmxhbmcoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZChcInlcIiwgKGlucHV0IC0geWVhcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWtZZWFyIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKFwieVwiLCAoaW5wdXQgLSB5ZWFyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2VlayA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxhbmcoKS53ZWVrKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoXCJkXCIsIChpbnB1dCAtIHdlZWspICogNyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2VlayA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZChcImRcIiwgKGlucHV0IC0gd2VlaykgKiA3KTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrZGF5IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubGFuZygpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoXCJkXCIsIGlucHV0IC0gd2Vla2RheSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gdGhpcy5kYXkoKSB8fCA3IDogdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyBpbnB1dCA6IGlucHV0IC0gNyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2Vla3NJblllYXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtzSW5ZZWFyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5fbGFuZy5fd2VlaztcbiAgICAgICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1t1bml0c10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJZiBwYXNzZWQgYSBsYW5ndWFnZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsYW5ndWFnZSBmb3IgdGhpc1xuICAgICAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICBsYW5nIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByYXdNb250aFNldHRlcihtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgaGVyZSFcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxhbmcoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksXG4gICAgICAgICAgICAgICAgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByYXdHZXR0ZXIobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByYXdTZXR0ZXIobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ01vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHJhd01vbnRoU2V0dGVyKG1vbSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQWNjZXNzb3IodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByYXdTZXR0ZXIodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3R2V0dGVyKHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vbWVudC5mbi5taWxsaXNlY29uZCA9IG1vbWVudC5mbi5taWxsaXNlY29uZHMgPSBtYWtlQWNjZXNzb3IoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcbiAgICBtb21lbnQuZm4uc2Vjb25kID0gbW9tZW50LmZuLnNlY29uZHMgPSBtYWtlQWNjZXNzb3IoJ1NlY29uZHMnLCBmYWxzZSk7XG4gICAgbW9tZW50LmZuLm1pbnV0ZSA9IG1vbWVudC5mbi5taW51dGVzID0gbWFrZUFjY2Vzc29yKCdNaW51dGVzJywgZmFsc2UpO1xuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgbW9tZW50LmZuLmhvdXIgPSBtb21lbnQuZm4uaG91cnMgPSBtYWtlQWNjZXNzb3IoJ0hvdXJzJywgdHJ1ZSk7XG4gICAgLy8gbW9tZW50LmZuLm1vbnRoIGlzIGRlZmluZWQgc2VwYXJhdGVseVxuICAgIG1vbWVudC5mbi5kYXRlID0gbWFrZUFjY2Vzc29yKCdEYXRlJywgdHJ1ZSk7XG4gICAgbW9tZW50LmZuLmRhdGVzID0gZGVwcmVjYXRlKFwiZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC5cIiwgbWFrZUFjY2Vzc29yKCdEYXRlJywgdHJ1ZSkpO1xuICAgIG1vbWVudC5mbi55ZWFyID0gbWFrZUFjY2Vzc29yKCdGdWxsWWVhcicsIHRydWUpO1xuICAgIG1vbWVudC5mbi55ZWFycyA9IGRlcHJlY2F0ZShcInllYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQuXCIsIG1ha2VBY2Nlc3NvcignRnVsbFllYXInLCB0cnVlKSk7XG5cbiAgICAvLyBhZGQgcGx1cmFsIG1ldGhvZHNcbiAgICBtb21lbnQuZm4uZGF5cyA9IG1vbWVudC5mbi5kYXk7XG4gICAgbW9tZW50LmZuLm1vbnRocyA9IG1vbWVudC5mbi5tb250aDtcbiAgICBtb21lbnQuZm4ud2Vla3MgPSBtb21lbnQuZm4ud2VlaztcbiAgICBtb21lbnQuZm4uaXNvV2Vla3MgPSBtb21lbnQuZm4uaXNvV2VlaztcbiAgICBtb21lbnQuZm4ucXVhcnRlcnMgPSBtb21lbnQuZm4ucXVhcnRlcjtcblxuICAgIC8vIGFkZCBhbGlhc2VkIGZvcm1hdCBtZXRob2RzXG4gICAgbW9tZW50LmZuLnRvSlNPTiA9IG1vbWVudC5mbi50b0lTT1N0cmluZztcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRHVyYXRpb24gUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBleHRlbmQobW9tZW50LmR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlLCB7XG5cbiAgICAgICAgX2J1YmJsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgICAgIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgICAgICBzZWNvbmRzID0gYWJzUm91bmQobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgICAgIG1pbnV0ZXMgPSBhYnNSb3VuZChzZWNvbmRzIC8gNjApO1xuICAgICAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgICAgICBob3VycyA9IGFic1JvdW5kKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICAgICAgZGF5cyArPSBhYnNSb3VuZChob3VycyAvIDI0KTtcbiAgICAgICAgICAgIGRhdGEuZGF5cyA9IGRheXMgJSAzMDtcblxuICAgICAgICAgICAgbW9udGhzICs9IGFic1JvdW5kKGRheXMgLyAzMCk7XG4gICAgICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocyAlIDEyO1xuXG4gICAgICAgICAgICB5ZWFycyA9IGFic1JvdW5kKG1vbnRocyAvIDEyKTtcbiAgICAgICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnNSb3VuZCh0aGlzLmRheXMoKSAvIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHVtYW5pemUgOiBmdW5jdGlvbiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSArdGhpcyxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUoZGlmZmVyZW5jZSwgIXdpdGhTdWZmaXgsIHRoaXMubGFuZygpKTtcblxuICAgICAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmxhbmcoKS5wYXN0RnV0dXJlKGRpZmZlcmVuY2UsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChtb21lbnQpXG4gICAgICAgICAgICB2YXIgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgKz0gZHVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgICAgICB0aGlzLl9kYXlzICs9IGR1ci5fZGF5cztcbiAgICAgICAgICAgIHRoaXMuX21vbnRocyArPSBkdXIuX21vbnRocztcblxuICAgICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnRyYWN0IDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyAtPSBkdXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHRoaXMuX2RheXMgLT0gZHVyLl9kYXlzO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzIC09IGR1ci5fbW9udGhzO1xuXG4gICAgICAgICAgICB0aGlzLl9idWJibGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IDogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzLnRvTG93ZXJDYXNlKCkgKyAncyddKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXMgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ2FzJyArIHVuaXRzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdW5pdHMuc2xpY2UoMSkgKyAncyddKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGFuZyA6IG1vbWVudC5mbi5sYW5nLFxuXG4gICAgICAgIHRvSXNvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgICAgIHZhciB5ZWFycyA9IE1hdGguYWJzKHRoaXMueWVhcnMoKSksXG4gICAgICAgICAgICAgICAgbW9udGhzID0gTWF0aC5hYnModGhpcy5tb250aHMoKSksXG4gICAgICAgICAgICAgICAgZGF5cyA9IE1hdGguYWJzKHRoaXMuZGF5cygpKSxcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGguYWJzKHRoaXMuaG91cnMoKSksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKHRoaXMubWludXRlcygpKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5hYnModGhpcy5zZWNvbmRzKCkgKyB0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwMCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5hc1NlY29uZHMoKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuYXNTZWNvbmRzKCkgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgICAgICh5ZWFycyA/IHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgICAgICAobW9udGhzID8gbW9udGhzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgICAgICAoZGF5cyA/IGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICgoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKGhvdXJzID8gaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgICAgIChtaW51dGVzID8gbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPyBzZWNvbmRzICsgJ1MnIDogJycpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtYWtlRHVyYXRpb25HZXR0ZXIobmFtZSkge1xuICAgICAgICBtb21lbnQuZHVyYXRpb24uZm5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRHVyYXRpb25Bc0dldHRlcihuYW1lLCBmYWN0b3IpIHtcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uLmZuWydhcycgKyBuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyAvIGZhY3RvcjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKGkgaW4gdW5pdE1pbGxpc2Vjb25kRmFjdG9ycykge1xuICAgICAgICBpZiAodW5pdE1pbGxpc2Vjb25kRmFjdG9ycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgbWFrZUR1cmF0aW9uQXNHZXR0ZXIoaSwgdW5pdE1pbGxpc2Vjb25kRmFjdG9yc1tpXSk7XG4gICAgICAgICAgICBtYWtlRHVyYXRpb25HZXR0ZXIoaS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1ha2VEdXJhdGlvbkFzR2V0dGVyKCdXZWVrcycsIDYwNDhlNSk7XG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzTW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCt0aGlzIC0gdGhpcy55ZWFycygpICogMzE1MzZlNikgLyAyNTkyZTYgKyB0aGlzLnllYXJzKCkgKiAxMjtcbiAgICB9O1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIERlZmF1bHQgTGFuZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gU2V0IGRlZmF1bHQgbGFuZ3VhZ2UsIG90aGVyIGxhbmd1YWdlcyB3aWxsIGluaGVyaXQgZnJvbSBFbmdsaXNoLlxuICAgIG1vbWVudC5sYW5nKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIEVNQkVEX0xBTkdVQUdFUyAqL1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFeHBvc2luZyBNb21lbnRcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBtYWtlR2xvYmFsKHNob3VsZERlcHJlY2F0ZSkge1xuICAgICAgICAvKmdsb2JhbCBlbmRlcjpmYWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIGVuZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9sZEdsb2JhbE1vbWVudCA9IGdsb2JhbFNjb3BlLm1vbWVudDtcbiAgICAgICAgaWYgKHNob3VsZERlcHJlY2F0ZSkge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgICAgICAgICBcIkFjY2Vzc2luZyBNb21lbnQgdGhyb3VnaCB0aGUgZ2xvYmFsIHNjb3BlIGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJyZWxlYXNlLlwiLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gbW9tZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgICBpZiAoaGFzTW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbW9tZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFwibW9tZW50XCIsIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuY29uZmlnICYmIG1vZHVsZS5jb25maWcoKSAmJiBtb2R1bGUuY29uZmlnKCkubm9HbG9iYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxlYXNlIHRoZSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICBnbG9iYWxTY29wZS5tb21lbnQgPSBvbGRHbG9iYWxNb21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtb21lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBtYWtlR2xvYmFsKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VHbG9iYWwoKTtcbiAgICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIC8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4gIC8vIGRldGVjdCB0byBkZXRlcm1pbmUgdGhlIGJlc3QgUk5HIHNvdXJjZSwgbm9ybWFsaXppbmcgdG8gYSBmdW5jdGlvbiB0aGF0XG4gIC8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG4gIHZhciBfcm5nO1xuXG4gIC8vIE5vZGUuanMgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvdjAuNi4yL2FwaS9jcnlwdG8uaHRtbFxuICAvL1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICBpZiAodHlwZW9mKHJlcXVpcmUpID09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9yYiA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgICAgX3JuZyA9IF9yYiAmJiBmdW5jdGlvbigpIHtyZXR1cm4gX3JiKDE2KTt9O1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmICghX3JuZyAmJiBfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gICAgLy9cbiAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICAgIHJldHVybiBfcm5kczg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghX3JuZykge1xuICAgIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgICAvL1xuICAgIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gICAgLy8gcXVhbGl0eS5cbiAgICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JuZHM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciBjbGFzcyB0byB1c2VcbiAgdmFyIEJ1ZmZlckNsYXNzID0gdHlwZW9mKEJ1ZmZlcikgPT0gJ2Z1bmN0aW9uJyA/IEJ1ZmZlciA6IEFycmF5O1xuXG4gIC8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG4gIHZhciBfYnl0ZVRvSGV4ID0gW107XG4gIHZhciBfaGV4VG9CeXRlID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbiAgfVxuXG4gIC8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuICBmdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICAgIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24ob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbiAgfVxuXG4gIC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbiAgLy9cbiAgLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbiAgLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuICAvLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxuICB2YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgdmFyIF9ub2RlSWQgPSBbXG4gICAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuICBdO1xuXG4gIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gIHZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbiAgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG4gIHZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9IG51bGwgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gICAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAgIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAgIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gICAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPSBudWxsID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gICAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPSBudWxsID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gICAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICAgIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gICAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gICAgLy8gdGltZSBpbnRlcnZhbFxuICAgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PSBudWxsKSB7XG4gICAgICBuc2VjcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICAgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gICAgfVxuXG4gICAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICAgIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gICAgLy8gYHRpbWVfbG93YFxuICAgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX21pZGBcbiAgICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBCdWZmZXJDbGFzcygxNikgOiBudWxsO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gICAgaWYgKGJ1Zikge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xuICB9XG5cbiAgLy8gRXhwb3J0IHB1YmxpYyBBUElcbiAgdmFyIHV1aWQgPSB2NDtcbiAgdXVpZC52MSA9IHYxO1xuICB1dWlkLnY0ID0gdjQ7XG4gIHV1aWQucGFyc2UgPSBwYXJzZTtcbiAgdXVpZC51bnBhcnNlID0gdW5wYXJzZTtcbiAgdXVpZC5CdWZmZXJDbGFzcyA9IEJ1ZmZlckNsYXNzO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBQdWJsaXNoIGFzIEFNRCBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQ7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2Uge1xuICAgIC8vIFB1Ymxpc2ggYXMgZ2xvYmFsIChpbiBicm93c2VycylcbiAgICB2YXIgX3ByZXZpb3VzUm9vdCA9IF9nbG9iYWwudXVpZDtcblxuICAgIC8vICoqYG5vQ29uZmxpY3QoKWAgLSAoYnJvd3NlciBvbmx5KSB0byByZXNldCBnbG9iYWwgJ3V1aWQnIHZhcioqXG4gICAgdXVpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfZ2xvYmFsLnV1aWQgPSBfcHJldmlvdXNSb290O1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcblxuICAgIF9nbG9iYWwudXVpZCA9IHV1aWQ7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIvKiFcbiAgKiBSZXF3ZXN0ISBBIGdlbmVyYWwgcHVycG9zZSBYSFIgY29ubmVjdGlvbiBtYW5hZ2VyXG4gICogbGljZW5zZSBNSVQgKGMpIER1c3RpbiBEaWF6IDIwMTRcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL3JlcXdlc3RcbiAgKi9cblxuIWZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgY29udGV4dFtuYW1lXSA9IGRlZmluaXRpb24oKVxufSgncmVxd2VzdCcsIHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgd2luID0gd2luZG93XG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgdHdvSHVuZG8gPSAvXigyMFxcZHwxMjIzKSQvXG4gICAgLCBieVRhZyA9ICdnZXRFbGVtZW50c0J5VGFnTmFtZSdcbiAgICAsIHJlYWR5U3RhdGUgPSAncmVhZHlTdGF0ZSdcbiAgICAsIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZSdcbiAgICAsIHJlcXVlc3RlZFdpdGggPSAnWC1SZXF1ZXN0ZWQtV2l0aCdcbiAgICAsIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF1cbiAgICAsIHVuaXFpZCA9IDBcbiAgICAsIGNhbGxiYWNrUHJlZml4ID0gJ3JlcXdlc3RfJyArICgrbmV3IERhdGUoKSlcbiAgICAsIGxhc3RWYWx1ZSAvLyBkYXRhIHN0b3JlZCBieSB0aGUgbW9zdCByZWNlbnQgSlNPTlAgY2FsbGJhY2tcbiAgICAsIHhtbEh0dHBSZXF1ZXN0ID0gJ1hNTEh0dHBSZXF1ZXN0J1xuICAgICwgeERvbWFpblJlcXVlc3QgPSAnWERvbWFpblJlcXVlc3QnXG4gICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cblxuICAgICwgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBBcnJheS5pc0FycmF5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICB9XG5cbiAgICAsIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgICAgICdjb250ZW50VHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICwgJ3JlcXVlc3RlZFdpdGgnOiB4bWxIdHRwUmVxdWVzdFxuICAgICAgICAsICdhY2NlcHQnOiB7XG4gICAgICAgICAgICAgICcqJzogICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJ1xuICAgICAgICAgICAgLCAneG1sJzogICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJ1xuICAgICAgICAgICAgLCAnaHRtbCc6ICd0ZXh0L2h0bWwnXG4gICAgICAgICAgICAsICd0ZXh0JzogJ3RleHQvcGxhaW4nXG4gICAgICAgICAgICAsICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICAgICwgJ2pzJzogICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCwgdGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICwgeGhyID0gZnVuY3Rpb24obykge1xuICAgICAgICAvLyBpcyBpdCB4LWRvbWFpblxuICAgICAgICBpZiAob1snY3Jvc3NPcmlnaW4nXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB4aHIgPSB3aW5beG1sSHR0cFJlcXVlc3RdID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBudWxsXG4gICAgICAgICAgaWYgKHhociAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpblt4RG9tYWluUmVxdWVzdF0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3aW5beG1sSHR0cFJlcXVlc3RdKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsIGdsb2JhbFNldHVwT3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVhZHlTdGF0ZShyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB1c2UgX2Fib3J0ZWQgdG8gbWl0aWdhdGUgYWdhaW5zdCBJRSBlcnIgYzAwYzAyM2ZcbiAgICAgIC8vIChjYW4ndCByZWFkIHByb3BzIG9uIGFib3J0ZWQgcmVxdWVzdCBvYmplY3RzKVxuICAgICAgaWYgKHIuX2Fib3J0ZWQpIHJldHVybiBlcnJvcihyLnJlcXVlc3QpXG4gICAgICBpZiAoci5yZXF1ZXN0ICYmIHIucmVxdWVzdFtyZWFkeVN0YXRlXSA9PSA0KSB7XG4gICAgICAgIHIucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBub29wXG4gICAgICAgIGlmICh0d29IdW5kby50ZXN0KHIucmVxdWVzdC5zdGF0dXMpKSBzdWNjZXNzKHIucmVxdWVzdClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVycm9yKHIucmVxdWVzdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRIZWFkZXJzKGh0dHAsIG8pIHtcbiAgICB2YXIgaGVhZGVycyA9IG9bJ2hlYWRlcnMnXSB8fCB7fVxuICAgICAgLCBoXG5cbiAgICBoZWFkZXJzWydBY2NlcHQnXSA9IGhlYWRlcnNbJ0FjY2VwdCddXG4gICAgICB8fCBkZWZhdWx0SGVhZGVyc1snYWNjZXB0J11bb1sndHlwZSddXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddWycqJ11cblxuICAgIC8vIGJyZWFrcyBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgd2l0aCBsZWdhY3kgYnJvd3NlcnNcbiAgICBpZiAoIW9bJ2Nyb3NzT3JpZ2luJ10gJiYgIWhlYWRlcnNbcmVxdWVzdGVkV2l0aF0pIGhlYWRlcnNbcmVxdWVzdGVkV2l0aF0gPSBkZWZhdWx0SGVhZGVyc1sncmVxdWVzdGVkV2l0aCddXG4gICAgaWYgKCFoZWFkZXJzW2NvbnRlbnRUeXBlXSkgaGVhZGVyc1tjb250ZW50VHlwZV0gPSBvWydjb250ZW50VHlwZSddIHx8IGRlZmF1bHRIZWFkZXJzWydjb250ZW50VHlwZSddXG4gICAgZm9yIChoIGluIGhlYWRlcnMpXG4gICAgICBoZWFkZXJzLmhhc093blByb3BlcnR5KGgpICYmICdzZXRSZXF1ZXN0SGVhZGVyJyBpbiBodHRwICYmIGh0dHAuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q3JlZGVudGlhbHMoaHR0cCwgbykge1xuICAgIGlmICh0eXBlb2Ygb1snd2l0aENyZWRlbnRpYWxzJ10gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBodHRwLndpdGhDcmVkZW50aWFscyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGh0dHAud2l0aENyZWRlbnRpYWxzID0gISFvWyd3aXRoQ3JlZGVudGlhbHMnXVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYWxDYWxsYmFjayhkYXRhKSB7XG4gICAgbGFzdFZhbHVlID0gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gdXJsYXBwZW5kICh1cmwsIHMpIHtcbiAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBzXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpIHtcbiAgICB2YXIgcmVxSWQgPSB1bmlxaWQrK1xuICAgICAgLCBjYmtleSA9IG9bJ2pzb25wQ2FsbGJhY2snXSB8fCAnY2FsbGJhY2snIC8vIHRoZSAnY2FsbGJhY2snIGtleVxuICAgICAgLCBjYnZhbCA9IG9bJ2pzb25wQ2FsbGJhY2tOYW1lJ10gfHwgcmVxd2VzdC5nZXRjYWxsYmFja1ByZWZpeChyZXFJZClcbiAgICAgICwgY2JyZWcgPSBuZXcgUmVnRXhwKCcoKF58XFxcXD98JiknICsgY2JrZXkgKyAnKT0oW14mXSspJylcbiAgICAgICwgbWF0Y2ggPSB1cmwubWF0Y2goY2JyZWcpXG4gICAgICAsIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgICAgLCBsb2FkZWQgPSAwXG4gICAgICAsIGlzSUUxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSAxMC4wJykgIT09IC0xXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGlmIChtYXRjaFszXSA9PT0gJz8nKSB7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKGNicmVnLCAnJDE9JyArIGNidmFsKSAvLyB3aWxkY2FyZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNidmFsID0gbWF0Y2hbM10gLy8gcHJvdmlkZWQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGNia2V5ICsgJz0nICsgY2J2YWwpIC8vIG5vIGNhbGxiYWNrIGRldGFpbHMsIGFkZCAnZW1cbiAgICB9XG5cbiAgICB3aW5bY2J2YWxdID0gZ2VuZXJhbENhbGxiYWNrXG5cbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgc2NyaXB0LnNyYyA9IHVybFxuICAgIHNjcmlwdC5hc3luYyA9IHRydWVcbiAgICBpZiAodHlwZW9mIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgIT09ICd1bmRlZmluZWQnICYmICFpc0lFMTApIHtcbiAgICAgIC8vIG5lZWQgdGhpcyBmb3IgSUUgZHVlIHRvIG91dC1vZi1vcmRlciBvbnJlYWR5c3RhdGVjaGFuZ2UoKSwgYmluZGluZyBzY3JpcHRcbiAgICAgIC8vIGV4ZWN1dGlvbiB0byBhbiBldmVudCBsaXN0ZW5lciBnaXZlcyB1cyBjb250cm9sIG92ZXIgd2hlbiB0aGUgc2NyaXB0XG4gICAgICAvLyBpcyBleGVjdXRlZC4gU2VlIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQgPSAnX3JlcXdlc3RfJyArIHJlcUlkXG4gICAgfVxuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKHNjcmlwdFtyZWFkeVN0YXRlXSAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdjb21wbGV0ZScgJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnbG9hZGVkJykgfHwgbG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICBzY3JpcHQub25jbGljayAmJiBzY3JpcHQub25jbGljaygpXG4gICAgICAvLyBDYWxsIHRoZSB1c2VyIGNhbGxiYWNrIHdpdGggdGhlIGxhc3QgdmFsdWUgc3RvcmVkIGFuZCBjbGVhbiB1cCB2YWx1ZXMgYW5kIHNjcmlwdHMuXG4gICAgICBmbihsYXN0VmFsdWUpXG4gICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgbG9hZGVkID0gMVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgc2NyaXB0IHRvIHRoZSBET00gaGVhZFxuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXG4gICAgLy8gRW5hYmxlIEpTT05QIHRpbWVvdXRcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIGVycih7fSwgJ1JlcXVlc3QgaXMgYWJvcnRlZDogdGltZW91dCcsIHt9KVxuICAgICAgICBsYXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgICAgIGxvYWRlZCA9IDFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXF1ZXN0KGZuLCBlcnIpIHtcbiAgICB2YXIgbyA9IHRoaXMub1xuICAgICAgLCBtZXRob2QgPSAob1snbWV0aG9kJ10gfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKClcbiAgICAgICwgdXJsID0gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG9bJ3VybCddXG4gICAgICAvLyBjb252ZXJ0IG5vbi1zdHJpbmcgb2JqZWN0cyB0byBxdWVyeS1zdHJpbmcgZm9ybSB1bmxlc3Mgb1sncHJvY2Vzc0RhdGEnXSBpcyBmYWxzZVxuICAgICAgLCBkYXRhID0gKG9bJ3Byb2Nlc3NEYXRhJ10gIT09IGZhbHNlICYmIG9bJ2RhdGEnXSAmJiB0eXBlb2Ygb1snZGF0YSddICE9PSAnc3RyaW5nJylcbiAgICAgICAgPyByZXF3ZXN0LnRvUXVlcnlTdHJpbmcob1snZGF0YSddKVxuICAgICAgICA6IChvWydkYXRhJ10gfHwgbnVsbClcbiAgICAgICwgaHR0cFxuICAgICAgLCBzZW5kV2FpdCA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSdyZSB3b3JraW5nIG9uIGEgR0VUIHJlcXVlc3QgYW5kIHdlIGhhdmUgZGF0YSB0aGVuIHdlIHNob3VsZCBhcHBlbmRcbiAgICAvLyBxdWVyeSBzdHJpbmcgdG8gZW5kIG9mIFVSTCBhbmQgbm90IHBvc3QgZGF0YVxuICAgIGlmICgob1sndHlwZSddID09ICdqc29ucCcgfHwgbWV0aG9kID09ICdHRVQnKSAmJiBkYXRhKSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBkYXRhKVxuICAgICAgZGF0YSA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAob1sndHlwZSddID09ICdqc29ucCcpIHJldHVybiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpXG5cbiAgICAvLyBnZXQgdGhlIHhociBmcm9tIHRoZSBmYWN0b3J5IGlmIHBhc3NlZFxuICAgIC8vIGlmIHRoZSBmYWN0b3J5IHJldHVybnMgbnVsbCwgZmFsbC1iYWNrIHRvIG91cnNcbiAgICBodHRwID0gKG8ueGhyICYmIG8ueGhyKG8pKSB8fCB4aHIobylcblxuICAgIGh0dHAub3BlbihtZXRob2QsIHVybCwgb1snYXN5bmMnXSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpXG4gICAgc2V0SGVhZGVycyhodHRwLCBvKVxuICAgIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pXG4gICAgaWYgKHdpblt4RG9tYWluUmVxdWVzdF0gJiYgaHR0cCBpbnN0YW5jZW9mIHdpblt4RG9tYWluUmVxdWVzdF0pIHtcbiAgICAgICAgaHR0cC5vbmxvYWQgPSBmblxuICAgICAgICBodHRwLm9uZXJyb3IgPSBlcnJcbiAgICAgICAgLy8gTk9URTogc2VlXG4gICAgICAgIC8vIGh0dHA6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9pZXdlYmRldmVsb3BtZW50L3RocmVhZC8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmVcbiAgICAgICAgaHR0cC5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7fVxuICAgICAgICBzZW5kV2FpdCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVSZWFkeVN0YXRlKHRoaXMsIGZuLCBlcnIpXG4gICAgfVxuICAgIG9bJ2JlZm9yZSddICYmIG9bJ2JlZm9yZSddKGh0dHApXG4gICAgaWYgKHNlbmRXYWl0KSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHR0cC5zZW5kKGRhdGEpXG4gICAgICB9LCAyMDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHAuc2VuZChkYXRhKVxuICAgIH1cbiAgICByZXR1cm4gaHR0cFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxd2VzdChvLCBmbikge1xuICAgIHRoaXMubyA9IG9cbiAgICB0aGlzLmZuID0gZm5cblxuICAgIGluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VHlwZShoZWFkZXIpIHtcbiAgICAvLyBqc29uLCBqYXZhc2NyaXB0LCB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIHhtbFxuICAgIGlmIChoZWFkZXIubWF0Y2goJ2pzb24nKSkgcmV0dXJuICdqc29uJ1xuICAgIGlmIChoZWFkZXIubWF0Y2goJ2phdmFzY3JpcHQnKSkgcmV0dXJuICdqcydcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCd0ZXh0JykpIHJldHVybiAnaHRtbCdcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCd4bWwnKSkgcmV0dXJuICd4bWwnXG4gIH1cblxuICBmdW5jdGlvbiBpbml0KG8sIGZuKSB7XG5cbiAgICB0aGlzLnVybCA9IHR5cGVvZiBvID09ICdzdHJpbmcnID8gbyA6IG9bJ3VybCddXG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuXG4gICAgLy8gd2hldGhlciByZXF1ZXN0IGhhcyBiZWVuIGZ1bGZpbGxlZCBmb3IgcHVycG9zZVxuICAgIC8vIG9mIHRyYWNraW5nIHRoZSBQcm9taXNlc1xuICAgIHRoaXMuX2Z1bGZpbGxlZCA9IGZhbHNlXG4gICAgLy8gc3VjY2VzcyBoYW5kbGVyc1xuICAgIHRoaXMuX3N1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24oKXt9XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVycyA9IFtdXG4gICAgLy8gZXJyb3IgaGFuZGxlcnNcbiAgICB0aGlzLl9lcnJvckhhbmRsZXJzID0gW11cbiAgICAvLyBjb21wbGV0ZSAoYm90aCBzdWNjZXNzIGFuZCBmYWlsKSBoYW5kbGVyc1xuICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMgPSBbXVxuICAgIHRoaXMuX2VycmVkID0gZmFsc2VcbiAgICB0aGlzLl9yZXNwb25zZUFyZ3MgPSB7fVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHt9XG5cbiAgICBpZiAob1sndGltZW91dCddKSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hYm9ydCgpXG4gICAgICB9LCBvWyd0aW1lb3V0J10pXG4gICAgfVxuXG4gICAgaWYgKG9bJ3N1Y2Nlc3MnXSkge1xuICAgICAgdGhpcy5fc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ3N1Y2Nlc3MnXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9bJ2Vycm9yJ10pIHtcbiAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ2Vycm9yJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAob1snY29tcGxldGUnXSkge1xuICAgICAgdGhpcy5fY29tcGxldGVIYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snY29tcGxldGUnXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlIChyZXNwKSB7XG4gICAgICBvWyd0aW1lb3V0J10gJiYgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcbiAgICAgIHNlbGYudGltZW91dCA9IG51bGxcbiAgICAgIHdoaWxlIChzZWxmLl9jb21wbGV0ZUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fY29tcGxldGVIYW5kbGVycy5zaGlmdCgpKHJlc3ApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyAocmVzcCkge1xuICAgICAgdmFyIHR5cGUgPSBvWyd0eXBlJ10gfHwgc2V0VHlwZShyZXNwLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSlcbiAgICAgIHJlc3AgPSAodHlwZSAhPT0gJ2pzb25wJykgPyBzZWxmLnJlcXVlc3QgOiByZXNwXG4gICAgICAvLyB1c2UgZ2xvYmFsIGRhdGEgZmlsdGVyIG9uIHJlc3BvbnNlIHRleHRcbiAgICAgIHZhciBmaWx0ZXJlZFJlc3BvbnNlID0gZ2xvYmFsU2V0dXBPcHRpb25zLmRhdGFGaWx0ZXIocmVzcC5yZXNwb25zZVRleHQsIHR5cGUpXG4gICAgICAgICwgciA9IGZpbHRlcmVkUmVzcG9uc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3AucmVzcG9uc2VUZXh0ID0gclxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBjYW4ndCBhc3NpZ24gdGhpcyBpbiBJRTw9OCwganVzdCBpZ25vcmVcbiAgICAgIH1cbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcCA9IHdpbi5KU09OID8gd2luLkpTT04ucGFyc2UocikgOiBldmFsKCcoJyArIHIgKyAnKScpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IocmVzcCwgJ0NvdWxkIG5vdCBwYXJzZSBKU09OIGluIHJlc3BvbnNlJywgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdqcyc6XG4gICAgICAgICAgcmVzcCA9IGV2YWwocilcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICByZXNwID0gclxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgcmVzcCA9IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yIC8vIElFIHRyb2xvbG9cbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLmVycm9yQ29kZVxuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IucmVhc29uXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogcmVzcC5yZXNwb25zZVhNTFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwXG4gICAgICBzZWxmLl9mdWxmaWxsZWQgPSB0cnVlXG4gICAgICBmbihyZXNwKVxuICAgICAgc2VsZi5fc3VjY2Vzc0hhbmRsZXIocmVzcClcbiAgICAgIHdoaWxlIChzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzcCA9IHNlbGYuX2Z1bGZpbGxtZW50SGFuZGxlcnMuc2hpZnQoKShyZXNwKVxuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZShyZXNwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKHJlc3AsIG1zZywgdCkge1xuICAgICAgcmVzcCA9IHNlbGYucmVxdWVzdFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MubXNnID0gbXNnXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MudCA9IHRcbiAgICAgIHNlbGYuX2VycmVkID0gdHJ1ZVxuICAgICAgd2hpbGUgKHNlbGYuX2Vycm9ySGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9lcnJvckhhbmRsZXJzLnNoaWZ0KCkocmVzcCwgbXNnLCB0KVxuICAgICAgfVxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QgPSBnZXRSZXF1ZXN0LmNhbGwodGhpcywgc3VjY2VzcywgZXJyb3IpXG4gIH1cblxuICBSZXF3ZXN0LnByb3RvdHlwZSA9IHtcbiAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWVcbiAgICAgIHRoaXMucmVxdWVzdC5hYm9ydCgpXG4gICAgfVxuXG4gICwgcmV0cnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGluaXQuY2FsbCh0aGlzLCB0aGlzLm8sIHRoaXMuZm4pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU21hbGwgZGV2aWF0aW9uIGZyb20gdGhlIFByb21pc2VzIEEgQ29tbW9uSnMgc3BlY2lmaWNhdGlvblxuICAgICAqIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1Byb21pc2VzL0FcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGB0aGVuYCB3aWxsIGV4ZWN1dGUgdXBvbiBzdWNjZXNzZnVsIHJlcXVlc3RzXG4gICAgICovXG4gICwgdGhlbjogZnVuY3Rpb24gKHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgICBmYWlsID0gZmFpbCB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCA9IHN1Y2Nlc3ModGhpcy5fcmVzcG9uc2VBcmdzLnJlc3ApXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZhaWwodGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVycy5wdXNoKHN1Y2Nlc3MpXG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmYWlsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgYWx3YXlzYCB3aWxsIGV4ZWN1dGUgd2hldGhlciB0aGUgcmVxdWVzdCBzdWNjZWVkcyBvciBmYWlsc1xuICAgICAqL1xuICAsIGFsd2F5czogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZnVsZmlsbGVkIHx8IHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZuKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgZmFpbGAgd2lsbCBleGVjdXRlIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHNcbiAgICAgKi9cbiAgLCBmYWlsOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCwgdGhpcy5fcmVzcG9uc2VBcmdzLm1zZywgdGhpcy5fcmVzcG9uc2VBcmdzLnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZm4pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXdlc3QobywgZm4pIHtcbiAgICByZXR1cm4gbmV3IFJlcXdlc3QobywgZm4pXG4gIH1cblxuICAvLyBub3JtYWxpemUgbmV3bGluZSB2YXJpYW50cyBhY2NvcmRpbmcgdG8gc3BlYyAtPiBDUkxGXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShzKSB7XG4gICAgcmV0dXJuIHMgPyBzLnJlcGxhY2UoL1xccj9cXG4vZywgJ1xcclxcbicpIDogJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcmlhbChlbCwgY2IpIHtcbiAgICB2YXIgbiA9IGVsLm5hbWVcbiAgICAgICwgdCA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgLCBvcHRDYiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgLy8gSUUgZ2l2ZXMgdmFsdWU9XCJcIiBldmVuIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlIGF0dHJpYnV0ZVxuICAgICAgICAgIC8vICdzcGVjaWZpZWQnIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9jb3JlLmh0bWwjSUQtODYyNTI5MjczXG4gICAgICAgICAgaWYgKG8gJiYgIW9bJ2Rpc2FibGVkJ10pXG4gICAgICAgICAgICBjYihuLCBub3JtYWxpemUob1snYXR0cmlidXRlcyddWyd2YWx1ZSddICYmIG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXVsnc3BlY2lmaWVkJ10gPyBvWyd2YWx1ZSddIDogb1sndGV4dCddKSlcbiAgICAgICAgfVxuICAgICAgLCBjaCwgcmEsIHZhbCwgaVxuXG4gICAgLy8gZG9uJ3Qgc2VyaWFsaXplIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FibGVkIG9yIHdpdGhvdXQgYSBuYW1lXG4gICAgaWYgKGVsLmRpc2FibGVkIHx8ICFuKSByZXR1cm5cblxuICAgIHN3aXRjaCAodCkge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGlmICghL3Jlc2V0fGJ1dHRvbnxpbWFnZXxmaWxlL2kudGVzdChlbC50eXBlKSkge1xuICAgICAgICBjaCA9IC9jaGVja2JveC9pLnRlc3QoZWwudHlwZSlcbiAgICAgICAgcmEgPSAvcmFkaW8vaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHZhbCA9IGVsLnZhbHVlXG4gICAgICAgIC8vIFdlYktpdCBnaXZlcyB1cyBcIlwiIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgY2hlY2tib3ggaGFzIG5vIHZhbHVlLCBzbyBjb3JyZWN0IGl0IGhlcmVcbiAgICAgICAgOyghKGNoIHx8IHJhKSB8fCBlbC5jaGVja2VkKSAmJiBjYihuLCBub3JtYWxpemUoY2ggJiYgdmFsID09PSAnJyA/ICdvbicgOiB2YWwpKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBjYihuLCBub3JtYWxpemUoZWwudmFsdWUpKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaWYgKGVsLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdC1vbmUnKSB7XG4gICAgICAgIG9wdENiKGVsLnNlbGVjdGVkSW5kZXggPj0gMCA/IGVsLm9wdGlvbnNbZWwuc2VsZWN0ZWRJbmRleF0gOiBudWxsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgZWwubGVuZ3RoICYmIGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLm9wdGlvbnNbaV0uc2VsZWN0ZWQgJiYgb3B0Q2IoZWwub3B0aW9uc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBjb2xsZWN0IHVwIGFsbCBmb3JtIGVsZW1lbnRzIGZvdW5kIGZyb20gdGhlIHBhc3NlZCBhcmd1bWVudCBlbGVtZW50cyBhbGxcbiAgLy8gdGhlIHdheSBkb3duIHRvIGNoaWxkIGVsZW1lbnRzOyBwYXNzIGEgJzxmb3JtPicgb3IgZm9ybSBmaWVsZHMuXG4gIC8vIGNhbGxlZCB3aXRoICd0aGlzJz1jYWxsYmFjayB0byB1c2UgZm9yIHNlcmlhbCgpIG9uIGVhY2ggZWxlbWVudFxuICBmdW5jdGlvbiBlYWNoRm9ybUVsZW1lbnQoKSB7XG4gICAgdmFyIGNiID0gdGhpc1xuICAgICAgLCBlLCBpXG4gICAgICAsIHNlcmlhbGl6ZVN1YnRhZ3MgPSBmdW5jdGlvbiAoZSwgdGFncykge1xuICAgICAgICAgIHZhciBpLCBqLCBmYVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmYSA9IGVbYnlUYWddKHRhZ3NbaV0pXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZmEubGVuZ3RoOyBqKyspIHNlcmlhbChmYVtqXSwgY2IpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlID0gYXJndW1lbnRzW2ldXG4gICAgICBpZiAoL2lucHV0fHNlbGVjdHx0ZXh0YXJlYS9pLnRlc3QoZS50YWdOYW1lKSkgc2VyaWFsKGUsIGNiKVxuICAgICAgc2VyaWFsaXplU3VidGFncyhlLCBbICdpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnIF0pXG4gICAgfVxuICB9XG5cbiAgLy8gc3RhbmRhcmQgcXVlcnkgc3RyaW5nIHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplUXVlcnlTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHJlcXdlc3QudG9RdWVyeVN0cmluZyhyZXF3ZXN0LnNlcmlhbGl6ZUFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpXG4gIH1cblxuICAvLyB7ICduYW1lJzogJ3ZhbHVlJywgLi4uIH0gc3R5bGUgc2VyaWFsaXphdGlvblxuICBmdW5jdGlvbiBzZXJpYWxpemVIYXNoKCkge1xuICAgIHZhciBoYXNoID0ge31cbiAgICBlYWNoRm9ybUVsZW1lbnQuYXBwbHkoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSBpbiBoYXNoKSB7XG4gICAgICAgIGhhc2hbbmFtZV0gJiYgIWlzQXJyYXkoaGFzaFtuYW1lXSkgJiYgKGhhc2hbbmFtZV0gPSBbaGFzaFtuYW1lXV0pXG4gICAgICAgIGhhc2hbbmFtZV0ucHVzaCh2YWx1ZSlcbiAgICAgIH0gZWxzZSBoYXNoW25hbWVdID0gdmFsdWVcbiAgICB9LCBhcmd1bWVudHMpXG4gICAgcmV0dXJuIGhhc2hcbiAgfVxuXG4gIC8vIFsgeyBuYW1lOiAnbmFtZScsIHZhbHVlOiAndmFsdWUnIH0sIC4uLiBdIHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgcmVxd2VzdC5zZXJpYWxpemVBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gW11cbiAgICBlYWNoRm9ybUVsZW1lbnQuYXBwbHkoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICBhcnIucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSlcbiAgICB9LCBhcmd1bWVudHMpXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgcmVxd2VzdC5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuICAgIHZhciBvcHQsIGZuXG4gICAgICAsIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cbiAgICBvcHQgPSBhcmdzLnBvcCgpXG4gICAgb3B0ICYmIG9wdC5ub2RlVHlwZSAmJiBhcmdzLnB1c2gob3B0KSAmJiAob3B0ID0gbnVsbClcbiAgICBvcHQgJiYgKG9wdCA9IG9wdC50eXBlKVxuXG4gICAgaWYgKG9wdCA9PSAnbWFwJykgZm4gPSBzZXJpYWxpemVIYXNoXG4gICAgZWxzZSBpZiAob3B0ID09ICdhcnJheScpIGZuID0gcmVxd2VzdC5zZXJpYWxpemVBcnJheVxuICAgIGVsc2UgZm4gPSBzZXJpYWxpemVRdWVyeVN0cmluZ1xuXG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH1cblxuICByZXF3ZXN0LnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAobywgdHJhZCkge1xuICAgIHZhciBwcmVmaXgsIGlcbiAgICAgICwgdHJhZGl0aW9uYWwgPSB0cmFkIHx8IGZhbHNlXG4gICAgICAsIHMgPSBbXVxuICAgICAgLCBlbmMgPSBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgICwgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICB2YWx1ZSA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUpID8gdmFsdWUoKSA6ICh2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSlcbiAgICAgICAgICBzW3MubGVuZ3RoXSA9IGVuYyhrZXkpICsgJz0nICsgZW5jKHZhbHVlKVxuICAgICAgICB9XG4gICAgLy8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cbiAgICBpZiAoaXNBcnJheShvKSkge1xuICAgICAgZm9yIChpID0gMDsgbyAmJiBpIDwgby5sZW5ndGg7IGkrKykgYWRkKG9baV1bJ25hbWUnXSwgb1tpXVsndmFsdWUnXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgZm9yIChwcmVmaXggaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpKSBidWlsZFBhcmFtcyhwcmVmaXgsIG9bcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzcGFjZXMgc2hvdWxkIGJlICsgYWNjb3JkaW5nIHRvIHNwZWNcbiAgICByZXR1cm4gcy5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XG4gICAgdmFyIG5hbWUsIGksIHZcbiAgICAgICwgcmJyYWNrZXQgPSAvXFxbXFxdJC9cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgZm9yIChpID0gMDsgb2JqICYmIGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdiA9IG9ialtpXVxuICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgIGFkZChwcmVmaXgsIHYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyA/IGkgOiAnJykgKyAnXScsIHYsIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiBvYmoudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgbmFtZSArICddJywgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgIGFkZChwcmVmaXgsIG9iailcbiAgICB9XG4gIH1cblxuICByZXF3ZXN0LmdldGNhbGxiYWNrUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFja1ByZWZpeFxuICB9XG5cbiAgLy8galF1ZXJ5IGFuZCBaZXB0byBjb21wYXRpYmlsaXR5LCBkaWZmZXJlbmNlcyBjYW4gYmUgcmVtYXBwZWQgaGVyZSBzbyB5b3UgY2FuIGNhbGxcbiAgLy8gLmFqYXguY29tcGF0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICByZXF3ZXN0LmNvbXBhdCA9IGZ1bmN0aW9uIChvLCBmbikge1xuICAgIGlmIChvKSB7XG4gICAgICBvWyd0eXBlJ10gJiYgKG9bJ21ldGhvZCddID0gb1sndHlwZSddKSAmJiBkZWxldGUgb1sndHlwZSddXG4gICAgICBvWydkYXRhVHlwZSddICYmIChvWyd0eXBlJ10gPSBvWydkYXRhVHlwZSddKVxuICAgICAgb1snanNvbnBDYWxsYmFjayddICYmIChvWydqc29ucENhbGxiYWNrTmFtZSddID0gb1snanNvbnBDYWxsYmFjayddKSAmJiBkZWxldGUgb1snanNvbnBDYWxsYmFjayddXG4gICAgICBvWydqc29ucCddICYmIChvWydqc29ucENhbGxiYWNrJ10gPSBvWydqc29ucCddKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlcXdlc3QobywgZm4pXG4gIH1cblxuICByZXF3ZXN0LmFqYXhTZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgIGdsb2JhbFNldHVwT3B0aW9uc1trXSA9IG9wdGlvbnNba11cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxd2VzdFxufSk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBzZjtcblxuICBzZiA9IHJlcXVpcmUoXCIuL2hvc3QvaG9zdFwiKShmYWxzZSk7XG5cbiAgKGZ1bmN0aW9uKHdpbmRvdywgc2YpIHtcbiAgICByZXR1cm4gd2luZG93W1wiJHNmXCJdID0gc2Y7XG4gIH0pKHdpbmRvdywgc2YpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gc2Y7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBzZjtcblxuICBzZiA9IHJlcXVpcmUoJy4uL3NoYXJlZC9iYXNlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93LCBzZikge1xuICAgIHZhciBBVVRPX0JPT1RfTUFYX1JFVFJJRVMsIFNGX0RBVEFUQUdfQ0xBU1MsIFNGX1BPU0VMRU1fV1JBUFBFUl9DTEFTUywgU0ZfVEFHX1RZUEUsIGJvb3QsIGJvb3RfcmV0cmllcywgZCwgZG9pbmdfYXV0b19ib290LCBkb20sIGhhc19ib290ZWQsIGlubGluZV90YWdzX3Byb2Nlc3NlZCwgbGFuZywgbGliLCB3aW4sIF9hdHRyLCBfYXV0b19ib290LCBfY2xlYW5fdXBfYm9vdGVkX3RhZ3MsIF9jcmVhdGVfcG9zX21hcmt1cCwgX2NzdHIsIF9lbHQsIF9ndWlkLCBfbG9nLCBfcGFyLCBfcHVyZ2UsIF9yZWFkeSwgX3RhZ3M7XG4gICAgd2luID0gd2luZG93ICE9IG51bGwgPyB3aW5kb3cgOiB0aGlzO1xuICAgIF9sb2cgPSBmdW5jdGlvbihtc2csIGlzX2Vycikge1xuICAgICAgdmFyIGVycl90YWcsIGhlYWRfZWwsIGxpYjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpYiA9IHNmLmxpYjtcbiAgICAgICAgaWYgKGxpYiAmJiBsaWIubG9nZ2VyICYmIHdpbiA9PT0gdG9wKSB7XG4gICAgICAgICAgaWYgKGlzX2Vycikge1xuICAgICAgICAgICAgbGliLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWIubG9nZ2VyLmxvZyhtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkX2VsID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gICAgICAgICAgZXJyX3RhZyA9IGQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICBlcnJfdGFnLnR5cGUgPSBcInRleHQvcGxhaW5cIjtcbiAgICAgICAgICBlcnJfdGFnLnRleHQgPSBcIjwhLS0gU2FmZUZyYW1lIFwiICsgKGlzX2VyciA/IFwiZXJyb3JcIiA6IFwibG9nXCIpICsgXCI6IFwiICsgKG1zZyB8fCBcInVua25vd25cIikgKyBcIiAtLT5cIjtcbiAgICAgICAgICBoZWFkX2VsLmFwcGVuZENoaWxkKGhlYWRfZWwsIGVycl90YWcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ3JlYXRlIHRoZSBIVE1MIG1hcmt1cCBmb3IgYSBwb3NpdGlvbiBpZiBhIHNyYyBwcm9wZXJ0eSB3YXMgdXNlZFxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LV9jcmVhdGVfcG9zX21hcmt1cFxuICAgIEBmdW5jdGlvblxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBfY3JlYXRlX3Bvc19tYXJrdXAgPSBmdW5jdGlvbihzcmMpIHtcbiAgICAgIHJldHVybiBfY3N0cihbXCI8c2NyXCIsIFwiaXB0IHR5cGU9J3RleHQvamF2YXNjcmlwdCcsIHNyYz0nXCIsIHNyYywgXCInPjwvc2NyXCIsIFwiaXB0PlwiXSk7XG4gICAgfTtcbiAgICBfYXV0b19ib290ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29uZmlnLCBkb19hdXRvLCBkb2luZ19hdXRvX2Jvb3QsIGUsIGhlYWQsIGhvc3RfZmlsZSwgc2NyX3RhZywgc2ZfaG9zdDtcbiAgICAgIGRvX2F1dG8gPSB0cnVlO1xuICAgICAgY29uZmlnID0gdm9pZCAwO1xuICAgICAgc2ZfaG9zdCA9IHZvaWQgMDtcbiAgICAgIGhvc3RfZmlsZSA9IHZvaWQgMDtcbiAgICAgIGhlYWQgPSB2b2lkIDA7XG4gICAgICBzY3JfdGFnID0gdm9pZCAwO1xuICAgICAgaWYgKGhhc19ib290ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2ZfaG9zdCA9IHNmICYmIHNmLmhvc3Q7XG4gICAgICBpZiAod2luID09PSB0b3ApIHtcbiAgICAgICAgaWYgKHNmX2hvc3QgJiYgIXNmX2hvc3QuYm9vdCkge1xuICAgICAgICAgIHNmX2hvc3QuYm9vdCA9IGJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25maWcgPSBzZl9ob3N0ICYmIHNmX2hvc3QuQ29uZmlnKCk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgY29uZmlnID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25maWcgPSBzZl9ob3N0ICYmIHNmX2hvc3QuY29uZjtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICBjb25maWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgaWYgKChcImF1dG9cIiBpbiBjb25maWcpICYmIGNvbmZpZy5hdXRvID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZG9fYXV0byA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNmX2hvc3QucmVuZGVyIHx8ICFzZl9ob3N0LkNvbmZpZykge1xuICAgICAgICAgICAgaG9zdF9maWxlID0gY29uZmlnLmhvc3RGaWxlO1xuICAgICAgICAgICAgaWYgKGhvc3RfZmlsZSkge1xuICAgICAgICAgICAgICBoZWFkID0gX3RhZ3MoXCJoZWFkXCIpWzBdO1xuICAgICAgICAgICAgICBzY3JfdGFnID0gZG9tLm1ha2UoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICAgIHNjcl90YWcuaWQgPSBcInNmX2hvc3RfbGliXCI7XG4gICAgICAgICAgICAgIHNjcl90YWcudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICAgIHNjcl90YWcuY2xhc3NOYW1lID0gXCJzZl9saWJcIjtcbiAgICAgICAgICAgICAgc2NyX3RhZy5zcmMgPSBob3N0X2ZpbGU7XG4gICAgICAgICAgICAgIGlmICh3aW4uQWN0aXZlWE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHNjcl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZG9pbmdfYXV0b19ib290LCBycztcbiAgICAgICAgICAgICAgICAgIHJzID0gc2NyX3RhZy5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgICAgICAgaWYgKHJzID09PSBcImxvYWRlZFwiIHx8IHJzID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9pbmdfYXV0b19ib290ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb19hdXRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYm9vdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjcl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc2NyX3RhZyA9IGhlYWQgPSBzZl9ob3N0ID0gY29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcl90YWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZG9pbmdfYXV0b19ib290O1xuICAgICAgICAgICAgICAgICAgZG9pbmdfYXV0b19ib290ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoZG9fYXV0bykge1xuICAgICAgICAgICAgICAgICAgICBib290KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzY3JfdGFnLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBzY3JfdGFnID0gaGVhZCA9IHNmX2hvc3QgPSBjb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9pbmdfYXV0b19ib290ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JfdGFnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9fYXV0bykge1xuICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IHRydWU7XG4gICAgICAgICAgICBib290KCk7XG4gICAgICAgICAgICBkb2luZ19hdXRvX2Jvb3QgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJvb3RfcmV0cmllcysrIDw9IEFVVE9fQk9PVF9NQVhfUkVUUklFUykge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KF9hdXRvX2Jvb3QsIDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvb3QoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBHbyB0aHJvdWdoIGFuZCByZW1vdmUgYW55IGlubGluZSBzY3JpcHQgdGFncyB0aGF0IGFyZSBvdXIgZGF0YS1pc2xhbmRzICwgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gYm9vc3RyYXBwZWRcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1fY2xlYW5fdXBfYm9vdGVkX3RhZ3NcbiAgICBAcHJpdmF0ZVxuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICBfY2xlYW5fdXBfYm9vdGVkX3RhZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY3JpcHRfdGFnLCBzY3JpcHRfdGFnX2lkO1xuICAgICAgc2NyaXB0X3RhZ19pZCA9IHZvaWQgMDtcbiAgICAgIHNjcmlwdF90YWcgPSB2b2lkIDA7XG4gICAgICBpZiAoZG9tKSB7XG4gICAgICAgIGZvciAoc2NyaXB0X3RhZ19pZCBpbiBpbmxpbmVfdGFnc19wcm9jZXNzZWQpIHtcbiAgICAgICAgICBzY3JpcHRfdGFnID0gX2VsdChzY3JpcHRfdGFnX2lkKTtcbiAgICAgICAgICBpZiAoc2NyaXB0X3RhZykge1xuICAgICAgICAgICAgX3B1cmdlKHNjcmlwdF90YWcpO1xuICAgICAgICAgICAgZGVsZXRlIGlubGluZV90YWdzX3Byb2Nlc3NlZFtzY3JpcHRfdGFnX2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWFyY2ggZm9yIFNhZmVGcmFtZXMgdGFncyBhbmQgcmVuZGVyIHRoZW0uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAgYXV0b21hdGljYWxseSB3aGVuZXZlciB0aGUgU2FmZUZyYW1lcyBwdWJsaXNoZXIgbGlicmFyeSBpcyBsb2FkZWQuIEhvd2V2ZXIgYSBjb25maWd1cmF0aW9uXG4gICAgY2FuIGJlIGFwcGxpZWQgdG8gbm90IGhhdmUgU2FmZUZyYW1lcyB0YWdzIGF1dG9tYXRpY2FsbHkgYmUgcmVuZGVyZWQsIHJlcXVpcmluZyBhIGNvbnRyb2xsZWRcbiAgICBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QuYm9vdFxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgYm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJvb3RfcG9zaXRpb25zLCBkYXRhLCBlLCBlcnIsIGVyck1zZywgaGFzX2Jvb3RlZCwgaHRtbCwgaWR4LCBsaWIsIG1ldGFfa2V5LCBwb3NfY29uZiwgcG9zX2Rlc3RfZWwsIHBvc19tZXRhLCBwb3NfbWV0YV9pdGVtLCBwb3Nfb2JqLCBwcnZfbWV0YSwgcHJ2X21ldGFfa2V5LCByZXQsIHNjcmlwdF90YWcsIHNjcmlwdF90YWdfaWQsIHNjcmlwdF90YWdfcGFyLCBzY3JpcHRfdGFncywgc2ZfY29uZiwgc2ZfaG9zdCwgc2ZfaW5saW5lX2NvbmYsIHNmX29jbmYsIHNoYXJlZF9tZXRhLCB0eXA7XG4gICAgICBzY3JpcHRfdGFncyA9IChfdGFncyAmJiBfdGFncyhcInNjcmlwdFwiKSkgfHwgW107XG4gICAgICBib290X3Bvc2l0aW9ucyA9IFtdO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgZXJyTXNnID0gdm9pZCAwO1xuICAgICAgc2ZfaG9zdCA9IHNmICYmIHNmLmhvc3Q7XG4gICAgICBzZl9pbmxpbmVfY29uZiA9IHNmX2hvc3QgJiYgc2ZfaG9zdC5jb25mO1xuICAgICAgc2NyaXB0X3RhZyA9IHZvaWQgMDtcbiAgICAgIHNjcmlwdF90YWdfcGFyID0gdm9pZCAwO1xuICAgICAgc2NyaXB0X3RhZ19pZCA9IHZvaWQgMDtcbiAgICAgIGRhdGEgPSB2b2lkIDA7XG4gICAgICBodG1sID0gdm9pZCAwO1xuICAgICAgcG9zX29iaiA9IHZvaWQgMDtcbiAgICAgIHBvc19jb25mID0gdm9pZCAwO1xuICAgICAgcG9zX2Rlc3RfZWwgPSB2b2lkIDA7XG4gICAgICBwb3NfbWV0YSA9IHZvaWQgMDtcbiAgICAgIHBvc19tZXRhX2l0ZW0gPSB2b2lkIDA7XG4gICAgICB0eXAgPSB2b2lkIDA7XG4gICAgICBzaGFyZWRfbWV0YSA9IHZvaWQgMDtcbiAgICAgIHBydl9tZXRhID0gdm9pZCAwO1xuICAgICAgcHJ2X21ldGFfa2V5ID0gdm9pZCAwO1xuICAgICAgbWV0YV9rZXkgPSB2b2lkIDA7XG4gICAgICBzZl9vY25mID0gdm9pZCAwO1xuICAgICAgZXJyID0gdm9pZCAwO1xuICAgICAgaWYgKCFzZiB8fCAhbGFuZyB8fCAhZG9tKSB7XG4gICAgICAgIF9sb2coXCJTYWZlRnJhbWUgYmFzZSBsaWJyYXJ5IG5vdCBmb3VuZFwiLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGlmICghbGliKSB7XG4gICAgICAgIGxpYiA9IHNmICYmIHNmLmxpYjtcbiAgICAgIH1cbiAgICAgIGlmIChkb2luZ19hdXRvX2Jvb3QgJiYgaGFzX2Jvb3RlZCkge1xuICAgICAgICBfbG9nKFwiQXV0b21hdGljIGJvb3QgYWxyZWFkeSBpbnZva2VkXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgaWYgKHdpbiA9PT0gdG9wKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2ZfY29uZiA9IHNmX2hvc3QuQ29uZmlnKCk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICBzZl9jb25mID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2ZfaW5saW5lX2NvbmYgJiYgIXNmX2NvbmYpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2ZfY29uZiA9IHNmX2hvc3QuQ29uZmlnKHNmX2lubGluZV9jb25mKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICBzZl9jb25mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZl9jb25mKSB7XG4gICAgICAgICAgX2xvZyhcIk5vIGNvbmZpZ3VyYXRpb24gZm91bmRcIik7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHNjcmlwdF90YWcgPSBzY3JpcHRfdGFnc1tpZHgrK10pIHtcbiAgICAgICAgaWYgKHNjcmlwdF90YWcuY2xhc3NOYW1lID09PSBTRl9EQVRBVEFHX0NMQVNTIHx8IF9hdHRyKHNjcmlwdF90YWcsIFwidHlwZVwiKSA9PT0gU0ZfVEFHX1RZUEUpIHtcbiAgICAgICAgICBoYXNfYm9vdGVkID0gdHJ1ZTtcbiAgICAgICAgICBzY3JpcHRfdGFnX2lkID0gX2F0dHIoc2NyaXB0X3RhZywgXCJpZFwiKTtcbiAgICAgICAgICBpZiAoIXNjcmlwdF90YWdfaWQpIHtcbiAgICAgICAgICAgIHNjcmlwdF90YWdfaWQgPSBfZ3VpZChcInNmX2RhdGFfZWxlbWVudFwiKTtcbiAgICAgICAgICAgIF9hdHRyKHNjcmlwdF90YWcsIFwiaWRcIiwgc2NyaXB0X3RhZ19pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmxpbmVfdGFnc19wcm9jZXNzZWRbc2NyaXB0X3RhZ19pZF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhID0gc2NyaXB0X3RhZy50ZXh0IHx8IHNjcmlwdF90YWcuaW5uZXJIVE1MIHx8IHNjcmlwdF90YWcuaW5uZXJUZXh0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gbGFuZy50cmltKGRhdGEpO1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBGdW5jdGlvbihcInJldHVybiBcIiArIGRhdGEpO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEoKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgZXJyTXNnID0gXCJFcnJvciBwYXJzaW5nIHRhZyBjb25maWd1cmF0aW9uIFwiICsgKGVyciAmJiBlcnIubWVzc2FnZSB8fCBcIlwiKTtcbiAgICAgICAgICAgIF9sb2coZXJyTXNnLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmlkICYmIChkYXRhLmh0bWwgfHwgZGF0YS5zcmMpKSB7XG4gICAgICAgICAgICBpZiAod2luICE9PSB0b3ApIHtcbiAgICAgICAgICAgICAgaHRtbCA9IGRhdGEuaHRtbCB8fCBcIlwiO1xuICAgICAgICAgICAgICBodG1sID0gaHRtbCB8fCBfY3JlYXRlX3Bvc19tYXJrdXAoZGF0YS5zcmMpO1xuICAgICAgICAgICAgICBpZiAoIV9yZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgZC53cml0ZShodG1sKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfbG9nKFwiY2Fubm90IHdyaXRlIGh0bWwgY29udGVudCBpbnRvIGFscmVhZHkgbG9hZGVkIGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY3JpcHRfdGFnX3BhciA9IF9wYXIoc2NyaXB0X3RhZyk7XG4gICAgICAgICAgICAgIGlmICghc2NyaXB0X3RhZ19wYXIpIHtcbiAgICAgICAgICAgICAgICBfbG9nKFwiY2FuJ3QgZmluZCBwYXJlbnQgZWxlbWVudCBmb3Igc2NyaXB0IHRhZ1wiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3NfY29uZiA9IHNmX2NvbmYgJiYgc2ZfY29uZi5wb3NpdGlvbnNbZGF0YS5pZF07XG4gICAgICAgICAgICAgIGlmICghcG9zX2NvbmYpIHtcbiAgICAgICAgICAgICAgICBwb3NfY29uZiA9IGRhdGEuY29uZjtcbiAgICAgICAgICAgICAgICBwb3NfY29uZi5pZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvc19jb25mKSB7XG4gICAgICAgICAgICAgICAgICBwb3NfY29uZiA9IG5ldyBzZl9ob3N0LlBvc0NvbmZpZyhwb3NfY29uZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcG9zX2NvbmYpIHtcbiAgICAgICAgICAgICAgICBfbG9nKFwibm8gcG9zaXRpb24gY29uZiBmb3VuZCBwcmUtZGVmaW5lZCBvciBpbmxpbmUgZm9yIHBvc2l0aW9uIFwiICsgZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwb3NfY29uZi5kZXN0KSB7XG4gICAgICAgICAgICAgICAgcG9zX2NvbmYgPSBuZXcgc2ZfaG9zdC5Qb3NDb25maWcocG9zX2NvbmYsIF9ndWlkKFNGX1BPU0VMRU1fV1JBUFBFUl9DTEFTUykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYXRhLm1ldGEpIHtcbiAgICAgICAgICAgICAgICBwb3NfbWV0YSA9IGRhdGEubWV0YTtcbiAgICAgICAgICAgICAgICBtZXRhX2tleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc2hhcmVkX21ldGEgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKG1ldGFfa2V5IGluIHBvc19tZXRhKSB7XG4gICAgICAgICAgICAgICAgICBwb3NfbWV0YV9pdGVtID0gcG9zX21ldGFbbWV0YV9rZXldO1xuICAgICAgICAgICAgICAgICAgdHlwID0gdHlwZW9mIHBvc19tZXRhX2l0ZW07XG4gICAgICAgICAgICAgICAgICBpZiAoIXBydl9tZXRhICYmIHR5cCA9PT0gXCJvYmplY3RcIiAmJiBwb3NfbWV0YV9pdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydl9tZXRhID0gcG9zX21ldGFfaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgcHJ2X21ldGFfa2V5ID0gbWV0YV9rZXk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodHlwICE9PSBcIm9iamVjdFwiICYmIHR5cCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXJlZF9tZXRhW21ldGFfa2V5XSA9IHBvc19tZXRhX2l0ZW07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc19tZXRhID0gbmV3IHNmX2hvc3QuUG9zTWV0YShzaGFyZWRfbWV0YSwgcHJ2X21ldGFfa2V5IHx8IFwiXCIsIChwcnZfbWV0YV9rZXkgJiYgcHJ2X21ldGEgPyBwcnZfbWV0YSA6IG51bGwpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3Nfb2JqID0gbmV3IHNmX2hvc3QuUG9zaXRpb24oZGF0YSwgbnVsbCwgcG9zX21ldGEsIHBvc19jb25mKTtcbiAgICAgICAgICAgICAgaW5saW5lX3RhZ3NfcHJvY2Vzc2VkW3NjcmlwdF90YWdfaWRdID0gc2NyaXB0X3RhZ19pZDtcbiAgICAgICAgICAgICAgcG9zX2Rlc3RfZWwgPSBfZWx0KHBvc19jb25mLmRlc3QpO1xuICAgICAgICAgICAgICBpZiAoIXBvc19kZXN0X2VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9yZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICBwb3NfZGVzdF9lbCA9IGRvbS5tYWtlKFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgX2F0dHIocG9zX2Rlc3RfZWwsIFwiaWRcIiwgcG9zX2NvbmYuZGVzdCk7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRfdGFnX3Bhci5pbnNlcnRCZWZvcmUocG9zX2Rlc3RfZWwpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX2xvZyhcImZhaWxlZCBhdXRvLWFkZGluZyBkZXN0aW5hdGlvbiBlbGVtZW50IFwiICsgZXJyLm1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZC53cml0ZShcIjxkaXYgaWQ9J1wiLCBwb3NfY29uZi5kZXN0LCBcIic+PC9kaXY+XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBib290X3Bvc2l0aW9ucy5wdXNoKHBvc19vYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbG9nKFwibm8gY29udGVudCBvciBpZCBwcm9wZXJ0eSBmb3VuZCBpbiB0aGUgaW5saW5lIHBvc2l0aW9uIG9iamVjdFwiLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib290X3Bvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZl9ob3N0LnJlbmRlcihib290X3Bvc2l0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgX2xvZyhcImZhaWxlZCBkdXJpbmcgcmVuZGVyaW5nIFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2xvZyhcIm5vIHBvc2l0aW9ucyB0byBib290XCIpO1xuICAgICAgfVxuICAgICAgZG9tLndhaXQoX2NsZWFuX3VwX2Jvb3RlZF90YWdzKTtcbiAgICB9O1xuICAgIFNGX0RBVEFUQUdfQ0xBU1MgPSBcInNmX2RhdGFcIjtcbiAgICBTRl9UQUdfVFlQRSA9IFwidGV4dC94LXNhZmVmcmFtZVwiO1xuICAgIEFVVE9fQk9PVF9NQVhfUkVUUklFUyA9IDEwMDtcbiAgICBTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MgPSBcInNmX3Bvc2l0aW9uXCI7XG4gICAgZCA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XG4gICAgbGliID0gc2YubGliO1xuICAgIGxhbmcgPSBsaWIubGFuZztcbiAgICBkb20gPSBsaWIuZG9tO1xuICAgIF9jc3RyID0gbGFuZy5jc3RyO1xuICAgIF9ndWlkID0gbGFuZy5ndWlkO1xuICAgIF9lbHQgPSBkb20uZWx0O1xuICAgIF9wYXIgPSBkb20ucGFyO1xuICAgIF90YWdzID0gZG9tLnRhZ3M7XG4gICAgX2F0dHIgPSBkb20uYXR0cjtcbiAgICBfcHVyZ2UgPSBkb20ucHVyZ2U7XG4gICAgX3JlYWR5ID0gZG9tLnJlYWR5O1xuICAgIGlubGluZV90YWdzX3Byb2Nlc3NlZCA9IHt9O1xuICAgIGJvb3RfcmV0cmllcyA9IDA7XG4gICAgaGFzX2Jvb3RlZCA9IGZhbHNlO1xuICAgIGRvaW5nX2F1dG9fYm9vdCA9IGZhbHNlO1xuICAgIHNldFRpbWVvdXQoX2F1dG9fYm9vdCwgNTApO1xuICAgIHJldHVybiBzZjtcbiAgfSkod2luZG93LCBzZik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG5cbi8qXG5AbmFtZXNwYWNlICRzZi5ob3N0IERlZmluZXMgdGhlIFB1Ymxpc2hlciBzaWRlIGFwaSwgYW5kIGhlbHBlciBmdW5jdGlvbnNcbkBuYW1lICRzZi5ob3N0XG5AYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86c3NuaWRlckB5YWhvby1pbmMuY29tXCI+U2VhbiBTbmlkZXI8L2E+XG5AYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Y2NvbGVbQVRdZW1pbmF0aW9uLmNvbVwiPkNocmlzIENvbGU8L2E+XG5AdmVyc2lvbiAxLjAuMlxuICovXG5cblxuLypcbkBpZ25vcmVcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBzZjtcblxuICBzZiA9IHJlcXVpcmUoJy4vYm9vdCcpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYWxsb3dOb3RUb3ApIHtcbiAgICBpZiAoYWxsb3dOb3RUb3AgPT0gbnVsbCkge1xuICAgICAgYWxsb3dOb3RUb3AgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChmdW5jdGlvbih3aW5kb3csIHNmKSB7XG4gICAgICB2YXIgQVRUQUNILCBBVVRPLCBBVVRPX0JPT1RfTUFYX1JFVFJJRVMsIEJGX1BPU19NU0csIENMSVAsIENPTExBUFNFX0NPTU1BTkQsIENPTVBBUkVfRE9DX1BPUywgQ09NUEFUX01PREUsIENPTlRBSU5TLCBDb25maWcsIERFRkFVTFRfUkVOREVSX1RJTUVPVVQsIERFRkFVTFRfWklOREVYLCBERVRBQ0gsIERPQywgRE9DX0VMLCBFTF9GUk9NX1BULCBFUlJPUl9DT01NQU5ELCBFWFBBTkRfQ09NTUFORCwgRkxBU0hfTUlNRSwgR0VPTV9VUERBVEVfSU5UUlZBTCwgR1VJRCwgSEVJR0hULCBISURERU4sIElFX0JPUkRFUl9BREosIElOVEVSU0VDVF9GQUNUT1IsIExFTiwgTSwgTVNHLCBOT0RFX1RZUEUsIE5PVElGWV9DT0xMQVBTRSwgTk9USUZZX0VYUEFORCwgTk9USUZZX0ZPQ1VTX0NIQU5HRSwgTk9USUZZX0dFT01fVVBEQVRFLCBPQkosIE9OU0NST0xMLCBPVkVSLCBQTVNHLCBQT1NfSURfQVVUT19QUkVGSVgsIFBPU19NU0csIFBPU19SRUxfQk9YX0lEX1BSRUZJWCwgUFgsIFBhcmFtSGFzaCwgUG9zQ29uZmlnLCBQb3NNZXRhLCBQb3NpdGlvbiwgU0NST0xMLCBTRl9EQVRBVEFHX0NMQVNTLCBTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MsIFNULCBTVFIsIFNVUFBPUlRTX0ZFQVRVUkVTLCBURlhELCBWRVJTSU9OLCBXSURUSCwgWENPTV9SRVNQX0RFTEFZLCBhdHRhY2hfaWZyYW1lX21zZ2luZywgYm91bmRzLCBjYW5Vc2VIVE1MNSwgY29tcGxldGVfaWZycywgY29uZmlnLCBjb250YWlucywgY3VycmVudFN0eWxlLCBjdXJyZW50X3N0YXR1cywgZGMsIGRldGFjaF9pZnJhbWVfbXNnaW5nLCBkb2NSZWN0LCBkb20sIGVudiwgZmxhc2hBY3RpdmVYVmVyc2lvbnMsIGZsYXNoX3ZlciwgZm9jdXNfdXBkYXRlX3RpbWVyLCBnZWNrVmVyLCBnZW9tX3VwZGF0ZV90aW1lciwgZ2V0LCBodG1sNUJvdW5kLCBpZVZlciwgaWZyX2Rlc3RfaWRfbWFwLCBpZnJhbWVzLCBpblZpZXdQZXJjZW50YWdlLCBpbml0SUQsIGlzSUUsIGxhbmcsIGxpYiwgbG9jLCBsb2NIb3N0LCBtZ3JfYm91bmRzX2RldGFpbHMsIG1zZ19waXBlcywgbXNnaG9zdGZiLCBudWtlLCBvcGVyYVZlciwgb3ZlcmxhcHMsIHBlbmRpbmdfaWZycywgcHJlcF9pZnJhbWVfbXNnaW5nLCByZW5kZXIsIHJlbmRlcmVkX2lmcnMsIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkLCBzZW5kX21zZ190b19jaGlsZF9pZnJhbWUsIHN0YXR1cywgdWEsIHVzaW5nSFRNTDUsIHdiVmVyLCB3aW4sIHdpblJlY3QsIHdpbl9ldmVudHNfYXR0YWNoZWQsIF9hdHRyLCBfYnVpbGRfZ2VvbSwgX2NhbGNCb3JkZXJzLCBfY2FsbF94bXNnX2hvc3RfZmIsIF9jYWxsYWJsZSwgX2Nib29sLCBfY2hlY2tfaHRtbDVfaW5pdCwgX2NsZWFyX2ZvY3VzX3VwZGF0ZV90aW1lciwgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyLCBfY251bSwgX2NvbGxhcHNlX3NhZmVmcmFtZSwgX2Nvb2tpZUhhc2gsIF9jb29raWVzX2VuYWJsZWRfdGVzdCwgX2NyZWF0ZV9wb3NfbWFya3VwLCBfY3N0ciwgX2RvYywgX2RvY05vZGUsIF9lbHQsIF9lcywgX2V4cGFuZF9zYWZlZnJhbWUsIF9maXJlX3B1Yl9jYWxsYmFjaywgX2dldENsaXAsIF9nZXRHZW9tLCBfZ2V0UmVjdElFLCBfZ2V0UmVjdE5vbklFLCBfZ2V0X2RvY19zY3JvbGwsIF9nZXRfZmxhc2hfdmVyc2lvbiwgX2d1aWQsIF9oYW5kbGVfZnJhbWVfbG9hZCwgX2hhbmRsZV9tc2dfZXZ0LCBfaGFuZGxlX21zZ19mcm9tX291dHNpZGUsIF9oYW5kbGVfbm9kZV9zY3JvbGwsIF9oYW5kbGVfcmVuZGVyX3RpbWVvdXQsIF9oYW5kbGVfdW5sb2FkLCBfaGFuZGxlX3dpbl9ibHVyLCBfaGFuZGxlX3dpbl9mb2N1cywgX2hhbmRsZV93aW5fZ2VvbV9yZXNpemUsIF9oYW5kbGVfd2luX2dlb21fc2Nyb2xsLCBfaGFzX3BlbmRpbmdfcmVuZGVycywgX2lmcl92aWV3LCBfaXNQWCwgX21heCwgX21pbiwgX21peCwgX25vb3AsIF9wYXIsIF9wdXJnZSwgX3JlYWRfY29va2llLCBfcmVhZHksIF9yZWNvcmRfZXJyb3IsIF9yZWN0LCBfcm91bmQsIF9zZW5kX2dlbmVyaWNfcmVzcG9uc2UsIF9zZW5kX3Jlc3BvbnNlLCBfc2V0X2ZvY3VzX3VwZGF0ZV90aW1lciwgX3NldF9nZW9tX3VwZGF0ZV90aW1lciwgX3NoaW1fZnJhbWUsIF9zdHJpcHBlZEVuY29kZWRMb2NhdGlvbiwgX3RhZ05hbWUsIF90YWdzLCBfdXBkYXRlX2ZvY3VzLCBfdXBkYXRlX2dlb20sIF91cGRhdGVfZ2VvbV93aW5fcmVzaXplLCBfdXBkYXRlX2dlb21fd2luX3Njcm9sbCwgX3ZpZXcsIF93cml0ZV9jb29raWU7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICBERUZBVUxUX1JFTkRFUl9USU1FT1VUID0gNjAwMDA7XG4gICAgICBQT1NfSURfQVVUT19QUkVGSVggPSBcInNmX3Bvc1wiO1xuICAgICAgUE9TX1JFTF9CT1hfSURfUFJFRklYID0gXCJzZl9wb3NfcmVsX2VsXCI7XG4gICAgICBTRl9EQVRBVEFHX0NMQVNTID0gXCJzZl9kYXRhXCI7XG4gICAgICBTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MgPSBcInNmX3Bvc2l0aW9uXCI7XG4gICAgICBBVVRPX0JPT1RfTUFYX1JFVFJJRVMgPSAxMDA7XG4gICAgICBHRU9NX1VQREFURV9JTlRSVkFMID0gMTAwO1xuICAgICAgWENPTV9SRVNQX0RFTEFZID0gMTtcbiAgICAgIElFX0JPUkRFUl9BREogPSAyO1xuICAgICAgSU5URVJTRUNUX0ZBQ1RPUiA9IDEwO1xuICAgICAgQkZfUE9TX01TRyA9IFwib25CZWZvcmVQb3NNc2dcIjtcbiAgICAgIFBPU19NU0cgPSBcIm9uUG9zTXNnXCI7XG4gICAgICBTVVBQT1JUU19GRUFUVVJFUyA9IHtcbiAgICAgICAgXCJleHAtb3ZyXCI6IDEsXG4gICAgICAgIFwiZXhwLXB1c2hcIjogMCxcbiAgICAgICAgYmc6IDAsXG4gICAgICAgIHBpbjogMCxcbiAgICAgICAgXCJyZWFkLWNvb2tpZVwiOiAwLFxuICAgICAgICBcIndyaXRlLWNvb2tpZVwiOiAwXG4gICAgICB9O1xuICAgICAgRVhQQU5EX0NPTU1BTkQgPSBcImV4cC1vdnJcIjtcbiAgICAgIENPTExBUFNFX0NPTU1BTkQgPSBcImNvbGxhcHNlXCI7XG4gICAgICBFUlJPUl9DT01NQU5EID0gXCJlcnJvclwiO1xuICAgICAgTk9USUZZX0VYUEFORCA9IFwiZXhwYW5kXCI7XG4gICAgICBOT1RJRllfR0VPTV9VUERBVEUgPSBcImdlb20tdXBkYXRlXCI7XG4gICAgICBOT1RJRllfQ09MTEFQU0UgPSBDT0xMQVBTRV9DT01NQU5EO1xuICAgICAgTk9USUZZX0ZPQ1VTX0NIQU5HRSA9IFwiZm9jdXMtY2hhbmdlXCI7XG4gICAgICBERUZBVUxUX1pJTkRFWCA9IDMwMDA7XG4gICAgICBPQkogPSBcIm9iamVjdFwiO1xuICAgICAgU1RSID0gXCJzdHJpbmdcIjtcbiAgICAgIFNUID0gXCJzdHlsZVwiO1xuICAgICAgTEVOID0gXCJsZW5ndGhcIjtcbiAgICAgIFdJRFRIID0gXCJ3aWR0aFwiO1xuICAgICAgSEVJR0hUID0gXCJoZWlnaHRcIjtcbiAgICAgIFBYID0gXCJQWFwiO1xuICAgICAgQ0xJUCA9IFwiY2xpcFwiO1xuICAgICAgU0NST0xMID0gXCJzY3JvbGxcIjtcbiAgICAgIE9OU0NST0xMID0gXCJvbnNjcm9sbFwiO1xuICAgICAgQ09NUEFUX01PREUgPSBcImNvbXBhdE1vZGVcIjtcbiAgICAgIERPQ19FTCA9IFwiZG9jdW1lbnRFbGVtZW50XCI7XG4gICAgICBET0MgPSBcImRvY3VtZW50XCI7XG4gICAgICBOT0RFX1RZUEUgPSBcIm5vZGVUeXBlXCI7XG4gICAgICBDT05UQUlOUyA9IFwiY29udGFpbnNcIjtcbiAgICAgIENPTVBBUkVfRE9DX1BPUyA9IFwiY29tcGFyZURvY3VtZW50UG9zaXRpb25cIjtcbiAgICAgIEVMX0ZST01fUFQgPSBcImVsZW1lbnRGcm9tUG9pbnRcIjtcbiAgICAgIEFVVE8gPSBcImF1dG9cIjtcbiAgICAgIEhJRERFTiA9IFwiaGlkZGVuXCI7XG4gICAgICBPVkVSID0gXCJvdmVyZmxvd1wiO1xuICAgICAgVEZYRCA9IFwidG9GaXhlZFwiO1xuICAgICAgQVRUQUNIID0gXCJhdHRhY2hcIjtcbiAgICAgIERFVEFDSCA9IFwiZGV0YWNoXCI7XG4gICAgICBNU0cgPSBcIm1lc3NhZ2VcIjtcbiAgICAgIFBNU0cgPSBcInBvc3RNZXNzYWdlXCI7XG4gICAgICBHVUlEID0gXCJndWlkXCI7XG4gICAgICBGTEFTSF9NSU1FID0gXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiO1xuICAgICAgVkVSU0lPTiA9IHNmLnZlcjtcbiAgICAgIGVudiA9IHNmLmVudjtcbiAgICAgIHVhID0gZW52LnVhO1xuICAgICAgbGliID0gc2YubGliO1xuICAgICAgbGFuZyA9IGxpYi5sYW5nO1xuICAgICAgZG9tID0gbGliLmRvbTtcbiAgICAgIGlmcmFtZXMgPSBkb20uaWZyYW1lcztcbiAgICAgIF9jYm9vbCA9IGxhbmcuY2Jvb2w7XG4gICAgICBfY251bSA9IGxhbmcuY251bTtcbiAgICAgIF9jc3RyID0gbGFuZy5jc3RyO1xuICAgICAgX2NhbGxhYmxlID0gbGFuZy5jYWxsYWJsZTtcbiAgICAgIF9ub29wID0gbGFuZy5ub29wO1xuICAgICAgX2d1aWQgPSBsYW5nW0dVSURdO1xuICAgICAgX21peCA9IGxhbmcubWl4O1xuICAgICAgX2VsdCA9IGRvbS5lbHQ7XG4gICAgICBfcGFyID0gZG9tLnBhcjtcbiAgICAgIF90YWdzID0gZG9tLnRhZ3M7XG4gICAgICBfYXR0ciA9IGRvbS5hdHRyO1xuICAgICAgX2RvYyA9IGRvbS5kb2M7XG4gICAgICBfdGFnTmFtZSA9IGRvbS50YWdOYW1lO1xuICAgICAgX3ZpZXcgPSBkb20udmlldztcbiAgICAgIF9pZnJfdmlldyA9IGlmcmFtZXMudmlldztcbiAgICAgIF9wdXJnZSA9IGRvbS5wdXJnZTtcbiAgICAgIF9yZWFkeSA9IGRvbS5yZWFkeTtcbiAgICAgIF9lcyA9IHdpbiAmJiB3aW4uZXNjYXBlO1xuICAgICAgTSA9IHdpbiAmJiB3aW4uTWF0aDtcbiAgICAgIF9tYXggPSBNLm1heDtcbiAgICAgIF9taW4gPSBNLm1pbjtcbiAgICAgIF9yb3VuZCA9IE0ucm91bmQ7XG4gICAgICBfcmVjdCA9IG51bGw7XG4gICAgICBQYXJhbUhhc2ggPSBsYW5nICYmIGxhbmcuUGFyYW1IYXNoO1xuICAgICAgZGMgPSB3aW4gJiYgd2luW0RPQ107XG4gICAgICBpc0lFID0gZW52ICYmIGVudi5pc0lFO1xuICAgICAgaWVWZXIgPSAodWEgJiYgdWEuaWUpIHx8IDA7XG4gICAgICB3YlZlciA9ICh1YSAmJiB1YS53ZWJraXQpIHx8IDA7XG4gICAgICBnZWNrVmVyID0gKHVhICYmIHVhLmdlY2tvKSB8fCAwO1xuICAgICAgb3BlcmFWZXIgPSAodWEgJiYgdWEub3BlcmEpIHx8IDA7XG4gICAgICBsb2MgPSB3aW4ubG9jYXRpb247XG4gICAgICBsb2NIb3N0ID0gbG9jICYmICgobG9jLnByb3RvY29sICsgXCIvL1wiICsgKGxvYy5ob3N0IHx8IGxvYy5ob3N0bmFtZSkpIHx8IFwiXCIpO1xuICAgICAgcmVuZGVyZWRfaWZycyA9IHt9O1xuICAgICAgbXNnX3BpcGVzID0ge307XG4gICAgICBpZnJfZGVzdF9pZF9tYXAgPSB7fTtcbiAgICAgIHBlbmRpbmdfaWZycyA9IHt9O1xuICAgICAgY29tcGxldGVfaWZycyA9IHt9O1xuICAgICAgc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWQgPSB7fTtcbiAgICAgIG1ncl9ib3VuZHNfZGV0YWlscyA9IGZhbHNlO1xuICAgICAgY2FuVXNlSFRNTDUgPSBmYWxzZTtcbiAgICAgIGh0bWw1Qm91bmQgPSBmYWxzZTtcbiAgICAgIHdpbl9ldmVudHNfYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIGdlb21fdXBkYXRlX3RpbWVyID0gMDtcbiAgICAgIGZvY3VzX3VwZGF0ZV90aW1lciA9IDA7XG4gICAgICBjdXJyZW50X3N0YXR1cyA9IG51bGw7XG4gICAgICBtc2dob3N0ZmIgPSBudWxsO1xuICAgICAgZmxhc2hfdmVyID0gbnVsbDtcbiAgICAgIGNvbmZpZyA9IG51bGw7XG4gICAgICBmbGFzaEFjdGl2ZVhWZXJzaW9ucyA9IFtcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoLjExXCIsIFwiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2guOFwiLCBcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoLjdcIiwgXCJTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaC42XCIsIFwiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2hcIl07XG4gICAgICBpbml0SUQgPSB2b2lkIDA7XG5cbiAgICAgIC8qXG4gICAgICBDb25maWd1cmUgdGhlIGJhc2UtbGV2ZWwgc2V0dGluZ3MgZm9yIHRoZSBTYWZlRnJhbWVzIGxpYnJhcnlcbiAgICAgIE5vdGUgdGhhdCBvbmx5IG9uZSBjb25maWd1cmF0aW9uIGNhbiBiZSBhY3RpdmUgYXQgYSBnaXZlbiB0aW1lLlxuICAgICAgVGhlcmVmb3JlIHlvdSBjYW5ub3QgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uIGJ5IGNyZWF0aW5nIGEgbmV3ICRzZi5ob3N0LkNvbmZpZyB3aGlsZVxuICAgICAgdGhlIFNhZmVGcmFtZXMgbGlicmFyeSBpcyBidXN5IChob3dldmVyIHlvdSBjYW4gYWRkIG5ldyBwb3NpdGlvbiBjb25maWd1cmF0aW9ucykuXG4gICAgICBJbnN0YXRpYXRpbmcgYSBuZXcgY29uZmlnLCB3aGVuIHRoZSBsaWJyYXJ5IGlzIG5vdCBidXN5IHdpbGwgZGVzdHJveSAvIHJlbW92ZSBhbGwgY3VycmVudGx5XG4gICAgICBtYW5hZ2VkIHBvc2l0aW9ucyBhbmQgdGhlcmUgY29uZmlndXJhdGlvbnMuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LkNvbmZpZ1xuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICBAcHVibGljXG4gICAgICBAcGFyYW0ge09iamVjdH0gY29uZiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGZvciBjb25maWd1cmF0aW9uXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IFtjb25mLmF1dG9dIFdoZXRoZXIgb3Igbm90IHRvIGhhdmUgU2FmZUZyYW1lcyBhdXRvbWF0aWNhbGx5IGJvb3N0cmFwIGFuIHJlbmRlciBhbnkgU2FmZUZyYW1lcyB0YWdzIHdpdGhpbiB0aGUgcGFnZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGNvbmYuY2RuIFRoZSBwcm90b2NvbCxob3N0IG5hbWUsIGFuZCBwb3J0IHBhcnRzIG9mIGEgVVJJLCB0aGF0IGlzIGEgMm5kYXJ5IG9yaWdpbiwgdXNlZCB3aXRoIFNhZmVGcmFtZXMgdG8gcmVuZGVyIGNvbnRlbnQuIEZvciBleGFtcGxlIEpTIGZpbGVzIHdvdWxkIGJlIGxvYWRlZCBmcm9tIGNvbmYuY2RuK1wiL1wiK2NvbmYucm9vdCtcIi9cIitjb25mLnZlcnNpb24rXCIvW2ZpbGVuYW1lXVwiXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IFtjb25mLmRlYnVnXSBXaGV0aGVyIG9yIG5vdCBkZWJ1ZyBtb2RlIGlzIG9uIG9yIG9mZlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGNvbmYucm9vdCBUaGUgcm9vdCBwYXRoIHBhcnQgb2YgdGhlIFVSSSB0aGF0IGlzIGEgMm5kYXJ5IG9yaWdpbiwgdXNlZCB3aXRoIFNhZmVGcmFtZXMgdG8gcmVuZGVyIGNvbnRlbnQuIEZvciBleGFtcGxlIHRoZSBIVE1MIGZpbGUgZm9yIHJlbmRlcmluZyBjb250ZW50IGludG8gd291bGQgYmVsb2FkZWQgZnJvbSBjb25mLmNkbitcIi9cIitjb25mLnJvb3QrXCIvXCIrY29uZi52ZXJzaW9uK1wiL1wiK2NvbmYucmVuZGVyRmlsZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGNvbmYucmVuZGVyRmlsZSBUaGUgZmlsZW5hbWUgKG1heSBhbHNvIGluY2x1ZGUgcGF0aCBpbmZvKSwgZm9yIHdoaWNoIHRvIHJlbmRlciBjb250ZW50IGludG8gdmlhIGEgU2FmZUZyYW1lLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtjb25mLm1zZ0ZpbGVdIFRoZSBmaWxlbmFtZSAobWF5IGFsc28gaW5jbHVkZSBwYXRoIGluZm8pLCBmb3Igd2hpY2ggdG8gdXNlIGFzIGEgcHJveHkgZm9yIHgtZG9tYWluIG1lc3NhZ2luZyB3aGVuZXZlciBIVE1MNSBtZXNzYWdpbmcgaXMgbm90IGF2YWlsYWJsZS4gT25seSByZXF1aXJlZCBpZiBzdXBwb3J0aW5nIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtjb25mLnRvXSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgYSBTYWZlRnJhbWUgdG8gZmluaXNoIHJlbmRlcmluZywgZGVmYXVsdHMgdG8gNjAgc2Vjb25kcy5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjb25mLm9uQmVmb3JlUG9zTXNnXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBmaXJlZCBiZWZvcmUgYW55IGNhbmNlbGxhYmxlIGFjdGlvbiBpcyByZXF1ZXN0ZWQgdG8gYmUgcGVmb3JtZWQgZnJvbSBhIGEgU2FmZUZyYW1lLCBzdWNoIGFzIGV4cGFuc2lvbiwgZXRjLiAgUmV0dXJuIHRydWUgb3V0IG9mIHRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FuY2VsL2Rpc2FsbG93IHRoZSBhY3Rpb24gaW4gcXVlc3Rpb24uXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZi5vblBvc01zZ10gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgZmlyZWQgd2hlbiBhbiBhY3Rpb24gcmVxdWVzdGVkIGJ5IGEgU2FmZUZyYW1lIGlzIHBlcmZvcm1lZFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmYub25TdGFydFBvc1JlbmRlcl0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgZmlyZWQgd2hlbiBhIFNhZmVGcmFtZSBzdGFydHMgdG8gcmVuZGVyIDNyZCBwYXJ0eSBjb250ZW50LlxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmYub25FbmRQb3NSZW5kZXJdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGZpcmVkIHdoZW4gYSBTYWZlRnJhbWUgZmluaXNoZXMgcmVuZGVyaW5nIDNyZCBwYXJ0eSBjb250ZW50LlxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtjb25mLnBvc2l0aW9uc10gQSBtYXAgb2YgcG9zaXRpb25zIHRvIGF1dG9tYXRpY2FsbHkgY29uZmlndXJlLCB3aGVyZSBlYWNoIGtleSBlcXVhbHMgdGhlIGlkIG9mIHRoZSAkc2YuaG9zdC5Qb3NDb25maWcgb2JqZWN0LCBhbmQgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHNhaWQgb2JqZWN0J3Mgc2V0dGluZ3MuXG4gICAgICAgKi9cbiAgICAgIENvbmZpZyA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICAgICAgdmFyIGJvb3RfdXAsIGNvbmZfcG9zX21hcCwgbWUsIHBvc0lELCBwb3NfY29uZiwgcG9zX2lkLCBwb3NfbWFwO1xuICAgICAgICBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAoY29uZmlnID8gX21peCh7fSwgY29uZmlnKSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG1lIGluc3RhbmNlb2YgQ29uZmlnKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29uZmlnKGNvbmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgIGNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYm9vdF91cCA9ICEhY29uZmlnO1xuICAgICAgICBtZS5hdXRvID0gKFwiYXV0b1wiIGluIGNvbmYgPyBfY2Jvb2woY29uZi5hdXRvKSA6IHRydWUpO1xuICAgICAgICBtZS5jZG4gPSBfY3N0cihjb25mLmNkbik7XG4gICAgICAgIG1lLmRlYnVnID0gX2Nib29sKGNvbmYuZGVidWcpO1xuICAgICAgICBtZS5yb290ID0gX2NzdHIoY29uZi5yb290KTtcbiAgICAgICAgbWUucmVuZGVyRmlsZSA9IF9jc3RyKGNvbmYucmVuZGVyRmlsZSk7XG4gICAgICAgIG1lLm1zZ0ZpbGUgPSBfY3N0cihjb25mLm1zZ0ZpbGUpO1xuICAgICAgICBtZS50byA9IF9jbnVtKGNvbmYudG8sIERFRkFVTFRfUkVOREVSX1RJTUVPVVQpO1xuICAgICAgICBtZS52ZXIgPSBfY3N0cihjb25mLnZlcikgfHwgVkVSU0lPTjtcbiAgICAgICAgbWUub25CZWZvcmVQb3NNc2cgPSAoX2NhbGxhYmxlKGNvbmYub25CZWZvcmVQb3NNc2cpID8gY29uZi5vbkJlZm9yZVBvc01zZyA6IF9ub29wKTtcbiAgICAgICAgbWUub25Qb3NNc2cgPSAoX2NhbGxhYmxlKGNvbmYub25Qb3NNc2cpID8gY29uZi5vblBvc01zZyA6IF9ub29wKTtcbiAgICAgICAgbWUub25TdGFydFBvc1JlbmRlciA9IChfY2FsbGFibGUoY29uZi5vblN0YXJ0UG9zUmVuZGVyKSA/IGNvbmYub25TdGFydFBvc1JlbmRlciA6IF9ub29wKTtcbiAgICAgICAgbWUub25FbmRQb3NSZW5kZXIgPSAoX2NhbGxhYmxlKGNvbmYub25FbmRQb3NSZW5kZXIpID8gY29uZi5vbkVuZFBvc1JlbmRlciA6IF9ub29wKTtcbiAgICAgICAgbWUub25GYWlsdXJlID0gKF9jYWxsYWJsZShjb25mLm9uRmFpbHVyZSkgPyBjb25mLm9uRmFpbHVyZSA6IF9ub29wKTtcbiAgICAgICAgbWUub25BZExvYWQgPSAoX2NhbGxhYmxlKGNvbmYub25BZExvYWQpID8gY29uZi5vbkFkTG9hZCA6IF9ub29wKTtcbiAgICAgICAgbWUub25SZWFkQ29va2llID0gKF9jYWxsYWJsZShjb25mLm9uUmVhZENvb2tpZSkgPyBjb25mLm9uUmVhZENvb2tpZSA6IF9ub29wKTtcbiAgICAgICAgbWUub25Xcml0ZUNvb2tpZSA9IChfY2FsbGFibGUoY29uZi5vbldyaXRlQ29va2llKSA/IGNvbmYub25Xcml0ZUNvb2tpZSA6IF9ub29wKTtcbiAgICAgICAgY29uZl9wb3NfbWFwID0gY29uZi5wb3NpdGlvbnM7XG4gICAgICAgIG1lLnBvc2l0aW9ucyA9IHBvc19tYXAgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZfcG9zX21hcCkge1xuICAgICAgICAgIGZvciAocG9zSUQgaW4gY29uZl9wb3NfbWFwKSB7XG4gICAgICAgICAgICBwb3NfY29uZiA9IGNvbmZfcG9zX21hcFtwb3NJRF07XG4gICAgICAgICAgICBpZiAocG9zX2NvbmYgJiYgdHlwZW9mIHBvc19jb25mID09PSBPQkopIHtcbiAgICAgICAgICAgICAgcG9zX2lkID0gcG9zSUQgfHwgcG9zX2NvbmYuaWQgfHwgX2d1aWQoUE9TX0lEX0FVVE9fUFJFRklYKTtcbiAgICAgICAgICAgICAgcG9zX21hcFtwb3NfaWRdID0gbmV3IFBvc0NvbmZpZyhwb3NfY29uZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lO1xuICAgICAgICBib290X3VwID0gISEoYm9vdF91cCAmJiBtZS5hdXRvICYmIChzZi5ob3N0LmJvb3QgIT0gbnVsbCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChib290X3VwKSB7XG4gICAgICAgICAgICBzZi5ob3N0LmJvb3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgcmV0dXJuIF9taXgoe30sIGNvbmZpZyk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ29uZmlndXJlIGEgcGFydGljdWFsYXIgcG9zaXRpb24gZm9yIHJlbmRlcmluZyBhIFNhZmVGcmFtZVxuICAgICAgRWFjaCAkc2YuaG9zdC5Qb3NDb25maWcgb2JqZWN0IGhhcyBhbiBpZCBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSB1bmlxdWUuICBDcmVhdGluZyBhIG5ldyAkc2YuaG9zdC5Qb3NDb25maWcgd2l0aCBhbiBpZCwgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICB1c2VkIHJlc3VsdHMgaW4gY2hhbmdpbmcgdGhlIG9sZCAkc2YuaG9zdC5Qb3NDb25maWcgc2V0dGluZ3MsIGFuZCBjYW4gb25seSBiZSBkb25lIGlmIHRoZSBTYWZlRnJhbWVzIGxpYnJhcnkgaXMgbm90IGJ1c3kuXG4gICAgICBBdXRvbWF0aWNhbGx5IGFkcyB0byB0aGUgcG9zaXRpb24gbWFwIG9mIHRoZSAkc2YuaG9zdC5Db25maWcgb2JqZWN0IGlmIHNhaWQgY29uZmlnIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QuUG9zQ29uZmlnXG4gICAgICBAcHVibGljXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAgIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcG9zSURvck9iaiBUaGUgaWQgb2YgdGhlICRzZi5ob3N0LlBvc0NvbmZpZyBpbnN0YW5jZSwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHNldHRpbmdzIHRoYXQgYXJlIHRvIGJlIHVzZWQgZm9yIHRoZSBpbnN0YW5jZS5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5pZF0gVGhlIGlkIG9mIHRoZSAkc2YuaG9zdC5Qb3NDb25maWcgaW5zdGFuY2UsIGlmIG5vdCBzcGVjaWZpZWQgb25lIHdpbGwgYmUgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouZGVzdF0gVGhlIEhUTUwgZWxlbWVudCBpZCBhdHRyaWJ1dGUgb2YgdGhlIEhUTUwgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQgd2hlcmUgYSBTYWZlRnJhbWUgd2lsbCBiZSByZW5kZXJlZC4gU2FpZCBlbGVtZW50IE1VU1QgZXhpc3Qgd2l0aGluIHRoZSBwYWdlIHByaW9yIHRvIGEgcmVuZGVyLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLmJnXSBUaGUgY29sb3Igb2YgdGhlIGJhY2tncm91bmQgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIFNhZmVGcmFtZS4gRGVmYXVsdCBlcXVhbHMgXCJ0cmFuc3BhcmVudFwiLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLnRndF0gVGhlIG5hbWUgb2YgdGhlIHRhcmdldCB3aW5kb3cgd2hlcmUgaHlwZXJsaW5rcyBpbnNpZGUgYSBTYWZlRnJhbWUgd2lsbCBuYXZpZ2F0ZSB0b28uLi5Ob3RlIHRoYXQgXCJfc2VsZlwiIGlzIG5vdCBhbGxvd2VkIGFuZCBhbHdheXMgY29udmVydGVkIHRvIFwiX3RvcFwiLiBBbGxvd2VkIHZhbHVlcyBhcmUgYW55IHN0cmluZyB2YWx1ZSBub3QgcHJlZml4ZWQgd2l0aCBcIl9cIiwgb3IgXCJfdG9wXCIgb3IgXCJfYmxhbmtcIi5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5jc3NdIEEgc3RyaW5nIG9mIENTUyBydWxlcywgb3IgYSBVUkwgdGhhdCBwb2ludHMgdG8gYSBDU1Mgc3R5bGUgc2hlZXQgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIFNhZmVGcmFtZVxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtwb3NJRG9yT2JqLnddIFRoZSB3aWR0aCBvZiB0aGUgU2FmZUZyYW1lLCBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBDYW5ub3QgYmUgc3BlY2lmaWVkIGluIGVtLCAlIG9yIGFub3RoZXIgdmFsdWVzLlxuICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtwb3NJRG9yT2JqLmhdIFRoZSBoZWlnaHQgb2YgdGhlIFNhZmVGcmFtZSwgc3BlY2lmaWVkIGluIHBpeGVscy4gQ2Fubm90IGJlIHNwZWNpZmllZCBpbiBlbSwgJSBvciBhbm90aGVyIHZhbHVlcy5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5zaXplXSBBIHN0cmluZyBmb3JtYXRlZCBhcyBcIndpZHRoWGhlaWdodFwiLCB0aGF0IGRlZmluZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIFNhZmVGcmFtZS4gVGhlIGRlbGltaXRlciBjaGFyYWN0ZXIgXCJYXCIgaXMgY2FuIGJlIHNwZWNpZmllZCBhcyBsb3dlciBvciB1cHBlciBjYXNlLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLnpdIFRoZSB6LWluZGV4IG9mIHRoZSBTYWZlRnJhbWUuXG4gICAgICBAcGFyYW0ge09iamVjdH0gW3Bvc0lEb3JPYmouc3VwcG9ydHNdIEFuIG9iamVjdCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlycyBmb3Igd2hhdCBmZWF0dXJlcy9hY3Rpb25zIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIFNhZmVGcmFtZSwgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIHJlcHJlc2VudHMgYSBib29sZWFuIGRldGVyZW1pbmcgd2hldGhlciB0aGF0IGZlYXR1cmUgY2FuIGJlIHVzZWQuICBDdXJyZW50bHkgc3VwcG9ydGVkIGtleXMgYXJlIFwiZXhwLW92clwiID09IFNhZmVGcmFtZSBjYW4gZXhwYW5kIGluIG92ZXJsYXkgbW9kZSwgXCJleHAtcHVzaFwiID09IFNhZmVGcmFtZSBjYW4gZXhwYW5kIGluIHB1c2ggbW9kZSwgYW5kIFwiYmdcIiA9PSBTYWZlRnJhbWUgY2FuIGNoYW5nZSB0aGUgYmFja2dyb3VuZCBvZiB0aGUgcHVibGlzaGVyIC8gaG9zdC5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbZGVzdElEXSBUaGUgSFRNTCBlbGVtZW50IGlkIGF0dHJpYnV0ZSBvZiB0aGUgSFRNTCBlbGVtZW50IGluIHRoZSBkb2N1bWVudCB3aGVyZSBhIFNhZmVGcmFtZSB3aWxsIGJlIHJlbmRlcmVkLiBTYWlkIGVsZW1lbnQgTVVTVCBleGlzdCB3aXRoaW4gdGhlIHBhZ2UgcHJpb3IgdG8gYSByZW5kZXIuXG4gICAgICBAcGFyYW0ge09iamVjdH0gW2Jhc2VDb25mXSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgJHNmLmhvc3QuQ29uZmlnIG9iamVjdCB0byBhdXRvbWF0aWNhbGx5IHVzZSAvIGNyZWF0ZSBmb3IgdGhlIFNhZmVGcmFtZXMgbGlicmFyeS4gTm90ZSB0aGF0IGJhc2VDb25mIGNhbiBvbmx5IGJlIHVzZWQgb25lIHRpbWUsIG90aGVyd2lzZSB5b3UgaGF2ZSB0byB1c2UgdGhlICRzZi5ob3N0LkNvbmZpZyBvYmplY3QgZGlyZWN0bHkuXG4gICAgICAgKi9cbiAgICAgIFBvc0NvbmZpZyA9IGZ1bmN0aW9uKHBvc0lEb3JPYmosIGRlc3RJRCwgYmFzZUNvbmYpIHtcbiAgICAgICAgdmFyIG1lLCBzeiwgc3pfc3BsaXQsIHR5cDtcbiAgICAgICAgbWUgPSB0aGlzO1xuICAgICAgICB0eXAgPSAocG9zSURvck9iaiAmJiB0eXBlb2YgcG9zSURvck9iaikgfHwgXCJcIjtcbiAgICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQb3NDb25maWcpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQb3NDb25maWcocG9zSURvck9iaiwgZGVzdElELCBiYXNlQ29uZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cCA9PT0gT0JKKSB7XG4gICAgICAgICAgbWUuaWQgPSBfY3N0cihwb3NJRG9yT2JqLmlkKTtcbiAgICAgICAgICBtZS5kZXN0ID0gX2NzdHIocG9zSURvck9iai5kZXN0IHx8IGRlc3RJRCk7XG4gICAgICAgICAgbWUuYmcgPSBfY3N0cihwb3NJRG9yT2JqLmJnKSB8fCBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgbWUudGd0ID0gX2NzdHIocG9zSURvck9iai50Z3QpIHx8IFwiX3RvcFwiO1xuICAgICAgICAgIG1lLmNzcyA9IF9jc3RyKHBvc0lEb3JPYmouY3NzKTtcbiAgICAgICAgICBtZS53ID0gX2NudW0ocG9zSURvck9iai53LCAwKTtcbiAgICAgICAgICBtZS5oID0gX2NudW0ocG9zSURvck9iai5oLCAwKTtcbiAgICAgICAgICBtZS56ID0gX2NudW0ocG9zSURvck9iai56LCAwKTtcbiAgICAgICAgICBtZS5yZW5kZXJGaWxlID0gX2NzdHIocG9zSURvck9iai5yZW5kZXJGaWxlKSB8fCBudWxsO1xuICAgICAgICAgIG1lLnN1cHBvcnRzID0gX21peCh7fSwgcG9zSURvck9iai5zdXBwb3J0cyB8fCBTVVBQT1JUU19GRUFUVVJFUywgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKCFtZS53IHx8ICFtZS5oKSB7XG4gICAgICAgICAgICBzeiA9IF9jc3RyKHBvc0lEb3JPYmouc2l6ZSk7XG4gICAgICAgICAgICBpZiAoc3opIHtcbiAgICAgICAgICAgICAgc3pfc3BsaXQgPSBzei5zcGxpdCgveC9nKTtcbiAgICAgICAgICAgICAgbWUudyA9IF9jbnVtKHN6X3NwbGl0WzBdLCAwKTtcbiAgICAgICAgICAgICAgbWUuaCA9IF9jbnVtKHN6X3NwbGl0WzFdLCAwKTtcbiAgICAgICAgICAgICAgbWUuc2l6ZSA9IHN6O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWUuc2l6ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNpemUgPSBtZS53ICsgXCJ4XCIgKyBtZS5oO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBtZS5pZCA9IF9jc3RyKHBvc0lEb3JPYmopO1xuICAgICAgICAgIG1lLmRlc3QgPSBfY3N0cihkZXN0SUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLmRlc3QgPSBcIlwiO1xuICAgICAgICAgIG1lLmJnID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgIG1lLnRndCA9IFwiX3RvcFwiO1xuICAgICAgICAgIG1lLmNzcyA9IFwiXCI7XG4gICAgICAgICAgbWUudyA9IDA7XG4gICAgICAgICAgbWUuaCA9IDA7XG4gICAgICAgICAgbWUuc2l6ZSA9IFwiXCI7XG4gICAgICAgICAgbWUueiA9IDA7XG4gICAgICAgICAgbWUuc3VwcG9ydHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBtZS5pZCA9IG1lLmlkIHx8IF9ndWlkKFBPU19JRF9BVVRPX1BSRUZJWCk7XG4gICAgICAgIGlmICghY29uZmlnICYmIGJhc2VDb25mKSB7XG4gICAgICAgICAgQ29uZmlnKGJhc2VDb25mKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgY29uZmlnLnBvc2l0aW9uc1ttZS5pZF0gPSBtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX21peCh7fSwgbWUpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENvbnN0cnVjdCBhIHNldCBvZiBkeW5hbWljIGtleS92YWx1ZSBwYWlycyB0aGF0IGNhbiBiZSBzaGFyZWQgYXMgbWV0YS1kYXRhIHdpdGggdGhlIDNyZCBwYXJ0eSBjb250ZW50IGluc2lkZSBhIFNhZmVGcmFtZS5cbiAgICAgIEFsbCBkYXRhIGlzIHRyZWF0ZWQgYXMgcHJvdGVjdGVkLCBhbmQgY2FuIG9ubHkgYmUgc3BlY2ZpZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgIFxuICAgICAgQGV4cG9ydHMgUG9zTWV0YSBhcyAkc2YuaG9zdC5Qb3NNZXRhI1xuICAgICAgQHB1YmxpY1xuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICBAY2xhc3NcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBzaGFyZWRfb2JqZWN0IEFuIG9iamVjdCBjb250YWluaW5nIGtleXMgYW5kIHZhbHVlcyB0byBiZSBzaGFyZWQgYXMgbWV0YS1kYXRhIGluc2lkZSB0aGUgU2FmZUZyYW1lXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW293bmVyX2tleV0gQSBrZXkgbmFtZSB0byBiZSB1c2VkIHRvIGhvbGQgcHNldWRvIHByaXZhdGUga2V5cyAvIHZhbHVlcyBvZiBtZXRhIGRhdGEuXG4gICAgICBAcGFyYW0ge09iamVjdH0gW293bmVkX29ial0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHN1ZWRvIHByaXZhdGUga2V5cyBhbmQgdmFsdWVzIHRvIGJlIHNoYXJlZCBhcyBtZXRhLWRhdGEgaW5zaWRlIHRoZSBTYWZlRnJhbWUuXG4gICAgICBAZXhhbXBsZVxuICAgICAgdmFyIHNoYXJlZF9kYXRhIFx0XHQgPSB7Y29udGVudF9pZDo4OTc4MDk4LHBhcnRuZXJfaWQ6OTl9LFxuICAgICAgcHJpdmF0ZV9kYXRhX2tleVx0ID0gXCJybXhcIixcbiAgICAgIHByaXZhdGVfZGF0YSAgICAgID0ge3NlY3Rpb25faWQ6MjM0MixzaXRlX2lkOjIzOTA0fSxcbiAgICAgIG1ldGFfZGF0YVx0XHQgPSBuZXcgJHNmLmhvc3QuUG9zTWV0YShzaGFyZWRfZGF0YSwgcHJpdmF0ZV9kYXRhX2tleSwgcHJpdmF0ZV9kYXRhKTtcbiAgICAgIFxuICAgICAgLy9zaG93IHNlY3Rpb24gaWQgb24gaG9zdCBzaWRlXG4gICAgICBhbGVydChtZXRhX2RhdGEudmFsdWUoXCJybXhcIiwgXCJzaXRlX2lkXCIpKTsgLy89PSAyMzkwNFxuICAgICAgXG4gICAgICBAZXhhbXBsZVxuICAgICAgLy9ub3cgcmV0cmlldmUgdGhpcyBpbmZvcm1hdGlvbiBpbnNpZGUgdGhlIHNhZmUgZnJhbWVcbiAgICAgIFxuICAgICAgdmFyIGNvbnRlbnRfaWQgPSAkc2YudmVuZC5tZXRhKFwiY29udGVudF9pZFwiKTsgLy89PSA4OTc4MDk4XG4gICAgICBcbiAgICAgIHZhciBybXhfc2VjdGlvbl9pZCA9ICRzZi52ZW5kLm1ldGEoXCJybXhcIiwgXCJzZWN0aW9uX2lkXCIpIC8vPT0gMjM0MiwgYnV0IG5vdGUgdGhhdCB2ZW5kb3Igc2lkZSBjb2RlIG11c3Qga25vdyB0aGUgXCJvd25lcl9rZXlcIiB1cGZyb250LlxuICAgICAgICovXG4gICAgICBQb3NNZXRhID0gZnVuY3Rpb24oc2hhcmVkX29iaiwgb3duZXJfa2V5LCBvd25lZF9vYmopIHtcblxuICAgICAgICAvKlxuICAgICAgICBBIG1ldGhvZCByZXRyaWV2ZXMgYSBtZXRhIGRhdGEgdmFsdWUgZnJvbSB0aGlzIG9iamVjdC5cbiAgICAgICAgXG4gICAgICAgIEBleHBvcnRzIGdldF92YWx1ZSBhcyAkc2YuaG9zdC5Qb3NNZXRhI3ZhbHVlXG4gICAgICAgIEBwYXJhbSB7U3RyaW5nfSBwcm9wS2V5IFRoZSBuYW1lIG9mIHRoZSB2YWx1ZSB0byByZXRyaWV2ZVxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gW293bmVyX2tleV0gVGhlIG5hbWUgb2YgdGhlIG93bmVyIGtleSBvZiB0aGUgbWV0YSBkYXRhIHZhbHVlLiBCeSBkZWZhdWx0LCBpdCBpcyBhc3N1bWVkIHRvIGJlIHNoYXJlZCwgc28gbm90aGluZyBuZWVkcyB0byBiZSBwYXNzZWQgaW4gdW5sZXNzIGxvb2tpbmcgZm9yIGEgc3BlY2lmaWMgcHJvcHJpZXRhcnkgdmFsdWVcbiAgICAgICAgQHJldHVybiB7U3RyaW5nfE51bWJlcnxCb29sZWFufVxuICAgICAgICBAZGVmYXVsdCB7U3RyaW5nfSBcIlwiXG4gICAgICAgIEBwdWJsaWNcbiAgICAgICAgQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZ2V0X3ZhbHVlLCBtZSwgbm9uX3NoYXJlZCwgb2xkLCBwb3NDb25mLCBzZXJpYWxpemUsIHNldF92YWx1ZSwgc2hhcmVkO1xuICAgICAgICBnZXRfdmFsdWUgPSBmdW5jdGlvbihwcm9wS2V5LCBvd25lcl9rZXkpIHtcbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIHJldCA9IFwiXCI7XG4gICAgICAgICAgaWYgKCFwcm9wS2V5IHx8IHR5cGVvZiBwcm9wS2V5ICE9PSBTVFIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3duZXJfa2V5IHx8IHR5cGVvZiBvd25lcl9rZXkgIT09IFNUUikge1xuICAgICAgICAgICAgb3duZXJfa2V5ID0gXCJzaGFyZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bmVyX2tleSA9PT0gXCJzaGFyZWRcIikge1xuICAgICAgICAgICAgcmV0ID0gc2hhcmVkW3Byb3BLZXldIHx8IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IChwcm9wS2V5IGluIG5vbl9zaGFyZWQgPyBub25fc2hhcmVkW3Byb3Bfa2V5XSB8fCBcIlwiIDogXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgUmV0dXJuIGEgc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gKGluIHVybCBxdWVyeSBzdHJpbmcgZm9ybWF0KSBvZiB0aGUgbWV0YSBkYXRhIG9iamVjdFxuICAgICAgICBcbiAgICAgICAgQGV4cG9ydHMgc2VyaWFsaXplIGFzICRzZi5ob3N0LlBvc01ldGEjdG9TdHJpbmdcbiAgICAgICAgQGZ1bmN0aW9uXG4gICAgICAgIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBvYmo7XG4gICAgICAgICAgb2JqID0gbmV3IFBhcmFtSGFzaCgpO1xuICAgICAgICAgIG9iai5zaGFyZWQgPSBzaGFyZWQ7XG4gICAgICAgICAgb2JqLm5vbl9zaGFyZWQgPSBub25fc2hhcmVkO1xuICAgICAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X3ZhbHVlID0gZnVuY3Rpb24ocHJvcEtleSwgb3duZXJLZXksIHZhbHVlKSB7XG4gICAgICAgICAgbm9uX3NoYXJlZFtvd25lcktleV0gfHwgKG5vbl9zaGFyZWRbb3duZXJLZXldID0ge30pO1xuICAgICAgICAgIHJldHVybiBub25fc2hhcmVkW293bmVyS2V5XVtwcm9wS2V5XSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBtZSA9IHRoaXM7XG4gICAgICAgIHNoYXJlZCA9IHZvaWQgMDtcbiAgICAgICAgbm9uX3NoYXJlZCA9IHZvaWQgMDtcbiAgICAgICAgb2xkID0gdm9pZCAwO1xuICAgICAgICBwb3NDb25mID0gdm9pZCAwO1xuICAgICAgICBpZiAoIShtZSBpbnN0YW5jZW9mIFBvc01ldGEpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQb3NNZXRhKGtleSwgb3duZWRfb2JqLCBwb3MsIHNoYXJlZF9vYmopO1xuICAgICAgICB9XG4gICAgICAgIHNoYXJlZCA9IHt9O1xuICAgICAgICBub25fc2hhcmVkID0ge307XG4gICAgICAgIGlmICghb3duZXJfa2V5IHx8IHR5cGVvZiBvd25lcl9rZXkgIT09IFNUUikge1xuICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVkX29iaiAmJiB0eXBlb2Ygc2hhcmVkX29iaiA9PT0gT0JKKSB7XG4gICAgICAgICAgc2hhcmVkID0gX21peChzaGFyZWQsIHNoYXJlZF9vYmopO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvd25lZF9vYmogJiYgdHlwZW9mIG93bmVkX29iaiA9PT0gT0JKKSB7XG4gICAgICAgICAgbm9uX3NoYXJlZFtvd25lcl9rZXldID0gb3duZWRfb2JqO1xuICAgICAgICB9XG4gICAgICAgIG1lLnRvU3RyaW5nID0gc2VyaWFsaXplO1xuICAgICAgICBtZS52YWx1ZSA9IGdldF92YWx1ZTtcbiAgICAgICAgbWUuc2V0VmFsdWUgPSBzZXRfdmFsdWU7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ3JlYXRlIHRoZSBIVE1MIG1hcmt1cCBmb3IgYSBwb3NpdGlvbiBpZiBhIHNyYyBwcm9wZXJ0eSB3YXMgdXNlZFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fY3JlYXRlX3Bvc19tYXJrdXBcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZV9wb3NfbWFya3VwID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgIHZhciBja1ZhbCwgZlZlcjtcbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIGlmIChzcmMuaW5kZXhPZihcIiR7c2ZfdmVyfVwiKSA+IC0xKSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFwke3NmX3Zlcn0vZywgJHNmLnZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcmMuaW5kZXhPZihcIiR7Y2tfb259XCIpID4gLTEpIHtcbiAgICAgICAgICAgIGNrVmFsID0gKF9jb29raWVzX2VuYWJsZWRfdGVzdCgpID8gXCIxXCIgOiBcIjBcIik7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFwke2NrX29ufS9nLCBja1ZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcmMuaW5kZXhPZihcIiR7Zmxhc2hfdmVyfVwiKSA+IC0xKSB7XG4gICAgICAgICAgICBmVmVyID0gX2dldF9mbGFzaF92ZXJzaW9uKCk7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFwke2ZsYXNoX3Zlcn0vZywgZlZlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3N0cihbXCI8c2NyXCIsIFwiaXB0IHR5cGU9J3RleHQvamF2YXNjcmlwdCcsIHNyYz0nXCIsIHNyYywgXCInPjwvc2NyXCIsIFwiaXB0PlwiXSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgR2V0IHRoZSBmYWxzaCB2ZXJzaW9uIG51bWJlclxuICAgICAgICovXG4gICAgICBfZ2V0X2ZsYXNoX3ZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVyciwgZ2V0QWN0aXZlWFZlcnNpb24sIGksIG1pbWVUeXBlcywgb2JqLCBwLCB0bXBWZXI7XG4gICAgICAgIGlmIChmbGFzaF92ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmxhc2hfdmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXZpZ2F0b3IucGx1Z2lucyAmJiBuYXZpZ2F0b3IucGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbWltZVR5cGVzID0gbmF2aWdhdG9yLm1pbWVUeXBlcztcbiAgICAgICAgICBpZiAobWltZVR5cGVzICYmIG1pbWVUeXBlc1tGTEFTSF9NSU1FXSAmJiBtaW1lVHlwZXNbRkxBU0hfTUlNRV0uZW5hYmxlZFBsdWdpbiAmJiBtaW1lVHlwZXNbRkxBU0hfTUlNRV0uZW5hYmxlZFBsdWdpbi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgZmxhc2hfdmVyID0gbWltZVR5cGVzW0ZMQVNIX01JTUVdLmVuYWJsZWRQbHVnaW4udmVyc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2YuZW52LmlzSUUpIHtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IGZsYXNoQWN0aXZlWFZlcnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb2JqID0gbmV3IEFjdGl2ZVhPYmplY3QoZmxhc2hBY3RpdmVYVmVyc2lvbnNbaV0pO1xuICAgICAgICAgICAgICB0bXBWZXIgPSBvYmouR2V0VmFyaWFibGUoXCIkdmVyc2lvblwiKTtcbiAgICAgICAgICAgICAgcCA9IHRtcFZlci5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgICAgICAgaWYgKHAgPiAtMSkge1xuICAgICAgICAgICAgICAgIGZsYXNoX3ZlciA9IHRtcFZlci5zdWJzdHIocCArIDEpLnJlcGxhY2UoLywvZywgXCIuXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsYXNoX3ZlciA9IHRtcFZlci5yZXBsYWNlKC8sL2csIFwiLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIG9iaiA9IG51bGw7XG4gICAgICAgICAgICAgIGZsYXNoX3ZlciA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGFzaF92ZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFzaF92ZXI7XG4gICAgICAgIGdldEFjdGl2ZVhWZXJzaW9uID0gZnVuY3Rpb24oYWN0aXZlWE9iaikge1xuICAgICAgICAgIHZhciB2ZXJzaW9uO1xuICAgICAgICAgIHZlcnNpb24gPSAtMTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmVyc2lvbiA9IGFjdGl2ZVhPYmouR2V0VmFyaWFibGUoXCIkdmVyc2lvblwiKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVGVzdCB0byBzZWUgaWYgY29va2llcyBhcmUgZW5hYmxlZFxuICAgICAgICovXG4gICAgICBfY29va2llc19lbmFibGVkX3Rlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvb2tpZUVuYWJsZWQ7XG4gICAgICAgIGNvb2tpZUVuYWJsZWQgPSAobmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvci5jb29raWVFbmFibGVkID09PSBcInVuZGVmaW5lZFwiICYmICFjb29raWVFbmFibGVkKSB7XG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gXCJ0ZXN0Y29va2llXCI7XG4gICAgICAgICAgY29va2llRW5hYmxlZCA9IChkb2N1bWVudC5jb29raWUuaW5kZXhPZihcInRlc3Rjb29raWVcIikgIT09IC0xID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IuY29va2llRW5hYmxlZCA9IGNvb2tpZUVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWVFbmFibGVkO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENvbnN0cnVjdGlvbiBhIHBvc3Rpb24gY29udGVudCBvYmplY3QgdGhhdCBjb250YWlucyBIVE1MLCBvcHRpb25hbGx5IG1ldGEtZGF0YSwgYW5kIG9wdGlvbmFsbHkgYSBwb3NpdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICAgIFRoZSBpZCBzcGVjaWZpZWQgbXVzdCBtYXRjaCBhbiBpZCBmb3IgYSAkc2YuaG9zdC5Qb3NDb25maWcgKGFsdGhvdWdoIHNhaWQgY29uZmlnIGNvdWxkIGJlIHNwZWNmaWVkIGRpcmVjdGx5IGhlcmUgdmlhIGFyZ3VtZW50cykuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LlBvc2l0aW9uXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcG9zSURvck9iaiBUaGUgaWQgb2YgdGhlIHBvc2l0aW9uIHdoaWNoIG1hcHMgdG8gaXRzIGNvbmZpZ3VyYXRpb24sIG9yIGFuIG9iamVjdCByZXByZXNldGluZyB0aGUgdmFyaW91cyB2YWx1ZXMgb2YgYW4gJHNmLmhvc3QuUG9zaXRpb24gaW5zdGFuY2UuXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouaWRdIFRoZSBpZCBvZiB0aGUgcG9zaXRpb24gd2hpY2ggbWFwcyB0byBpdHMgY29uZmlndXJhdGlvbi5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5odG1sXSBUaGUgSFRNTCBjb250ZW50IHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgU2FmZUZyYW1lLiBOb3RlIHRoYXQgSFRNTCBzdHJpbmdzIHdoaWNoIGhhdmUgU0NSSVBUIHRhZ3Mgb3Igb3RoZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIG1heSBuZWVkIHRvIGJlIHByb3Blcmx5IGVzY2FwZWQgaW4gb3JkZXIgdG8gYXZvaWQgSmF2YVNjcmlwdCBzeW50YXggZXJyb3JzLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLnNyY10gQW4gb3B0aW9uYWwgVVJMIHRvIGJlIHVzZWQgZm9yIHJlZGVyaW5nIGluc2lkZSB0aGUgU2FmZUZyYW1lIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIFNDUklQVCB0YWcgd2l0aCB0aGUgc3BlY2lmaWVkIFVSTC5cbiAgICAgIEBwYXJhbSB7JHNmLmhvc3QuUG9zTWV0YX0gW3Bvc0lEb3JPYmoubWV0YV0gQW4gb3B0aW9uYWwgaW5zdGFuY2Ugb2YgdGhlICRzZi5ob3N0LlBvc01ldGEgb2JqZWN0IHRvIGJlIHBhc3NlZCBhbG9uZyBpbnRvIHRoZSBTYWZlRnJhbWVcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBbcG9zSURvck9iai5jb25mXSBBbiBvcHRpb25hbCByZXByZXNlbnRhdGlvbiBvZiBhbiAkc2YuaG9zdC5Qb3NDb25maWcgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBTYWZlRnJhbWUgcG9zaXRpb24uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2h0bWxdIFRoZSBIVE1MIGNvbnRlbnQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBTYWZlRnJhbWUuIE5vdGUgdGhhdCBIVE1MIHN0cmluZ3Mgd2hpY2ggaGF2ZSBTQ1JJUFQgdGFncyBvciBvdGhlciBzcGVjaWFsIGNoYXJhY3RlcnMgbWF5IG5lZWQgdG8gYmUgcHJvcGVybHkgZXNjYXBlZCBpbiBvcmRlciB0byBhdm9pZCBKYXZhU2NyaXB0IHN5bnRheCBlcnJvcnMuXG4gICAgICBAcGFyYW0geyRzZi5ob3N0LlBvc01ldGF9IFttZXRhXSBBbiBvcHRpb25hbCBpbnN0YW5jZSBvZiB0aGUgJHNmLmhvc3QuUG9zTWV0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGFsb25nIGludG8gdGhlIFNhZmVGcmFtZVxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtjb25mXSBBbiBvcHRpb25hbCByZXByZXNlbnRhdGlvbiBvZiBhbiAkc2YuaG9zdC5Qb3NDb25maWcgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBTYWZlRnJhbWUgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zSURvck9iaiwgaHRtbCwgbWV0YSwgY29uZikge1xuICAgICAgICB2YXIgaWQsIG1lLCBtc2csIG9yaWdIdG1sLCB0eXA7XG4gICAgICAgIG1lID0gdGhpcztcbiAgICAgICAgdHlwID0gcG9zSURvck9iaiAmJiB0eXBlb2YgcG9zSURvck9iajtcbiAgICAgICAgb3JpZ0h0bWwgPSBodG1sO1xuICAgICAgICBpZiAoIShtZSBpbnN0YW5jZW9mIFBvc2l0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zSURvck9iaiwgaHRtbCwgbWV0YSwgY29uZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgbXNnID0gXCJQdWJsaXNoZXIgQ29uZmlnIG5vdCBpbml0aWFsaXplZCAtIGFib3J0XCI7XG4gICAgICAgICAgc2YubGliLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgIHNmLmluZm8uZXJycy5wdXNoKG1zZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXAgPT09IE9CSikge1xuICAgICAgICAgIF9taXgobWUsIHBvc0lEb3JPYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gbWUuaWQgPSBfY3N0cihwb3NJRG9yT2JqKSB8fCBfZ3VpZChQT1NfSURfQVVUT19QUkVGSVgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaHRtbCkge1xuICAgICAgICAgIGlmIChtZS5zcmMpIHtcbiAgICAgICAgICAgIG1lLmh0bWwgPSBfY3JlYXRlX3Bvc19tYXJrdXAobWUuc3JjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuaHRtbCA9IG1lLmh0bWwgfHwgXCJcIjtcbiAgICAgICAgICAgIG1lLnNyYyA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLmh0bWwgPSBodG1sO1xuICAgICAgICAgIG1lLnNyYyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZS5odG1sKSB7XG4gICAgICAgICAgbWUuaHRtbCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbWUubWV0YSA9IG1ldGEgfHwgbWUubWV0YSB8fCB7fTtcbiAgICAgICAgbWUuY29uZiA9IGNvbmYgfHwgbWUuY29uZiB8fCB7fTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcucG9zaXRpb25zW2lkXSkge1xuICAgICAgICAgICAgbWUuY29uZiA9IGNvbmZpZy5wb3NpdGlvbnNbaWRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29uZikge1xuICAgICAgICAgICAgICBjb25mLmlkID0gaWQ7XG4gICAgICAgICAgICAgIG1lLmNvbmYgPSBuZXcgUG9zQ29uZmlnKGNvbmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEBuYW1lc3BhY2UgJHNmLmxpYi5kb20ubXNnaG9zdCBDb250YWlucyBmdW5jdGlvbmFsaXR5IHRvIHJlc2lkZSBpbiB0aGUgdG9wIGxldmVsIHBhZ2UgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZyB4LWRvbWFpbiBtZXNzYWdlcyB0byBTYWZlRnJhbWUgY29udGFpbmVyc1xuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdFxuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm5zIHRoZSByb290IGRvY3VtZW50IEhUTUxFbGVtZW50IC8gbm9kZVxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20tX2RvY05vZGVcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQW4gSFRNTEVsZW1lbnQgdG8gdXNlIGFzIGEgcmVmZXJlbmNlIGZvciBmaW5kaW5nIHRoZSByb290IGRvY3VtZW50IGVsZW1lbnQuXG4gICAgICBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIF9kb2NOb2RlID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGNvbXBhdE1vZGUsIGQsIHJvb3Q7XG4gICAgICAgIGQgPSAoZWwgJiYgX2RvYyhlbCkpIHx8IGRjO1xuICAgICAgICBjb21wYXRNb2RlID0gZFtDT01QQVRfTU9ERV07XG4gICAgICAgIHJvb3QgPSBkW0RPQ19FTF07XG4gICAgICAgIGlmIChjb21wYXRNb2RlICYmICFvcGVyYVZlciAmJiBjb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgICAgICAgIHJvb3QgPSBkLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIHNwZWNpZmllZCBpbiBwaXhlbHNcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLV9pc1BYXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gdmFsIEEgY3NzIHZhbHVlIG9mIHNpemVcbiAgICAgIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBfaXNQWCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YWwgPSBfY3N0cih2YWwpO1xuICAgICAgICBpZiAodmFsICYmIHZhbC5zZWFyY2goL1xcRCsvZykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCAmJiB2YWwuc2VhcmNoKC9weC9nKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybiBhbiBhcnJheSBvZiB2YWx1ZXMgb2YgY2xpcHBpbmcgcmVnaW9uIGluZm9ybWF0aW9uLiBBcnJheSByZXByZXNlbnRzIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICAgICAgSWYgdmFsdWVzIGFyZSBub3Qgc3BlY2lmaWVkIGluIHBpeGVscywgb3Igbm8gY2xpcCByZWdpb24gaXMgZGVmaW5lZCBmb3IgdGhhdCBlbGVtZW50LCAtMSBpcyByZXR1cm5lZCBmb3IgZWFjaCB2YWx1ZS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20tX2dldENsaXBcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwYXJhbSB7SFRNTFN0eWxlT2JqZWN0fSBjdXJTdCBUaGUgY3VycmVudCBzdHlsZSBvYmplY3Qgb2YgYW4gSFRNTEVsZW1lbnRcbiAgICAgIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICBfZ2V0Q2xpcCA9IGZ1bmN0aW9uKGN1clN0KSB7XG4gICAgICAgIHZhciBjbGlwVmFsLCBpZHgsIGxlbiwgcHJvcCwgcHJvcHMsIHJldCwgdmFsO1xuICAgICAgICByZXQgPSBbLTEsIC0xLCAtMSwgLTFdO1xuICAgICAgICBwcm9wcyA9IFtDTElQICsgXCJUb3BcIiwgQ0xJUCArIFwiUmlnaHRcIiwgQ0xJUCArIFwiQm90dG9tXCIsIENMSVAgKyBcIkxlZnRcIl07XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIGNsaXBWYWwgPSB2b2lkIDA7XG4gICAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICAgIHZhbCA9IHZvaWQgMDtcbiAgICAgICAgbGVuID0gdm9pZCAwO1xuICAgICAgICBpZiAoIWN1clN0KSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWVWZXIpIHtcbiAgICAgICAgICB3aGlsZSAocHJvcCA9IHByb3BzW2lkeF0pIHtcbiAgICAgICAgICAgIGNsaXBWYWwgPSBjdXJTdFtwcm9wXTtcbiAgICAgICAgICAgIGlmIChfaXNQWChjbGlwVmFsKSkge1xuICAgICAgICAgICAgICBjbGlwVmFsID0gX2NudW0oY2xpcFZhbCwgLTEpO1xuICAgICAgICAgICAgICBpZiAoY2xpcFZhbCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0W2lkeF0gPSBjbGlwVmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpcFZhbCA9IGN1clN0W0NMSVBdO1xuICAgICAgICAgIGlmIChjbGlwVmFsICYmIGNsaXBWYWwuc2VhcmNoKC9cXGQrL2cpICE9PSAtMSkge1xuICAgICAgICAgICAgY2xpcFZhbCA9IGNsaXBWYWwucmVwbGFjZSgvXFx3K1xcKChbXlxcKV0qPylcXCkvZywgXCIkMVwiKTtcbiAgICAgICAgICAgIHJldCA9IGNsaXBWYWwuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgcmV0ID0gKHJldFtMRU5dIDw9IDEgPyByZXQuc3BsaXQoXCIsXCIpIDogcmV0KTtcbiAgICAgICAgICAgIGxlbiA9IHJldFtMRU5dO1xuICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgICB2YWwgPSByZXRbaWR4XTtcbiAgICAgICAgICAgICAgaWYgKCFfaXNQWCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2lkeF0gPSAtMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbaWR4XSA9IF9jbnVtKHZhbCwgLTEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybnMgYm9yZGVyIHZhbHVlcyBpbiBwaXhlbHMgaWYgcG9zc2libGUgdG8gaGVscCBjYWxjdWxhdGUgZ2VvbWV0cnkgb2YgYW4gZWxlbWVudFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS1fY2FsY0JvcmRlcnNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBIVE1MRWxlbWVudCBmb3Igd2hpY2ggdG8gbG9vayBhdC4gLiAuXG4gICAgICBAcGFyYW0ge09iamVjdH0gcmVjdCBUaGUgcmVjdCBvYmplY3QgZ2VuZXJhdGVkIGZvciB0aGUgSFRNTEVsZW1lbnQgaW4gcXVlc3Rpb24gdG8gYmUgYWRqdXN0ZWRcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IHJlY3RcbiAgICAgICAqL1xuICAgICAgX2NhbGNCb3JkZXJzID0gZnVuY3Rpb24oZWwsIHJlY3QpIHtcbiAgICAgICAgdmFyIGwsIHJlLCBzdCwgdDtcbiAgICAgICAgdCA9IDA7XG4gICAgICAgIGwgPSAwO1xuICAgICAgICBzdCA9IHZvaWQgMDtcbiAgICAgICAgcmUgPSAvXnQoPzphYmxlfGR8aHxyfGhlYWR8Zm9vdCkkL2k7XG4gICAgICAgIHN0ID0gY3VycmVudFN0eWxlKGVsKTtcbiAgICAgICAgaWYgKHN0KSB7XG4gICAgICAgICAgdCA9IHN0W1wiYm9yZGVyVG9wV2lkdGhcIl07XG4gICAgICAgICAgbCA9IHN0W1wiYm9yZGVyTGVmdFdpZHRoXCJdO1xuICAgICAgICAgIHQgPSAoX2lzUFgodCkgPyBfY251bSh0LCAwKSA6IDApO1xuICAgICAgICAgIGwgPSAoX2lzUFgobCkgPyBfY251bShsLCAwKSA6IDApO1xuICAgICAgICAgIGlmIChnZWNrVmVyICYmIHJlLnRlc3QoX3RhZ05hbWUoZWwpKSkge1xuICAgICAgICAgICAgdCA9IGwgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWN0ID0gcmVjdCB8fCB7XG4gICAgICAgICAgdDogMCxcbiAgICAgICAgICBsOiAwXG4gICAgICAgIH07XG4gICAgICAgIHJlY3QudCArPSB0O1xuICAgICAgICByZWN0LmwgKz0gbDtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0cmlldmUgc2Nyb2xsIHZhbHVlcyBvZiBhIGRvY3VtZW50XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLV9nZXRfZG9jX3Njcm9sbFxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gW2VsXSBBbiBIVE1MRWxlbWVudCB0byB1c2UgYXMgYSByZWZlcmVuY2UgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgbWFpbiBkb2N1bWVudFxuICAgICAgQHJldHVybiB7T2JqZWN0fSBDb250YWlucyB4LCB5LCB3LCBoIHByb3BlcnRpZXMgZm9yIHNjcm9sbGluZ1xuICAgICAgICovXG4gICAgICBfZ2V0X2RvY19zY3JvbGwgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgZCwgZGIsIGRlLCBkZWYsIGR2LCBvZmZzZXRYLCBvZmZzZXRZLCBwb3M7XG4gICAgICAgIHBvcyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdzogMCxcbiAgICAgICAgICBoOiAwXG4gICAgICAgIH07XG4gICAgICAgIGRlZiA9IHtcbiAgICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgICAgICBzY3JvbGxXaWR0aDogMCxcbiAgICAgICAgICBzY3JvbGxIZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgZCA9IHZvaWQgMDtcbiAgICAgICAgZGUgPSB2b2lkIDA7XG4gICAgICAgIGR2ID0gdm9pZCAwO1xuICAgICAgICBkYiA9IHZvaWQgMDtcbiAgICAgICAgb2Zmc2V0WCA9IDA7XG4gICAgICAgIG9mZnNldFkgPSAwO1xuICAgICAgICBkID0gX2RvYyhlbCkgfHwgZGM7XG4gICAgICAgIGRlID0gZFtET0NfRUxdIHx8IGRlZjtcbiAgICAgICAgZGIgPSBkLmJvZHkgfHwgZGVmO1xuICAgICAgICBkdiA9IGQuZGVmYXVsdFZpZXc7XG4gICAgICAgIGlmIChkdikge1xuICAgICAgICAgIG9mZnNldFggPSBfY251bShkdi5wYWdlWE9mZnNldCwgMCk7XG4gICAgICAgICAgb2Zmc2V0WSA9IF9jbnVtKGR2LnBhZ2VZT2Zmc2V0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MueCA9IF9tYXgoZGUuc2Nyb2xsTGVmdCwgZGIuc2Nyb2xsTGVmdCwgb2Zmc2V0WCk7XG4gICAgICAgIHBvcy55ID0gX21heChkZS5zY3JvbGxUb3AsIGRiLnNjcm9sbFRvcCwgb2Zmc2V0WSk7XG4gICAgICAgIHBvcy53ID0gX21heChkZS5zY3JvbGxXaWR0aCwgZGIuc2Nyb2xsV2lkdGgsIDApO1xuICAgICAgICBwb3MuaCA9IF9tYXgoZGUuc2Nyb2xsSGVpZ2h0LCBkYi5zY3JvbGxIZWlnaHQsIDApO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENhbGN1bGF0ZSBhIGdlb21ldHJpYyByZWN0YW5nbGUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gTm90ZSB0aGF0IGZvciBJRSBicm93c2Vyc1xuICAgICAgd2UgY2FuIHVzZSB0aGUgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBmdW5jdGlvbiB3aGljaCBzYXZlcyB1cyBzb21lIHRpbWUgLyBpbmNyZWFzZXNcbiAgICAgIHBlZm9ybWFuY2UuIC4gaG93ZXZlciBpdCByZWFsbHkgY2FuIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBET00gaXMgY29tcGxldGVseSBsb2FkZWQsXG4gICAgICBhbmQgaWYgdGhhdCBpcyB0aGUgY2FzZSB3ZSBmYWxsYmFjayB0byB0aGUgYnJ1dGUtZm9yY2UgLyBub24tSUUgbWV0aG9kLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS1fZ2V0UmVjdElFXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAgVGhlIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGRlcml2ZSBhIHJlY3RhbmdsZSBvYmplY3RcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlY3RhbmdsZSBmb3IgdGhlIGdpdmVuIEhUTUxFbGVtZW50XG4gICAgICAgKi9cbiAgICAgIF9nZXRSZWN0SUUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgYWRqdXN0WCwgYWRqdXN0WSwgYkxlZnQsIGJUb3AsIGJveCwgY29tcGF0TW9kZSwgZCwgZGUsIGUsIHJlY3QsIHNjcm9sbCwgc3QsIF9iYWNrO1xuICAgICAgICByZWN0ID0ge1xuICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgbDogMCxcbiAgICAgICAgICByOiAwLFxuICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgdzogMCxcbiAgICAgICAgICBoOiAwLFxuICAgICAgICAgIHo6IDBcbiAgICAgICAgfTtcbiAgICAgICAgX2JhY2sgPSBcIkJhY2tDb21wYXRcIjtcbiAgICAgICAgc2Nyb2xsID0gdm9pZCAwO1xuICAgICAgICBib3ggPSB2b2lkIDA7XG4gICAgICAgIGQgPSB2b2lkIDA7XG4gICAgICAgIGRlID0gdm9pZCAwO1xuICAgICAgICBjb21wYXRNb2RlID0gdm9pZCAwO1xuICAgICAgICBzdCA9IHZvaWQgMDtcbiAgICAgICAgYWRqdXN0WCA9IHZvaWQgMDtcbiAgICAgICAgYWRqdXN0WSA9IHZvaWQgMDtcbiAgICAgICAgYkxlZnQgPSB2b2lkIDA7XG4gICAgICAgIGJUb3AgPSB2b2lkIDA7XG4gICAgICAgIGlmIChlbCAmJiBlbFtOT0RFX1RZUEVdID09PSAxKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGQgPSBfZG9jKGVsKSB8fCBkYztcbiAgICAgICAgICAgIGlmICghZG9tLnJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRSZWN0Tm9uSUUoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Nyb2xsID0gX2dldF9kb2Nfc2Nyb2xsKGVsKTtcbiAgICAgICAgICAgIGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmVjdC50ID0gYm94LnRvcDtcbiAgICAgICAgICAgIHJlY3QubCA9IGJveC5sZWZ0O1xuICAgICAgICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSBJRV9CT1JERVJfQURKO1xuICAgICAgICAgICAgY29tcGF0TW9kZSA9IGRbQ09NUEFUX01PREVdO1xuICAgICAgICAgICAgZGUgPSBkW0RPQ19FTF07XG4gICAgICAgICAgICBzdCA9IGN1cnJlbnRTdHlsZShkZSk7XG4gICAgICAgICAgICBiTGVmdCA9IHN0W1wiYm9yZGVyTGVmdFdpZHRoXCJdO1xuICAgICAgICAgICAgYlRvcCA9IHN0W1wiYm9yZGVyVG9wV2lkdGhcIl07XG4gICAgICAgICAgICBpZiAoaWVWZXIgPT09IDYpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbXBhdE1vZGUgIT09IF9iYWNrKSB7XG4gICAgICAgICAgICAgICAgYWRqdXN0WCA9IGFkanVzdFkgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGF0TW9kZSA9PT0gX2JhY2spIHtcbiAgICAgICAgICAgICAgYkxlZnQgPSAoX2lzUFgoYkxlZnQpID8gX2NudW0oYkxlZnQsIDApIDogMCk7XG4gICAgICAgICAgICAgIGFkanVzdFggPSBiTGVmdDtcbiAgICAgICAgICAgICAgYlRvcCA9IChfaXNQWChiVG9wKSA/IF9jbnVtKGJUb3AsIDApIDogMCk7XG4gICAgICAgICAgICAgIGFkanVzdFkgPSBiVG9wO1xuICAgICAgICAgICAgICByZWN0LnQgLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgcmVjdC5sIC09IGFkanVzdFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWN0LnQgKz0gc2Nyb2xsLnk7XG4gICAgICAgICAgICByZWN0LmwgKz0gc2Nyb2xsLng7XG4gICAgICAgICAgICByZWN0LmIgPSByZWN0LnQgKyBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICByZWN0LnIgPSByZWN0LmwgKyBlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHJlY3QudyA9IF9tYXgocmVjdC5yIC0gcmVjdC5sLCAwKTtcbiAgICAgICAgICAgIHJlY3QuaCA9IF9tYXgocmVjdC5iIC0gcmVjdC50LCAwKTtcbiAgICAgICAgICAgIHJlY3QueiA9IGN1cnJlbnRTdHlsZShlbCwgXCJ6SW5kZXhcIik7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgICAgdDogMCxcbiAgICAgICAgICAgICAgbDogMCxcbiAgICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgICAgdzogMCxcbiAgICAgICAgICAgICAgaDogMCxcbiAgICAgICAgICAgICAgejogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ2FsY3VsYXRlIGEgZ2VvbWV0cmljIHJlY3RhbmdsZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBGb3Igbm9uLUlFIGJyb3dzZXJzLCB3ZSBtdXN0IHVzZVxuICAgICAgYnJ1dGUtZm9yY2UgYW5kIHdhbGsgdXAgdGhlIG9mZnNldFBhcmVudCB0cmVlLiBBbHNvIHRha2VzIGluIGNvbnNpZGVyYXRpb24gZm9yIHNvbWVcbiAgICAgIG90aGVyIHNsaWdodCB2YXJpYXRpb25zIGluIGJyb3dzZXJzLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS1fZ2V0UmVjdE5vbklFXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAgVGhlIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGRlcml2ZSBhIHJlY3RhbmdsZSBvYmplY3RcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlY3RhbmdsZSBmb3IgdGhlIGdpdmVuIEhUTUxFbGVtZW50XG4gICAgICAgKi9cbiAgICAgIF9nZXRSZWN0Tm9uSUUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgYkNoZWNrLCBlLCBoLCBwYXJlbnROb2RlLCByZWN0LCByb290LCBzY3JvbGwsIHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgdztcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICB0OiAwLFxuICAgICAgICAgIGw6IDAsXG4gICAgICAgICAgcjogMCxcbiAgICAgICAgICBiOiAwLFxuICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgaDogMCxcbiAgICAgICAgICB6OiAwXG4gICAgICAgIH07XG4gICAgICAgIHNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICBiQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgcm9vdCA9IF9kb2NOb2RlKGVsKTtcbiAgICAgICAgc2Nyb2xsID0gX2dldF9kb2Nfc2Nyb2xsKGVsKTtcbiAgICAgICAgcGFyZW50Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgdyA9IHZvaWQgMDtcbiAgICAgICAgaCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGVsICYmIGVsW05PREVfVFlQRV0gPT09IDEpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVjdC5sID0gZWwub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgICAgcmVjdC50ID0gZWwub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gZWw7XG4gICAgICAgICAgICBiQ2hlY2sgPSBnZWNrVmVyIHx8IHdiVmVyID4gNTE5O1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICByZWN0LnQgKz0gcGFyZW50Tm9kZS5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgICAgICAgcmVjdC5sICs9IHBhcmVudE5vZGUub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgICAgICBpZiAoYkNoZWNrKSB7XG4gICAgICAgICAgICAgICAgX2NhbGNCb3JkZXJzKHBhcmVudE5vZGUsIHJlY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBlbDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3R5bGUocGFyZW50Tm9kZSwgXCJwb3NpdGlvblwiKSAhPT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBlbDtcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUgPSBfcGFyKHBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVbTk9ERV9UWVBFXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gcGFyZW50Tm9kZS5zY3JvbGxUb3AgfHwgMDtcbiAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgPSBwYXJlbnROb2RlLnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgICAgICAgICAgIGlmIChnZWNrVmVyICYmIGN1cnJlbnRTdHlsZShwYXJlbnROb2RlLCBPVkVSKSAhPT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbGNCb3JkZXJzKHBhcmVudE5vZGUsIHJlY3QpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVjdC5sIC09IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICByZWN0LnQgLT0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlY3QudCArPSBzY3JvbGwueTtcbiAgICAgICAgICAgICAgcmVjdC5sICs9IHNjcm9sbC54O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjdC50ICs9IHNjcm9sbC55O1xuICAgICAgICAgICAgICByZWN0LmwgKz0gc2Nyb2xsLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWllVmVyICYmIGVsID09PSBfZG9jTm9kZShlbCkpIHtcbiAgICAgICAgICAgICAgaCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgdyA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgdyA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdC5iID0gcmVjdC50ICsgaDtcbiAgICAgICAgICAgIHJlY3QuciA9IHJlY3QubCArIHc7XG4gICAgICAgICAgICByZWN0LncgPSBfbWF4KHJlY3QuciAtIHJlY3QubCwgMCk7XG4gICAgICAgICAgICByZWN0LmggPSBfbWF4KHJlY3QuYiAtIHJlY3QudCwgMCk7XG4gICAgICAgICAgICByZWN0LnogPSBjdXJyZW50U3R5bGUoZWwsIFwiekluZGV4XCIpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgICAgIGw6IDAsXG4gICAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgICAgIGg6IDAsXG4gICAgICAgICAgICAgIHo6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHJlY3RhbmdsZSB3aXRoIHRoZSBnZW9tZXRyaWMgaW5mb3JtYXRpb24gb2YgYW4gSFRNTERvY3VtZW50XG4gICAgICAoaW5jbHVkZXMgc2Nyb2xsIHdpZHRoIC8gaGVpZ2h0KVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS5kb2NSZWN0XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQW4gSFRNTEVsZW1lbnQgdG8gdXNlIGFzIHRoZSByZWZlcmVuY2UgZm9yIGFuIEhUTUxEb2N1bWVudFxuICAgICAgQHJldHVybnMge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZG9jUmVjdCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBoLCByb290LCB3O1xuICAgICAgICByb290ID0gX2RvY05vZGUoZWwpO1xuICAgICAgICB3ID0gMDtcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgdyA9IHJvb3Quc2Nyb2xsV2lkdGggfHwgMDtcbiAgICAgICAgICBoID0gcm9vdC5zY3JvbGxIZWlnaHQgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgbDogMCxcbiAgICAgICAgICBiOiBoLFxuICAgICAgICAgIHI6IHcsXG4gICAgICAgICAgdzogdyxcbiAgICAgICAgICBoOiBoXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgcmVjdGFuZ2xlIHdpdGggdGhlIGdlb21ldHJpYyBpbmZvcm1hdGlvbiBvZiBhbiBIVE1MV2luZG93XG4gICAgICAoZG9lcyBub3QgaW5jbHVkZSBzY3JvbGwgd2lkdGggLyBoZWlnaHQpXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLndpblJlY3RcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gW2VsXSBBbiBIVE1MRWxlbWVudCB0byB1c2UgYXMgdGhlIHJlZmVyZW5jZXMgZm9yIGFuIEhUTUxXaW5kb3dcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHdpblJlY3QgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgYiwgaCwgbCwgciwgcm9vdCwgdCwgdywgd2k7XG4gICAgICAgIHdpID0gKGVsICYmIF92aWV3KGVsKSkgfHwgd2luO1xuICAgICAgICBoID0gd2kuaW5uZXJIZWlnaHQgfHwgMDtcbiAgICAgICAgdyA9IHdpLmlubmVyV2lkdGggfHwgMDtcbiAgICAgICAgdCA9IHdpLnNjcmVlblkgfHwgd2kuc2NyZWVuVG9wIHx8IDA7XG4gICAgICAgIGIgPSBoICsgdDtcbiAgICAgICAgbCA9IHdpLnNjcmVlblggfHwgd2kuc2NyZWVuTGVmdCB8fCAwO1xuICAgICAgICByID0gdyArIGw7XG4gICAgICAgIHJvb3QgPSBfZG9jTm9kZShlbCk7XG4gICAgICAgIGlmICghaCAmJiAhdyAmJiByb290KSB7XG4gICAgICAgICAgaCA9IHJvb3QuY2xpZW50SGVpZ2h0IHx8IDA7XG4gICAgICAgICAgdyA9IHJvb3QuY2xpZW50V2lkdGggfHwgMDtcbiAgICAgICAgICByID0gbCArIHc7XG4gICAgICAgICAgYiA9IHQgKyBoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdDogdCxcbiAgICAgICAgICBsOiBsLFxuICAgICAgICAgIGI6IGIsXG4gICAgICAgICAgcjogcixcbiAgICAgICAgICB3OiB3LFxuICAgICAgICAgIGg6IGhcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIEhUTUxFbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW5vdGhlciBIVE1MRWxlbWVudFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS5jb250YWluc1xuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBIVE1MRWxlbWVudCByZWZlcmVuY2UgdG8gc2VhcmNoIHdpdGhpblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gbmVlZGxlIFRoZSBIVE1MRWxlbWVudCBmb3Igd2hpY2ggeW91IHdhbnQgdG8gY2hlY2sgaWYgaXRzIGNvbnRhaW5lZCBieSB0aGUgMXN0IHBhcmFtZXRlclxuICAgICAgQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGNvbnRhaW5zID0gZnVuY3Rpb24oZWxlbWVudCwgbmVlZGxlKSB7XG4gICAgICAgIHZhciBlbF9ub2RlX3R5cGUsIG5lZWRsZV9ub2RlX3R5cGUsIHJldDtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIGVsX25vZGVfdHlwZSA9IChlbGVtZW50ICYmIGVsZW1lbnRbTk9ERV9UWVBFXSkgfHwgLTE7XG4gICAgICAgIG5lZWRsZV9ub2RlX3R5cGUgPSAobmVlZGxlICYmIG5lZWRsZVtOT0RFX1RZUEVdKSB8fCAtMTtcbiAgICAgICAgaWYgKGVsX25vZGVfdHlwZSA9PT0gMSAmJiBuZWVkbGVfbm9kZV90eXBlICE9PSAtMSkge1xuICAgICAgICAgIGlmIChlbGVtZW50W0NPTlRBSU5TXSkge1xuICAgICAgICAgICAgaWYgKG9wZXJhVmVyIHx8IG5lZWRsZV9ub2RlX3R5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0ID0gZWxlbWVudFtDT05UQUlOU10obmVlZGxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChuZWVkbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gbmVlZGxlKSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5lZWRsZSA9IG5lZWRsZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50W0NPTVBBUkVfRE9DX1BPU10pIHtcbiAgICAgICAgICAgICAgcmV0ID0gZWxlbWVudCA9PT0gbmVlZGxlIHx8ICEhKGVsZW1lbnRbQ09NUEFSRV9ET0NfUE9TXShuZWVkbGUpICYgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdHlsZSBhdHRyaWJ1dGUsIG9yIHRoZSBjdXJyZW50IHN0eWxlIG9iamVjdCBpbiBpdHMgZW50aXJldHkgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYW4gYXR0cmlidXRlIHBhcmFtZXRlciBpcyBzcGVjaWZpZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20uY3VycmVudFN0eWxlXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBIVE1MRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgaW5mb3JtYXRpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbYXR0cl0gVGhlIHN0eWxlIGF0dHJpYnV0ZSAoaW4gSmF2YVNjcmlwdCBub3RhdGlvbiwgZS5nLiAnYmFja2dyb3VuZENvbG9yJyByYXRoZXIgdGhhbiAnYmFja2dyb3VuZC1jb2xvcicpIHRvIGZldGNoLlxuICAgICAgQHJldHVybiB7SFRNTFN0eWxlT2JqZWN0fSBBbiBIVE1MU3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgY3VycmVudCBzdHlsZSBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2YWx1ZSBvZiBhbiBzdHlsZSBhdHRyaWJ1dGUgKG9ubHkgaWYgYXR0ciBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkKS5cbiAgICAgICAqL1xuICAgICAgY3VycmVudFN0eWxlID0gZnVuY3Rpb24oZWwsIGF0dHIpIHtcbiAgICAgICAgdmFyIGNvbXAsIGUsIGhhc0F0dHIsIHZhbDtcbiAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgICAgaGFzQXR0ciA9ICEhKGFyZ3VtZW50cy5sZW5ndGggJiYgYXR0cik7XG4gICAgICAgIGNvbXAgPSBcImdldENvbXB1dGVkU3R5bGVcIjtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGhhc0F0dHIpIHtcbiAgICAgICAgICBpZiAoaWVWZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZVthdHRyXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWwgPSBfdmlldyhlbClbY29tcF0oZWwsIG51bGwpW2F0dHJdO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIHZhbCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpZVZlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbCA9IF92aWV3KGVsKVtjb21wXShlbCwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDYWxjdWxhdGUgdGhlIHN1cnJvdW5kaW5nIGJvdW5kYXJpZXMgb2YgYW4gSFRNTEVsZW1lbnQsIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgSFRNTEVsZW1lbnQgaXMgXCJpbi12aWV3XCIgb2YgdGhlIHVzZXJcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20uYm91bmRzXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgaW5mb3JtYXRpb25cbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsc10gQW4gb2JqZWN0IHJlZmVyZW5jZSB1c2VkIGFzIGFuIG91dHB1dCBwYXJhbWV0ZXIgaW4gd2hpY2ggZnVydGhlciBkZXRhaWxzIGFib3V0IHRoZSBib3VuZGFyaWVzIG9mIHRoZSBlbGVtZW50IGFyZSBzcGVjaWZpZWRcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2NoZWNrXzNEXSBDaGVjayB0aGUgZWxlbWVudCB3aXRoaW4gMyBkaW1lbnNpb25hbCBzcGFjZSBzdWNoIHRoYXQgYW55IGVsZW1lbnRzIGNvdmVyaW5nIHNhaWQgZWxlbWVudCBhcmUgYWxzbyB0YWtlIGludG8gY29uc2lkZXJhdGlvblxuICAgICAgQHJldHVybnMge09iamVjdH0gaW5mbyBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZWxlbWVudCBib3VuZGFyaWVzXG4gICAgICAgKi9cbiAgICAgIGJvdW5kcyA9IGZ1bmN0aW9uKGVsLCBkZXRhaWxzLCBjaGVja18zRCkge1xuICAgICAgICB2YXIgYiwgY2xpZW50X2hlaWdodCwgY2xpZW50X3dpZHRoLCBjbGlwLCBjbGlwX3JlY3QsIGN1cl9zdCwgZG9jX3JlY3QsIGVsX3JlY3QsIGV4cF9yZWN0LCBoLCBpc19zY3JvbGxfbm9kZSwgaXNfdXNpbmdfZG9jX3Jvb3RfYiwgaXNfdXNpbmdfZG9jX3Jvb3RfciwgbCwgb2Zmc2V0X2hlaWdodCwgb2Zmc2V0X3dpZHRoLCBvdmVyX3hfdmFsLCBvdmVyX3lfdmFsLCBwYXIsIHIsIHJlZl9ub2RlLCByb290LCByb290X3JlY3QsIHJvb3Rfc2Nyb2xsLCBzY3JvbGxfaGVpZ2h0LCBzY3JvbGxfbGVmdCwgc2Nyb2xsX3RvcCwgc2Nyb2xsX3dpZHRoLCB0LCB0ZW1wX3JlY3QsIHcsIHhfaGlkZGVuLCB4c2JfaCwgeV9oaWRkZW4sIHlzYl93O1xuICAgICAgICBwYXIgPSBlbCAmJiBfcGFyKGVsKTtcbiAgICAgICAgcm9vdCA9IF9kb2NOb2RlKGVsKTtcbiAgICAgICAgZWxfcmVjdCA9IF9yZWN0KGVsKTtcbiAgICAgICAgcm9vdF9yZWN0ID0gX3JlY3Qocm9vdCk7XG4gICAgICAgIHJvb3Rfc2Nyb2xsID0gX2dldF9kb2Nfc2Nyb2xsKHJvb3QpO1xuICAgICAgICBkb2NfcmVjdCA9IGRvY1JlY3QoZWwpO1xuICAgICAgICBjbGlwX3JlY3QgPSB7XG4gICAgICAgICAgdDogMCxcbiAgICAgICAgICBsOiAwLFxuICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgYjogMCxcbiAgICAgICAgICB3OiAwLFxuICAgICAgICAgIGg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgZXhwX3JlY3QgPSB7XG4gICAgICAgICAgdDogMCxcbiAgICAgICAgICBsOiAwLFxuICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgYjogMCxcbiAgICAgICAgICB4czogMCxcbiAgICAgICAgICB5czogMCxcbiAgICAgICAgICB4aXY6IDAsXG4gICAgICAgICAgeWl2OiAwLFxuICAgICAgICAgIGl2OiAwLFxuICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgaDogMFxuICAgICAgICB9O1xuICAgICAgICB4c2JfaCA9IDA7XG4gICAgICAgIHlzYl93ID0gMDtcbiAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSBmYWxzZTtcbiAgICAgICAgaXNfdXNpbmdfZG9jX3Jvb3RfciA9IGZhbHNlO1xuICAgICAgICBpc191c2luZ19kb2Nfcm9vdF9iID0gZmFsc2U7XG4gICAgICAgIGN1cl9zdCA9IHZvaWQgMDtcbiAgICAgICAgdyA9IHZvaWQgMDtcbiAgICAgICAgaCA9IHZvaWQgMDtcbiAgICAgICAgdCA9IHZvaWQgMDtcbiAgICAgICAgbCA9IHZvaWQgMDtcbiAgICAgICAgciA9IHZvaWQgMDtcbiAgICAgICAgYiA9IHZvaWQgMDtcbiAgICAgICAgc2Nyb2xsX3dpZHRoID0gdm9pZCAwO1xuICAgICAgICBvZmZzZXRfd2lkdGggPSB2b2lkIDA7XG4gICAgICAgIGNsaWVudF93aWR0aCA9IHZvaWQgMDtcbiAgICAgICAgc2Nyb2xsX2hlaWdodCA9IHZvaWQgMDtcbiAgICAgICAgb2Zmc2V0X2hlaWdodCA9IHZvaWQgMDtcbiAgICAgICAgY2xpZW50X2hlaWdodCA9IHZvaWQgMDtcbiAgICAgICAgb3Zlcl94X3ZhbCA9IHZvaWQgMDtcbiAgICAgICAgc2Nyb2xsX2xlZnQgPSB2b2lkIDA7XG4gICAgICAgIHNjcm9sbF90b3AgPSB2b2lkIDA7XG4gICAgICAgIG92ZXJfeV92YWwgPSB2b2lkIDA7XG4gICAgICAgIGNsaXAgPSB2b2lkIDA7XG4gICAgICAgIHhfaGlkZGVuID0gdm9pZCAwO1xuICAgICAgICB5X2hpZGRlbiA9IHZvaWQgMDtcbiAgICAgICAgcmVmX25vZGUgPSB2b2lkIDA7XG4gICAgICAgIHRlbXBfcmVjdCA9IHZvaWQgMDtcbiAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSBmYWxzZTtcbiAgICAgICAgZGV0YWlscyA9IChkZXRhaWxzICYmIHR5cGVvZiBkZXRhaWxzID09PSBPQkogPyBkZXRhaWxzIDoge30pO1xuICAgICAgICBpZiAocGFyKSB7XG4gICAgICAgICAgd2hpbGUgKGN1cl9zdCA9IGN1cnJlbnRTdHlsZShwYXIpKSB7XG4gICAgICAgICAgICBpZiAoY3VyX3N0W1wiZGlzcGxheVwiXSA9PT0gXCJibG9ja1wiIHx8IGN1cl9zdFtcInBvc2l0aW9uXCJdID09PSBcImFic29sdXRlXCIgfHwgY3VyX3N0W1wiZmxvYXRcIl0gIT09IFwibm9uZVwiIHx8IGN1cl9zdFtcImNsZWFyXCJdICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICBvdmVyX3hfdmFsID0gY3VyX3N0W09WRVIgKyBcIlhcIl07XG4gICAgICAgICAgICAgIG92ZXJfeV92YWwgPSBjdXJfc3RbT1ZFUiArIFwiWVwiXTtcbiAgICAgICAgICAgICAgY2xpcCA9IF9nZXRDbGlwKGN1cl9zdCk7XG4gICAgICAgICAgICAgIGlmIChwYXIgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxfd2lkdGggPSByb290X3Njcm9sbC53O1xuICAgICAgICAgICAgICAgIHNjcm9sbF9oZWlnaHQgPSByb290X3Njcm9sbC5oO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcm9sbF93aWR0aCA9IHBhci5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICBzY3JvbGxfaGVpZ2h0ID0gcGFyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvZmZzZXRfd2lkdGggPSBwYXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgIG9mZnNldF9oZWlnaHQgPSBwYXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICBjbGllbnRfd2lkdGggPSBwYXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgIGNsaWVudF9oZWlnaHQgPSBwYXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICBpZiAob3Zlcl94X3ZhbCA9PT0gSElEREVOIHx8IGNsaXBbMV0gPiAwIHx8IGNsaXBbM10gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgeF9oaWRkZW4gPSAxO1xuICAgICAgICAgICAgICAgICAgcmVmX25vZGUgPSBwYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvdmVyX3lfdmFsID09PSBISURERU4gfHwgY2xpcFswXSA+IDAgfHwgY2xpcFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICB5X2hpZGRlbiA9IDE7XG4gICAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG92ZXJfeF92YWwgPT09IFNDUk9MTCkge1xuICAgICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICAgIHhzYl9oID0gb2Zmc2V0X2hlaWdodCAtIGNsaWVudF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvdmVyX3lfdmFsID09PSBTQ1JPTEwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeXNiX3cgPSBvZmZzZXRfd2lkdGggLSBjbGllbnRfd2lkdGg7XG4gICAgICAgICAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvdmVyX3hfdmFsID09PSBBVVRPKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgcmVmX25vZGUgPSBwYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxfd2lkdGggPiBjbGllbnRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIHhzYl9oID0gb2Zmc2V0X2hlaWdodCAtIGNsaWVudF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzX3Njcm9sbF9ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Zlcl95X3ZhbCA9PT0gQVVUTykge1xuICAgICAgICAgICAgICAgIGlmICghcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsX2hlaWdodCA+IGNsaWVudF9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIHlzYl93ID0gb2Zmc2V0X3dpZHRoIC0gY2xpZW50X3dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc19zY3JvbGxfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlZl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXIgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgaWYgKHNjcm9sbF93aWR0aCA+IGNsaWVudF93aWR0aCkge1xuICAgICAgICAgICAgICAgIGggPSAod2luLmlubmVySGVpZ2h0IHx8IDApIHx8IG9mZnNldF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgeHNiX2ggPSBoIC0gY2xpZW50X2hlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2Nyb2xsX2hlaWdodCA+IGNsaWVudF9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB3ID0gKHdpbi5pbm5lcldpZHRoIHx8IDApIHx8IG9mZnNldF93aWR0aDtcbiAgICAgICAgICAgICAgICB5c2JfdyA9IHcgLSBjbGllbnRfd2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyID0gX3BhcihwYXIpO1xuICAgICAgICAgICAgaWYgKCFwYXIgfHwgcGFyW05PREVfVFlQRV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbF9yZWN0LncgJiYgZWxfcmVjdC5oKSB7XG4gICAgICAgICAgaWYgKCFyZWZfbm9kZSB8fCByZWZfbm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgZXhwX3JlY3QudCA9IF9tYXgoZWxfcmVjdC50LCAwKTtcbiAgICAgICAgICAgIGV4cF9yZWN0LmwgPSBfbWF4KGVsX3JlY3QubCwgMCk7XG4gICAgICAgICAgICBpZiAoaWVWZXIgJiYgZGNbQ09NUEFUX01PREVdID09PSBcIkJhY2tDb21wYXRcIiAmJiBfYXR0cihyb290LCBTQ1JPTEwpID09PSBcIm5vXCIpIHtcbiAgICAgICAgICAgICAgeV9oaWRkZW4gPSB4X2hpZGRlbiA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJfc3QgPSBjdXJyZW50U3R5bGUocm9vdCk7XG4gICAgICAgICAgICAgIGlmIChjdXJfc3QpIHtcbiAgICAgICAgICAgICAgICB4X2hpZGRlbiA9IGN1cl9zdFtPVkVSICsgXCJYXCJdID09PSBISURERU47XG4gICAgICAgICAgICAgICAgeV9oaWRkZW4gPSBjdXJfc3RbT1ZFUiArIFwiWVwiXSA9PT0gSElEREVOO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdF9zY3JvbGwuaCA+IHJvb3QuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGlmICh5X2hpZGRlbikge1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzX3VzaW5nX2RvY19yb290X2IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSBfbWF4KCgoZG9jX3JlY3QuaCAtIGVsX3JlY3QuaCkgLSB4c2JfaCkgLSBlbF9yZWN0LnQsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHBfcmVjdC5iID0gX21heCgoKHJvb3RfcmVjdC5oIC0gZWxfcmVjdC5oKSAtIHhzYl9oKSAtIGVsX3JlY3QudCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdF9zY3JvbGwudyA+IHJvb3QuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgaWYgKHhfaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNfdXNpbmdfZG9jX3Jvb3RfciA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IF9tYXgoKChkb2NfcmVjdC53IC0gZWxfcmVjdC53KSAtIHlzYl93KSAtIGVsX3JlY3QubCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4cF9yZWN0LnIgPSBfbWF4KCgocm9vdF9yZWN0LnIgLSBlbF9yZWN0LncpIC0geXNiX3cpIC0gZWxfcmVjdC5sLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyX3N0ID0gY3VycmVudFN0eWxlKHJlZl9ub2RlKTtcbiAgICAgICAgICAgIGlmIChfdGFnTmFtZShyZWZfbm9kZSkgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgIHJlZl9ub2RlID0gcm9vdDtcbiAgICAgICAgICAgICAgdCA9IGVsX3JlY3QudDtcbiAgICAgICAgICAgICAgbCA9IGVsX3JlY3QubDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHQgPSBsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaXBfcmVjdCA9IF9yZWN0KHJlZl9ub2RlKTtcbiAgICAgICAgICAgIGlmIChjbGlwWzFdID4gMCkge1xuICAgICAgICAgICAgICBjbGlwX3JlY3QudyA9IGNsaXBbMV07XG4gICAgICAgICAgICAgIGNsaXBfcmVjdC5yID0gY2xpcF9yZWN0LmwgKyBjbGlwX3JlY3QudztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGlwWzNdID4gMCkge1xuICAgICAgICAgICAgICBjbGlwX3JlY3QubCA9IGNsaXBfcmVjdC5sICsgY2xpcFszXTtcbiAgICAgICAgICAgICAgY2xpcF9yZWN0LncgPSBjbGlwX3JlY3QudyAtIGNsaXBbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpcFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgY2xpcF9yZWN0LmggPSBjbGlwWzJdO1xuICAgICAgICAgICAgICBjbGlwX3JlY3QuYiA9IGNsaXBfcmVjdC50ICsgY2xpcF9yZWN0Lmg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpcFswXSA+IDApIHtcbiAgICAgICAgICAgICAgY2xpcF9yZWN0LnQgPSBjbGlwX3JlY3QudCArIGNsaXBbMF07XG4gICAgICAgICAgICAgIGNsaXBfcmVjdC5oID0gY2xpcF9yZWN0LmggLSBjbGlwWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsX3JlY3QudCA+IGNsaXBfcmVjdC50ICYmIGNsaXBfcmVjdC50ID4gMCkge1xuICAgICAgICAgICAgICB0ID0gZWxfcmVjdC50IC0gY2xpcF9yZWN0LnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxfcmVjdC5sID4gY2xpcF9yZWN0LmwgJiYgY2xpcF9yZWN0LmwgPiAwKSB7XG4gICAgICAgICAgICAgIGwgPSBlbF9yZWN0LmwgLSBjbGlwX3JlY3QubDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcm9sbF90b3AgPSByZWZfbm9kZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBzY3JvbGxfbGVmdCA9IHJlZl9ub2RlLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBzY3JvbGxfaGVpZ2h0ID0gcmVmX25vZGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgc2Nyb2xsX3dpZHRoID0gcmVmX25vZGUuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICBleHBfcmVjdC50ID0gX21heCh0LCAwKTtcbiAgICAgICAgICAgIGV4cF9yZWN0LmwgPSBfbWF4KGwsIDApO1xuICAgICAgICAgICAgaWYgKGN1cl9zdCkge1xuICAgICAgICAgICAgICB4X2hpZGRlbiA9IGN1cl9zdFtPVkVSICsgXCJYXCJdID09PSBISURERU4gfHwgY2xpcFsxXSA+IDAgfHwgY2xpcFszXSA+IDA7XG4gICAgICAgICAgICAgIHlfaGlkZGVuID0gY3VyX3N0W09WRVIgKyBcIllcIl0gPT09IEhJRERFTiB8fCBjbGlwWzBdID4gMCB8fCBjbGlwWzJdID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbF9yZWN0LnQgPj0gY2xpcF9yZWN0LmIpIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXlfaGlkZGVuICYmIGVsX3JlY3QudCA+PSBjbGlwX3JlY3QuYikge1xuICAgICAgICAgICAgICAgIHlfaGlkZGVuID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2Nyb2xsX2hlaWdodCA+IHJlZl9ub2RlLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmICh5X2hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSBfbWF4KCgoc2Nyb2xsX2hlaWdodCAtIGVsX3JlY3QuaCkgLSB4c2JfaCkgLSB0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IF9tYXgoKChjbGlwX3JlY3QuaCAtIGVsX3JlY3QuaCkgLSB4c2JfaCkgLSB0LCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsX3JlY3QubCA+PSBjbGlwX3JlY3Qucikge1xuICAgICAgICAgICAgICBleHBfcmVjdC5yID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICgheF9oaWRkZW4gJiYgZWxfcmVjdC5sID49IGNsaXBfcmVjdC5yKSB7XG4gICAgICAgICAgICAgICAgeF9oaWRkZW4gPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzY3JvbGxfd2lkdGggPiByZWZfbm9kZS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIGlmICh4X2hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4cF9yZWN0LnIgPSBfbWF4KCgoc2Nyb2xsX3dpZHRoIC0gZWxfcmVjdC53KSAtIHlzYl93KSAtIGwsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBfcmVjdC5yID0gX21heCgoKGNsaXBfcmVjdC53IC0gZWxfcmVjdC53KSAtIHlzYl93KSAtIGwsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cF9yZWN0LnhzID0gKHhzYl9oID8gMSA6IDApO1xuICAgICAgICAgIGV4cF9yZWN0LnlzID0gKHlzYl93ID8gMSA6IDApO1xuICAgICAgICAgIGV4cF9yZWN0LncgPSBleHBfcmVjdC5yICsgZXhwX3JlY3QubDtcbiAgICAgICAgICBleHBfcmVjdC5oID0gZXhwX3JlY3QudCArIGV4cF9yZWN0LmI7XG4gICAgICAgICAgaWYgKCFyZWZfbm9kZSB8fCByZWZfbm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgdGVtcF9yZWN0ID0gcm9vdF9yZWN0O1xuICAgICAgICAgICAgcmVmX25vZGUgPSByb290O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wX3JlY3QgPSBjbGlwX3JlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGwgPSBfbWF4KGVsX3JlY3QubCwgdGVtcF9yZWN0LmwpO1xuICAgICAgICAgIHIgPSBfbWluKGVsX3JlY3QuciwgKGlzX3VzaW5nX2RvY19yb290X3IgPyBfbWluKGRvY19yZWN0LnIsIHRlbXBfcmVjdC5yKSA6IHRlbXBfcmVjdC5yKSk7XG4gICAgICAgICAgdyA9IF9tYXgociAtIGwsIDApO1xuICAgICAgICAgIHQgPSBfbWF4KGVsX3JlY3QudCwgdGVtcF9yZWN0LnQpO1xuICAgICAgICAgIGIgPSBfbWluKGVsX3JlY3QuYiwgKGlzX3VzaW5nX2RvY19yb290X2IgPyBfbWluKGRvY19yZWN0LmIsIHRlbXBfcmVjdC5iKSA6IHRlbXBfcmVjdC5iKSk7XG4gICAgICAgICAgaCA9IF9tYXgoYiAtIHQsIDApO1xuICAgICAgICAgIGV4cF9yZWN0LnhpdiA9IF9jbnVtKCh3IC8gZWxfcmVjdC53KVtURlhEXSgyKSk7XG4gICAgICAgICAgZXhwX3JlY3QueWl2ID0gX2NudW0oKGggLyBlbF9yZWN0LmgpW1RGWERdKDIpKTtcbiAgICAgICAgICBleHBfcmVjdC5pdiA9IF9jbnVtKCgodyAqIGgpIC8gKGVsX3JlY3QudyAqIGVsX3JlY3QuaCkpW1RGWERdKDIpKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnJlZk5vZGUgPSByZWZfbm9kZSB8fCByb290O1xuICAgICAgICBkZXRhaWxzLmlzUm9vdCA9IHJlZl9ub2RlID09PSByb290O1xuICAgICAgICBkZXRhaWxzLmNhblNjcm9sbCA9IGlzX3Njcm9sbF9ub2RlO1xuICAgICAgICBkZXRhaWxzLnJlZlJlY3QgPSAoIXJlZl9ub2RlIHx8IHJlZl9ub2RlID09PSByb290ID8gcm9vdF9yZWN0IDogY2xpcF9yZWN0KTtcbiAgICAgICAgZGV0YWlscy5leHBSZWN0ID0gZXhwX3JlY3Q7XG4gICAgICAgIGRldGFpbHMucmVjdCA9IGVsX3JlY3Q7XG4gICAgICAgIGlmIChjaGVja18zRCkge1xuICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhck92cmxhcHMsIGVsX2FyZWEsIGVsX2gsIGVsX3csIGlkeCwgbGVuLCBuZXdfaXYsIG5ld194aXYsIG5ld195aXYsIG92cl9hcmVhLCBvdnJfbm9kZSwgb3ZyX25vZGVfcmVjdDtcbiAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgYXJPdnJsYXBzID0gdm9pZCAwO1xuICAgICAgICAgICAgZWxfdyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGVsX2ggPSB2b2lkIDA7XG4gICAgICAgICAgICBlbF9hcmVhID0gdm9pZCAwO1xuICAgICAgICAgICAgb3ZyX25vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBvdnJfbm9kZV9yZWN0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGIgPSB2b2lkIDA7XG4gICAgICAgICAgICBsID0gdm9pZCAwO1xuICAgICAgICAgICAgciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGggPSB2b2lkIDA7XG4gICAgICAgICAgICB3ID0gdm9pZCAwO1xuICAgICAgICAgICAgb3ZyX2FyZWEgPSB2b2lkIDA7XG4gICAgICAgICAgICBuZXdfaXYgPSB2b2lkIDA7XG4gICAgICAgICAgICBuZXdfeGl2ID0gdm9pZCAwO1xuICAgICAgICAgICAgbmV3X3lpdiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChleHBfcmVjdC5pdiA+IC41KSB7XG4gICAgICAgICAgICAgIG1ncl9ib3VuZHNfZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgICAgICAgIGFyT3ZybGFwcyA9IG92ZXJsYXBzKGVsLCBfY251bShjaGVja18zRCwgMSwgMSkpO1xuICAgICAgICAgICAgICBtZ3JfYm91bmRzX2RldGFpbHMgPSBudWxsO1xuICAgICAgICAgICAgICBsZW4gPSBhck92cmxhcHNbTEVOXTtcbiAgICAgICAgICAgICAgZWxfdyA9IGVsX3JlY3QudztcbiAgICAgICAgICAgICAgZWxfaCA9IGVsX3JlY3QuaDtcbiAgICAgICAgICAgICAgZWxfYXJlYSA9IGVsX3cgKiBlbF9oO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG92cl9ub2RlID0gYXJPdnJsYXBzW2lkeCsrXSkge1xuICAgICAgICAgICAgICAgICAgb3ZyX25vZGVfcmVjdCA9IF9yZWN0KG92cl9ub2RlKTtcbiAgICAgICAgICAgICAgICAgIGwgPSBfbWF4KGVsX3JlY3QubCwgb3ZyX25vZGVfcmVjdC5sKTtcbiAgICAgICAgICAgICAgICAgIHIgPSBfbWluKGVsX3JlY3Quciwgb3ZyX25vZGVfcmVjdC5yKTtcbiAgICAgICAgICAgICAgICAgIHQgPSBfbWF4KGVsX3JlY3QudCwgb3ZyX25vZGVfcmVjdC50KTtcbiAgICAgICAgICAgICAgICAgIGIgPSBfbWluKGVsX3JlY3QuYiwgb3ZyX25vZGVfcmVjdC5iKTtcbiAgICAgICAgICAgICAgICAgIHcgPSByIC0gbDtcbiAgICAgICAgICAgICAgICAgIGggPSBiIC0gdDtcbiAgICAgICAgICAgICAgICAgIG92cl9hcmVhID0gdyAqIGg7XG4gICAgICAgICAgICAgICAgICBuZXdfeGl2ID0gKDEgLSAodyAvIGVsX3cpKVtURlhEXSgyKTtcbiAgICAgICAgICAgICAgICAgIG5ld195aXYgPSAoMSAtIChoIC8gZWxfaCkpW1RGWERdKDIpO1xuICAgICAgICAgICAgICAgICAgbmV3X2l2ID0gKDEgLSAob3ZyX2FyZWEgLyBlbF9hcmVhKSlbVEZYRF0oMik7XG4gICAgICAgICAgICAgICAgICBpZiAoKG5ld194aXYgPiAwICYmIG5ld194aXYgPCBleHBfcmVjdC54aXYpIHx8IChuZXdfeWl2ID4gMCAmJiBuZXdfeWl2IDwgZXhwX3JlY3QueWl2KSkge1xuICAgICAgICAgICAgICAgICAgICBleHBfcmVjdC54aXYgPSBuZXdfeGl2O1xuICAgICAgICAgICAgICAgICAgICBleHBfcmVjdC55aXYgPSBuZXdfeWl2O1xuICAgICAgICAgICAgICAgICAgICBleHBfcmVjdC5pdiA9IG5ld19pdjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBfcmVjdDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBGaW5kIGFueSBIVE1MRWxlbWVudHMgdGhhdCBhcmUgY292ZXJpbmcgYSBnaXZlbiBIVE1MRWxlbWVudC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ub3ZlcmxhcHNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIEhUTUxFbGVtZW50IGZvciB3aGljaCB0byBmaW5kIGFueSBvdGhlciBlbGVtZW50cyB0aGF0IG1heSBiZSBjb3ZlcmluZyBpdC5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb3ZlcmluZyBlbGVtZW50cyB0byByZXR1cm5cbiAgICAgIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgY292ZXJpbmcgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgb3ZlcmxhcHMgPSBmdW5jdGlvbihlbCwgbGltaXQpIHtcbiAgICAgICAgdmFyIGJhc2VILCBiYXNlVywgY2hlY2tFbCwgY3VySCwgY3VyVywgZG9jLCBmYWN0b3IsIGgsIGlkLCBpZHgsIGwsIG1heFgsIG1heFksIHBhcl9kZXRhaWxzLCBwb2ludHMsIHB0LCByZWN0LCByZWZfcGFyX25vZGUsIHJlZl9wYXJfcmVjdCwgcmV0LCByb290LCBzZWVuLCB0LCB3LCB4LCB5O1xuICAgICAgICByZWN0ID0gX3JlY3QoZWwpO1xuICAgICAgICBkb2MgPSBfZG9jKGVsKTtcbiAgICAgICAgcm9vdCA9IF9kb2NOb2RlKGRvYyk7XG4gICAgICAgIHQgPSByZWN0LnQ7XG4gICAgICAgIGwgPSByZWN0Lmw7XG4gICAgICAgIHcgPSByZWN0LnIgLSByZWN0Lmw7XG4gICAgICAgIGggPSByZWN0LmIgLSByZWN0LnQ7XG4gICAgICAgIGZhY3RvciA9IElOVEVSU0VDVF9GQUNUT1I7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICBiYXNlVyA9IF9yb3VuZCh3IC8gZmFjdG9yKTtcbiAgICAgICAgYmFzZUggPSBfcm91bmQoaCAvIGZhY3Rvcik7XG4gICAgICAgIGN1clcgPSBiYXNlVztcbiAgICAgICAgY3VySCA9IGJhc2VIO1xuICAgICAgICBzZWVuID0ge307XG4gICAgICAgIHBhcl9kZXRhaWxzID0ge307XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICB4ID0gdm9pZCAwO1xuICAgICAgICB5ID0gdm9pZCAwO1xuICAgICAgICBwdCA9IHZvaWQgMDtcbiAgICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICAgIGNoZWNrRWwgPSB2b2lkIDA7XG4gICAgICAgIHJlZl9wYXJfbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgcmVmX3Bhcl9yZWN0ID0gdm9pZCAwO1xuICAgICAgICBtYXhYID0gdm9pZCAwO1xuICAgICAgICBtYXhZID0gdm9pZCAwO1xuICAgICAgICBpZiAobWdyX2JvdW5kc19kZXRhaWxzKSB7XG4gICAgICAgICAgcGFyX2RldGFpbHMgPSBtZ3JfYm91bmRzX2RldGFpbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm91bmRzKGVsLCBwYXJfZGV0YWlscywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmX3Bhcl9ub2RlID0gcGFyX2RldGFpbHMucmVmTm9kZTtcbiAgICAgICAgcmVmX3Bhcl9yZWN0ID0gcGFyX2RldGFpbHMucmVmUmVjdDtcbiAgICAgICAgaWYgKHJlZl9wYXJfcmVjdCAmJiByZWZfcGFyX25vZGUgJiYgcmVmX3Bhcl9ub2RlICE9PSByb290KSB7XG4gICAgICAgICAgbWF4WCA9IHJlZl9wYXJfcmVjdC5yO1xuICAgICAgICAgIG1heFkgPSByZWZfcGFyX3JlY3QuYjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhYID0gbCArIHc7XG4gICAgICAgICAgbWF4WSA9IHQgKyBoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2MgJiYgcm9vdCAmJiBkb2NbRUxfRlJPTV9QVF0pIHtcbiAgICAgICAgICB3aGlsZSAoY3VyVyA8IHcpIHtcbiAgICAgICAgICAgIGN1ckggPSBiYXNlSDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJIIDwgaCkge1xuICAgICAgICAgICAgICB4ID0gbCArIGN1clc7XG4gICAgICAgICAgICAgIHkgPSB0ICsgY3VySDtcbiAgICAgICAgICAgICAgaWYgKHggPCBtYXhYICYmIHkgPCBtYXhZKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJIICs9IGJhc2VIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyVyArPSBiYXNlVztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGltaXQgPSBfY251bShsaW1pdCwgcG9pbnRzW0xFTl0pO1xuICAgICAgICAgIHdoaWxlIChwdCA9IHBvaW50c1tpZHgrK10pIHtcbiAgICAgICAgICAgIGNoZWNrRWwgPSBkb2NbRUxfRlJPTV9QVF0ocHRbMF0sIHB0WzFdKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjaGVja0VsICYmIGNoZWNrRWwubm9kZVR5cGUgPT09IDEgJiYgY2hlY2tFbCAhPT0gcm9vdCAmJiBjaGVja0VsICE9PSBlbCAmJiAhY29udGFpbnMoZWwsIGNoZWNrRWwpKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBfYXR0cihjaGVja0VsLCBcImlkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgIGlkID0gbGFuZy5ndWlkKFwiZ2VvbV9pbnRlclwiKTtcbiAgICAgICAgICAgICAgICAgIF9hdHRyKGNoZWNrRWwsIFwiaWRcIiwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlZW5baWRdICYmIHJldFtMRU5dIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHNlZW5baWRdID0gMTtcbiAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGNoZWNrRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZCA9IFwiXCI7XG4gICAgICAgIGZvciAoaWQgaW4gc2Vlbikge1xuICAgICAgICAgIGlmIChpZC5pbmRleE9mKFwiZ2VvbV9pbnRlclwiKSA9PT0gMCkge1xuICAgICAgICAgICAgY2hlY2tFbCA9IF9lbHQoaWQpO1xuICAgICAgICAgICAgaWYgKGNoZWNrRWwpIHtcbiAgICAgICAgICAgICAgX2F0dHIoY2hlY2tFbCwgXCJpZFwiLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBBIHByb3h5IHdyYXBwZXIgZm9yIGNhbGxpbmcgaW50byB0aGUgY3Jvc3MtZG9tYWluIG1lc3NhZ2luZyBob3N0IGZhbGwgYmFjayBsaWJyYXJ5XG4gICAgICBMb29rcyBmb3IgbmFtZXNwYWNlIHdpbGwgYmUgJHNmLmxpYi5kb20ubXNnaG9zdF9mYlxuICAgICAgU2FpZCBsaWJyYXJ5IGlzIHVzZWQgaW4gY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm90IEhUTUw1IHN0eWxlIG1lc3NhZ2luZyAoaS5lLiBubyBwb3N0TWVzc2FnZSBtZXRob2QgYXZhaWxhYmxlKS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC1fY2FsbF94bXNnX2hvc3RfZmJcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBtZXRoTmFtZSBUaGUgbWV0aG9kIG5hbWUgaW4gdGhlIG1zZyBob3N0IGxpYnJhcnkgdG8gY2FsbFxuICAgICAgQHBhcmFtIHsqfSBhcmcxIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAxc3QgYXJnXG4gICAgICBAcGFyYW0geyp9IGFyZzIgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDJuZCBhcmdcbiAgICAgIEBwYXJhbSB7Kn0gYXJnMyBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgM3JkIGFyZ1xuICAgICAgQHJldHVybnMgeyp9IHdoYXRldmVyIGNvbWVzIGJhY2sgZnJvbSB0aGUgbWV0aG9kXG4gICAgICAgKi9cbiAgICAgIF9jYWxsX3htc2dfaG9zdF9mYiA9IGZ1bmN0aW9uKG1ldGhOYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGlmICghbXNnaG9zdGZiKSB7XG4gICAgICAgICAgbXNnaG9zdGZiID0gZG9tLm1zZ2hvc3RfZmI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhOYW1lICYmIG1zZ2hvc3RmYiAmJiBtc2dob3N0ZmJbbWV0aE5hbWVdICYmIG1zZ2hvc3RmYlttZXRoTmFtZV0oYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTGlzdGVuIGZvciBhbiBpbml0aWFsIEhUTUw1IHBvc3RNZXNzYWdlIGV2ZW50LCB0byB2YWxpZGF0ZSB0aGF0IEhUTUw1IHN0eWxlXG4gICAgICBtZXNzYWdpbmcgY2FuIGJlIHVzZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC1fY2hlY2tfaHRtbDVfaW5pdFxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IEhUTUwgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gdGhlIHBvc3RNZXNzYWdlIGNhbGxcbiAgICAgICAqL1xuICAgICAgX2NoZWNrX2h0bWw1X2luaXQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCFjYW5Vc2VIVE1MNSAmJiBldnQgJiYgZXZ0LmRhdGEgPT09IGluaXRJRCkge1xuICAgICAgICAgIGNhblVzZUhUTUw1ID0gdHJ1ZTtcbiAgICAgICAgICBkb20uZXZ0Q25jbChldnQpO1xuICAgICAgICAgIGRvbVtERVRBQ0hdKHdpbiwgTVNHLCBfY2hlY2tfaHRtbDVfaW5pdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBMaXN0ZW4gZm9yIG9ubWVzc2FnZSBldmVudHMgaW4gdGhlIG1haW4gd2luZG93LiBWYWxpZGF0ZSB0aGF0IG1lc3NhZ2UgaXMgZm9yIHVzLCBhbmQgaWYgc29cbiAgICAgIHBhc3MgaXQgdGhyb3VnaCB0byB0aGUgcmVzdCBvZiB0aGUgY29kZSBhbmQgY2FuY2VsIGZ1cnRoZXIgaGFuZGxpbmcuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QtX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgSFRNTCBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSB0aGUgcG9zdE1lc3NhZ2UgY2FsbFxuICAgICAgICovXG4gICAgICBfaGFuZGxlX21zZ19mcm9tX291dHNpZGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIGNiLCBkYXRhLCBkYXRhR1VJRCwgZSwgZnJfd2luLCBpZnIsIG1zZ193aW4sIHBhcmFtcywgcGlwZSwgcGlwZUdVSUQsIHJldCwgdGd0SUQ7XG4gICAgICAgIGRhdGEgPSBldnQgJiYgZXZ0LmRhdGE7XG4gICAgICAgIG1zZ193aW4gPSBldnQgJiYgZXZ0LnNvdXJjZTtcbiAgICAgICAgcGFyYW1zID0gZGF0YSAmJiAoZGF0YS5pbmRleE9mKEdVSUQpICE9PSAtMSkgJiYgUGFyYW1IYXNoKGRhdGEpO1xuICAgICAgICB0Z3RJRCA9IHBhcmFtcyAmJiBwYXJhbXMuaWQ7XG4gICAgICAgIGlmciA9IHRndElEICYmIF9lbHQodGd0SUQpO1xuICAgICAgICBmcl93aW4gPSBpZnIgJiYgX2lmcl92aWV3KGlmcik7XG4gICAgICAgIHBpcGUgPSB0Z3RJRCAmJiBtc2dfcGlwZXNbdGd0SURdO1xuICAgICAgICBkYXRhR1VJRCA9IHBhcmFtcyAmJiBwYXJhbXNbR1VJRF07XG4gICAgICAgIHBpcGVHVUlEID0gcGlwZSAmJiBwaXBlW0dVSURdO1xuICAgICAgICBjYiA9IHBpcGUgJiYgcGlwZS5feG1zZ2NiO1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBpcGVHVUlEICYmIGRhdGFHVUlEICYmIGRhdGFHVUlEID09PSBwaXBlR1VJRCAmJiBtc2dfd2luICYmIGZyX3dpbiAmJiBmcl93aW4gPT09IG1zZ193aW4pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0ID0gY2IocGFyYW1zLm1zZyk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBkb20uZXZ0Q25jbChldnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgU2VuZCBhIG1lc3NhZ2UgdG8gYSBjaGlsZCBpZnJhbWUuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3Quc2VuZFxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gdGd0SUQgVGhlIEhUTUwgaWQgYXR0cmlidXRlIG9mIHRoZSBpZnJhbWUgZWxlbWVudCBmb3Igd2hpY2ggdG8gc2VuZCBhIG1lc3NhZ2VcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSBzdHJpbmcgb2YgZGF0YSB0byBzZW5kIHRvIHRoZSBnaXZlbiBpZnJhbWVcbiAgICAgIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCBtZXNzYWdlIHdhcyBzZW5kIHN1Y2Nlc2Z1bGx5IChub3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBtZWFuIG1lc3NhZ2Ugd2FzIGhhbmRsZWQgLyByZWNldmllZCwgb25seSB0aGF0IHNlbmRpbmcgd2FzIG9rKS5cbiAgICAgICAqL1xuICAgICAgc2VuZF9tc2dfdG9fY2hpbGRfaWZyYW1lID0gZnVuY3Rpb24odGd0SUQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGUsIGVsLCBtc2dPYmosIHBpcGUsIHN1Y2Nlc3MsIHc7XG4gICAgICAgIHBpcGUgPSB0Z3RJRCAmJiBtc2dfcGlwZXNbdGd0SURdO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgICAgdyA9IHZvaWQgMDtcbiAgICAgICAgZWwgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGlmICghcGlwZSkge1xuICAgICAgICAgIHN1Y2Nlc3MgPSBfY2FsbF94bXNnX2hvc3RfZmIoXCJzZW5kXCIsIHRndElELCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGlwZSkge1xuICAgICAgICAgICAgbXNnT2JqID0gUGFyYW1IYXNoKCk7XG4gICAgICAgICAgICBtc2dPYmoubXNnID0gZGF0YTtcbiAgICAgICAgICAgIG1zZ09iai5ndWlkID0gcGlwZS5ndWlkO1xuICAgICAgICAgICAgaWYgKHVzaW5nSFRNTDUoKSkge1xuICAgICAgICAgICAgICBlbCA9IF9lbHQodGd0SUQpO1xuICAgICAgICAgICAgICB3ID0gX2lmcl92aWV3KGVsKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3W1BNU0ddKF9jc3RyKG1zZ09iaiksIHBpcGUuc3JjSG9zdCB8fCBcIipcIik7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWNjZXNzID0gX2NhbGxfeG1zZ19ob3N0X2ZiKFwic2VuZFwiLCB0Z3RJRCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1zZ09iaiA9IHcgPSBlbCA9IG51bGw7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEdldCB3aGV0aGVyIG9yIG5vdCBIVE1MNSBzdHlsZSBtZXNzYWdpbmcgY2FuIGJlIHVzZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC51c2luZ0hUTUw1XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICB1c2luZ0hUTUw1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYW5Vc2VIVE1MNTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBHZXRzIGEgbG9jYXRpb24gb2YgdGhlIGhvc3RpbmcgcGFnZSwgc3RyaXBwZWQgb2YgdGhlIHNlYXJjaCBoYXNoLFxuICAgICAgYnV0IGxlYXZpbmcgcXVlcnkgcGFyYW1ldGVycywgcG9ydCwgaG9zdCwgcGF0aCwgZXRjLlxuICAgICAgICovXG4gICAgICBfc3RyaXBwZWRFbmNvZGVkTG9jYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsZWFuZWQsIHBvcztcbiAgICAgICAgY2xlYW5lZCA9IHZvaWQgMDtcbiAgICAgICAgcG9zID0gbG9jLmhyZWYuaW5kZXhPZihcIiNcIik7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgIGNsZWFuZWQgPSBsb2MuaHJlZi5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbmVkID0gbG9jLmhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gY2xlYW5lZC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVzY2FwZShjbGVhbmVkKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBQcmVwYXJlIGFuIGlmcmFtZSBpbiB0aGUgdG9wIGxldmVsIHdpbmRvdyB0byBiZSBhYmxlIHRvIHNlbmQgLyByZWNlaXZlIGNyb3NzLWRvbWFpbiBtZXNzYWdlc1xuICAgICAgR2VuZXJhbGx5IHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmcm9tICRzZi5saWIuaWZyYW1lcy4gIFRoZSBhdHRycyBvYmplY3QgaW4gcXVlc3Rpb24gc2hvdWxkXG4gICAgICByZXByZXNlbnQga2V5L3ZhbHVlIHBhaXJzIG9mIEhUTUwgYXR0cmlidXRlcyBmb3IgdGhlIGlmcmFtZS4gTm90ZSB0aGF0IHRoZSBhdHRycyBvYmplY3QgcGFzc2VkXG4gICAgICBpbiB3aWxsIGJlIG1vZGlmaWVkIHdpdGggYSBuZXcgXCJuYW1lXCIgcHJvcGVydHksIHRvIHNlbmQgaW5mb3JtYXRpb24gaW50byB0aGUgaWZyYW1lIGFuZCBzZXR1cFxuICAgICAgbWVzc2FnaW5nLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS5tc2dob3N0LnByZXBcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtPYmplY3R9IGF0dHJzIEluZm9ybWF0aW9uIHJlcXVpcmVkIHRvIHNldCB1cCB0aGUgY3Jvc3MtZG9tYWluIG1lc3NhZ2luZyBjaGFubmVsXG4gICAgICBAcGFyYW0ge1N0cmluZ30gYXR0cnMuaWQgVGhlIElGUkFNRSBIVE1MIGlkIGF0dHJpYnV0ZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGF0dHJzLnNyYyBUaGUgVVJMIC8gc3JjIGF0dHJpYnV0ZSBvZiB0aGUgSUZSQU1FXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2F0dHJzLmd1aWRdIFRoZSBndWlkIC8gc2lnbmF0dXJlIHRvIHVzZSB0byB2YWxpZGF0ZSB0aGF0IG1lc3NhZ2VzIHNlbnQvIHJlY2VpdmVkIGNhbiBiZSBhY2NlcHRlZC4gSWYgbm90IHNwZWNpZmllZCwgb25lIHdpbGwgYmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFthdHRycy5uYW1lXSBUaGUgSUZSQU1FIEhUTUwgbmFtZSBhdHRyaWJ1dGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNlbmQgYW4gaW50aWFsIG1lc3NhZ2UgdG8gdGhlIEhUTUwgZG9jdW1lbnQgaW5zaWRlIHRoZSBJRlJBTUUuXG4gICAgICBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB2YXJpb3VzIHByb3BlcnRpZXMgZGV0YWlsaW5nIHRoZSBtZXNzYWdpbmcgcGlwZS1saW5lLlxuICAgICAgICovXG4gICAgICBwcmVwX2lmcmFtZV9tc2dpbmcgPSBmdW5jdGlvbihhdHRycykge1xuICAgICAgICB2YXIgaWZyYW1lTmFtZSwgbG9jU3RyaXBwZWQsIG5hbWVQYXJhbXMsIG5ld1BpcGUsIHBpcGUsIHNyYywgc3JjSG9zdDtcbiAgICAgICAgcGlwZSA9IG51bGw7XG4gICAgICAgIGlmcmFtZU5hbWUgPSB2b2lkIDA7XG4gICAgICAgIG5hbWVQYXJhbXMgPSB2b2lkIDA7XG4gICAgICAgIHNyYyA9IHZvaWQgMDtcbiAgICAgICAgc3JjSG9zdCA9IHZvaWQgMDtcbiAgICAgICAgbmV3UGlwZSA9IHZvaWQgMDtcbiAgICAgICAgbG9jU3RyaXBwZWQgPSBfc3RyaXBwZWRFbmNvZGVkTG9jYXRpb24oKTtcbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgaWZyYW1lTmFtZSA9IGF0dHJzLm5hbWU7XG4gICAgICAgICAgbmFtZVBhcmFtcyA9IFBhcmFtSGFzaChpZnJhbWVOYW1lKTtcbiAgICAgICAgICBzcmMgPSBfY3N0cihhdHRycy5zcmMpO1xuICAgICAgICAgIHNyY0hvc3QgPSBzcmMgJiYgc3JjLnN1YnN0cmluZygwLCBzcmMuaW5kZXhPZihcIi9cIiwgOSkpO1xuICAgICAgICAgIHNyY0hvc3QgPSAoc3JjSG9zdC5zZWFyY2goL2h0dHAvZykgIT09IDAgPyBcIlwiIDogc3JjSG9zdCk7XG4gICAgICAgICAgcGlwZSA9IFBhcmFtSGFzaChuYW1lUGFyYW1zKTtcbiAgICAgICAgICBwaXBlLmlkID0gYXR0cnMuaWQgfHwgKFwiaWZyYW1lX1wiICsgX2d1aWQoKSk7XG4gICAgICAgICAgcGlwZS5zcmMgPSBzcmM7XG4gICAgICAgICAgcGlwZS5zcmNIb3N0ID0gc3JjSG9zdDtcbiAgICAgICAgICBwaXBlW0dVSURdID0gcGlwZVtHVUlEXSB8fCBfZ3VpZCgpO1xuICAgICAgICAgIHBpcGUuaG9zdCA9IGxvY0hvc3Q7XG4gICAgICAgICAgcGlwZS5sb2MgPSBsb2NTdHJpcHBlZDtcbiAgICAgICAgICBwaXBlLnByb3h5SUQgPSBcIlwiO1xuICAgICAgICAgIGlmICh1c2luZ0hUTUw1KCkpIHtcbiAgICAgICAgICAgIHBpcGUuaHRtbDUgPSAxO1xuICAgICAgICAgICAgcGlwZS5wcm94eVBhdGggPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdQaXBlID0gX2NhbGxfeG1zZ19ob3N0X2ZiKFwicHJlcFwiLCBwaXBlKTtcbiAgICAgICAgICAgIGlmIChuZXdQaXBlKSB7XG4gICAgICAgICAgICAgIHBpcGUgPSBuZXdQaXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRycy5uYW1lID0gcGlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gYW4gSUZSQU1FLiBOb3RlIHRoYXQgb24gdGhlIGhvc3QgLyBwdWJsaXNoZXIgc2lkZVxuICAgICAgdGhpcyBsaWJyYXJ5IG9ubHkgYWxsb3dzIGZvciBvbmUgbWVzc2FnZSBoYW5kbGVyIHRvIGJlIGF0dGFjaGVkIHRvIGEgZ2l2ZW5cbiAgICAgIElGUkFNRS5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC5hdHRhY2hcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIElGUkFNRSByZWZlcmVuY2UgdG8gYXR0YWNoIGEgbGlzdGVuZXIgY2FsbGJhY2sgdG9vLiAuXG4gICAgICBAcGFyYW0ge09iamVjdH0gcGlwZSBUaGUgbWVzc2FnZSBwaXBlIG9iamVjdCBjcmVhdGVkIGZyb20gJHNmLmxpYi5kb20ubXNnaG9zdC5wcmVwXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgICAgICovXG4gICAgICBhdHRhY2hfaWZyYW1lX21zZ2luZyA9IGZ1bmN0aW9uKGVsLCBwaXBlLCBjYikge1xuICAgICAgICB2YXIgdGd0SUQ7XG4gICAgICAgIHRndElEID0gdm9pZCAwO1xuICAgICAgICBpZiAoX3RhZ05hbWUoZWwpID09PSBcImlmcmFtZVwiKSB7XG4gICAgICAgICAgdGd0SUQgPSBfYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgICAgICBpZiAodGd0SUQgJiYgcGlwZSAmJiAocGlwZSBpbnN0YW5jZW9mIFBhcmFtSGFzaCkgJiYgdGd0SUQgPT09IHBpcGUuaWQpIHtcbiAgICAgICAgICAgIGlmICh1c2luZ0hUTUw1KCkpIHtcbiAgICAgICAgICAgICAgbXNnX3BpcGVzW3RndElEXSA9IHBpcGU7XG4gICAgICAgICAgICAgIHBpcGUuX3htc2djYiA9IGNiO1xuICAgICAgICAgICAgICBpZiAoIWh0bWw1Qm91bmQpIHtcbiAgICAgICAgICAgICAgICBkb21bQVRUQUNIXSh3aW4sIE1TRywgX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlKTtcbiAgICAgICAgICAgICAgICBodG1sNUJvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2NhbGxfeG1zZ19ob3N0X2ZiKEFUVEFDSCwgZWwsIHBpcGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBEZXRhY2ggbGlzdGVuaW5nIGZvciBtZXNzYWdlcyBmcm9tIGFuIElGUkFNRVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS5tc2dob3N0LmRldGFjaFxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSUZSQU1FIHJlZmVyZW5jZSB0byBkZXRhY2ggYSBsaXN0ZW5lclxuICAgICAgICovXG4gICAgICBkZXRhY2hfaWZyYW1lX21zZ2luZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBlbXB0eSwgaWQsIHBpcGUsIHc7XG4gICAgICAgIGlkID0gX2F0dHIoZWwsIFwiaWRcIik7XG4gICAgICAgIHBpcGUgPSBpZCAmJiBtc2dfcGlwZXNbaWRdO1xuICAgICAgICB3ID0gbnVsbDtcbiAgICAgICAgZW1wdHkgPSB0cnVlO1xuICAgICAgICBpZiAoIXBpcGUpIHtcbiAgICAgICAgICBfY2FsbF94bXNnX2hvc3RfZmIoREVUQUNILCBlbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaXBlKSB7XG4gICAgICAgICAgcGlwZS5feG1zZ2NiID0gbXNnX3BpcGVzW2lkXSA9IG51bGw7XG4gICAgICAgICAgcGlwZSA9IG51bGw7XG4gICAgICAgICAgZGVsZXRlIG1zZ19waXBlc1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSBcIlwiO1xuICAgICAgICBmb3IgKGlkIGluIG1zZ19waXBlcykge1xuICAgICAgICAgIHBpcGUgPSBtc2dfcGlwZXNbaWRdO1xuICAgICAgICAgIGlmIChwaXBlICYmIHBpcGVbR1VJRF0pIHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5ICYmIHVzaW5nSFRNTDUoKSAmJiBodG1sNUJvdW5kKSB7XG4gICAgICAgICAgaHRtbDVCb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGRvbVtERVRBQ0hdKHdpbiwgTVNHLCBfaGFuZGxlX21zZ19mcm9tX291dHNpZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gdyA9IHBpcGUgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEZpcmUgdGhlIHNwZWNpZmVkIGNhbGxiYWNrIG91dCB0byB0aGUgcHVibGlzaGVyLiBOb3RlIHRoYXQgb3RoZXIgYXJndW1lbnRzIGJleW9uZCB0aGUgMXN0IGFyZ3VtZW50IGFyZSBwYXNzZWQgdGhyb3VnIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2ZpcmVfcHViX2NhbGxiYWNrXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gY2JfbmFtZSBUaGUgY2FsbGJhY2sgbmFtZSB0byBmaXJlXG4gICAgICAgKi9cbiAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayA9IGZ1bmN0aW9uKGNiX25hbWUpIHtcbiAgICAgICAgdmFyIGEsIGFyZ3MsIGNiX2FyZ3MsIGUsIGYsIGlkeCwgbGVuLCByZXQ7XG4gICAgICAgIGNiX2FyZ3MgPSBbXTtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGVuID0gYXJnc1tMRU5dO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBmID0gdm9pZCAwO1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgYSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgIGYgPSBjb25maWdbY2JfbmFtZV07XG4gICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgICBhID0gYXJnc1tpZHgrK107XG4gICAgICAgICAgICAgIGlmIChhICE9PSBjYl9uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2JfYXJncy5wdXNoKGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXQgPSBmLmFwcGx5KG51bGwsIGNiX2FyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIE51a2UgdGhlIHBvc2l0aW9uIGFuIHJlcG9ydCB0aGF0IHNhaWQgcG9zaXRpb24gdG9vayB0b28gbG9uZyB0byByZW5kZXJcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV9yZW5kZXJfdGltZW91dFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHBvc19pZCBUaGUgcG9zaXRpb24gaWQgdGhhdCBoYXMgdGFrZW4gdG9vIGxvbmdcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV9yZW5kZXJfdGltZW91dCA9IGZ1bmN0aW9uKHBvc19pZCkge1xuICAgICAgICB2YXIgcGVuZDtcbiAgICAgICAgcGVuZCA9IHBvc19pZCAmJiBwZW5kaW5nX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgaWYgKHBlbmQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocGVuZCk7XG4gICAgICAgICAgbnVrZShwb3NfaWQpO1xuICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBcInJlbmRlci10aW1lb3V0XCIsIHBvc19pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfaGFzX3BlbmRpbmdfcmVuZGVycygpKSB7XG4gICAgICAgICAgY3VycmVudF9zdGF0dXMgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ2xlYXIgdGhlIHRpbWVyIHRoYXQgZmlyZXMgZXZlcnkgc28gb2Z0ZW4gdG8gdXBkYXRlIHRoZSBnZW9tZXRyeSBpbiBzaWRlXG4gICAgICBvZiBTYWZlRnJhbWVzXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lclxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGdlb21fdXBkYXRlX3RpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGdlb21fdXBkYXRlX3RpbWVyKTtcbiAgICAgICAgICBnZW9tX3VwZGF0ZV90aW1lciA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICArXHQgKiBDbGVhciB0aGUgdGltZXIgdGhhdCBmaXJlcyBldmVyeSBzbyBvZnRlbiB0byB1cGRhdGUgdGhlIGdlb21ldHJ5IGluIHNpZGVcbiAgICAgICtcdCAqIG9mIFNhZmVGcmFtZXNcbiAgICAgICtcdCAqXG4gICAgICArXHQgKiBAbmFtZSAkc2YuaG9zdC1fY2xlYXJfZ2VvbV91cGRhdGVfdGltZXJcbiAgICAgICtcdCAqIEBzdGF0aWNcbiAgICAgICtcdCAqIEBwcml2YXRlXG4gICAgICArXHQgKiBAZnVuY3Rpb25cbiAgICAgICtcdCAqXG4gICAgICArXG4gICAgICAgKi9cbiAgICAgIF9jbGVhcl9mb2N1c191cGRhdGVfdGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGZvY3VzX3VwZGF0ZV90aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChmb2N1c191cGRhdGVfdGltZXIpO1xuICAgICAgICAgIGZvY3VzX3VwZGF0ZV90aW1lciA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfc2V0X2ZvY3VzX3VwZGF0ZV90aW1lciA9IGZ1bmN0aW9uKGluX2ZvY3VzKSB7XG4gICAgICAgIF9jbGVhcl9mb2N1c191cGRhdGVfdGltZXIoKTtcbiAgICAgICAgZm9jdXNfdXBkYXRlX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdXBkYXRlX2ZvY3VzKGluX2ZvY3VzKTtcbiAgICAgICAgfSwgMik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgU2V0IHVwIHRoZSB0aW1lciBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgZWFjaCBTYWZlRnJhbWUgd2l0aCB1cCB0byBkYXRlIGdlb21ldHJpYyBpbmZvcm1hdGlvblxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fc2V0X2dlb21fdXBkYXRlX3RpbWVyXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9zZXRfZ2VvbV91cGRhdGVfdGltZXIgPSBmdW5jdGlvbihpc193aW5fc2Nyb2xsKSB7XG4gICAgICAgIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lcigpO1xuICAgICAgICBpZiAoaXNfd2luX3Njcm9sbCkge1xuICAgICAgICAgIGdlb21fdXBkYXRlX3RpbWVyID0gc2V0VGltZW91dChfdXBkYXRlX2dlb21fd2luX3Njcm9sbCwgR0VPTV9VUERBVEVfSU5UUlZBTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbV91cGRhdGVfdGltZXIgPSBzZXRUaW1lb3V0KF91cGRhdGVfZ2VvbV93aW5fcmVzaXplLCBHRU9NX1VQREFURV9JTlRSVkFMKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFVwZGF0ZSBhbGwgU2FmZUZyYW1lcyB3aXRoIHVwZGF0ZWQgZ2VvbWV0cmljIGluZm9ybWF0aW9uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV91cGRhdGVfZ2VvbVxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtCb29sZWFufSBpc193aW5fc2Nyb2xsIFdoZXRoZXIgb3Igbm90IHdlIGFyZSB1cGRhdGluZyBkdWUgdG8gdGhlIG1haW4gd2luZG93IGJlaW5nIHNjcm9sbGVkXG4gICAgICAgKi9cbiAgICAgIF91cGRhdGVfZ2VvbSA9IGZ1bmN0aW9uKGlzX3dpbl9zY3JvbGwpIHtcbiAgICAgICAgdmFyIGcsIGlkLCBpZnIsIG1zZ09iaiwgcGFyYW1zLCBwb3NJRDtcbiAgICAgICAgcG9zSUQgPSB2b2lkIDA7XG4gICAgICAgIHBhcmFtcyA9IHZvaWQgMDtcbiAgICAgICAgbXNnT2JqID0gdm9pZCAwO1xuICAgICAgICBpZCA9IHZvaWQgMDtcbiAgICAgICAgaWZyID0gdm9pZCAwO1xuICAgICAgICBnID0gdm9pZCAwO1xuICAgICAgICBmb3IgKHBvc0lEIGluIHJlbmRlcmVkX2lmcnMpIHtcbiAgICAgICAgICBpZiAoaXNfd2luX3Njcm9sbCAmJiAocG9zSUQgaW4gc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgICAgaWQgPSBwYXJhbXMgJiYgcGFyYW1zLmRlc3Q7XG4gICAgICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICAgICAgaWYgKGlmciAmJiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGcgPSBfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKTtcbiAgICAgICAgICAgIG1zZ09iaiA9IFBhcmFtSGFzaCgpO1xuICAgICAgICAgICAgbXNnT2JqLnBvcyA9IHBvc0lEO1xuICAgICAgICAgICAgbXNnT2JqLmNtZCA9IE5PVElGWV9HRU9NX1VQREFURTtcbiAgICAgICAgICAgIG1zZ09iai5nZW9tID0gX2VzKGcpO1xuICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBOT1RJRllfR0VPTV9VUERBVEUsIGcpO1xuICAgICAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBVcGRhdGUgYWxsIFNhZmVGcmFtZXMgd2l0aCB1cGRhdGVkIGdlb21ldHJpYyBpbmZvcm1hdGlvbiBkdWUgdG8gYSB3aW5kb3cgcmVzaXplXG4gICAgICBldmVudC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3VwZGF0ZV9nZW9tX3dpbl9yZXNpemVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX3VwZGF0ZV9nZW9tX3dpbl9yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3VwZGF0ZV9nZW9tKCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVXBkYXRlIGFsbCBTYWZlRnJhbWVzIHdpdGggdXBkYXRlZCBnZW9tZXRyaWMgaW5mb3JtYXRpb24gZHVlIHRvIGEgd2luZG93IHNjcm9sbCBldmVudFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fdXBkYXRlX2dlb21fd2luX3Njcm9sbFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBfdXBkYXRlX2dlb21fd2luX3Njcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdXBkYXRlX2dlb20odHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVXBkYXRlIGEgU2FmZUZyYW1lIHRoYXQgaGFzIG5ldyBnZW9tZXRyaWMgaW5mb3JtYXRpb24gZHVlIHRvIGl0cyBwYXJlbnQgSFRNTCBlbGVtZW50XG4gICAgICBzY3JvbGxpbmcuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfbm9kZV9zY3JvbGxcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV9ub2RlX3Njcm9sbCA9IGZ1bmN0aW9uKGV2dCwgcG9zSUQsIG5vZGUpIHtcbiAgICAgICAgdmFyIGcsIHNjcl9oYW5kbGU7XG4gICAgICAgIHNjcl9oYW5kbGUgPSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICAgIGcgPSB2b2lkIDA7XG4gICAgICAgIGlmIChzY3JfaGFuZGxlKSB7XG4gICAgICAgICAgaWYgKHNjcl9oYW5kbGUudElEKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgICAgICAgZGVsZXRlIHNjcl9oYW5kbGUudElEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JfaGFuZGxlLnRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaWQsIGlmciwgbXNnT2JqLCBwYXJhbXM7XG4gICAgICAgICAgICBwYXJhbXMgPSByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgICAgIGlkID0gcGFyYW1zICYmIHBhcmFtcy5kZXN0O1xuICAgICAgICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICAgICAgICBnID0gdm9pZCAwO1xuICAgICAgICAgICAgbXNnT2JqID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGlmciAmJiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgZyA9IF9idWlsZF9nZW9tKHBvc0lELCBpZnIsIHRydWUpO1xuICAgICAgICAgICAgICBtc2dPYmogPSBQYXJhbUhhc2goKTtcbiAgICAgICAgICAgICAgbXNnT2JqLnBvcyA9IHBvc0lEO1xuICAgICAgICAgICAgICBtc2dPYmouY21kID0gTk9USUZZX0dFT01fVVBEQVRFO1xuICAgICAgICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhnKTtcbiAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBOT1RJRllfR0VPTV9VUERBVEUsIGcpO1xuICAgICAgICAgICAgICBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgc2NyX2hhbmRsZS50SUQ7XG4gICAgICAgICAgfSwgR0VPTV9VUERBVEVfSU5UUlZBTCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIHdpbmRvdyBvbnNjcm9sbCBldmVudCwgZXZlbnR1YWxseSBsZWFkaW5nIHRvIGEgZ2VvbWV0cmljIHVwZGF0ZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1faGFuZGxlX3dpbl9nZW9tX3Njcm9sbFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IGV2ZW50IG9iamVjdFxuICAgICAgICovXG4gICAgICBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfc2V0X2dlb21fdXBkYXRlX3RpbWVyKDEpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSB0aGUgd2luZG93IG9ucmVzaXplIGV2ZW50LCBldmVudHVhbGx5IGxlYWRpbmcgdG8gYSBnZW9tZXRyaWMgdXBkYXRlXG4gICAgICBvbmNlIHRoZSB3aW5kb3cgZXZlbnRzIGFyZSBzbG93ZWQgZG93blxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1faGFuZGxlX3dpbl9nZW9tX3Jlc2l6ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IGV2ZW50IG9iamVjdFxuICAgICAgICovXG4gICAgICBfaGFuZGxlX3dpbl9nZW9tX3Jlc2l6ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfc2V0X2dlb21fdXBkYXRlX3RpbWVyKCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVXBkYXRlIGFsbCBTYWZlRnJhbWVzIHdpdGggdXBkYXRlZCBmb2N1cyBpbmZvcm1hdGlvblxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fdXBkYXRlX2ZvY3VzXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IGluX2ZvY3VzIFRydWUgd2hlbiB0aGUgd2luZG93IGhhcyBnYWluZWQgZm9jdXNcbiAgICAgICAqL1xuICAgICAgX3VwZGF0ZV9mb2N1cyA9IGZ1bmN0aW9uKGluX2ZvY3VzKSB7XG4gICAgICAgIHZhciBkYXRhLCBpZCwgaWZyLCBtc2dPYmosIHBhcmFtcywgcG9zSUQ7XG4gICAgICAgIHBvc0lEID0gdm9pZCAwO1xuICAgICAgICBwYXJhbXMgPSB2b2lkIDA7XG4gICAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICAgIGlmciA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChwb3NJRCBpbiByZW5kZXJlZF9pZnJzKSB7XG4gICAgICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgICAgaWQgPSBwYXJhbXMgJiYgcGFyYW1zLmRlc3Q7XG4gICAgICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICAgICAgaWYgKGlmciAmJiBwYXJhbXMpIHtcbiAgICAgICAgICAgIG1zZ09iaiA9IFBhcmFtSGFzaCgpO1xuICAgICAgICAgICAgZGF0YSA9IFBhcmFtSGFzaCgpO1xuICAgICAgICAgICAgbXNnT2JqLnBvcyA9IHBvc0lEO1xuICAgICAgICAgICAgbXNnT2JqLmNtZCA9IGRhdGEuY21kID0gTk9USUZZX0ZPQ1VTX0NIQU5HRTtcbiAgICAgICAgICAgIG1zZ09iai52YWx1ZSA9IGluX2ZvY3VzO1xuICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIHBvc0lELCBOT1RJRllfRk9DVVNfQ0hBTkdFLCBpbl9mb2N1cyk7XG4gICAgICAgICAgICBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9jbGVhcl9mb2N1c191cGRhdGVfdGltZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIHdpbmRvdyBmb2N1cyBldmVudCwgd2hpY2ggbm90aWZpZXMgYWRzIG9mIHRoZSBjaGFuZ2VcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV93aW5fZm9jdXMgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3NldF9mb2N1c191cGRhdGVfdGltZXIodHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIHRoZSB3aW5kb3cgYmx1ciBldmVudCwgd2hpY2ggbm90aWZpZXMgYWRzIG9mIHRoZSBjaGFuZ2VcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV93aW5fYmx1ciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfc2V0X2ZvY3VzX3VwZGF0ZV90aW1lcihmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIHRoZSB3aW5kb3cgdW5sb2FkIGV2ZW50LCBjbGVhcmluZyB1cCBvdXIgc3RhdGVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV91bmxvYWRcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBldmVudCBvYmplY3RcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV91bmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIGUsIHByb3AsIHNjcl9oYW5kbGU7XG4gICAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICAgIHNjcl9oYW5kbGUgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvbS5kZXRhY2god2luLCBTQ1JPTEwsIF9oYW5kbGVfd2luX2dlb21fc2Nyb2xsKTtcbiAgICAgICAgICBkb20uZGV0YWNoKHdpbiwgXCJyZXNpemVcIiwgX2hhbmRsZV93aW5fZ2VvbV9yZXNpemUpO1xuICAgICAgICAgIGRvbS5kZXRhY2god2luLCBcInVubG9hZFwiLCBfaGFuZGxlX3VubG9hZCk7XG4gICAgICAgICAgZG9tLmRldGFjaCh3aW4sIFwiZm9jdXNcIiwgX2hhbmRsZV93aW5fZm9jdXMpO1xuICAgICAgICAgIGRvbS5kZXRhY2god2luLCBcImJsdXJcIiwgX2hhbmRsZV93aW5fYmx1cik7XG4gICAgICAgICAgZm9yIChwcm9wIGluIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkKSB7XG4gICAgICAgICAgICBzY3JfaGFuZGxlID0gc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcHJvcF07XG4gICAgICAgICAgICBpZiAoc2NyX2hhbmRsZSkge1xuICAgICAgICAgICAgICBpZiAoc2NyX2hhbmRsZS50SUQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvbS5kZXRhY2goc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcHJvcF0sIFNDUk9MTCwgc2NyX2hhbmRsZVtPTlNDUk9MTF0pO1xuICAgICAgICAgICAgICBzY3JfaGFuZGxlW09OU0NST0xMXSA9IHNjcl9oYW5kbGUubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwcm9wXSA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdpbl9ldmVudHNfYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSB0aGUgd2luZG93IG1lc3NhZ2UgZXZlbnQsIHBhc3NlZCBmcm9tIHJhdyBldmVudCBoYW5kbGluZyBvZiB0aGUgbXNnaG9zdCBjb2RlLlxuICAgICAgUGFzcyB0aHJvdWdoIHRoZSBkYXRhIHRvIG91ciBmb3JtYXQgaGFuZGxpbmcgZnVuY3Rpb25zIGZvciBleHBhbmQsIGV0Yy5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV9tc2dfZXZ0XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGEgdGhlIG1lc3NhZ2UgdG8gYmUgaGFuZGxlZFxuICAgICAgQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBtZXNzYWdlIHdhcyBoYW5kbGVkXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfbXNnX2V2dCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGNhblJlYWQsIGNhbldyaXRlLCBpbmZvLCBtc2dPYmosIHJldDtcbiAgICAgICAgbXNnT2JqID0gdm9pZCAwO1xuICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgaW5mbyA9IHZvaWQgMDtcbiAgICAgICAgbXNnT2JqID0gUGFyYW1IYXNoKGRhdGEsIG51bGwsIG51bGwsIHRydWUsIHRydWUpO1xuICAgICAgICBpZiAobXNnT2JqICYmIG1zZ09iai5wb3MpIHtcbiAgICAgICAgICBpbmZvID0gcmVuZGVyZWRfaWZyc1ttc2dPYmoucG9zXTtcbiAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgcmV0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKG1zZ09iai5jbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXhwLXB1c2hcIjpcbiAgICAgICAgICAgICAgICAgIF9leHBhbmRfc2FmZWZyYW1lKG1zZ09iaiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXhwLW92clwiOlxuICAgICAgICAgICAgICAgICAgX2V4cGFuZF9zYWZlZnJhbWUobXNnT2JqKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb2xsYXBzZVwiOlxuICAgICAgICAgICAgICAgICAgX2NvbGxhcHNlX3NhZmVmcmFtZShtc2dPYmopO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1zZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJjbGlja2VkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZpZXdlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1ZXN0ZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidW52aWV3ZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVsb2FkXCI6XG4gICAgICAgICAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgbXNnT2JqLnBvcywgbXNnT2JqLmNtZCwgbXNnT2JqLm1zZyk7XG4gICAgICAgICAgICAgICAgICBfc2VuZF9nZW5lcmljX3Jlc3BvbnNlKG1zZ09iai5wb3MsIG1zZ09iai5jbWQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvYWRlZFwiOlxuICAgICAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFwib25BZExvYWRcIiwgbXNnT2JqLnBvcywgbXNnT2JqKTtcbiAgICAgICAgICAgICAgICAgIF9zZW5kX2dlbmVyaWNfcmVzcG9uc2UobXNnT2JqLnBvcywgbXNnT2JqLmNtZCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIEVSUk9SX0NPTU1BTkQ6XG4gICAgICAgICAgICAgICAgICBfcmVjb3JkX2Vycm9yKG1zZ09iaik7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIE5PVElGWV9HRU9NX1VQREFURTpcbiAgICAgICAgICAgICAgICAgIHNmLmxpYi5sb2dnZXIubG9nKFwiR2VvbSB1cGRhdGUgY29tcGxldGU6IFwiICsgbXNnT2JqLnBvcyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVhZC1jb29raWVcIjpcbiAgICAgICAgICAgICAgICAgIGNhblJlYWQgPSBpbmZvLmNvbmYgJiYgaW5mby5jb25mLnN1cHBvcnRzICYmIGluZm8uY29uZi5zdXBwb3J0c1ttc2dPYmouY21kXSAmJiBpbmZvLmNvbmYuc3VwcG9ydHNbbXNnT2JqLmNtZF0gIT09IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhblJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlYWRfY29va2llKG1zZ09iaik7XG4gICAgICAgICAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhcIm9uQ29va2llUmVhZFwiLCBtc2dPYmoucG9zLCBtc2dPYmouY29va2llKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwid3JpdGUtY29va2llXCI6XG4gICAgICAgICAgICAgICAgICBjYW5Xcml0ZSA9IGluZm8uY29uZiAmJiBpbmZvLmNvbmYuc3VwcG9ydHMgJiYgaW5mby5jb25mLnN1cHBvcnRzW21zZ09iai5jbWRdICYmIGluZm8uY29uZi5zdXBwb3J0c1ttc2dPYmouY21kXSAhPT0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FuV3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3dyaXRlX2Nvb2tpZShtc2dPYmopO1xuICAgICAgICAgICAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soXCJvbkNvb2tpZVdyaXRlXCIsIG1zZ09iai5wb3MsIG1zZ09iai5jb29raWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDaGVjayB3aGV0aGVyIG9yIG5vdCB0aGVyZSBhcmUgYW55IFNhZmVGcmFtZXMgYmVpbmcgcmVuZGVyZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2hhc19wZW5kaW5nX3JlbmRlcnNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2hhc19wZW5kaW5nX3JlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsbF9yZW5kZXJzX2RvbmUsIHBvc19pZDtcbiAgICAgICAgYWxsX3JlbmRlcnNfZG9uZSA9IHRydWU7XG4gICAgICAgIHBvc19pZCA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChwb3NfaWQgaW4gcGVuZGluZ19pZnJzKSB7XG4gICAgICAgICAgYWxsX3JlbmRlcnNfZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxfcmVuZGVyc19kb25lO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFNlbmQgYSByZXNwb25zZSBiYWNrIGRvd24gdG8gdGhlIFNhZmVGcmFtZSBhZnRlciBhIG1lc3NhZ2Ugd2FzIGhhbmRsZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3NlbmRfcmVzcG9uc2VcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7JHNmLmxpYi5sYW5nLlBhcmFtSGFzaH0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIG9iamVjdCBzdG9yZWQgZm9yIGEgcmVuZGVyZWQgU2FmZUZyYW1lIGhvbGRpbmcgc3RhdGUgaW5mb3JtYXRpb25cbiAgICAgIEBwYXJhbSB7JHNmLmxpYi5sYW5nLlBhcmFtSGFzaH0gbXNnT2JqIFRoZSBtZXNzYWdlIHRvIHNlbmQgYmFjayBkb3duIGludG8gdGhlIFNhZmVGcmFtZVxuICAgICAgICovXG4gICAgICBfc2VuZF9yZXNwb25zZSA9IGZ1bmN0aW9uKHBhcmFtcywgbXNnT2JqKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudF9zdGF0dXMgPSBcInNlbmRpbmctbXNnLWRvd24tXCIgKyBtc2dPYmouY21kO1xuICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgaWQgPSBwYXJhbXMgJiYgcGFyYW1zLmRlc3Q7XG4gICAgICAgICAgaWYgKGlkICYmIG1zZ09iaikge1xuICAgICAgICAgICAgc2VuZF9tc2dfdG9fY2hpbGRfaWZyYW1lKGlkLCBtc2dPYmoudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJcIjtcbiAgICAgICAgICBtc2dPYmogPSBpZCA9IHBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0pLCBYQ09NX1JFU1BfREVMQVkpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSB0aGUgb25sb2FkIGV2ZW50IGZyb20gdGhlIElGUkFNRSB0YWcgY3JlYXRlZCBmb3IgYSBTYWZlRnJhbWUuXG4gICAgICBOb3RlIHRoYXQgYi9jIHdlIHVzZWQgb3VyIG93biBsaWJyYXJ5IHRvIGNyZWF0ZSB0aGUgSUZSQU1FICgkc2YubGliLmRvbS5pZnJhbWVzKSxcbiAgICAgIHRoZSBcInRoaXNcIiBrZXl3b3JkIHdpbGwgbm93IHByb3Blcmx5IHBvaW50IHRvIHRoZSBJRlJBTUUgaW4gcXVlc3Rpb24uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfZnJhbWVfbG9hZFxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBfaGFuZGxlX2ZyYW1lX2xvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsbF9yZW5kZXJzX2RvbmUsIGVsLCBwb3NfaWQ7XG4gICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgcG9zX2lkID0gZG9tLmF0dHIoZWwsIFwiX3Bvc19pZFwiKTtcbiAgICAgICAgYWxsX3JlbmRlcnNfZG9uZSA9IHRydWU7XG4gICAgICAgIGlmIChwZW5kaW5nX2lmcnNbcG9zX2lkXSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nX2lmcnNbcG9zX2lkXSk7XG4gICAgICAgICAgZGVsZXRlIHBlbmRpbmdfaWZyc1twb3NfaWRdO1xuICAgICAgICAgIGNvbXBsZXRlX2lmcnNbcG9zX2lkXSA9IHBvc19pZDtcbiAgICAgICAgICBkb20uYXR0cihlbCwgXCJfcG9zX2lkXCIsIG51bGwpO1xuICAgICAgICAgIGRvbS5hdHRyKGVsLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgICAgICAgZWxbU1RdLnZpc2liaWxpdHkgPSBcImluaGVyaXRcIjtcbiAgICAgICAgICBlbFtTVF0uZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soXCJvbkVuZFBvc1JlbmRlclwiLCBwb3NfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2hhc19wZW5kaW5nX3JlbmRlcnMoKSkge1xuICAgICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEJ1aWxkIGFuIGV4dHJhIElGUkFNRSB0byBwdXQgYmVoaW5kIGFueSBpZnJhbWUgdGhhdCBpcyBleHBhbmRpbmcsIHRvIHByb3RlY3RcbiAgICAgIGFnYWluc3QgcGFpbnRpbmcgaXNzdWVzIGluIElFIHdpdGggd2luZG93J2QgbW9kZSBmbGFzaC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3NoaW1fZnJhbWVcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX3NoaW1fZnJhbWUgPSBmdW5jdGlvbihpZCwgc2hvd0l0LCB3LCBoLCB6KSB7XG4gICAgICAgIHZhciBpZnIsIHNobUZybSwgc2htSUQ7XG4gICAgICAgIGlmICghaXNJRSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZnIgPSBfZWx0KGlkKTtcbiAgICAgICAgc2htSUQgPSBcInNobV9cIiArIGlkO1xuICAgICAgICBzaG1Gcm0gPSBfZWx0KHNobUlEKTtcbiAgICAgICAgaWYgKHNob3dJdCkge1xuICAgICAgICAgIGlmIChzaG1Gcm0pIHtcbiAgICAgICAgICAgIHNobUZybVtTVF0udmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaG1Gcm0gPSBpZnJhbWVzLmNsb25lKGlmciwge1xuICAgICAgICAgICAgaWQ6IHNobUlELFxuICAgICAgICAgICAgc3JjOiBcIlwiLFxuICAgICAgICAgICAgbmFtZTogc2htSURcbiAgICAgICAgICB9LCBbV0lEVEgsIFwiOlwiLCB3LCBQWCwgXCI7cG9zaXRpb246YWJzb2x1dGU7XCIsIEhFSUdIVCwgXCI6XCIsIGgsIFBYLCBcIjt6LWluZGV4OlwiLCB6IC0gMSwgXCI7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShvcGFjaXR5PTApXCJdKTtcbiAgICAgICAgICBkb20uYXBwZW5kKF9wYXIoaWZyKSwgc2htRnJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXNob3dJdCAmJiBzaG1Gcm0pIHtcbiAgICAgICAgICAgIHNobUZybVtTVF0udmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQnVpbGQgYSBnZW9tZXRyeSBpbmZvIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyIFNhZmVGcmFtZSBwb3NpdGlvbiwgYW5kIGFsc29cbiAgICAgIG1heSBhdHRhY2ggYW4gb25zY3JvbGwgZXZlbnQgbGlzdGVuZXIgdG8gYSBwYXJlbnQgSFRNTCBlbGVtZW50IGlmIHNhaWQgcGFyZW50IGVsZW1lbnRcbiAgICAgIGlzIHNjcm9sbGFibGUgYnV0IG5vdCB0aGUgcm9vdCBkb2N1bWVudCBub2RlIC8gYm9keVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fYnVpbGRfZ2VvbVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHJldHVybiB7T2JqZWN0fSBXaXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnZW9tZXRyeSBhcm91bmQgYSBnaXZlbiBTYWZlRnJhbWVcbiAgICAgICAqL1xuICAgICAgX2J1aWxkX2dlb20gPSBmdW5jdGlvbihwb3NJRCwgZGVzdCwgZG9udF9hdHRhY2hfc2Nyb2xsX2V2dCkge1xuICAgICAgICB2YXIgZGV0YWlscywgZSwgZXgsIGluZm8sIG5ld19yZWZfbm9kZSwgbm9kZSwgcywgc2NyX2hhbmRsZTtcbiAgICAgICAgYm91bmRzID0gdm9pZCAwO1xuICAgICAgICBpbmZvID0gUGFyYW1IYXNoKCk7XG4gICAgICAgIGRldGFpbHMgPSB7fTtcbiAgICAgICAgc2NyX2hhbmRsZSA9IHZvaWQgMDtcbiAgICAgICAgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgbmV3X3JlZl9ub2RlID0gdm9pZCAwO1xuICAgICAgICBleCA9IHZvaWQgMDtcbiAgICAgICAgcyA9IHZvaWQgMDtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBib3VuZHMgPSBkb20uYm91bmRzKGRlc3QsIGRldGFpbHMsIHRydWUpO1xuICAgICAgICAgIGlmICghZG9udF9hdHRhY2hfc2Nyb2xsX2V2dCAmJiAhZGV0YWlscy5pc1Jvb3QgJiYgZGV0YWlscy5jYW5TY3JvbGwpIHtcbiAgICAgICAgICAgIGV4ID0gZGV0YWlscy5leHBSZWN0O1xuICAgICAgICAgICAgaWYgKGV4LnhzIHx8IGV4LnlzKSB7XG4gICAgICAgICAgICAgIHNjcl9oYW5kbGUgPSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICAgICAgICAgIG5ld19yZWZfbm9kZSA9IGRldGFpbHMucmVmTm9kZTtcbiAgICAgICAgICAgICAgaWYgKHNjcl9oYW5kbGUgJiYgc2NyX2hhbmRsZS5ub2RlICE9PSBuZXdfcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NyX2hhbmRsZS50SUQpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JfaGFuZGxlLnRJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbS5kZXRhY2gobm9kZSwgU0NST0xMLCBzY3JfaGFuZGxlW09OU0NST0xMXSk7XG4gICAgICAgICAgICAgICAgc2NyX2hhbmRsZS5ub2RlID0gc2NyX2hhbmRsZVtPTlNDUk9MTF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXSkge1xuICAgICAgICAgICAgICAgIHNjcl9oYW5kbGUgPSB7fTtcbiAgICAgICAgICAgICAgICBzY3JfaGFuZGxlLm5vZGUgPSBuZXdfcmVmX25vZGU7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIEBpZ25vcmVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzY3JfaGFuZGxlW09OU0NST0xMXSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgX2hhbmRsZV9ub2RlX3Njcm9sbChldnQsIHBvc0lEKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXSA9IHNjcl9oYW5kbGU7XG4gICAgICAgICAgICAgICAgZG9tLmF0dGFjaChuZXdfcmVmX25vZGUsIFNDUk9MTCwgc2NyX2hhbmRsZVtPTlNDUk9MTF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGluZm8ud2luID0gUGFyYW1IYXNoKGRvbS53aW5SZWN0KCkpO1xuICAgICAgICAgICAgaW5mby5wYXIgPSBQYXJhbUhhc2goZGV0YWlscy5yZWZSZWN0KTtcbiAgICAgICAgICAgIGV4ID0gUGFyYW1IYXNoKGRldGFpbHMuZXhwUmVjdCk7XG4gICAgICAgICAgICBzID0gUGFyYW1IYXNoKGRldGFpbHMucmVjdCk7XG4gICAgICAgICAgICBzLml2ID0gZXguaXY7XG4gICAgICAgICAgICBzLnhpdiA9IGV4LnhpdjtcbiAgICAgICAgICAgIHMueWl2ID0gZXgueWl2O1xuICAgICAgICAgICAgZGVsZXRlIGV4Lml2O1xuICAgICAgICAgICAgZGVsZXRlIGV4LnhpdjtcbiAgICAgICAgICAgIGRlbGV0ZSBleC55aXY7XG4gICAgICAgICAgICBpbmZvLmV4cCA9IGV4O1xuICAgICAgICAgICAgaW5mby5zZWxmID0gcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgRXhwYW5kcyBhIGdpdmVuIFNhZmVGcmFtZSBiYXNlZCBvbiBhIGNvbW1hbmQgZnJvbSB0aGUgM3JkIHBhcnR5IGNvbnRlbnRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2V4cGFuZF9zYWZlZnJhbWVcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7JHNmLmxpYi5sYW5nLlBhcmFtSGFzaH0gbXNnT2JqIERldGFpbHMgYWJvdXQgaG93IHRvIGRvIHRoZSBleHBhbnNpb25cbiAgICAgIFxuICAgICAgVE9ETywgaGFuZGxlIG9tbmktZGlyZWN0aW9uYWwgYW5kIHB1c2hcbiAgICAgICAqL1xuICAgICAgX2V4cGFuZF9zYWZlZnJhbWUgPSBmdW5jdGlvbihtc2dPYmosIHB1c2gpIHtcbiAgICAgICAgdmFyIGIsIGRlbHRhLCBkeCwgZHksIGV4cCwgaWQsIGlmciwgaWZyU3QsIGwsIG5IdCwgbldkLCBvckh0LCBvcldkLCBwYXIsIHBhclN0LCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRCwgciwgc2NyX2hhbmRsZSwgdCwgeG4sIHluLCB6O1xuICAgICAgICB4biA9IGZhbHNlO1xuICAgICAgICB5biA9IGZhbHNlO1xuICAgICAgICBwb3NJRCA9IG1zZ09iaiAmJiBtc2dPYmoucG9zO1xuICAgICAgICBwYXJhbXMgPSB2b2lkIDA7XG4gICAgICAgIHBhcmFtc19jb25mID0gdm9pZCAwO1xuICAgICAgICBpZnIgPSB2b2lkIDA7XG4gICAgICAgIHBhciA9IHZvaWQgMDtcbiAgICAgICAgaWZyU3QgPSB2b2lkIDA7XG4gICAgICAgIHBhclN0ID0gdm9pZCAwO1xuICAgICAgICBvcldkID0gdm9pZCAwO1xuICAgICAgICBvckh0ID0gdm9pZCAwO1xuICAgICAgICBkeCA9IHZvaWQgMDtcbiAgICAgICAgZHkgPSB2b2lkIDA7XG4gICAgICAgIG5XZCA9IHZvaWQgMDtcbiAgICAgICAgbkh0ID0gdm9pZCAwO1xuICAgICAgICBpZCA9IHZvaWQgMDtcbiAgICAgICAgdCA9IHZvaWQgMDtcbiAgICAgICAgbCA9IHZvaWQgMDtcbiAgICAgICAgciA9IHZvaWQgMDtcbiAgICAgICAgYiA9IHZvaWQgMDtcbiAgICAgICAgZXhwID0gdm9pZCAwO1xuICAgICAgICB6ID0gdm9pZCAwO1xuICAgICAgICBkZWx0YSA9IHZvaWQgMDtcbiAgICAgICAgc2NyX2hhbmRsZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFwb3NJRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgcGFyYW1zX2NvbmYgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbmY7XG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXNfY29uZikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZCA9IHBhcmFtcy5kZXN0O1xuICAgICAgICBpZnIgPSBfZWx0KGlkKTtcbiAgICAgICAgcGFyID0gX2VsdChQT1NfUkVMX0JPWF9JRF9QUkVGSVggKyBcIl9cIiArIHBvc0lEKTtcbiAgICAgICAgaWYgKCFpZnIgfHwgIXBhcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZnJTdCA9IGlmcltTVF07XG4gICAgICAgIHBhclN0ID0gcGFyW1NUXTtcbiAgICAgICAgaWYgKCFpZnJTdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzY3JfaGFuZGxlID0gc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcG9zSURdO1xuICAgICAgICBpZiAoc2NyX2hhbmRsZSAmJiBzY3JfaGFuZGxlLnRJRCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChzY3JfaGFuZGxlLnRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyKCk7XG4gICAgICAgIGV4cCA9IG1zZ09iai5leHBfb2JqO1xuICAgICAgICBvcldkID0gcGFyYW1zX2NvbmYudztcbiAgICAgICAgb3JIdCA9IHBhcmFtc19jb25mLmg7XG4gICAgICAgIGlmICghZXhwKSB7XG4gICAgICAgICAgZHggPSBwYXJhbXMuZHggPSBfY251bShtc2dPYmouZHgpO1xuICAgICAgICAgIGR5ID0gcGFyYW1zLmR5ID0gX2NudW0obXNnT2JqLmR5KTtcbiAgICAgICAgICB4biA9IGR4IDwgMDtcbiAgICAgICAgICB5biA9IGR5IDwgMDtcbiAgICAgICAgICBuV2QgPSAoeG4gPyBvcldkICsgKGR4ICogLTEpIDogb3JXZCArIGR4KTtcbiAgICAgICAgICBuSHQgPSAoeW4gPyBvckh0ICsgKGR5ICogLTEpIDogb3JIdCArIGR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gX2NudW0oZXhwLnQsIDAsIDApO1xuICAgICAgICAgIGwgPSBfY251bShleHAubCwgMCwgMCk7XG4gICAgICAgICAgciA9IF9jbnVtKGV4cC5yLCAwLCAwKTtcbiAgICAgICAgICBiID0gX2NudW0oZXhwLmIsIDAsIDApO1xuICAgICAgICAgIG5XZCA9IF9jbnVtKG9yV2QgKyBsICsgciwgMCwgMCk7XG4gICAgICAgICAgbkh0ID0gX2NudW0ob3JIdCArIHQgKyBiLCAwLCAwKTtcbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgZHkgPSB0ICogLTE7XG4gICAgICAgICAgICB5biA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICAgIGR4ID0gbCAqIC0xO1xuICAgICAgICAgICAgeG4gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuV2QgPD0gb3JXZCAmJiBuSHQgPD0gb3JIdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZpcmVfcHViX2NhbGxiYWNrKEJGX1BPU19NU0csIHBvc0lELCBFWFBBTkRfQ09NTUFORCwgZHgsIGR5KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZnJTdFtXSURUSF0gPSBuV2QgKyBQWDtcbiAgICAgICAgaWZyU3RbSEVJR0hUXSA9IG5IdCArIFBYO1xuICAgICAgICBpZiAoeG4pIHtcbiAgICAgICAgICBpZnJTdC5sZWZ0ID0gZHggKyBQWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeW4pIHtcbiAgICAgICAgICBpZnJTdC50b3AgPSBkeSArIFBYO1xuICAgICAgICB9XG4gICAgICAgIHogPSBfY251bShwYXJhbXMueiwgMCk7XG4gICAgICAgIGlmICgheikge1xuICAgICAgICAgIHogPSBERUZBVUxUX1pJTkRFWDtcbiAgICAgICAgfVxuICAgICAgICBpZnJTdC56SW5kZXggPSB6O1xuICAgICAgICBfc2hpbV9mcmFtZShpZCwgdHJ1ZSwgbldkLCBuSHQsIHogLSAxKTtcbiAgICAgICAgaWYgKHB1c2gpIHtcbiAgICAgICAgICBwYXJTdFtXSURUSF0gPSBuV2QgKyBQWDtcbiAgICAgICAgICBwYXJTdFtIRUlHSFRdID0gbkh0ICsgUFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyU3RbV0lEVEhdID0gb3JXZCArIFBYO1xuICAgICAgICAgIHBhclN0W0hFSUdIVF0gPSBvckh0ICsgUFg7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgbXNnT2JqLmR4ID0gZHg7XG4gICAgICAgIG1zZ09iai5keSA9IGR5O1xuICAgICAgICBtc2dPYmoudyA9IG5XZDtcbiAgICAgICAgbXNnT2JqLmggPSBuSHQ7XG4gICAgICAgIG1zZ09iai5jbWQgPSBcImV4cGFuZFwiO1xuICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKSk7XG4gICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBwb3NJRCwgRVhQQU5EX0NPTU1BTkQsIGR4LCBkeSk7XG4gICAgICAgIF9zZW5kX3Jlc3BvbnNlKHBhcmFtcywgbXNnT2JqKTtcbiAgICAgICAgaWZyU3QgPSBwYXIgPSBpZnIgPSBwYXJhbXMgPSBtc2dPYmogPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENvbGxhcHNlIGEgU2FmZUZyYW1lIGFmdGVyIGl0IGhhcyBiZWVuIGV4cGFuZGVkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9jb2xsYXBzZV9zYWZlZnJhbWVcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7JHNmLmxpYi5sYW5nLlBhcmFtSGFzaH0gbXNnT2JqIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBtZXNzYWdlIHNlbmQgZnJvbSB0aGUgU2FmZUZyYW1lIHRvIGNvbGxhcHNlXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IFtpc091dHNpZGVdIFdoZXRoZXIgb3Igbm90IHRoZSBjb2xsYXBzZSBjb21tYW5kIGNhbWUgZnJvbSB0aGUgcHVibGlzaGVyXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IFtub01zZ2luZ10gV2hldGhlciBvciBub3QgdG8gc2VuZCBhIG1lc3NhZ2Ugb2YgcmVzcG9uc2UgYmFjayB0byB0aGUgU2FmZUZyYW1lIGJlaW5nIGNvbGxhcHNlZFxuICAgICAgICovXG4gICAgICBfY29sbGFwc2Vfc2FmZWZyYW1lID0gZnVuY3Rpb24obXNnT2JqLCBpc091dHNpZGUsIG5vTXNnaW5nKSB7XG4gICAgICAgIHZhciBpZCwgaWZyLCBpZnJTdCwgcGFyLCBwYXJTdCwgcGFyYW1zLCBwYXJhbXNfY29uZiwgcG9zSUQsIHNjcl9oYW5kbGU7XG4gICAgICAgIHBvc0lEID0gbXNnT2JqICYmIG1zZ09iai5wb3M7XG4gICAgICAgIHBhcmFtcyA9IHBvc0lEICYmIHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgICBwYXJhbXNfY29uZiA9IHBhcmFtcyAmJiBwYXJhbXMuY29uZjtcbiAgICAgICAgaWQgPSBwYXJhbXNfY29uZiAmJiBwYXJhbXNfY29uZi5kZXN0O1xuICAgICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgICAgcGFyID0gaWZyICYmIF9lbHQoUE9TX1JFTF9CT1hfSURfUFJFRklYICsgXCJfXCIgKyBwb3NJRCk7XG4gICAgICAgIGlmclN0ID0gaWZyICYmIGlmcltTVF07XG4gICAgICAgIHBhclN0ID0gcGFyICYmIHBhcltTVF07XG4gICAgICAgIHNjcl9oYW5kbGUgPSB2b2lkIDA7XG4gICAgICAgIGlmICghcG9zSUQgfHwgIXBhcmFtcyB8fCAhaWZyIHx8ICFwYXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NyX2hhbmRsZSA9IHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXTtcbiAgICAgICAgaWYgKHNjcl9oYW5kbGUgJiYgc2NyX2hhbmRsZS50SUQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgICB9XG4gICAgICAgIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lcigpO1xuICAgICAgICBpZiAoIW5vTXNnaW5nKSB7XG4gICAgICAgICAgaWYgKF9maXJlX3B1Yl9jYWxsYmFjayhCRl9QT1NfTVNHLCBwb3NJRCwgQ09MTEFQU0VfQ09NTUFORCwgMCwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWZyU3QubGVmdCA9IGlmclN0LnRvcCA9IFwiMHB4XCI7XG4gICAgICAgIHBhclN0W1dJRFRIXSA9IGlmclN0W1dJRFRIXSA9IHBhcmFtc19jb25mLncgKyBQWDtcbiAgICAgICAgcGFyU3RbSEVJR0hUXSA9IGlmclN0W0hFSUdIVF0gPSBwYXJhbXNfY29uZi5oICsgUFg7XG4gICAgICAgIGlmclN0LnpJbmRleCA9IHBhcmFtcy5keCA9IHBhcmFtcy5keSA9IDA7XG4gICAgICAgIF9zaGltX2ZyYW1lKGlkKTtcbiAgICAgICAgaWYgKCFub01zZ2luZykge1xuICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBwb3NJRCwgQ09MTEFQU0VfQ09NTUFORCwgMCwgMCk7XG4gICAgICAgICAgbXNnT2JqLmNtZCA9IChpc091dHNpZGUgPyBcImNvbGxhcHNlZFwiIDogXCJjb2xsYXBzZVwiKTtcbiAgICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKSk7XG4gICAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICB9XG4gICAgICAgIGlmciA9IGlmclN0ID0gcGFyID0gcGFyU3QgPSBwYXJhbXMgPSBtc2dPYmogPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlY29yZHMgYSByZXBvcnRlZCBlcnJvciBtZXNzYWdlIHRvICRzZi5pbmZvLmVycm9ycyBhbmQgZmlyZXMgYW55IGxpc3RlbmVyc1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fcmVjb3JkX2Vycm9yXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBUaGUgZGV0YWlscyBhYm91dCB0aGUgbWVzc2FnZSBzZW5kIGZyb20gdGhlIFNhZmVGcmFtZSBoYXZpbmcgYW4gZXJyb3JcbiAgICAgICAqL1xuICAgICAgX3JlY29yZF9lcnJvciA9IGZ1bmN0aW9uKG1zZ09iaikge1xuICAgICAgICB2YXIgaWQsIGlmciwgaWZyU3QsIHBhciwgcGFyU3QsIHBhcmFtcywgcGFyYW1zX2NvbmYsIHBvc0lELCBzY3JfaGFuZGxlO1xuICAgICAgICBwb3NJRCA9IG1zZ09iaiAmJiBtc2dPYmoucG9zO1xuICAgICAgICBwYXJhbXMgPSBwb3NJRCAmJiByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgcGFyYW1zX2NvbmYgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbmY7XG4gICAgICAgIGlkID0gcGFyYW1zX2NvbmYgJiYgcGFyYW1zX2NvbmYuZGVzdDtcbiAgICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICAgIHBhciA9IGlmciAmJiBfZWx0KFBPU19SRUxfQk9YX0lEX1BSRUZJWCArIFwiX1wiICsgcG9zSUQpO1xuICAgICAgICBpZnJTdCA9IGlmciAmJiBpZnJbU1RdO1xuICAgICAgICBwYXJTdCA9IHBhciAmJiBwYXJbU1RdO1xuICAgICAgICBzY3JfaGFuZGxlID0gdm9pZCAwO1xuICAgICAgICBpZiAoc2YgJiYgc2YuaW5mbyAmJiBzZi5pbmZvLmVycnMpIHtcbiAgICAgICAgICBzZi5pbmZvLmVycnMucHVzaChtc2dPYmopO1xuICAgICAgICB9XG4gICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBwb3NJRCwgRVJST1JfQ09NTUFORCwgbXNnT2JqKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50IGNvb2tpZXMgYXMgYSBoYXNoXG4gICAgICBAbmFtZSAkc2YubGliLl9jb29raWVIYXNoXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBfY29va2llSGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYywgY29va2llcywgY29va3MsIGksIGtleTtcbiAgICAgICAgY29va3MgPSB2b2lkIDA7XG4gICAgICAgIGtleSA9IHZvaWQgMDtcbiAgICAgICAgaSA9IHZvaWQgMDtcbiAgICAgICAgY29va2llcyA9IHt9O1xuICAgICAgICBjID0gdm9pZCAwO1xuICAgICAgICBjb29rcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjsgXCIpO1xuICAgICAgICBpID0gY29va3MubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgIGMgPSBjb29rc1tpXS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgY29va2llc1tjWzBdXSA9IGNbMV07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWVzO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlYWQgYSBob3N0IGRvbWFpbiBjb29raWVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3JlYWRfY29va2llXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBUaGUgZGV0YWlscyBhYm91dCB0aGUgbWVzc2FnZSBzZW5kIGZyb20gdGhlIFNhZmVGcmFtZVxuICAgICAgQHBhcmFtIHtCb29sZWFufSBbaXNPdXRzaWRlXSBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZC1jb29raWUgY29tbWFuZCBjYW1lIGZyb20gdGhlIHB1Ymxpc2hlclxuICAgICAgICovXG4gICAgICBfcmVhZF9jb29raWUgPSBmdW5jdGlvbihtc2dPYmosIGlzT3V0c2lkZSkge1xuICAgICAgICB2YXIgY2FuUmVhZCwgY29tbWFuZCwgY29va2llcywgaWQsIGlmciwga2V5LCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRDtcbiAgICAgICAgcG9zSUQgPSBtc2dPYmogJiYgbXNnT2JqLnBvcztcbiAgICAgICAgcGFyYW1zID0gcG9zSUQgJiYgcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgICBpZCA9IHBhcmFtc19jb25mICYmIHBhcmFtc19jb25mLmRlc3Q7XG4gICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICBrZXkgPSB2b2lkIDA7XG4gICAgICAgIGNvb2tpZXMgPSB2b2lkIDA7XG4gICAgICAgIGNvbW1hbmQgPSBcInJlYWQtY29va2llXCI7XG4gICAgICAgIGNhblJlYWQgPSBwYXJhbXNfY29uZi5zdXBwb3J0cyAmJiBwYXJhbXNfY29uZi5zdXBwb3J0c1tjb21tYW5kXSAmJiBwYXJhbXNfY29uZi5zdXBwb3J0c1tjb21tYW5kXSAhPT0gXCIwXCI7XG4gICAgICAgIGlmICghY2FuUmVhZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBvc0lEIHx8ICFwYXJhbXMgfHwgIWlmcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBtc2dPYmouY29va2llO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb29raWVzID0gX2Nvb2tpZUhhc2goKTtcbiAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIGNvbW1hbmQsIHBvc0lELCAwLCAwKTtcbiAgICAgICAgbXNnT2JqLmNtZCA9IGNvbW1hbmQ7XG4gICAgICAgIG1zZ09iai5nZW9tID0gX2VzKF9idWlsZF9nZW9tKHBvc0lELCBpZnIsIHRydWUpKTtcbiAgICAgICAgbXNnT2JqLnZhbHVlID0gY29va2llc1trZXldO1xuICAgICAgICBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICAgIGlmciA9IHBhcmFtcyA9IG1zZ09iaiA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgV3JpdGUgYSBob3N0IGRvbWFpbiBjb29raWVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3dyaXRlX2Nvb2tpZVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHskc2YubGliLmxhbmcuUGFyYW1IYXNofSBtc2dPYmogVGhlIGRldGFpbHMgYWJvdXQgdGhlIG1lc3NhZ2Ugc2VuZCBmcm9tIHRoZSBTYWZlRnJhbWVcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2lzT3V0c2lkZV0gV2hldGhlciBvciBub3QgdGhlIHdyaXRlLWNvb2tpZSBjb21tYW5kIGNhbWUgZnJvbSB0aGUgcHVibGlzaGVyXG4gICAgICAgKi9cbiAgICAgIF93cml0ZV9jb29raWUgPSBmdW5jdGlvbihtc2dPYmosIGlzT3V0c2lkZSkge1xuICAgICAgICB2YXIgY192YWx1ZSwgY2FuUmVhZCwgY29tbWFuZCwgY29va2llcywgZXhkYXRlLCBpZCwgaWZyLCBrZXksIG5ld0Nvb2tpZXMsIG5ld1ZhbHVlLCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRDtcbiAgICAgICAgcG9zSUQgPSBtc2dPYmogJiYgbXNnT2JqLnBvcztcbiAgICAgICAgcGFyYW1zID0gcG9zSUQgJiYgcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgICBpZCA9IHBhcmFtc19jb25mICYmIHBhcmFtc19jb25mLmRlc3Q7XG4gICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICBrZXkgPSB2b2lkIDA7XG4gICAgICAgIG5ld1ZhbHVlID0gdm9pZCAwO1xuICAgICAgICBjb29raWVzID0gdm9pZCAwO1xuICAgICAgICBuZXdDb29raWVzID0gdm9pZCAwO1xuICAgICAgICBjb21tYW5kID0gXCJ3cml0ZS1jb29raWVcIjtcbiAgICAgICAgY2FuUmVhZCA9IHBhcmFtc19jb25mLnN1cHBvcnRzICYmIHBhcmFtc19jb25mLnN1cHBvcnRzW2NvbW1hbmRdICYmIHBhcmFtc19jb25mLnN1cHBvcnRzW2NvbW1hbmRdICE9PSBcIjBcIjtcbiAgICAgICAgaWYgKCFjYW5SZWFkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcG9zSUQgfHwgIXBhcmFtcyB8fCAhaWZyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IG1zZ09iai5jb29raWU7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld1ZhbHVlID0gZXNjYXBlKG1zZ09iai52YWx1ZSk7XG4gICAgICAgIGlmIChtc2dPYmouZXhwaXJlcykge1xuICAgICAgICAgIGV4ZGF0ZSA9IG5ldyBEYXRlKF9jbnVtKG1zZ09iai5leHBpcmVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBleGRhdGUuc2V0RGF0ZShleGRhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY192YWx1ZSA9IG5ld1ZhbHVlICsgXCI7IHBhdGg9LzsgZXhwaXJlcz1cIiArIGV4ZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBrZXkgKyBcIj1cIiArIGNfdmFsdWU7XG4gICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBjb21tYW5kLCBwb3NJRCwgMCwgMCk7XG4gICAgICAgIG1zZ09iai5jbWQgPSBjb21tYW5kO1xuICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKSk7XG4gICAgICAgIG1zZ09iai5pbmZvID0gbmV3VmFsdWU7XG4gICAgICAgIG1zZ09iai52YWx1ZSA9IFwiXCI7XG4gICAgICAgIF9zZW5kX3Jlc3BvbnNlKHBhcmFtcywgbXNnT2JqKTtcbiAgICAgICAgaWZyID0gcGFyYW1zID0gbXNnT2JqID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZW1vdmUgLyBkZXN0cm95IG9uZSBvciBtb3JlIFNhZmVGcmFtZXMgZnJvbSB0aGUgcHVibGlzaGVyIHBhZ2VcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QubnVrZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcHVibGljXG4gICAgICBAcGFyYW0ge1N0cmluZ30gcG9zX2lkKiBPbmUgb3IgbW9yZSBwb3NpdGlvbiBpZHMgdG8gcmVtb3ZlIGZyb20gdGhlIHBhZ2UuIElmIG5vIGFyZ3VtZW50cyBhcmUgc3BlY2lmZWQsIGFsbCBwb3NpdGlvbnMgY3VycmVudGx5IHJlbmRlcmVkIGFyZSByZW1vdmVkLlxuICAgICAgICovXG4gICAgICBudWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzLCBlbCwgZWxfaWQsIGVtcHR5LCBpZHgsIHBhciwgcG9zLCBwb3NfaWQsIHNiX3JlbDtcbiAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgZW1wdHkgPSB0cnVlO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBwb3NfaWQgPSB2b2lkIDA7XG4gICAgICAgIHBvcyA9IHZvaWQgMDtcbiAgICAgICAgZWxfaWQgPSB2b2lkIDA7XG4gICAgICAgIGVsID0gdm9pZCAwO1xuICAgICAgICBzYl9yZWwgPSB2b2lkIDA7XG4gICAgICAgIHBhciA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFhcmdzW0xFTl0gfHwgYXJnc1tpZHhdID09PSBcIipcIikge1xuICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICBmb3IgKHBvc19pZCBpbiByZW5kZXJlZF9pZnJzKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gocG9zX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBvc19pZCA9IGFyZ3NbaWR4KytdKSB7XG4gICAgICAgICAgcG9zID0gcmVuZGVyZWRfaWZyc1twb3NfaWRdO1xuICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3NfaWQgaW4gcGVuZGluZ19pZnJzKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nX2lmcnNbcG9zX2lkXSk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NfaWQgaW4gY29tcGxldGVfaWZycykge1xuICAgICAgICAgICAgICBkZWxldGUgY29tcGxldGVfaWZyc1twb3NfaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxfaWQgPSBwb3MuZGVzdDtcbiAgICAgICAgICAgIGVsID0gZWxfaWQgJiYgX2VsdChlbF9pZCk7XG4gICAgICAgICAgICBwYXIgPSBlbCAmJiBfcGFyKGVsKTtcbiAgICAgICAgICAgIGlmIChkb20uYXR0cihwYXIsIFwiaWRcIikuaW5kZXhPZihQT1NfUkVMX0JPWF9JRF9QUkVGSVgpICE9PSAtMSkge1xuICAgICAgICAgICAgICBzYl9yZWwgPSBwYXI7XG4gICAgICAgICAgICAgIHBhciA9IF9wYXIoc2JfcmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbS5wdXJnZShlbCk7XG4gICAgICAgICAgICBpZiAoc2JfcmVsKSB7XG4gICAgICAgICAgICAgIGRvbS5wdXJnZShzYl9yZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZWRfaWZyc1twb3NfaWRdID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSByZW5kZXJlZF9pZnJzW3Bvc19pZF07XG4gICAgICAgICAgICBlbCA9IGRvbS5tYWtlKFwiZGl2XCIpO1xuICAgICAgICAgICAgZG9tLmF0dHIoZWwsIFwiaWRcIiwgZWxfaWQpO1xuICAgICAgICAgICAgZG9tLmFwcGVuZChwYXIsIGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2lkID0gXCJcIjtcbiAgICAgICAgZm9yIChwb3NfaWQgaW4gcmVuZGVyZWRfaWZycykge1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgY3VycmVudF9zdGF0dXMgPSBcIlwiO1xuICAgICAgICAgIF9oYW5kbGVfdW5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZW5kZXIgb25lIG9yIG1vcmUgJHNmLmhvc3QuUG9zaXRpb24gb2JqZWN0cyBpbnRvIHRoZSBwYWdlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LnJlbmRlclxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyRzZi5ob3N0LlBvc2l0aW9ufSBwb3MqIEFuIGluc3RhbmNlIG9mIGFuICRzZi5ob3N0LlBvc2l0aW9uIG9iamVjdCB0byByZW5kZXIuIE5vdGUgdGhhdCBzYWlkIG9iamVjdCBtdXN0IGhhdmUgYSBjb3JyZXNwb25kaW5nICRzZi5ob3N0LlBvc0NvbmZpZywgYXMgd2VsbCBhcyAkc2YuaG9zdC5Db25maWcgbXVzdCBoYXZlIGJlZW4gc2V0XG4gICAgICAgKi9cbiAgICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncywgY3NzX3R4dCwgZGVzdF9lbCwgZGVzdF9pZCwgZGVzdF9yZWxfaWQsIGUsIGZpbmFsQ1NTRW5kLCBmaW5hbENTU1BvcywgZmlyc3RDU1NQb3MsIGgsIGlkeCwgbmFtZV9wYXJhbXMsIG5ld19kZXN0X2VsLCBwYXJfZWwsIHBlbmQsIHBvcywgcG9zX2NvbmYsIHBvc19pZCwgcmVsX2VsLCBzdCwgdztcbiAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgZmlyc3RDU1NQb3MgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIGZpbmFsQ1NTUG9zID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBmaW5hbENTU0VuZCA9IFwidG9wOjBweDtsZWZ0OjBweDt2aXNpYmlsaXR5OmhpZGRlbjtkaXNwbGF5Om5vbmU7XCI7XG4gICAgICAgIHBvcyA9IHZvaWQgMDtcbiAgICAgICAgcG9zX2lkID0gdm9pZCAwO1xuICAgICAgICBwb3NfY29uZiA9IHZvaWQgMDtcbiAgICAgICAgZGVzdF9lbCA9IHZvaWQgMDtcbiAgICAgICAgbmV3X2Rlc3RfZWwgPSB2b2lkIDA7XG4gICAgICAgIHJlbF9lbCA9IHZvaWQgMDtcbiAgICAgICAgcGFyX2VsID0gdm9pZCAwO1xuICAgICAgICBuYW1lX3BhcmFtcyA9IHZvaWQgMDtcbiAgICAgICAgZGVzdF9pZCA9IHZvaWQgMDtcbiAgICAgICAgZGVzdF9yZWxfaWQgPSB2b2lkIDA7XG4gICAgICAgIGNzc190eHQgPSB2b2lkIDA7XG4gICAgICAgIHcgPSB2b2lkIDA7XG4gICAgICAgIGggPSB2b2lkIDA7XG4gICAgICAgIHN0ID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBwZW5kID0gdm9pZCAwO1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbS5yZWFkeSgpKSB7XG4gICAgICAgICAgZG9tLndhaXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW5kZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBhcmdzID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGFyZ3NbMF0gaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnc1tMRU5dID09PSAxKSB7XG4gICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBvcyA9IGFyZ3NbaWR4KytdKSB7XG4gICAgICAgICAgcG9zX2lkID0gcG9zLmlkO1xuICAgICAgICAgIHBvc19jb25mID0gKHBvc19pZCA/IGNvbmZpZy5wb3NpdGlvbnNbcG9zX2lkXSA6IG51bGwpO1xuICAgICAgICAgIGlmIChwb3NfY29uZikge1xuICAgICAgICAgICAgZGVzdF9pZCA9IHBvc19jb25mLmRlc3Q7XG4gICAgICAgICAgICBkZXN0X2VsID0gZGVzdF9pZCAmJiBfZWx0KGRlc3RfaWQpO1xuICAgICAgICAgICAgaWYgKGRlc3RfZWwpIHtcbiAgICAgICAgICAgICAgdyA9IHBvc19jb25mLnc7XG4gICAgICAgICAgICAgIGggPSBwb3NfY29uZi5oO1xuICAgICAgICAgICAgICBpZiAoIXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdyA9IGRlc3RfZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAgICAgICBwb3NfY29uZi53ID0gdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGggPSBkZXN0X2VsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgICAgICBoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgICAgICAgIHBvc19jb25mLmggPSBoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodyAmJiBoKSB7XG4gICAgICAgICAgICAgICAgbmFtZV9wYXJhbXMgPSBuZXcgUGFyYW1IYXNoKCk7XG4gICAgICAgICAgICAgICAgZGVzdF9yZWxfaWQgPSBQT1NfUkVMX0JPWF9JRF9QUkVGSVggKyBcIl9cIiArIHBvc19pZDtcbiAgICAgICAgICAgICAgICByZWxfZWwgPSBfZWx0KGRlc3RfcmVsX2lkKTtcbiAgICAgICAgICAgICAgICBwYXJfZWwgPSBfcGFyKGRlc3RfZWwpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxfZWwgJiYgcGFyX2VsID09PSByZWxfZWwpIHtcbiAgICAgICAgICAgICAgICAgIHBhcl9lbCA9IF9wYXIocmVsX2VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3NoaW1fZnJhbWUoZGVzdF9pZCk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIEBpZ25vcmVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwZW5kID0gcGVuZGluZ19pZnJzW3Bvc19pZF07XG4gICAgICAgICAgICAgICAgaWYgKHBlbmQpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGVuZCA9IGNvbXBsZXRlX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBsZXRlX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGVuZGluZ19pZnJzW3Bvc19pZF0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgX2hhbmRsZV9yZW5kZXJfdGltZW91dChwb3NfaWQpO1xuICAgICAgICAgICAgICAgIH0sIGNvbmZpZy50byk7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zdGF0dXMgPSBcInJlbmRlcmluZ1wiO1xuICAgICAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhcIm9uU3RhcnRQb3NSZW5kZXJcIiwgcG9zX2lkLCBwb3NfY29uZiwgcG9zKTtcbiAgICAgICAgICAgICAgICBjc3NfdHh0ID0gW1wicG9zaXRpb246XCIsIFwiXCIsIFwiO3otaW5kZXg6MDtcIiwgV0lEVEgsIFwiOlwiLCB3LCBQWCwgXCI7XCIsIEhFSUdIVCwgXCI6XCIsIGgsIFBYLCBcIjtcIiwgXCJ2aXNpYmlsaXR5OmluaGVyaXQ7XCJdO1xuICAgICAgICAgICAgICAgIGlmICghcmVsX2VsKSB7XG4gICAgICAgICAgICAgICAgICBjc3NfdHh0WzFdID0gZmlyc3RDU1NQb3M7XG4gICAgICAgICAgICAgICAgICByZWxfZWwgPSBkb20ubWFrZShcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgIHJlbF9lbC5pZCA9IGRlc3RfcmVsX2lkO1xuICAgICAgICAgICAgICAgICAgcmVsX2VsLmNsYXNzTmFtZSA9IFwiaWFiX3NmXCI7XG4gICAgICAgICAgICAgICAgICBuZXdfZGVzdF9lbCA9IGRlc3RfZWwuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIGRvbS5jc3MobmV3X2Rlc3RfZWwsIGNzc190eHQpO1xuICAgICAgICAgICAgICAgICAgcmVsX2VsLmFwcGVuZENoaWxkKG5ld19kZXN0X2VsKTtcbiAgICAgICAgICAgICAgICAgIGRvbS5jc3MocmVsX2VsLCBjc3NfdHh0KTtcbiAgICAgICAgICAgICAgICAgIHBhcl9lbC5yZXBsYWNlQ2hpbGQocmVsX2VsLCBkZXN0X2VsKTtcbiAgICAgICAgICAgICAgICAgIGRlc3RfZWwgPSBfZWx0KGRlc3RfaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdCA9IHJlbF9lbFtTVF07XG4gICAgICAgICAgICAgICAgICBzdC53aWR0aCA9IHcgKyBQWDtcbiAgICAgICAgICAgICAgICAgIHN0LmhlaWdodCA9IGggKyBQWDtcbiAgICAgICAgICAgICAgICAgIHN0ID0gZGVzdF9lbCAmJiBkZXN0X2VsW1NUXTtcbiAgICAgICAgICAgICAgICAgIHN0LndpZHRoID0gdyArIFBYO1xuICAgICAgICAgICAgICAgICAgc3QuaGVpZ2h0ID0gaCArIFBYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5pZCA9IHBvc19pZDtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5kZXN0ID0gZGVzdF9pZDtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5jb25mID0gUGFyYW1IYXNoKHBvc19jb25mKTtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5tZXRhID0gcG9zLm1ldGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5odG1sID0gX2VzKHBvcy5odG1sKTtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5nZW9tID0gX2VzKF9idWlsZF9nZW9tKHBvc19pZCwgZGVzdF9lbCkpO1xuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLnNyYyA9IHBvc19jb25mLnJlbmRlckZpbGUgfHwgY29uZmlnLnJlbmRlckZpbGU7XG4gICAgICAgICAgICAgICAgbmFtZV9wYXJhbXMuaGFzX2ZvY3VzID0gbGFuZy5jc3RyKGRvY3VtZW50Lmhhc0ZvY3VzKCkpO1xuICAgICAgICAgICAgICAgIGNzc190eHRbMV0gPSBmaW5hbENTU1BvcztcbiAgICAgICAgICAgICAgICBjc3NfdHh0WzEzXSA9IGZpbmFsQ1NTRW5kO1xuICAgICAgICAgICAgICAgIGlmICghd2luX2V2ZW50c19hdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgZG9tLmF0dGFjaCh3aW4sIFNDUk9MTCwgX2hhbmRsZV93aW5fZ2VvbV9zY3JvbGwpO1xuICAgICAgICAgICAgICAgICAgZG9tLmF0dGFjaCh3aW4sIFwicmVzaXplXCIsIF9oYW5kbGVfd2luX2dlb21fcmVzaXplKTtcbiAgICAgICAgICAgICAgICAgIGRvbS5hdHRhY2god2luLCBcInVubG9hZFwiLCBfaGFuZGxlX3VubG9hZCk7XG4gICAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgXCJmb2N1c1wiLCBfaGFuZGxlX3dpbl9mb2N1cyk7XG4gICAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgXCJibHVyXCIsIF9oYW5kbGVfd2luX2JsdXIpO1xuICAgICAgICAgICAgICAgICAgd2luX2V2ZW50c19hdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmcmFtZXMucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgICBpZDogZGVzdF9pZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVfcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgc3JjOiBwb3NfY29uZi5yZW5kZXJGaWxlIHx8IGNvbmZpZy5yZW5kZXJGaWxlLFxuICAgICAgICAgICAgICAgICAgX3Bvc19pZDogcG9zX2lkXG4gICAgICAgICAgICAgICAgfSwgY3NzX3R4dCwgcmVsX2VsLCBfaGFuZGxlX2ZyYW1lX2xvYWQsIF9oYW5kbGVfbXNnX2V2dCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRfaWZyc1twb3NfaWRdID0gbmFtZV9wYXJhbXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBHZXRzIGEgY29weSBvZiB0aGUgUG9zaXRpb24gY29uZmlndXJhdGlvbiwgY29udGVudCwgYW5kIG1ldGEgZGF0YSBmb3IgYSBnaXZlbiBTYWZlRnJhbWVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QuZ2V0XG4gICAgICBAcHVibGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZ2V0ID0gZnVuY3Rpb24ocG9zaXRpb25JZCkge1xuICAgICAgICB2YXIgb2JqO1xuICAgICAgICBvYmogPSByZW5kZXJlZF9pZnJzW3Bvc2l0aW9uSWRdO1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbWl4KHt9LCBvYmopO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybnMgYSBzdHJpbmcgYXMgdG8gd2hldGhlciBvciBub3QgdGhlIGxpYnJhcnkgaXMgYnVzeSwgZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIG9uIGlkbGVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3Quc3RhdHVzXG4gICAgICBAcHVibGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBzdGF0aWNcbiAgICAgIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgc3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50X3N0YXR1cztcbiAgICAgIH07XG4gICAgICBfc2VuZF9nZW5lcmljX3Jlc3BvbnNlID0gZnVuY3Rpb24ocG9zSUQsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIG1zZ09iaiwgcGFyYW1zO1xuICAgICAgICBtc2dPYmogPSBuZXcgUGFyYW1IYXNoKCk7XG4gICAgICAgIHBhcmFtcyA9IHBvc0lEICYmIHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgICBtc2dPYmouY21kID0gY29tbWFuZDtcbiAgICAgICAgbXNnT2JqLnBvcyA9IHBvc0lEO1xuICAgICAgICByZXR1cm4gX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgfTtcbiAgICAgIF9nZXRHZW9tID0gZnVuY3Rpb24ocG9zSUQpIHtcbiAgICAgICAgdmFyIGcsIGlkLCBpZnIsIHBhcmFtcztcbiAgICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIGlkID0gcGFyYW1zICYmIHBhcmFtcy5kZXN0O1xuICAgICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgICAgZyA9IF9idWlsZF9nZW9tKHBvc0lELCBpZnIsIHRydWUpO1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH07XG4gICAgICBpblZpZXdQZXJjZW50YWdlID0gZnVuY3Rpb24ocG9zSUQpIHtcbiAgICAgICAgdmFyIGdlb21faW5mbywgaXYsIHR2LCBfcmVmO1xuICAgICAgICBnZW9tX2luZm8gPSBfZ2V0R2VvbShwb3NJRCk7XG4gICAgICAgIGl2ID0gX2NudW0oZ2VvbV9pbmZvICE9IG51bGwgPyAoX3JlZiA9IGdlb21faW5mby5zZWxmKSAhPSBudWxsID8gX3JlZi5pdiA6IHZvaWQgMCA6IHZvaWQgMCwgLTEsIDApO1xuICAgICAgICBpZiAoaXYgPj0gMCkge1xuICAgICAgICAgIHR2ID0gTWF0aC5mbG9vcihpdiAqIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR2O1xuICAgICAgfTtcbiAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgIGlmICh3aW4gPT09IHRvcCB8fCBhbGxvd05vdFRvcCkge1xuICAgICAgICAgIF9yZWN0ID0gKGllVmVyID8gX2dldFJlY3RJRSA6IF9nZXRSZWN0Tm9uSUUpO1xuICAgICAgICAgIF9taXgoZG9tLCB7XG4gICAgICAgICAgICByZWN0OiBfcmVjdCxcbiAgICAgICAgICAgIGN1cnJlbnRTdHlsZTogY3VycmVudFN0eWxlLFxuICAgICAgICAgICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgICAgICAgICAgZG9jUmVjdDogZG9jUmVjdCxcbiAgICAgICAgICAgIHdpblJlY3Q6IHdpblJlY3QsXG4gICAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgICAgIG92ZXJsYXBzOiBvdmVybGFwc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICBAaWdub3JlXG4gICAgICAgICAgICovXG4gICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tLm1zZ2hvc3QgPSB7XG4gICAgICAgICAgICAgIHByZXA6IHByZXBfaWZyYW1lX21zZ2luZyxcbiAgICAgICAgICAgICAgYXR0YWNoOiBhdHRhY2hfaWZyYW1lX21zZ2luZyxcbiAgICAgICAgICAgICAgZGV0YWNoOiBkZXRhY2hfaWZyYW1lX21zZ2luZyxcbiAgICAgICAgICAgICAgdXNpbmdIVE1MNTogdXNpbmdIVE1MNSxcbiAgICAgICAgICAgICAgc2VuZDogc2VuZF9tc2dfdG9fY2hpbGRfaWZyYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9tW0FUVEFDSF0od2luLCBNU0csIF9jaGVja19odG1sNV9pbml0KTtcbiAgICAgICAgICAgIGluaXRJRCA9IFwieGRtLWh0bWw1LWluaXQtXCIgKyBfZ3VpZCgpO1xuICAgICAgICAgICAgbG9jSG9zdCA9IChsb2NIb3N0LmluZGV4T2YoXCJmaWxlXCIpID09PSAwID8gbG9jSG9zdCA9IFwiZmlsZVwiIDogbG9jSG9zdCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5bUE1TR10oaW5pdElELCAobG9jSG9zdCA9PT0gXCJmaWxlXCIgPyBcIipcIiA6IGxvY0hvc3QpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICBkb21bREVUQUNIXSh3aW4sIE1TRywgX2NoZWNrX2h0bWw1X2luaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgX21peChzZi5ob3N0LCB7XG4gICAgICAgICAgICBDb25maWc6IENvbmZpZyxcbiAgICAgICAgICAgIFBvc0NvbmZpZzogUG9zQ29uZmlnLFxuICAgICAgICAgICAgUG9zTWV0YTogUG9zTWV0YSxcbiAgICAgICAgICAgIFBvc2l0aW9uOiBQb3NpdGlvbixcbiAgICAgICAgICAgIG51a2U6IG51a2UsXG4gICAgICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICBpblZpZXdQZXJjZW50YWdlOiBpblZpZXdQZXJjZW50YWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd05vdFRvcCkge1xuICAgICAgICB3aW5kb3dbXCIkc2ZcIl0gPSBzZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZjtcbiAgICB9KSh3aW5kb3csIHNmKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSwgZW52LCBsYW5nLCBsb2dnZXI7XG5cbiAgbGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpO1xuXG4gIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxuICBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKGxhbmcsIGVudiwgZG9tLCBsb2dnZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyOiBcIjEtMS0wXCIsXG4gICAgICBzcGVjVmVyc2lvbjogXCIxLjFcIixcbiAgICAgIGxpYjoge1xuICAgICAgICBsYW5nOiBsYW5nLFxuICAgICAgICBkb206IGRvbSxcbiAgICAgICAgbG9nZ2VyOiBsb2dnZXJcbiAgICAgIH0sXG4gICAgICBlbnY6IGVudixcbiAgICAgIGhvc3Q6IHt9LFxuICAgICAgZXh0OiB7fSxcbiAgICAgIGluZm86IHtcbiAgICAgICAgZXJyczogW10sXG4gICAgICAgIGxpc3Q6IFtdXG4gICAgICB9XG4gICAgfTtcbiAgfSkobGFuZywgZW52LCBkb20sIGxvZ2dlcik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBlbnYsIGxhbmc7XG5cbiAgbGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpO1xuXG4gIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93LCBsYW5nLCBlbnYpIHtcbiAgICB2YXIgQkxBTktfVVJMLCBFVlRfQ05DTF9NRVRIT0RTLCBHQywgSUVfR0NfSU5URVJWQUwsIElGUkFNRSwgYXBwZW5kLCBhdHRhY2gsIGF0dHIsIGNsb25lX2lmcmFtZSwgY3NzLCBkZXRhY2gsIGRvYywgZG9tLCBkb21faXNfcmVhZHksIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUsIGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCwgZG9tX3JlYWR5X2Noa19tYXhfdHJpZXMsIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQsIGRvbV9yZWFkeV9jaGtfdHJpZXMsIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsLCBlbHQsIGV2dENuY2wsIGV2dFRndCwgZXZ0X3RndF9wcm9wX2EsIGV2dF90Z3RfcHJvcF9iLCBnYywgZ2NfdGltZXJfaWQsIGllX2F0dGFjaCwgaWVfZGV0YWNoLCBpZnJhbWVfY2JzX2F0dGFjaGVkLCBpZnJhbWVfbXNnX2hvc3RfbGliLCBpZnJhbWVfbmV4dF9pZCwgaWZyYW1lX3ZpZXcsIGlzSUUsIG1ha2VfZWxlbWVudCwgbWFrZV9pZnJhbWUsIHBhciwgcHVyZ2UsIHJlYWR5LCByZXBsYWNlX2lmcmFtZSwgdGFnTmFtZSwgdGFncywgdGhlRG9jdW1lbnQsIHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMsIHVzZV9hdHRhY2gsIHVzZV9kZXRhY2gsIHVzZV9pZV9vbGRfYXR0YWNoLCB2aWV3LCB3M2NfYXR0YWNoLCB3M2NfZGV0YWNoLCB3YWl0LCB3aW4sIF9iaW5kX2lmcmFtZV9vbmxvYWQsIF9ieUlELCBfY2FsbF94bXNnX2hvc3QsIF9jYWxsYWJsZSwgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrLCBfY2xvbmVfaWZyYW1lLCBfY3N0ciwgX2VudiwgX2hhbmRsZV9kb21fbG9hZF9ldnQsIF9sYW5nLCBfcmVhZHlfc3RhdGVfY2hlY2ssIF91bmJpbmRfaWZyYW1lX29ubG9hZDtcbiAgICBkb20gPSB7fTtcbiAgICBfbGFuZyA9IGxhbmc7XG4gICAgX2VudiA9IGVudjtcbiAgICB3aW4gPSB3aW5kb3c7XG4gICAgSUZSQU1FID0gXCJpZnJhbWVcIjtcbiAgICBHQyA9IFwiQ29sbGVjdEdhcmJhZ2VcIjtcbiAgICBpZV9hdHRhY2ggPSBcImF0dGFjaEV2ZW50XCI7XG4gICAgdzNjX2F0dGFjaCA9IFwiYWRkRXZlbnRMaXN0ZW5lclwiO1xuICAgIGllX2RldGFjaCA9IFwiZGV0YWNoRXZlbnRcIjtcbiAgICB3M2NfZGV0YWNoID0gXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XG4gICAgdXNlX2F0dGFjaCA9IFwiXCI7XG4gICAgdXNlX2RldGFjaCA9IFwiXCI7XG4gICAgdXNlX2llX29sZF9hdHRhY2ggPSBmYWxzZTtcbiAgICBJRV9HQ19JTlRFUlZBTCA9IDMwMDA7XG4gICAgRVZUX0NOQ0xfTUVUSE9EUyA9IHtcbiAgICAgIFwicHJldmVudERlZmF1bHRcIjogMCxcbiAgICAgIFwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCI6IDAsXG4gICAgICBcInN0b3BQcm9wYWdhdGlvblwiOiAwLFxuICAgICAgXCJwcmV2ZW50QnViYmxlXCI6IDBcbiAgICB9O1xuICAgIGlzSUUgPSBlbnYuaXNJRTtcbiAgICB1c2VPbGRTdHlsZUF0dHJNZXRob2RzID0gZmFsc2U7XG4gICAgZ2NfdGltZXJfaWQgPSAwO1xuICAgIGRvbV9pc19yZWFkeSA9IG51bGw7XG4gICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gMDtcbiAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICBkb21fcmVhZHlfY2hrX21heF90cmllcyA9IDMwMDtcbiAgICBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCA9IDUwO1xuICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgPSAwO1xuICAgIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQgPSAwO1xuICAgIGlmcmFtZV9uZXh0X2lkID0gMDtcbiAgICBpZnJhbWVfY2JzX2F0dGFjaGVkID0ge307XG4gICAgZXZ0X3RndF9wcm9wX2EgPSBcIlwiO1xuICAgIGV2dF90Z3RfcHJvcF9iID0gXCJcIjtcbiAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gbnVsbDtcbiAgICB0aGVEb2N1bWVudCA9IHdpbi5kb2N1bWVudDtcbiAgICBCTEFOS19VUkwgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgX2NzdHIgPSBsYW5nLmNzdHI7XG4gICAgX2NhbGxhYmxlID0gbGFuZy5jYWxsYWJsZTtcblxuICAgIC8qXG4gICAgQ2xlYXIgb3V0IHRoZSB0aW1lciBmdW5jdGlvbiB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiByZWFkeSBzdGF0ZSBvZiB0aGUgRE9NXG4gICAgY2Fubm90IGJlIGRpcmVjdGx5IGRldGVjdGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9tX3JlYWR5X2Noa190aW1lcl9pZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZG9tX3JlYWR5X2Noa190aW1lcl9pZCk7XG4gICAgICAgIGRvbV9yZWFkeV9jaGtfdGltZXJfaWQgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgX2hhbmRsZV9kb21fbG9hZF9ldnQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGRldGFjaCh3aW4sIFwibG9hZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICBkZXRhY2god2luLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgdG8gc2VlIGlmIHRoZSBET00gaXMgcmVhZHkgdG8gYmUgbWFuaXB1bGF0ZWQsIHdpdGhvdXQgdGhlIG5lZWQgZm9yIGV2ZW50IGhvb2tpbmcuXG4gICAgT2Z0ZW4gdGltZXMgeW91J2xsIHNlZSBmb2xrcyB1c2UgdGhlIG9ubG9hZCBldmVudCBvciBET01Db250ZW50TG9hZGVkIGV2ZW50LiAgSG93ZXZlclxuICAgIHRoZSBwcm9ibGVtIHdpdGggdGhvc2UsIGlzIHRoYXQgeW91ciBKYXZhU2NyaXB0IGNvZGUgbWF5IGhhdmUgYmVlbiBsb2FkZWQgYXN5bmNocm9ub3VzbHksXG4gICAgYWZ0ZXIgZWl0aGVyIG9uZSBvZiB0aG9zZSBldmVudHMgaGF2ZSBmaXJlZCwgYW5kIGluIHdoaWNoIGNhc2UgeW91IHN0aWxsIGRvbid0IGtub3cgaWYgdGhlIERPTSBpcyByZWFsbHlcbiAgICByZWFkeS4gIE1vc3QgbW9kZXJuIGJyb3dzZXJzIChpbmNsdWRpbmcgSUUpLCBpbXBsZW1lbnQgYSBkb2N1bWVudC5yZWFkeVN0YXRlIHByb3BlcnR5IHRoYXQgd2UgY2FuXG4gICAgY2hlY2ssIGJ1dCBub3QgYWxsLiAgSW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBwcm9wZXJ0eSBpcyBub3QgaW1wbGVtZW50ZWQsIHdlIGRvIGEgc2VyaWVzIG9mIG5vZGVcbiAgICBjaGVja3MgYW5kIHRhZyBjb3VudHMgdmlhIHRpbWVycy4gIE9mIGNvdXJzZSB0aGlzIG1lYW5zIHRoYXQgb24gdGhlIHZlcnkgMXN0IGNhbGwsIHdlIHdpbGwgYWx3YXlzXG4gICAgYXBwZWFyIHRvIGJlIG5vdCByZWFkeSBldmVudGhvdWdoIHRoZSBET00gaXRzZWxmIG1heSBiZSBpbiBhIHJlYWR5IHN0YXRlLCBidXQgb3VyIHRpbWVvdXQgaW50ZXJ2YWxcbiAgICBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGlzIGlzIE9LLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLV9yZWFkeV9zdGF0ZV9jaGVja1xuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgICAqL1xuICAgIF9yZWFkeV9zdGF0ZV9jaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGIsIGUsIGtpZHMsIGxzdCwgdGFnX2NudDtcbiAgICAgIF9jbGVhcl9yZWFkeV90aW1lcl9jaGVjaygpO1xuICAgICAgaWYgKGRvbV9yZWFkeV9jaGtfdHJpZXMgPj0gZG9tX3JlYWR5X2Noa19tYXhfdHJpZXMpIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZG9tX2lzX3JlYWR5ID09PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYiA9IHRoZURvY3VtZW50ICYmIHRoZURvY3VtZW50LmJvZHk7XG4gICAgICAgICAga2lkcyA9IGIgJiYgdGFncyhcIipcIiwgYik7XG4gICAgICAgICAgdGFnX2NudCA9IGtpZHMgJiYga2lkc1tMRU5dO1xuICAgICAgICAgIGxzdCA9IGIgJiYgYi5sYXN0Q2hpbGQ7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gMDtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ICYmIHRhZ19jbnQgPT09IGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCAmJiBsc3QgPT09IGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUpIHtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX3RhZ19jb3VudCA9IHRhZ19jbnQ7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IGxzdDtcbiAgICAgICAgICBkb21fcmVhZHlfY2hrX3RyaWVzICs9IDE7XG4gICAgICAgICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IHNldFRpbWVvdXQoX3JlYWR5X3N0YXRlX2NoZWNrLCBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIERldGFjaCBvbmxvYWQgaGFuZGxlcnMgb24gaWZyYW1lcyB0aGF0IHdlIGhhdmUgY3JlYXRlZFxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX3VuYmluZF9pZnJhbWVfb25sb2FkXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIGlmcmFtZSBlbGVtZW50IHRvIHVuYmluZCBmcm9tXG4gICAgICovXG4gICAgX3VuYmluZF9pZnJhbWVfb25sb2FkID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBpZCwgb2xkQ0I7XG4gICAgICBpZCA9IGF0dHIoZWwsIFwiaWRcIik7XG4gICAgICBvbGRDQiA9IHZvaWQgMDtcbiAgICAgIG9sZENCID0gaWQgJiYgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF07XG4gICAgICBpZiAob2xkQ0IpIHtcbiAgICAgICAgZGV0YWNoKGVsLCBcImxvYWRcIiwgb2xkQ0IpO1xuICAgICAgICBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBBIGRlZmF1bHQgb25sb2FkIGV2ZW50IGhhbmRsZXIgZm9yIElGcmFtZXMuIFdlIGRvbid0XG4gICAgd2FudCB0byBhdHRhY2ggdG8gb25sb2FkIGV2ZW50cyBmb3IgSUZyYW1lcyB2aWEgYXR0cmlidXRlc1xuICAgIGIvYyB3ZSBkb24ndCB3YW50IG90aGVycyB0byBzZWUgd2hhdCBoYW5kbGVycyBhcmUgdGhlcmUuXG4gICAgSW4gdHVybiB3ZSBhbHNvIG1ha2Ugc3VyZSB0aGUgXCJ0aGlzXCIgcmVmZXJlbmNlIGZvciB0aGUgb3V0c2lkZVxuICAgIGhhbmRsZSBnZXRzIHNldCBwcm9wZXJseSwgYW5kIGl0IGFsbG93cyB1cyB0byBtYWtlIHN1cmVcbiAgICB0aGF0IHVuYmluZGluZyBvZiB0aGUgZXZlbnQgaGFuZGxlciBhbHNvIGdldHMgaGFuZGxlZCBhbHdheXNcbiAgICBzbyBhcyBub3QgdG8gY3JlYXRlIG1lbW9yeSBsZWFrIGlzc3Vlcy5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLV9iaW5kX2lmcmFtZV9vbmxvYWRcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgaWZyYW1lIGVsZW1lbnQgdG8gYmluZCB0b29cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgb25sb2FkIGhhbmRsZXIgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqL1xuICAgIF9iaW5kX2lmcmFtZV9vbmxvYWQgPSBmdW5jdGlvbihlbCwgY2IpIHtcbiAgICAgIHZhciBpZCwgbmV3Q0I7XG4gICAgICBuZXdDQiA9IHZvaWQgMDtcbiAgICAgIGlkID0gdm9pZCAwO1xuICAgICAgaWYgKF9jYWxsYWJsZShjYikpIHtcblxuICAgICAgICAvKlxuICAgICAgICBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICBuZXdDQiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHZhciBlLCB0Z3Q7XG4gICAgICAgICAgdGd0ID0gZXZ0VGd0KGV2dCk7XG4gICAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQodGd0KTtcbiAgICAgICAgICBpZiAodGd0ICYmIGNiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYi5jYWxsKHRndCwgZXZ0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICB9XG4gICAgICAgICAgdGd0ID0gZWwgPSBjYiA9IG5ld0NCID0gaWQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBpZCA9IGF0dHIoZWwsIFwiaWRcIik7XG4gICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZChlbCk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdID0gbmV3Q0I7XG4gICAgICAgIH1cbiAgICAgICAgYXR0YWNoKGVsLCBcImxvYWRcIiwgbmV3Q0IpO1xuICAgICAgfVxuICAgICAgbmV3Q0IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgZWxlbWVudCByZWZlcmVuY2UgcGFzc2VkIGluLCBhbmQgaWYgaXRzIGEgc3RyaW5nIHZhbHVlIHBhc3NlZFxuICAgIGluIHVzZSB0aGF0IHRvIGxvb2t1cCB0aGUgZWxlbWVudCBieSBpZCBhdHRyaWJ1dGUuXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX2J5SURcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gZWwgIHRoZSBlbGVtZW50IGlkIC8gZWxlbWVudCByZWZlcmVuY2VcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudHxlbH1cbiAgICAgKi9cbiAgICBfYnlJRCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICBpZiAoZWwgJiYgdHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBlbHQoZWwpIHx8IGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEEgcHJveHkgd3JhcHBlciBmb3IgY2FsbGluZyBpbnRvIHRoZSBjcm9zcy1kb21haW4gbWVzc2FnaW5nIGhvc3QgbGlicmFyeVxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX2NhbGxfeG1zZ19ob3N0XG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IG1ldGhOYW1lIFRoZSBtZXRob2QgbmFtZSBpbiB0aGUgbXNnIGhvc3QgbGlicmFyeSB0byBjYWxsXG4gICAgQHBhcmFtIHsqfSBhcmcxIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAxc3QgYXJnXG4gICAgQHBhcmFtIHsqfSBhcmcyIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAybmQgYXJnXG4gICAgQHBhcmFtIHsqfSBhcmczIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAzcmQgYXJnXG4gICAgQHJldHVybiB7Kn0gd2hhdGV2ZXIgY29tZXMgYmFjayBmcm9tIHRoZSBtZXRob2RcbiAgICAgKi9cbiAgICBfY2FsbF94bXNnX2hvc3QgPSBmdW5jdGlvbihtZXRoTmFtZSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIGU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpZnJhbWVfbXNnX2hvc3RfbGliKSB7XG4gICAgICAgICAgaWZyYW1lX21zZ19ob3N0X2xpYiA9IGRvbS5tc2dob3N0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgaWZyYW1lX21zZ19ob3N0X2xpYiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAod2luICE9PSB0b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhOYW1lICYmIGlmcmFtZV9tc2dfaG9zdF9saWIgJiYgaWZyYW1lX21zZ19ob3N0X2xpYlttZXRoTmFtZV0gJiYgaWZyYW1lX21zZ19ob3N0X2xpYlttZXRoTmFtZV0oYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgYSBkb2N1bWVudCBmb3IgYSBnaXZlbiBIVE1MIEVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBkb2MgYXMgJHNmLmxpYi5kb20uZG9jXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IGZvciB3aGljaCB5b3Ugd2lzaCB0byBmaW5kIGl0J3MgcGFyZW50IGRvY3VtZW50XG4gICAgQHJldHVybiB7RG9jdW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgZG9jID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBlLCBsb2NhbEQ7XG4gICAgICBsb2NhbEQgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxEID0gZWwuZG9jdW1lbnQgfHwgZWwub3duZXJEb2N1bWVudCB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGxvY2FsRCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxEO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIHRoZSBob3N0IHdpbmRvdyBvYmplY3QgZm9yIGEgZ2l2ZW4gSFRNTCBFbGVtZW50L2RvY3VtZW50LiBOb3RlIHRoYXQgdGhpcyBpcyBOT1QgdGhlIHNhbWUgYXMgJHNmLmxpYi5kb20uaWZyYW1lcy52aWV3LCB3aGljaFxuICAgIHJldHVybnMgdGhlIHdpbmRvdyByZWZlcmVuY2UgSU5TSURFIHRoZSBJRlJBTUUgZWxlbWVudC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyB2aWV3IGFzICRzZi5saWIuZG9tLnZpZXdcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTERvY3VtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50L2RvY3VtZW50IGZvciB3aGljaCB5b3Ugd2lzaCB0byBmaW5kIGl0J3MgcGFyZW50IHdpbmRvd1xuICAgIEByZXR1cm4ge0RvY3VtZW50fG51bGx9IG51bGwgaWYgbm90aGluZyBmb3VuZFxuICAgICAqL1xuICAgIHZpZXcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGxvY2FsRCwgcHJvcDEsIHByb3AyLCB3O1xuICAgICAgdyA9IG51bGw7XG4gICAgICBsb2NhbEQgPSB2b2lkIDA7XG4gICAgICBwcm9wMSA9IFwicGFyZW50V2luZG93XCI7XG4gICAgICBwcm9wMiA9IFwiZGVmYXVsdFZpZXdcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIHcgPSBlbFtwcm9wMV0gfHwgZWxbcHJvcDJdIHx8IG51bGw7XG4gICAgICAgICAgaWYgKCF3KSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBkb2MoZWwpO1xuICAgICAgICAgICAgdyA9IChsb2NhbEQgJiYgKGxvY2FsRFtwcm9wMV0gfHwgbG9jYWxEW3Byb3AyXSkpIHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdztcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSBhbiBlbGVtZW50IGJ5IGl0cyBJRC4gLiBiYXNpY2FsbHkgYSBzaG9ydCBoYW5kIHdyYXBwZXIgYXJvdW5kIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGVsdCBhcyAkc2YubGliLmRvbS5lbHRcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBpZCAoUmVxdWlyZWQpIHRoZSBpZCBvZiB0aGUgSFRNTCBlbGVtZW50IHRvIGZpbmRcbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxXaW5kb3d8SFRNTERvY3VtZW50fSBbcGFyXSBUaGUgcGFyZW50IGVsZW1lbnQsZG9jdW1lbnQsd2luZG93IHRvIGxvb2sgZm9yIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgZWx0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBhcmdzLCBkYywgbGVuO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgZGMgPSB2b2lkIDA7XG4gICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICBkYyA9IGRvYyhhcmdzWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRjID0gdGhlRG9jdW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGRjICYmIGRjLmdldEVsZW1lbnRCeUlkKGlkKSkgfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIHdyYXBwZXIgYXJvdW5kIHJldHJpZXZpbmcgdGhlIHRhZ05hbWUgb2YgYW4gSFRNTCBlbGVtZW50IChub3JtYWxpemVzIHZhbHVlcyB0byBsb3dlciBjYXNlIHN0cmluZ3MpLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHRhZ05hbWUgYXMgJHNmLmxpYi5kb20udGFnTmFtZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIEhUTUwgZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSB0YWcgbmFtZS5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0YWcgbmFtZSBpbiBhbGwgbG93ZXIgY2FzZSBvZiBhbiBIVE1MIGVsZW1lbnQsIGlmIGl0IGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgcmV0cmlldmVkLCBhbHdhc3lzIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nICh3aGljaCB3aWxsIGV2YWx1YXRlIHRvIGZhbHNlKS5cbiAgICAgKi9cbiAgICB0YWdOYW1lID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBhcm91bmQgcmV0cmlldmluZyBhIGxpc3Qgb2YgdGFncyBieSBuYW1lLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHRhZ3MgYXMgJHNmLmxpYi5kb20udGFnc1xuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZ3MgdGhhdCB5b3Ugd2lzaCB0byBsb29rIGZvciwgbm90ZSB0aGF0IHlvdSBjYW4gcGFzcyBpbiBcIipcIiB0byBmaW5kIGFsbC5cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fERvY3VtZW50fSBbcGFyTm9kZV0gdGhlIHBhcmVudCBub2RlIHRoYXQgeW91IHdpc2ggdG8gbG9vayBpblxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50Q29sbGVjdGlvbn0gTGlzdCBvZiB0YWdzIGZvdW5kLiBOb3RlIHRoYXQgaXMgTk9UIGEgcmVhbCBKYXZhU2NyaXB0IEFycmF5XG4gICAgICovXG4gICAgdGFncyA9IGZ1bmN0aW9uKG5hbWUsIHBhck5vZGUpIHtcbiAgICAgIHZhciBlLCByZXQ7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGFyTm9kZSAmJiBwYXJOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG4gICAgICAgICAgcmV0ID0gcGFyTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSB8fCByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gdGhlRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSkgfHwgcmV0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpdmUgdGhlIHBhcmVudCBlbGVtZW50IG9mIGFuIEhUTUwgZWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHBhciBhcyAkc2YubGliLmRvbS5wYXJcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gY2hlY2tcbiAgICByZXR1cm4ge0hUTUxFbGVtZW50fSB0aGUgbmV3IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGVsZW1lbnQgb3IgbnVsbFxuICAgICAqL1xuICAgIHBhciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwgJiYgKGVsLnBhcmVudE5vZGUgfHwgZWwucGFyZW50RWxlbWVudCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUvU2V0L0RlbGV0ZSBhbiBlbGVtZW50J3MgYXR0cmlidXRlLiBOb3RlIHRoYXQgdGhpcyBoYW5kbGUnc1xuICAgIHNsaWdodCBkaWZmZXJlbmNlcyBpbiB0aGUgd2F5IEhUTUwgYXR0cmlidXRlcyBhcmUgaGFuZGxlZCBhY3Jvc3MgYnJvd3NlcnNcbiAgICBhcyB3ZWxsIGFzIGJlaW5nIHNob3J0aGFuZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGF0dHIgYXMgJHNmLmxpYi5kb20uYXR0clxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBtYW5pcHVsYXRlXG4gICAgQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIHRoZSBhdHRyaWJ1dGUgdG8gc2V0L2dldFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbYXR0clZhbF0sIGlmIHNwZWNpZmllZCB3aWxsIHNldCB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBmb3IgdGhpcyBlbGVtZW50LiAgUGFzc2luZyBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgY29tcGxldGVseVxuICAgIEByZXR1cm4ge1N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgbm9ybWFsaXplZCB0byBhIHN0cmluZyAobWF5IGJlIGVtcHR5KVxuICAgICAqL1xuICAgIGF0dHIgPSBmdW5jdGlvbihlbCwgYXR0ck5hbWUsIGF0dHJWYWwpIHtcbiAgICAgIHZhciBlO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgIGlmIChhdHRyVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGF0dHJWYWwpO1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBhdHRyVmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWwsIDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMpIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBfY3N0cihlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIDApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGF0dHJWYWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJWYWw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2V0L0dldCB0aGUgQ1NTIHRleHQgb2YgYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgY3NzIGFzICRzZi5saWIuZG9tLmNzc1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBtYW5pcHVsYXRlXG4gICAgQHBhcmFtIHtTdHJpbmd9IFt2YWxdIHRoZSBDU1Mgc3RyaW5nIHRvIHNldCBpZiBzcGVjaWZpZWQgKGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3Bvc2l0aW9uOmFic29sdXRlO3RvcDowcHg7bGVmdDowcHhcIikuXG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBub3JtYWxpemVkIHRvIGEgc3RyaW5nIChtYXkgYmUgZW1wdHkpXG4gICAgICovXG4gICAgY3NzID0gZnVuY3Rpb24oZWwsIHZhbCkge1xuICAgICAgdmFyIGUsIHN0O1xuICAgICAgc3QgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBzdCA9IGVsLnN0eWxlO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdC5jc3NUZXh0ID0gX2NzdHIodmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBzdC5jc3NUZXh0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWFrZSBhIG5ldyBlbGVtZW50XG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20ubWFrZVxuICAgIEBleHBvcnRzIG1ha2VfZWxlbWVudCBhcyAkc2YubGliLmRvbS5tYWtlXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZVxuICAgIEBwYXJhbSB7RG9jdW1lbnR8SFRNTEVsZW1lbnR8V2luZG93fSBbcGFyZW50XSBlbGVtZW50LCBkb2N1bWVudCwgb3Igd2luZG93IHRvIG1ha2UgdGhlIHRhZyBpbiwgb3B0aW9uYWwuXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgbWFrZV9lbGVtZW50ID0gZnVuY3Rpb24odGFnTmFtZSwgcGFyKSB7XG4gICAgICByZXR1cm4gKChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBkb2MocGFyKSkgfHwgdGhlRG9jdW1lbnQpLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQXBwZW5kIGFuZCBIVE1MRWxlbWVudCB0byBhbm90aGVyIEhUTUxFbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXBwZW5kIGFzICRzZi5saWIuZG9tLmFwcGVuZFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyTm9kZSB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZCAoUmVxdWlyZWQpIHRoZSBuZXcgSFRNTCBlbGVtZW50IHRvIGFkZCB0byB0aGUgcGFyZW50XG4gICAgcmV0dXJuIHtIVE1MRWxlbWVudHxCb29sZWFufSB0aGUgbmV3IHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgZWxlbWVudCB0aGF0IHdhcyBhcHBlbmRlZCwgb3IgZmFsc2UgaWYgZmFpbHVyZVxuICAgICAqL1xuICAgIGFwcGVuZCA9IGZ1bmN0aW9uKHBhck5vZGUsIGNoaWxkKSB7XG4gICAgICB2YXIgZSwgc3VjY2VzcztcbiAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGFyTm9kZSkge1xuICAgICAgICAgIHN1Y2Nlc3MgPSBwYXJOb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBtZXRob2QgZm9yIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gYSBkb2N1bWVudCByYXRoZXIgdGhhbiBjYWxsaW5nIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQgcmF3LlxuICAgIEhhcyBzcGVjaWFsIHByb2Nlc3NpbmcgdG8gZW5zdXJlIHRoYXQgY29udGVudHMgb2YgSUZSQU1FIHRhZ3MgZ2V0cyByZWxlYXNlZCBmcm9tIG1lbW9yeSBhcyB3ZWxsXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcHVyZ2UgYXMgJHNmLmxpYi5kb20ucHVyZ2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgVGhlIEhUTUwgZWxlbWVudCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGRvbVxuICAgIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIHB1cmdlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGUsIGlzSUZyYW1lLCBwYXJOb2RlLCBzdWNjZXNzO1xuICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgcGFyTm9kZSA9IHZvaWQgMDtcbiAgICAgIGlzSUZyYW1lID0gdGFnTmFtZShub2RlKSA9PT0gSUZSQU1FO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGlmIChpc0lGcmFtZSkge1xuICAgICAgICBfY2FsbF94bXNnX2hvc3QoXCJkZXRhY2hcIiwgbm9kZSk7XG4gICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZChub2RlKTtcbiAgICAgICAgaWYgKCFpc0lFKSB7XG4gICAgICAgICAgYXR0cihub2RlLCBcInNyY1wiLCBCTEFOS19VUkwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBwYXJOb2RlID0gcGFyKG5vZGUpO1xuICAgICAgICBpZiAocGFyTm9kZSkge1xuICAgICAgICAgIHBhck5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgaWYgKGlzSUUgJiYgaXNJRnJhbWUpIHtcbiAgICAgICAgICAgIGdjKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBub2RlID0gcGFyTm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuXG4gICAgLypcbiAgICBBdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0byBhbiBIVE1MRWxlbWVudC4gIE5vdGUgbm9ybWFsaXplIGV2ZW50IG5hbWVzIHRvIGxvd2VyIGNhc2UgLyB3M2Mgc3RhbmRhcmRzLlxuICAgIFNlZSBleGFtcGxlLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGF0dGFjaCBhcyAkc2YubGliLmRvbS5hdHRhY2hcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gYXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgdG9vXG4gICAgQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b29cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgZnVuY3Rpb24gdXNlZCB0byBoYW5kbGUgdGhlIHBhcnRpY3VsYXIgZXZlbnRcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBlbCA9ICRzZi5saWIuZG9tLmVsdChcIm15X2VsZW1lbnRcIik7XG4gICAgZnVuY3Rpb24gaGFuZGxlX2NsaWNrKGV2dClcbiAgICB7XG4gICAgYWxlcnQoJ2kgd2FzIGNsaWNrZWQnKTtcbiAgICB9XG4gICAgXG4gICAgJHNmLmxpYi5kb20uYXR0YWNoKGVsLFwiY2xpY2tcIixoYW5kbGVfY2xpY2spO1xuICAgICAqL1xuICAgIGF0dGFjaCA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh1c2VfaWVfb2xkX2F0dGFjaCkge1xuICAgICAgICAgIG9ialt1c2VfYXR0YWNoXShcIm9uXCIgKyBuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW3VzZV9hdHRhY2hdKG5hbWUsIGNiLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIG9iaiA9IGNiID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBEZXRhY2ggYW4gZXZlbnQgaGFuZGxlciB0byBhbiBIVE1MRWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGRldGFjaCBhcyAkc2YubGliLmRvbS5kZXRhY2hcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgdG8gYXR0YWNoIGFuIGV2ZW50IGhhbmRsZXIgdG9vXG4gICAgQHBhcmFtIHtTdHJpbmd9IG5hbWV0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGhhbmRsZSB0aGUgcGFydGljdWxhciBldmVudFxuICAgICAqL1xuICAgIGRldGFjaCA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh1c2VfaWVfb2xkX2F0dGFjaCkge1xuICAgICAgICAgIG9iai5kZXRhY2hFdmVudChcIm9uXCIgKyBuYW1lLCBjYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgb2JqID0gY2IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIERPTSBpcyByZWFkeSB0byBiZSBtYW5pcHVsYXRlZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHJlYWR5IGFzICRzZi5saWIuZG9tLnJlYWR5XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnM7XG4gICAgICBycyA9IHZvaWQgMDtcbiAgICAgIF9jbGVhcl9yZWFkeV90aW1lcl9jaGVjaygpO1xuICAgICAgaWYgKGRvbV9pc19yZWFkeSkge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBycyA9IHRoZURvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgICBpZiAocnMpIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChycyA9PT0gXCJsb2FkZWRcIiB8fCBycyA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICBkb21fcmVhZHlfY2hrX3RyaWVzID0gZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gMDtcbiAgICAgIF9yZWFkeV9zdGF0ZV9jaGVjaygpO1xuICAgICAgcmV0dXJuICEhZG9tX2lzX3JlYWR5O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEZpcmUgb2ZmIGEgcGFydGljdWxhciBmdW5jdGlvbiB3aGVuIGl0IGlzIGRldGVjdGVkIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgIFVzZWZ1bCB3aGVuIHlvdSBkb24ndCBrbm93IGZvciBzdXJlIGlmIHRoZSBET00gb2YgdGhlIGJyb3dzZXIgaXMgcmVhZHkgb3Igbm90LCBzbyB0aGlzIHdpbGwgZGV0ZWN0IGFuZCBmaXJlXG4gICAgeW91ciBmdW5jdGlvbiBmb3IgeW91LlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHdhaXQgYXMgJHNmLmxpYi5kb20ud2FpdFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgQSBmdW5jdGlvbiByZWZlcmVuY2UgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuICAgICAqL1xuICAgIHdhaXQgPSBmdW5jdGlvbihjYikge1xuICAgICAgdmFyIGUsIHJkeTtcbiAgICAgIHJkeSA9IHJlYWR5KCk7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgaWYgKHJkeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChsYW5nLmNhbGxhYmxlKGNiKSkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdhaXQoY2IpO1xuICAgICAgICBjYiA9IG51bGw7XG4gICAgICB9KSwgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwgKyAxKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDYW5jZWwgdGhlIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZXZ0Q25jbCBhcyAkc2YubGliLmRvbS5ldnRDbmNsXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0ICBUaGUgcmF3IEhUTUwgZXZlbnRcbiAgICAgKi9cbiAgICBldnRDbmNsID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgZSwgcHJvcDtcbiAgICAgIHByb3AgPSBcIlwiO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGV2dCA9IGV2dCB8fCB3aW4uZXZlbnQ7XG4gICAgICBpZiAoZXZ0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICBmb3IgKHByb3AgaW4gRVZUX0NOQ0xfTUVUSE9EUykge1xuICAgICAgICAgIGlmIChFVlRfQ05DTF9NRVRIT0RTW3Byb3BdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBldnRbcHJvcF0oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gdGhlIHRhcmdldC9zcmNFbGVtZW50IG9mIGFuIGV2ZW50IGZyb20gYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZXZ0VGd0IGFzICRzZi5saWIuZG9tLmV2dFRndFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IEhUTUwgZXZlbnRcbiAgICAgKi9cbiAgICBldnRUZ3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlLCB0Z3Q7XG4gICAgICB0Z3QgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXZ0ID0gZXZ0IHx8IHdpbi5ldmVudDtcbiAgICAgICAgdGd0ID0gKGV2dCA/IGV2dFtldnRfdGd0X3Byb3BfYV0gfHwgZXZ0W2V2dF90Z3RfcHJvcF9iXSA6IG51bGwpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHRndCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGd0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBuYW1lc3BhY2UgJHNmLmxpYi5kb20uaWZyYW1lcyBEZWZpbmVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgc3BlY2lmaWNhbGx5IHdpdGggSUZSQU1FIHRhZ3MsIHdoaWNoIGlzIGtleSB0byBTYWZlRnJhbWVzIHRlY2ggaW4gYSBicm93c2VyLlxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXNcbiAgICBAcmVxdWlyZXMgJHNmLmxpYi5sYW5nXG4gICAgICovXG5cbiAgICAvKlxuICAgIENsb25lcyBhbiBpZnJhbWUuIC4gLlxuICAgIFRoaXMgY29kZSBjcmVhdGVzIC8gY2xvbmVzIGlmcmFtZSB0YWdzIGluIGEgdmVyeSBzcGVjaWZpYyB3YXkgdG8gZW5zdXJlIGJvdGggb3B0aW1hbCBwZXJmb3JtYW5jZSBhbmQgc3RhYmlsaXR5LlxuICAgIFdlIHVzZSBzdHJpbmcgYnVmZmVycyB0byBidWlsZCBtYXJrdXAgaW50ZXJuYWxseSwgd2hpY2ggaXMgdHlwaWNhbGx5IGZhc3RlciB0aGFuIHVzaW5nIGFsbCBET00gQVBJcy4gIEFsc29cbiAgICB3ZSBhbGxvdyB0aGUgdXNhZ2Ugb2YgdGhlIFwibmFtZVwiIGF0dHJpYnV0ZSBhcyBhIGRhdGEgcGlwZWxpbmUsIHdoaWNoIGluIHR1cm4gYWxsb3dzIGZvciBzeW5jaHJvbm91cyBkb3dud2FyZFxuICAgIHgtZG9tYWluIG1lc3NhZ2luZy5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLmNsb25lXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50L1N0cmluZ30gZWwgIEFuIGlmcmFtZSBlbGVtZW50IG9yIGlkIG9mIGFuIGlmcmFtZSBlbGVtZW50IHRvIGNsb25lXG4gICAgQHBhcmFtIHtPYmplY3R9IFthdHRyc10gIEEgaGFzaCBtYXAgb2Ygb3RoZXIgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIGlmcmFtZS4gIERvIG5vdCBzZXQgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGZyYW1lIGhlcmUsIHNlZSB0aGUgbmV4dCBhcmd1bWVudCBmb3IgdGhhdC5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2Nzc1RleHRdICBUaGUgc3R5bGUgc3RyaW5nIChhcyBpbiB3aGF0IHlvdSB3b3VsZCB1c2UgaW4gSFRNTCBtYXJrdXAsIGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtib3JkZXI6c29saWQgM3B4IGJsdWU7XCIpLCB0byB1c2UgZm9yIHRoaXMgaWZyYW1lXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gc3BlY2lmeSBmb3Igd2hlbiB0aGUgaWZyYW1lIGxvYWRzLlxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFt4bXNnQ0JdIEFuIG9wdGlvbmFsIGNhbGwgYmFjayBmb3IgcmVjZWl2aW5nIG1lc3NhZ2VzIGZyb20gdGhlIGlmcmFtZVxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgdGhlIGlmcmFtZSBub2RlIGlmIHN1Y2Nlc2Z1bGx5IGNyZWF0ZWQgb3IgbnVsbC4gIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGluc2VydCB0aGUgaWZyYW1lIGludG8gdGhlIGRvY3VtZW50IGZvciB5b3UuIC4gLlxuICAgICAqL1xuICAgIGNsb25lX2lmcmFtZSA9IGZ1bmN0aW9uKGVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQikge1xuICAgICAgcmV0dXJuIF9jbG9uZV9pZnJhbWUoZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAaWdub3JlXG4gICAgICovXG4gICAgX2Nsb25lX2lmcmFtZSA9IGZ1bmN0aW9uKGVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQiwgaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgIHZhciBhdHRyU3RyLCBidWZmZXJIVE1MLCBjbCwgaHRtbCwgbmV3Q2wsIHByb3AsIHRlbXAsIHhtc2dQaXBlO1xuICAgICAgYnVmZmVySFRNTCA9IFtcIjxcIiwgSUZSQU1FLCBcIiBcIl07XG4gICAgICB4bXNnUGlwZSA9IFwiXCI7XG4gICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgdGVtcCA9IHZvaWQgMDtcbiAgICAgIGNsID0gdm9pZCAwO1xuICAgICAgbmV3Q2wgPSB2b2lkIDA7XG4gICAgICBodG1sID0gdm9pZCAwO1xuICAgICAgYXR0clN0ciA9IHZvaWQgMDtcbiAgICAgIGlmICghaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgICAgZWwgPSBfYnlJRChlbCk7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSAhPT0gSUZSQU1FKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2wgPSBlbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2wgPSBlbDtcbiAgICAgIH1cbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICBpZiAoXCJzcmNcIiBpbiBhdHRycykge1xuICAgICAgICBhdHRyKGNsLCBcInNyY1wiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLnNyYyA9IGF0dHIoZWwsIFwic3JjXCIpIHx8IEJMQU5LX1VSTDtcbiAgICAgIH1cbiAgICAgIGlmIChcIm5hbWVcIiBpbiBhdHRycykge1xuICAgICAgICBhdHRyKGNsLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRycy5uYW1lID0gYXR0cihlbCwgXCJuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRycy5zcmMpIHtcbiAgICAgICAgYXR0cnMuc3JjID0gQkxBTktfVVJMO1xuICAgICAgfVxuICAgICAgeG1zZ1BpcGUgPSB4bXNnQ0IgJiYgX2NhbGxfeG1zZ19ob3N0KFwicHJlcFwiLCBhdHRycyk7XG4gICAgICBpZiAoIWlmcmFtZV9za2lwX2Nsb25lKSB7XG4gICAgICAgIGF0dHIoY2wsIFwid2lkdGhcIiwgbnVsbCk7XG4gICAgICAgIGF0dHIoY2wsIFwiaGVpZ2h0XCIsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgdGVtcCA9IGNzcyhjbCk7XG4gICAgICAgIGlmICh0ZW1wICYmIHRlbXAuY2hhckF0KHRlbXAubGVuZ3RoIC0gMSkgIT09IFwiO1wiKSB7XG4gICAgICAgICAgdGVtcCArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICBjc3MoY2wsIFt0ZW1wLCBfY3N0cihjc3NUZXh0KV0pO1xuICAgICAgfVxuICAgICAgdGVtcCA9IG1ha2VfZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGFwcGVuZCh0ZW1wLCBjbCk7XG4gICAgICBodG1sID0gdGVtcC5pbm5lckhUTUw7XG4gICAgICBhdHRyU3RyID0gaHRtbC5yZXBsYWNlKC88aWZyYW1lKC4qPyk+KC4qPyk8XFwvaWZyYW1lPi9nLCBcIiQxXCIpO1xuICAgICAgYnVmZmVySFRNTC5wdXNoKFwibmFtZT1cXFwiXCIsIGF0dHJzLm5hbWUsIFwiXFxcIiBcIiwgYXR0clN0ciwgXCI+PC9cIiwgSUZSQU1FLCBcIj5cIik7XG4gICAgICBkZWxldGUgYXR0cnMubmFtZTtcbiAgICAgIHRlbXAuaW5uZXJIVE1MID0gX2NzdHIoYnVmZmVySFRNTCk7XG4gICAgICBuZXdDbCA9IHRlbXAuZmlyc3RDaGlsZDtcbiAgICAgIGZvciAocHJvcCBpbiBhdHRycykge1xuICAgICAgICBhdHRyKG5ld0NsLCBwcm9wLCBhdHRyc1twcm9wXSk7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHIobmV3Q2wsIFwiaWRcIikpIHtcbiAgICAgICAgYXR0cihuZXdDbCwgXCJpZFwiLCBcInNmX1wiICsgSUZSQU1FICsgXCJfXCIgKyBpZnJhbWVfbmV4dF9pZCk7XG4gICAgICAgIGlmcmFtZV9uZXh0X2lkKys7XG4gICAgICB9XG4gICAgICBhdHRyKG5ld0NsLCBcIkZSQU1FQk9SREVSXCIsIFwibm9cIik7XG4gICAgICBhdHRyKG5ld0NsLCBcIlNDUk9MTElOR1wiLCBcIm5vXCIpO1xuICAgICAgYXR0cihuZXdDbCwgXCJBTExPV1RSQU5TUEFSRU5DWVwiLCB0cnVlKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiSElERUZPQ1VTXCIsIHRydWUpO1xuICAgICAgYXR0cihuZXdDbCwgXCJUQUJJTkRFWFwiLCAtMSk7XG4gICAgICBhdHRyKG5ld0NsLCBcIk1BUkdJTldJRFRIXCIsIDApO1xuICAgICAgYXR0cihuZXdDbCwgXCJNQVJHSU5IRUlHSFRcIiwgMCk7XG4gICAgICBfYmluZF9pZnJhbWVfb25sb2FkKG5ld0NsLCBjYik7XG4gICAgICBpZiAoeG1zZ1BpcGUpIHtcbiAgICAgICAgX2NhbGxfeG1zZ19ob3N0KFwiYXR0YWNoXCIsIG5ld0NsLCB4bXNnUGlwZSwgeG1zZ0NCKTtcbiAgICAgIH1cbiAgICAgIHhtc2dQaXBlID0geG1zZ0NCID0gY2wgPSBjYiA9IGVsID0gdGVtcCA9IG51bGw7XG4gICAgICByZXR1cm4gbmV3Q2w7XG4gICAgfTtcblxuICAgIC8qXG4gICAgTWFrZSBhIG5ldyBpZnJhbWVcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLm1ha2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAgQSBoYXNoIG1hcCBvZiBvdGhlciBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgaWZyYW1lLiAgRG8gbm90IHNldCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZnJhbWUgaGVyZSwgc2VlIHRoZSBuZXh0IGFyZ3VtZW50IGZvciB0aGF0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbY3NzVGV4dF0gIFRoZSBzdHlsZSBzdHJpbmcgKGFzIGluIHdoYXQgeW91IHdvdWxkIHVzZSBpbiBIVE1MIG1hcmt1cCwgZS5nLiBcImJhY2tncm91bmQtY29sb3I6cmVkO2JvcmRlcjpzb2xpZCAzcHggYmx1ZTtcIiksIHRvIHVzZSBmb3IgdGhpcyBpZnJhbWVcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9ICB0aGUgaWZyYW1lIG5vZGUgaWYgc3VjY2VzZnVsbHkgY3JlYXRlZCBvciBudWxsLiAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgaW5zZXJ0IHRoZSBpZnJhbWUgaW50byB0aGUgZG9jdW1lbnQgZm9yIHlvdS4gLiAuXG4gICAgICovXG4gICAgbWFrZV9pZnJhbWUgPSBmdW5jdGlvbihhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQikge1xuICAgICAgcmV0dXJuIF9jbG9uZV9pZnJhbWUobWFrZV9lbGVtZW50KElGUkFNRSksIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBIG1ldGhvZCB0byBpbnNlcnQgb3IgcmVwbGFjZSBhbiBIVE1MIHRhZyB3aXRoIGFuIElGUkFNRSB0YWcsIHdpdGggYSBuZXcgVVJMIGFuZCBhdHRyaWJ1dGVzLlxuICAgIFxuICAgIFVzZWQgZm9yIDMgcmVhc29uczpcbiAgICA8b2w+XG4gICAgPGxpPkl0IGF2b2lkcyBjbGljayBzb3VuZHMgb24gSUUuPC9saT5cbiAgICA8bGk+SXQgYWxsb3dzIGFsd2F5cyByZXNldHRpbmcgdGhlIHdpbmRvdy5uYW1lIHByb3BlcnR5IG9mIHRoZSBpZnJhbWVzIHVuZGVybHlpbmcgSFRNTFdpbmRvdyBvYmplY3QsIHVuZm9ydW5hdGVseSBJRSB3aWxsIG5vdCBsZXQgeW91IHNldCB0aGlzIGF0dHJpYnV0ZSBvbiBhIGNsb25lLjwvbGk+XG4gICAgPGxpPkl0IGVuc3VyZXMgdGhhdCBldmVudCBoYW5kbGVycyBpbiB0aGUgdW5kZXJseWluZyBkb2N1bWVudCBmb3IgdW5sb2FkaW5nIGFyZSBleGVjdXRlZC48L2xpPlxuICAgIDxsaT5DaGFuZ2luZyB0aGUgc3JjIGF0dHJpYnV0ZSBkaXJlY3RseSB3aWxsIHJlc3VsdCBpbiBhIGJyb3dzZXIgaGlzdG9yeSB1cGRhdGUsIHdoaWNoIHdlIGRvIG5vdCB3YW50LjwvbGk+XG4gICAgPC9vbD5cbiAgICBcbiAgICBXZSBjb3VsZCBqdXN0IGNoYW5nZSBsb2NhdGlvbi5ocmVmIHByb3BlcnR5IG9yIGNhbGwgbG9jYXRpb24ucmVwbGFjZSwgaG93ZXZlciB0aGF0IGlzIG5vdCBhbHdheXMgIHBvc3NpYmxlIHNpbmNlXG4gICAgdGhlIGZyYW1lIGNvdWxkIGJlIHgtZG9tYWluLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMucmVwbGFjZVxuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBIGhhc2ggbWFwIG9mIG90aGVyIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBpZnJhbWUuICBEbyBub3Qgc2V0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSBmcmFtZSBoZXJlLCBzZWUgdGhlIG5leHQgYXJndW1lbnQgZm9yIHRoYXQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjc3NUZXh0XSAgVGhlIHN0eWxlIHN0cmluZyAoYXMgaW4gd2hhdCB5b3Ugd291bGQgdXNlIGluIEhUTUwgbWFya3VwLCBlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7Ym9yZGVyOnNvbGlkIDNweCBibHVlO1wiKSwgdG8gdXNlIGZvciB0aGlzIGlmcmFtZVxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBbcGFyUmVmXSAgQW4gcGFyZW50IGVsZW1lbnQgb3IgcGFyZW50IGVsZW1lbnQgaWQsIHRvIGJlIHVzZWQgb25seSBpZiBhIG5ldyBpZnJhbWUgaXMgY3JlYXRlZCwgdGhlIGlmcmFtZSB3aWxsIGJlIGFwcGVuZCB0byB0aGF0IHBhcmVudCwgaWYgbm90IHNwZWNpZmllZCBkb2N1bWVudCBib2R5IGlzIHVzZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9IGEgcmVmZXJlbmNlIHRvIHRoZSBuZXdseSBjcmVhdGVkIGlmcmFtZSBlbGVtZW50IGlmIHN1Y2Nlc3NmdWxseSBpbnNlcnRlZCwgb3RoZXJ3aXNlIG51bGwuXG4gICAgICovXG4gICAgcmVwbGFjZV9pZnJhbWUgPSBmdW5jdGlvbihhdHRycywgY3NzVGV4dCwgcGFyUmVmLCBjYiwgeG1zZ0NCKSB7XG4gICAgICB2YXIgY2wsIGUsIGVsLCBlbElELCBmcmFtZUVsLCBwYXJOb2RlLCB0Z247XG4gICAgICBjbCA9IHZvaWQgMDtcbiAgICAgIGVsID0gdm9pZCAwO1xuICAgICAgZnJhbWVFbCA9IHZvaWQgMDtcbiAgICAgIGVsSUQgPSB2b2lkIDA7XG4gICAgICB0Z24gPSB2b2lkIDA7XG4gICAgICBwYXJOb2RlID0gdm9pZCAwO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICBlbElEID0gYXR0cnMuaWQ7XG4gICAgICBlbCA9IGVsSUQgJiYgX2J5SUQoZWxJRCk7XG4gICAgICB0Z24gPSB0YWdOYW1lKGVsKTtcbiAgICAgIGVsID0gKHRnbiA/IGVsIDogbnVsbCk7XG4gICAgICBmcmFtZUVsID0gKHRnbiA9PT0gSUZSQU1FID8gZWwgOiBudWxsKTtcbiAgICAgIGlmIChmcmFtZUVsKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdChcImRldGFjaFwiLCBmcmFtZUVsKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKGZyYW1lRWwpO1xuICAgICAgICBwYXJOb2RlID0gcGFyKGZyYW1lRWwpO1xuICAgICAgICBjbCA9IGNsb25lX2lmcmFtZShmcmFtZUVsLCBhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQik7XG4gICAgICAgIGF0dHIoY2wsIFwib25sb2FkXCIsIG51bGwpO1xuICAgICAgICBhdHRyKGNsLCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJSZWYpIHtcbiAgICAgICAgICBwYXJSZWYgPSBfYnlJRChwYXJSZWYpO1xuICAgICAgICAgIGlmICh0YWdOYW1lKHBhclJlZikpIHtcbiAgICAgICAgICAgIHBhck5vZGUgPSBwYXJSZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyTm9kZSAmJiBlbCkge1xuICAgICAgICAgIHBhck5vZGUgPSBwYXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGNzc1RleHQgPSBfY3N0cihjc3NUZXh0KSB8fCBjc3MoZWwpIHx8IFwiXCI7XG4gICAgICAgIGNsID0gbWFrZV9pZnJhbWUoYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFwYXJOb2RlKSB7XG4gICAgICAgICAgYXBwZW5kKHRoZURvY3VtZW50LmJvZHksIGNsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZnJhbWVFbCkge1xuICAgICAgICAgICAgcGFyTm9kZS5yZXBsYWNlQ2hpbGQoY2wsIGZyYW1lRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgcGFyTm9kZS5yZXBsYWNlQ2hpbGQoY2wsIGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGVuZChwYXJOb2RlLCBjbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBjbCA9IGVsID0gYXR0cnMgPSBmcmFtZUVsID0gcGFyTm9kZSA9IGNiID0gbnVsbDtcbiAgICAgIHJldHVybiBlbHQoZWxJRCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgdGhlIHdpbmRvdyByZWZlcmVuY2UgaW5zaWRlIG9mIGFuIElGUkFNRS4gTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggJHNmLmxpYi5kb20udmlldyB3aGljaFxuICAgIHJldHVybnMgdGhlIHBhcmVudCB3aW5kb3cgcmVmZXJlbmNlIG9mIGFuIGVsZW1lbnQuXG4gICAgXG4gICAgTm90ZSB0aGF0IGV2ZW4gaW4gY3Jvc3MtZG9tYWluIHNjZW5hcmlvcywgeW91IGFyZSBzdXBwb3NlZCB0byBhYmxlIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHdpbmRvdyByZWZlcmVuY2UuXG4gICAgSW4gYSBjcm9zcy1kb21haW4gc2NlbmFyaW8sIHlvdSB3b3VsZCBub3QgYmUgYWJsZSB0byB0aGVuIGFjZXNzcyBtb3N0IHByb3BlcnRpZXMgLyBtZXRob2RzIC8gb2JqZWN0cyBvZiB0aGF0XG4gICAgd2luZG93LCBidXQgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgYWxsb3dlZC5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5pZnJhbWVzLnZpZXdcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBpZnJhbWUgZWxlbWVudCB0byBzYWZlbHkgZ2V0IGJhY2sgdGhlIHdpbmRvd1xuICAgIEByZXR1cm4ge0hUTUxXaW5kb3d9IHRoZSB3aW5kb3cgcmVmZXJlbmNlIGluc2lkZSB0aGUgaWZyYW1lLlxuICAgICAqL1xuICAgIGlmcmFtZV92aWV3ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBlLCBlbERvYywgZWxXaW4sIGVyciwgZmUsIGZyYW1lLCBmcmFtZV9saXN0LCBpZHgsIGxvY2FsV2luO1xuICAgICAgbG9jYWxXaW4gPSB2b2lkIDA7XG4gICAgICBlbFdpbiA9IHZvaWQgMDtcbiAgICAgIGVsRG9jID0gdm9pZCAwO1xuICAgICAgZnJhbWVfbGlzdCA9IHZvaWQgMDtcbiAgICAgIGZyYW1lID0gdm9pZCAwO1xuICAgICAgZmUgPSB2b2lkIDA7XG4gICAgICBpZHggPSAwO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIGVyciA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsV2luID0gZWwuY29udGVudFdpbmRvdyB8fCBudWxsO1xuICAgICAgICBpZiAoIXdpbikge1xuICAgICAgICAgIGVsRG9jID0gZG9jKGVsKTtcbiAgICAgICAgICBlbFdpbiA9IGVsRG9jICYmIHZpZXcoZWxEb2MpO1xuICAgICAgICAgIGZyYW1lX2xpc3QgPSAoZWxXaW4gJiYgZWxXaW4uZnJhbWVzKSB8fCBbXTtcbiAgICAgICAgICB3aGlsZSAoZnJhbWUgPSBmcmFtZV9saXN0W2lkeCsrXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZmUgPSBmcmFtZS5mcmFtZUVsZW1lbnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgICAgICBmZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmUgJiYgZmUgPT09IGVsKSB7XG4gICAgICAgICAgICAgIGxvY2FsV2luID0gZnJhbWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGxvY2FsV2luID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NhbFdpbjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAaWdub3JlXG4gICAgICovXG4gICAgZ2MgPSBfbGFuZy5ub29wO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBBVFRSX05BTUUsIENSRUFURV9FVkVOVCwgRVZUX1RZUEUsIGVyciwgb2JqLCBwcm9wO1xuICAgICAgb2JqID0gdm9pZCAwO1xuICAgICAgQVRUUl9OQU1FID0gXCJTQ1JPTExJTkdcIjtcbiAgICAgIENSRUFURV9FVkVOVCA9IFwiY3JlYXRlRXZlbnRcIjtcbiAgICAgIEVWVF9UWVBFID0gXCJVSUV2ZW50XCI7XG4gICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgZXJyID0gdm9pZCAwO1xuICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2EgPSBcInNyY0VsZW1lbnRcIjtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2IgPSBcInRhcmdldFwiO1xuICAgICAgICBvYmogPSBtYWtlX2VsZW1lbnQoSUZSQU1FKTtcbiAgICAgICAgYXR0cihvYmosIEFUVFJfTkFNRSwgXCJub1wiKTtcbiAgICAgICAgdXNlT2xkU3R5bGVBdHRyTWV0aG9kcyA9IGF0dHIob2JqLCBBVFRSX05BTUUpICE9PSBcIm5vXCI7XG4gICAgICAgIGlmIChHQyBpbiB3aW4pIHtcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgQGlnbm9yZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGdjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZ2NfdGltZXJfaWQpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdjX3RpbWVyX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjX3RpbWVyX2lnKHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luW0dDXSgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgICAgICB9LCBJRV9HQ19JTlRFUlZBTCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2MgPSBfbGFuZy5ub29wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldnRfdGd0X3Byb3BfYSA9IFwidGFyZ2V0XCI7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9iID0gXCJjdXJyZW50VGFyZ2V0XCI7XG4gICAgICB9XG4gICAgICBpZiAod2luW3czY19hdHRhY2hdICYmICFpc0lFKSB7XG4gICAgICAgIHVzZV9hdHRhY2ggPSB3M2NfYXR0YWNoO1xuICAgICAgICB1c2VfZGV0YWNoID0gdzNjX2RldGFjaDtcbiAgICAgIH0gZWxzZSBpZiAoaXNJRSkge1xuICAgICAgICB1c2VfaWVfb2xkX2F0dGFjaCA9IHRydWU7XG4gICAgICAgIHVzZV9hdHRhY2ggPSBpZV9hdHRhY2g7XG4gICAgICAgIHVzZV9kZXRhY2ggPSBpZV9kZXRhY2g7XG4gICAgICB9XG4gICAgICBvYmogPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqID0gdGhlRG9jdW1lbnRbQ1JFQVRFX0VWRU5UXShFVlRfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICBvYmogPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYmogPSB0aGVEb2N1bWVudFtDUkVBVEVfRVZFTlRdKEVWVF9UWVBFICsgXCJzXCIpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgb2JqID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iaikge1xuICAgICAgICBmb3IgKHByb3AgaW4gRVZUX0NOQ0xfTUVUSE9EUykge1xuICAgICAgICAgIGlmIChvYmpbcHJvcF0pIHtcbiAgICAgICAgICAgIEVWVF9DTkNMX01FVEhPRFNbcHJvcF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqID0gbnVsbDtcbiAgICAgIGF0dGFjaCh3aW4sIFwibG9hZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICByZXR1cm4gYXR0YWNoKHdpbiwgXCJET01Db250ZW50TG9hZGVkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBkb20gPSB7XG4gICAgICBkb2M6IGRvYyxcbiAgICAgIHZpZXc6IHZpZXcsXG4gICAgICBlbHQ6IGVsdCxcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICB0YWdzOiB0YWdzLFxuICAgICAgcGFyOiBwYXIsXG4gICAgICBtYWtlOiBtYWtlX2VsZW1lbnQsXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIGF0dHI6IGF0dHIsXG4gICAgICBnYzogZ2MsXG4gICAgICBhcHBlbmQ6IGFwcGVuZCxcbiAgICAgIHB1cmdlOiBwdXJnZSxcbiAgICAgIGF0dGFjaDogYXR0YWNoLFxuICAgICAgZGV0YWNoOiBkZXRhY2gsXG4gICAgICByZWFkeTogcmVhZHksXG4gICAgICB3YWl0OiB3YWl0LFxuICAgICAgZXZ0Q25jbDogZXZ0Q25jbCxcbiAgICAgIGV2dFRndDogZXZ0VGd0LFxuICAgICAgaWZyYW1lczoge1xuICAgICAgICBtYWtlOiBtYWtlX2lmcmFtZSxcbiAgICAgICAgY2xvbmU6IGNsb25lX2lmcmFtZSxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZV9pZnJhbWUsXG4gICAgICAgIHZpZXc6IGlmcmFtZV92aWV3XG4gICAgICB9XG4gICAgfTtcbiAgfSkod2luZG93LCBsYW5nLCBlbnYpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGxhbmcsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgbGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBjYWNoZWRfdWEsIGlzSUUsIGlzSUUxMSwgbmF2aWdhdG9yLCB0aGVEb2N1bWVudCwgdWEsIHVzZXJBZ2VudCwgd2luO1xuICAgIHdpbiA9IHdpbmRvdztcbiAgICBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuICAgIHRoZURvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHVzZXJBZ2VudCA9IChuYXZpZ2F0b3IgIT0gbnVsbCA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiB2b2lkIDApIHx8IFwiXCI7XG4gICAgaXNJRTExID0gIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmIF9faW5kZXhPZi5jYWxsKHdpbmRvdywgXCJBY3RpdmVYT2JqZWN0XCIpID49IDA7XG4gICAgaXNJRSA9ICFpc0lFMTEgJiYgKHdpbiAmJiAoX19pbmRleE9mLmNhbGwod2luLCBcIkFjdGl2ZVhPYmplY3RcIikgPj0gMCkpO1xuICAgIGNhY2hlZF91YSA9IG51bGw7XG4gICAgdWEgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgIC8qXG4gICAgICBDb252ZXJ0IGEgdmVyc2lvbiBzdHJpbmcgaW50byBhIG51bWVyaWMgdmFsdWVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS1fbnVtYmVyaWZ5XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gcyBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIHZlcnNpb24gbnVtYmVyIChlLmcuICdtYWpvci5taW5vci5yZXZpc2lvbicpXG4gICAgICBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB2YXIgcGFyc2VfdWEsIF9tYXRjaEl0LCBfbnVtYmVyaWZ5LCBfdGVzdEl0O1xuICAgICAgX251bWJlcmlmeSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIGMgPSAwO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzLnJlcGxhY2UoL1xcLi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYysrID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFdyYXBwZXIgbWV0aG9kIGZvciByZXR1cm5pbmcgdmFsdWVzIGZyb20gYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2ggc2FmZWx5LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLV9tYXRjaEl0XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgQHBhcmFtIHtSZWdFeHB9IHJlZ0V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdXNlIGZvciBtYXRjaGluZ1xuICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtpZHhdIFRoZSBpbmRleCBudW1iZXIgb2YgYSBtYXRjaCB0byBwdWxsIGZyb21cbiAgICAgIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIF9tYXRjaEl0ID0gZnVuY3Rpb24oc3RyLCByZWdFeCwgaWR4KSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICBtID0gc3RyICYmIHN0ci5tYXRjaChyZWdFeCk7XG4gICAgICAgIGlmICghKGlkeCAhPSBudWxsKSkge1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAobSAmJiBtW2lkeF0pIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBXcmFwcGVyIG1ldGhvZCBmb3IgdGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEtX3Rlc3RJdFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtSZWdFeHB9IHJlZ0V4IFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gdGVzdCB3aXRoXG4gICAgICBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICBAcGFyYW0ge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIF90ZXN0SXQgPSBmdW5jdGlvbihyZWdFeCwgc3RyKSB7XG4gICAgICAgIHJldHVybiByZWdFeC50ZXN0KHN0cik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUGFyc2UgYSB1c2VyLWFnZW50IHN0cmluZyBmcm9tIHRoZSBicm93c2VyIGFuZCBnYXRoZXIgcGVydGluZW50IGJyb3dzZXIsIGFuZCBPUyBpbmZvcm1hdGlvblxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnBhcnNlXG4gICAgICBAc3RhdGljXG4gICAgICBAcHVibGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbc3ViVUFdIEFuIGFsdGVybmF0ZSB1c2VyLWFnZW50IHN0cmluZyB0byBwYXJzZS4gSWYgbm8gdmFsaWQgc3RyaW5nIGlzIHBhc3NlZCBpbiwgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gb2JqZWN0IGJhc2VkIG9uIHRoZSBrbm93biB1c2VyLWFnZW50XG4gICAgICBAcmV0dXJucyB7T2JqZWN0fSA8Yj5wYXJzZWQ8L2I+IEJyb3dzZXIgYW5kIE9TIGluZm9ybWF0aW9uPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmllICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+Lm9wZXJhIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgT3BlcmEgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uZ2Vja28gVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBHZWNrbyAoRmlyZWZveCkgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ud2Via2l0IFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViS2l0IGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnNhZmFyaSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNhZmFyaSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5jaHJvbWUgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDaHJvbWUgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uYWlyIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQUlSIFNESyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaXBvZCBXaGV0aGVyIG9yIG5vdCBhbiBpUG9kIGRldmljZSBpcyBiZWluZyB1c2VkIDEgZm9yIHRydWUsIDAgZm9yIGZhbHNlLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pcGFkIFdoZXRoZXIgb3Igbm90IGFuIGlQYWQgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmlwaG9uZSBXaGV0aGVyIG9yIG5vdCBhbiBpUGhvbmUgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmFuZHJvaWQgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBbmRyb2lkIE9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi53ZWJvcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYk9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5zaWxrIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2lsayBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5ub2RlanMgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBOb2RlSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnBoYW50b21qcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFBoYW50b21KUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtTdHJpbmd9IDxiPnBhcnNlZDwvYj4ubW9iaWxlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIG9zIGlzIGEgbW9iaWxlIGRldmljZSAgYW5kIGl0J3MgdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSAnd2luZG93cycsICdhbmRyb2lkJywgJ3N5bWJvcycsICdsaW51eCcsICdtYWNpbnRvc2gnLCAncmhpbm8nLCAnZ2Vja28nLCAnQXBwbGUnLCAnY2hyb21lJy48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaW9zIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgaU9TIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge0Jvb2xlYW59IDxiPnBhcnNlZDwvYj4uYWNjZWwgV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBlbnZpcm9ubWVudCBpbiBxdWVzdGlvbiBpcyBoYXJkd2FyZSBhY2NlbGVyYXRlZC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uY2FqYVZlcnNpb24gVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDQUpBIGVudmlyb25tZW50IG9yIDAgaWYgbm90LlxuICAgICAgICovXG4gICAgICBwYXJzZV91YSA9IGZ1bmN0aW9uKHN1YlVBKSB7XG4gICAgICAgIHZhciBkYXRlLCBlLCBtYXRjaCwgcmV0O1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmICghc3ViVUEgJiYgY2FjaGVkX3VhKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZF91YTtcbiAgICAgICAgfVxuICAgICAgICByZXQuaWUgPSByZXQub3BlcmEgPSByZXQuZ2Vja28gPSByZXQud2Via2l0ID0gcmV0LnNhZmFyaSA9IHJldC5jaHJvbWUgPSByZXQuYWlyID0gcmV0Lmlwb2QgPSByZXQuaXBhZCA9IHJldC5pcGhvbmUgPSByZXQuYW5kcm9pZCA9IHJldC53ZWJvcyA9IHJldC5zaWxrID0gcmV0Lm5vZGVqcyA9IHJldC5waGFudG9tanMgPSAwO1xuICAgICAgICByZXQubW9iaWxlID0gcmV0LmlvcyA9IHJldC5vcyA9IG51bGw7XG4gICAgICAgIHJldC5hY2NlbCA9IGZhbHNlO1xuICAgICAgICByZXQuY2FqYSA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuY2FqYVZlcnNpb247XG4gICAgICAgIHJldC5ja3MgPSBmYWxzZTtcbiAgICAgICAgc3ViVUEgPSBzdWJVQSB8fCB1c2VyQWdlbnQgfHwgXCJcIjtcbiAgICAgICAgaWYgKHN1YlVBKSB7XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL3dpbmRvd3N8d2luMzIvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcIndpbmRvd3NcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL21hY2ludG9zaHxtYWNfcG93ZXJwYy9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwibWFjaW50b3NoXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9hbmRyb2lkL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJhbmRyb2lkXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9zeW1ib3MvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcInN5bWJvc1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvbGludXgvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcImxpbnV4XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfdGVzdEl0KC9yaGluby9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgcmV0Lm9zID0gXCJyaGlub1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvS0hUTUwvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC53ZWJraXQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvSUVNb2JpbGV8WEJMV1A3Lywgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQubW9iaWxlID0gXCJ3aW5kb3dzXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9GZW5uZWMvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcImdlY2tvXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BcHBsZVdlYktpdFxcLyhbXlxcc10qKS8sIDEpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0LndlYmtpdCA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgcmV0LnNhZmFyaSA9IHJldC53ZWJraXQ7XG4gICAgICAgICAgICBpZiAoX3Rlc3RJdCgvUGhhbnRvbUpTLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9QaGFudG9tSlNcXC8oW15cXHNdKikvLCAxKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0LnBoYW50b21qcyA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3Rlc3RJdChSZWdFeHAoXCIgTW9iaWxlXFxcXC9cIiksIHN1YlVBKSB8fCBfdGVzdEl0KC9pUGFkfGlQb2R8aVBob25lLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIkFwcGxlXCI7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9PUyAoW15cXHNdKikvLCAxKTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaCAmJiBfbnVtYmVyaWZ5KG1hdGNoLnJlcGxhY2UoXCJfXCIsIFwiLlwiKSk7XG4gICAgICAgICAgICAgIHJldC5pb3MgPSBtYXRjaDtcbiAgICAgICAgICAgICAgcmV0LmlwYWQgPSByZXQuaXBvZCA9IHJldC5pcGhvbmUgPSAwO1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvaVBhZHxpUG9kfGlQaG9uZS8sIDApO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXRbbWF0Y2gudG9Mb3dlckNhc2UoKV0gPSByZXQuaW9zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvTm9raWFOW15cXC9dKnxBbmRyb2lkIFxcZFxcLlxcZHx3ZWJPU1xcL1xcZFxcLlxcZC8sIDApO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gbWF0Y2g7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoL3dlYk9TLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiV2ViT1NcIjtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvd2ViT1NcXC8oW15cXHNdKik7LywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQud2Vib3MgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoUmVnRXhwKFwiIEFuZHJvaWRcIiksIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIkFuZHJvaWRcIjtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvQW5kcm9pZCAoW15cXHNdKik7LywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQuYW5kcm9pZCA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvU2lsay8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9TaWxrXFwvKFteXFxzXSopXFwpLywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICByZXQuc2lsayA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJldC5hbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICByZXQuYW5kcm9pZCA9IDIuMzQ7XG4gICAgICAgICAgICAgICAgICByZXQub3MgPSBcIkFuZHJvaWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90ZXN0SXQoL0FjY2VsZXJhdGVkPXRydWUvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hY2NlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCA9IHN1YlVBLm1hdGNoKC8oQ2hyb21lfENyTW8pXFwvKFteXFxzXSopLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0gJiYgbWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgcmV0LmNocm9tZSA9IF9udW1iZXJpZnkobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICByZXQuc2FmYXJpID0gMDtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSBcIkNyTW9cIikge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcImNocm9tZVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvQWRvYmVBSVJcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0LmFpciA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmV0LndlYmtpdCkge1xuICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09wZXJhW1xcc1xcL10oW15cXHNdKikvLCAxKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICByZXQub3BlcmEgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09wZXJhIE1pbmlbXjtdKi8sIDApO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gbWF0Y2g7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9NU0lFXFxzKFteO10qKS8sIDEpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQuaWUgPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvR2Vja29cXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5nZWNrbyA9IDE7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvcnY6KFteXFxzXFwpXSopLywgMSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmdlY2tvID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgMTAwMCk7XG4gICAgICAgICAgdGhlRG9jdW1lbnQuY29va2llID0gbGFuZy5jc3RyKFtcInNmX2NrX3RzdD10ZXN0OyBleHBpcmVzPVwiLCBkYXRlLnRvR01UU3RyaW5nKCksIFwiOyBwYXRoPS9cIl0pO1xuICAgICAgICAgIGlmICh0aGVEb2N1bWVudC5jb29raWUuaW5kZXhPZihcInNmX2NrX3RzdFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldC5ja3MgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICByZXQuY2tzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgICAgICAgICByZXQub3MgPSBwcm9jZXNzLnBsYXRmb3JtO1xuICAgICAgICAgICAgICByZXQubm9kZWpzID0gbnVtYmVyaWZ5KHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJldC5ub2RlanMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBJbnRlcm5ldCBFeHBsb3JlciBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmllXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE9wZXJhIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAbmFtZSAkc2YuZW52LnVhLm9wZXJhXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEdlY2tvIChGaXJlZm94KSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5nZWNrb1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJLaXQgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEud2Via2l0XG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNhZmFyaSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5zYWZhcmlcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ2hyb21lIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmNocm9tZVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBSVIgU0RLIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5haXJcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IGFuIGlQb2QgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcG9kXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCBhbiBpUGFkIGRldmljZSBpcyBiZWluZyB1c2VkLCAwIGZvciBmYWxzZSwgJmd0OyAwID09IHRydWVcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaXBhZFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgYW4gaVBob25lIGRldmljZSBpcyBiZWluZyB1c2VkLCAwIGZvciBmYWxzZSwgJmd0OyAwID09IHRydWVcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaXBob25lXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFuZHJvaWQgT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmFuZHJvaWRcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLndlYm9zXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFNpbGsgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuc2lsa1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBOb2RlSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLm5vZGVqc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBQaGFudG9tSlMgZW52aXJvbm1lbnQgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnBoYW50b21qc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gb3MgaXMgYSBtb2JpbGUgZGV2aWNlICBhbmQgaXQncyB0eXBlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd3aW5kb3dzJywgJ2FuZHJvaWQnLCAnc3ltYm9zJywgJ2xpbnV4JywgJ21hY2ludG9zaCcsICdyaGlubycsICdnZWNrbycsICdBcHBsZScsICdjaHJvbWUnLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLm1vYmlsZVxuICAgICAgQHR5cGUge1N0cmluZ31cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBpT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlvc1xuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBlbnZpcm9ubWVudCBpbiBxdWVzdGlvbiBpcyBoYXJkd2FyZSBhY2NlbGVyYXRlZC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuYWNjZWxcbiAgICAgIEB0eXBlIHtCb29sZWFufVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENBSkEgZW52aXJvbm1lbnQgb3IgMCBpZiBub3RcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuY2FqYVZlcnNpb25cbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cbiAgICAgIGNhY2hlZF91YSA9IHBhcnNlX3VhKCk7XG4gICAgICBjYWNoZWRfdWEucGFyc2UgPSBwYXJzZV91YTtcbiAgICAgIHJldHVybiBjYWNoZWRfdWE7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdWE6IHVhLFxuICAgICAgaXNJRTogaXNJRVxuICAgIH07XG4gIH0pKHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiOER3b2hSXCIpKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIFBhcmFtSGFzaCwgYmFja1NsYXNoLCBjYWxsYWJsZSwgY2Jvb2wsIGNudW0sIGNzdHIsIGRlZiwgZW50aXR5TWFwLCBlbnRpdHlSZWdleGVzLCBndWlkLCBpc0FycmF5LCBqc3NhZmVfaHRtbCwganN1bnNhZmVfaHRtbCwgaywga2V5cywgbGFuZywgbWl4LCBuZXh0X2lkLCBub29wLCBucywgcHJvdG8sIHJhbmQsIHNjcmlwX3N0ciwgdGltZSwgdG9TdHJpbmcsIHRyaW0sIHYsIHdpbiwgd3JhcCwgX2VzLCBfcmVmLCBfdWU7XG4gICAgbmV4dF9pZCA9IDA7XG4gICAgd2luID0gd2luZG93O1xuICAgIGJhY2tTbGFzaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTIpO1xuICAgIHNjcmlwX3N0ciA9ICdzY3JcIitcImlwdCc7XG4gICAgX2VzID0gd2luLmVzY2FwZTtcbiAgICBfdWUgPSB3aW4udW5lc2NhcGU7XG5cbiAgICAvKlxuICAgIEEgZnVuY3Rpb24gcmVmZXJlbmNlIHRoYXQgZG9lcyBub3RoaW5nLlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBub29wIGFzICRzZi5saWIubGFuZy5ub29wXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwdWJsaWNcbiAgICBAcmV0dXJuIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIG5vb3AgPSBmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBOb3RlIHRoYXQgXCJmYWxzeVwiIHZhbHVlcyBvciB2YWx1ZXMgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgIGFzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikuXG4gICAgICBcbiAgICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICAgIEBleHBvcnRzIGNzdHIgYXMgJHNmLmxpYi5sYW5nLmNzdHJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHsqfSBzdHIgIEFueSBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9ICBUaGUgbm9ybWFsaXplZCBzdHJpbmcgdmFsdWUuXG4gICAgICAgKi9cbiAgICB9O1xuICAgIGNzdHIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciB0eXA7XG4gICAgICB0eXAgPSB0eXBlb2Ygc3RyO1xuICAgICAgaWYgKHR5cCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJudW1iZXJcIiAmJiAhc3RyKSB7XG4gICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwib2JqZWN0XCIgJiYgc3RyICYmIHN0ci5qb2luKSB7XG4gICAgICAgIHJldHVybiBzdHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIGJvb2xlYW4uXG4gICAgXCJGYWxzeVwiIHZhbHVlcyBzdWNoIGFzIFwiXCIsIDAsIG51bGwsIGFuZCB1bmRlZmluZWQgYWxsIHJldHVybiBmYWxzZVxuICAgIFN0cmluZyB2YWx1ZXMgb2YgIFwiMFwiLCBcImZhbHNlXCIsIFwibm9cIiwgXCJ1bmRlZmluZWRcIiwgXCJudWxsXCIgYWxzbyByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY2Jvb2wgYXMgJHNmLmxpYi5sYW5nLmNib29sXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0geyp9IHZhbCBBbnkgSmF2YVNjcmlwdCByZWZlcmVuY2UgLyB2YWx1ZVxuICAgIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub3JtYWxpemVkIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBjYm9vbCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKCF2YWwgfHwgdmFsID09PSBcIjBcIiB8fCB2YWwgPT09IFwiZmFsc2VcIiB8fCB2YWwgPT09IFwibm9cIiB8fCB2YWwgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBrLCBfdjtcbiAgICAgIHJldHVybiAodHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3Qua2V5cyhvYmopIDogdm9pZCAwKSB8fCAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICBfdiA9IG9ialtrXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEZvcmNlcyB0eXBlIGNvbnZlcnNpb24gb2YgYW55IEphdmFTY3JpcHQgdmFyaWFibGUgdG8gYSBudW1iZXIuXG4gICAgVmFsdWVzIC8gb2JqZWN0cyB0aGF0IGNhbm5vdCBiZSBjb252ZXJ0ZWQsIHdpbGwgYmUgcmV0dXJuZWQgYXMgTmFOLCB1bmxlc3NcbiAgICBhIGRlZmF1bHQgdmFsdWUgaXMgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHVzZWQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGNudW0gYXMgJHNmLmxpYi5sYW5nLmNudW1cbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7Kn0gdmFsIEFueSBKYXZhU2NyaXB0IHJlZmVyZW5jZSAvIHZhbHVlXG4gICAgQHBhcmFtIHsqfSBbZGVmVmFsXSB1c2UgdGhpcyB2YWx1ZSBpZiBvcmlnaW5hbCB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLCBvciBpZiB2YWx1ZSBpcyBsZXNzIHRoYW4gbWluIHZhbHVlLCBvciBpZiB2YWx1ZSBpcyBsZXNzIHRoYW4gbWF4IHZhbHVlLlxuICAgIEBwYXJhbSB7TnVtYmVyfSBbbWluVmFsXSBzcGVjaWZpZXMgdGhlIGxvd2VzdCBudW1lcmljYWwgdmFsdWUsIGlmIG9yaWdpbmFsIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLCB0aGUgZGVmVmFsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgQHBhcmFtIHtOdW1iZXJ9IFttYXhWYWxdIHNwZWNpZmllcyB0aGUgZ3JlYXRlc3QgbnVtZXJpY2FsIHZhbHVlLCBpZiBvcmlnaW5hbCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGRlZlZhbCB3aWxsIGJlIHJldHVybmVkLlxuICAgIEByZXR1cm4ge051bWJlcnxOYU58Kn0gdGhlIGNvbnZlcnRlZCB2YWx1ZSwgb3RoZXJ3aXNlIE5hTiBvciBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgY251bSA9IGZ1bmN0aW9uKHZhbCwgZGVmVmFsLCBtaW5WYWwsIG1heFZhbCkge1xuICAgICAgdmFyIGU7XG4gICAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICB2YWwgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHZhbCA9IE51bWJlci5OYU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXhWYWwgPT0gbnVsbCkge1xuICAgICAgICBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKG1pblZhbCA9PSBudWxsKSB7XG4gICAgICAgIG1pblZhbCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKChpc05hTih2YWwpIHx8IHZhbCA8IG1pblZhbCB8fCB2YWwgPiBtYXhWYWwpICYmIChkZWZWYWwgIT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZlZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ2hlY2tzIHRoYXQgYSBmdW5jdGlvbiByZWZlcmVuY2UgY2FuIGJlIGNhbGxlZCBzYWZlbHkuICBTb21ldGltZXMgZnVuY3Rpb24gcmVmZXJlbmNlcyBhcmUgcGFydFxuICAgIG9mIG9iamVjdHMgdGhhdCBtYXkgaGF2ZSBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkIChzdWNoIGFzIGEgZnVuY3Rpb24gcmVmZXJlbmNlIGZyb20gYW5vdGhlciB3aW5kb3cgb3IgZG9tIGVsZW1lbnQpLlxuICAgIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGUgcmVmZXJlbmNlIGJ5IG1ha2luZyBzdXJlIGl0IGhhcyBhIGNvbnN0cnVjdG9yIGFuZCB0b1N0cmluZyBwcm9wZXJ0aWVzLlxuICAgIFxuICAgIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBmdW5jdGlvbiBpdHNlbGYgd2hlbiBjYWxsZWQgKG9yIGl0cyBzdWJzcXVlbnQgY2FsbCBzdGFjayksIGNhbid0IHRocm93IGFuIGVycm9yLiAuIC5cbiAgICBzaW1wbHkgdGhhdCB5b3UgYXJlIGFibGUgdG8gY2FsbCBpdC4gLiAuXG4gICAgXG4gICAgdGhpcyBjYW4gcHJvYmxlbSBiZSByZW1vdmVkIGluIGxpZXUgb2YgZnVuYz8oKSBpbiBjc1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjYWxsYWJsZSBhcyAkc2YubGliLmxhbmcuY2FsbGFibGVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7RnVuY3Rpb259IEEgcmVmZXJlbmNlIHRvIGEgSmF2YVNjcmlwdCBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBzYWZlbHksIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBjYWxsYWJsZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHZhciBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiA9IChmICYmIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIgJiYgZi50b1N0cmluZygpICYmIChuZXcgZi5jb25zdHJ1Y3RvcigpKSA/IGYgOiBudWxsKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBmID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIWY7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2VuZXJhdGUgYSB1bmlxdWUgaWQgc3RyaW5nXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGd1aWQgYXMgJHNmLmxpYi5sYW5nLmd1aWRcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBhIHN1YnN0cmluZyB0byB1c2UgYSBwcmVmaXhcbiAgICBAcmV0dXJuIHtTdHJpbmd9IHVuaXF1ZSBpZCBzdHJpbmdcbiAgICAgKi9cbiAgICBndWlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICByZXR1cm4gY3N0cihbcHJlZml4IHx8IFwiXCIsIFwiX1wiLCB0aW1lKCksIFwiX1wiLCByYW5kKCksIFwiX1wiLCBuZXh0X2lkKytdKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNaXhlZCB0aGUgcHJvcGVydGllcyBvZiBvbmUgb2JqZWN0IGludG8gYW5vdGhlciBvYmplY3QuXG4gICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgcmVjdXJzaXZlXG4gICAgXG4gICAgXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG1peCBhcyAkc2YubGliLmxhbmcubWl4XG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge09iamVjdH0gIHIgIFRoZSBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGVydGllc1xuICAgIEBwYXJhbSB7T2JqZWN0fSAgcyAgVGhlIG9iamVjdCB0aGF0IHdpbGwgZGVsaWV2ZXIgcHJvcGVydGllc1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW293bmVkXSBXaGV0aGVyIG9yIG5vdCB0byBza2lwIG92ZXIgcHJvcGVydGllcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBvYmplY3QgcHJvdG90eXBlXG4gICAgQHBhcmFtIHtCb29sZWFufSBbc2tpcEZ1bmNzXSBXaGV0aGVyIG9yIG5vdCB0byBza2lwIG92ZXIgZnVuY3Rpb24gcmVmZXJlbmNlc1xuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW25vX292cl0gV2hldGhlciBvciBub3QgdG8gb3ZlcndyaXRlIHByb3BlcnRpZXMgdGhhdCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gZmlsbGVkIG91dFxuICAgIEByZXR1cm4ge09iamVjdH0gVGhlIHJlY2VpdmVyIG9iamVjdCBwYXNzZWQgaW4gd2l0aCBwb3RlbnRpYWxseSBuZXcgcHJvcGVydGllcyBhZGRlZFxuICAgICAqL1xuICAgIG1peCA9IGZ1bmN0aW9uKHIsIHMsIG93bmVkLCBza2lwRnVuY3MsIG5vX292cikge1xuICAgICAgdmFyIGl0ZW0sIHAsIHR5cDtcbiAgICAgIGlmICghcyB8fCAhcikge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGZvciAocCBpbiBzKSB7XG4gICAgICAgIGl0ZW0gPSBzW3BdO1xuICAgICAgICB0eXAgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKG93bmVkICYmICFzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vX292ciAmJiAocCBpbiByKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwRnVuY3MgJiYgdHlwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwID09PSBcIm9iamVjdFwiICYmIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoaXRlbS5zbGljZSkge1xuICAgICAgICAgICAgaXRlbSA9IG1peChbXSwgaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtaXgoe30sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByW3BdID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcywgZnJvbSB0aGUgZXBvY2hcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgdGltZSBhcyAkc2YubGliLmxhbmcudGltZVxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHJldHVybiB7TnVtYmVyfSBjdXJyZW50IHRpbWVcbiAgICAgKi9cbiAgICB0aW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBhbnl3aGVyZSBmcm9tIDAgdG8gOTlcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgcmFuZCBhcyAkc2YubGliLmxhbmcucmFuZFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHJldHVybiB7TnVtYmVyfSByYW5kb20gbnVtYmVyXG4gICAgICovXG4gICAgcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVHJpbSB0aGUgYmVnaW5pbmcgYW5kIGVuZGluZyB3aGl0ZXNwYWNlIGZyb20gYSBzdHJpbmcuXG4gICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGFuIGFyZ3VtZW50IHRvIGEgc3RyaW5nIGZpcnN0XG4gICAgZm9yIHR5cGUgc2FmZXR5IHB1cnBvc2VzLiBJZiBzdHJpbmcgY2Fubm90IGJlIGNvbnZlcnRlZCwgYW5kIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyB0cmltIGFzICRzZi5saWIubGFuZy50cmltXG4gICAgQHJldHVybiB7U3RyaW5nfSB0cmltbWVkIHN0cmluZ1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgdHJpbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHJldDtcbiAgICAgIHJldCA9IGNzdHIoc3RyKTtcbiAgICAgIHJldHVybiByZXQgJiYgcmV0LnJlcGxhY2UoL15cXHNcXHMqLywgXCJcIikucmVwbGFjZSgvXFxzXFxzKiQvLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBEZWZpbmUgYSBKYXZhU2NyaXB0IE5hbWVzcGFjZSB3aXRoaW4gYSBnaXZlbiBjb250ZXh0XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGRlZiBhcyAkc2YubGliLmxhbmcuZGVmXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cl9ucyAgVGhlIG5hbWUgb2YgdGhlIG5hbWVzcGFjZSBpbiBkb3Qgbm90YXRpb24gYXMgYSBzdHJpbmcgKGUuZy4gXCJGb28uYmFyXCIpXG4gICAgQHBhcmFtIHtPYmplY3R9IFthdWddIGRlZmluZXMgdGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lc3BhY2UuICBJZiBuYW1lc3BhY2UgaXMgYWxyZWFkeSBzcGVjaWZpZWQsIGFuZCB0aGlzIG9iamVjdCBpcyBwcm92aWRlZCwgdGhlIG5hbWVzcGFjZSB3aWxsIGJlIGF1Z21lbnRlZCB3aXRoIHByb3BlcnRpZXMgZnJvbSB0aGlzIG9iamVjdC4gSWYgbm90aGluZyBpcyBwYXNzZWQgaW4sIGRlZmF1bHRzIHRvIHVzaW5nIGFuIGVtcHR5IG9iamVjdC5cbiAgICBAcGFyYW0ge09iamVjdH0gW3Jvb3RdIHRoZSByb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBuYW1lc3BhY2UgaXMgZGVmaW5lZC4gIElmIG5vdCBwYXNzZWQgaW4gZGVmYXVsdHMgdG8gdGhlIGdsb2JhbC93aW5kb3cgb2JqZWN0XG4gICAgQHBhcmFtIHtCb29sZWFufSBbbm9fb3ZyXSBpZiB0cnVlLCBwcm9wZXJ0aWVzIGFscmVhZHkgZGVmaW5lZCBvbiByb290IHdpdGggdGhlIHNhbWUgbmFtZSB3aWxsIGJlIGlnbm9yZWRcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICBkZWYgPSBmdW5jdGlvbihzdHJfbnMsIGF1Zywgcm9vdCwgbm9fb3ZyKSB7XG4gICAgICB2YXIgYXIsIGlkeCwgaXRlbSwgb2JqLCBwZXIsIHJldDtcbiAgICAgIG9iaiA9IChyb290ICYmIHR5cGVvZiByb290ID09PSBcIm9iamVjdFwiID8gcm9vdCA6IHdpbik7XG4gICAgICBpZHggPSAwO1xuICAgICAgcGVyID0gXCIuXCI7XG4gICAgICByZXQgPSBudWxsO1xuICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICBzdHJfbnMgPSBjc3RyKHN0cl9ucyk7XG4gICAgICAgIGF1ZyA9IChhdWcgJiYgdHlwZW9mIGF1ZyA9PT0gXCJvYmplY3RcIiA/IGF1ZyA6IG51bGwpO1xuICAgICAgICBpZiAoc3RyX25zLmluZGV4T2YocGVyKSkge1xuICAgICAgICAgIGFyID0gc3RyX25zLnNwbGl0KHBlcik7XG4gICAgICAgICAgd2hpbGUgKGl0ZW0gPSBhcltpZHgrK10pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0cmltKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChvYmpbaXRlbV0gJiYgYXVnKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gbWl4KG9ialtpdGVtXSwgYXVnLCBmYWxzZSwgbnVsbCwgbm9fb3ZyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobm9fb3ZyICYmIChpdGVtIGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dID0gb2JqW2l0ZW1dIHx8IGF1ZyB8fCB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChub19vdnIgJiYgKGl0ZW0gaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV0gPSBvYmpbaXRlbV0gfHwge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IG9ialtpdGVtXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9ialtzdHJfbnNdICYmIGF1Zykge1xuICAgICAgICAgICAgcmV0ID0gb2JqW3N0cl9uc10gPSBtaXgob2JqW3N0cl9uc10sIGF1ZywgZmFsc2UsIG51bGwsIG5vX292cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IG9ialtzdHJfbnNdID0gb2JqW3N0cl9uc10gfHwgYXVnIHx8IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBKYXZhU2NyaXB0IG5hbWVzcGFjZVxuICAgIGFzIG9wcG9zZWQgdG8gZGVmLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmaW5lIHRoZSBuYW1lc3BhY2VcbiAgICB3aXRoIGEgZ2l2ZW4gY29udGV4dC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgbnMgYXMgJHNmLmxpYi5sYW5nLm5zXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0cl9ucyAgQSBzdHJpbmcgd2l0aCAuIG9yIFtdIG5vdGF0aW9uIG9mIGEgSmF2YVNjcmlwdCBuYW1lc2FjZSAoZS5nLiBcImZvby5iYXIuc2hvd1wiLCBvciBcImZvb1snYmFyJ11bJ3Nob3cnXVwiKS5cbiAgICBAcGFyYW0ge09iamVjdH0gW3Jvb3RdIHRoZSByb290IG9iamVjdCB0byBjaGVjayB3aXRoaW4uIC5kZWZhdWx0cyB0byBnbG9iYWwgLyB3aW5kb3dcbiAgICBAcmV0dXJuIHsqfSBUaGUgZW5kcG9pbnQgcmVmZXJlbmNlIG9mIHRoZSBuYW1lc3BhY2Ugb3IgZmFsc2UgaWYgbm90IGZvdW5kXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICBucyA9IGZ1bmN0aW9uKHN0cl9ucywgcm9vdCkge1xuICAgICAgdmFyIGV4aXN0cywgZXhwLCBleHAyLCBleHAzLCBleHA0LCBpZHgsIG1hdGNoZXMsIG9iaiwgcHJvcCwgcm9vdFN0cjtcbiAgICAgIGV4cCA9IC8oXFxbKC57MSx9KVxcXSl8KFxcLlxcdyspL2c7XG4gICAgICBleHAyID0gL1xcWygoJ3xcIik/KSgoXFxzfC4pKj8pKCgnfFwiKT8pXFxdL2c7XG4gICAgICBleHAzID0gLyhcXFsuKil8KFxcLi4qKS9nO1xuICAgICAgZXhwNCA9IC9cXC4vZztcbiAgICAgIGlkeCA9IDA7XG4gICAgICByb290U3RyID0gXCJcIjtcbiAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICBvYmogPSByb290ID0gcm9vdCB8fCB3aW47XG4gICAgICBpZiAoc3RyX25zKSB7XG4gICAgICAgIHN0cl9ucyA9IGNzdHIoc3RyX25zKTtcbiAgICAgICAgaWYgKHN0cl9ucykge1xuICAgICAgICAgIHN0cl9ucyA9IHRyaW0oc3RyX25zKTtcbiAgICAgICAgICBtYXRjaGVzID0gc3RyX25zLm1hdGNoKGV4cCk7XG4gICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJvb3RTdHIgPSBzdHJfbnMucmVwbGFjZShleHAzLCBcIlwiKTtcbiAgICAgICAgICAgIG1hdGNoZXMudW5zaGlmdChyb290U3RyKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9wID0gbWF0Y2hlc1tpZHgrK10pIHtcbiAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZShleHAyLCBcIiQzXCIpLnJlcGxhY2UoZXhwNCwgXCJcIik7XG4gICAgICAgICAgICAgIGlmICghb2JqW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wID0gc3RyX25zO1xuICAgICAgICAgICAgb2JqID0gb2JqW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGV4aXN0cyAmJiBvYmopIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBmdW5jdGlvblxuICAgIFRlc3RzIHRvIHNlZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpcyBhbiBhcnJheVxuICAgICAqL1xuICAgIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKG9iai5sZW5ndGggIT0gbnVsbCkgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSBKYXZhU2NyaXB0IG5hbWVzcGFjZVxuICAgIGFzIG9wcG9zZWQgdG8gZGVmLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGVmaW5lIHRoZSBuYW1lc3BhY2VcbiAgICB3aXRoIGEgZ2l2ZW4gY29udGV4dC4gICAgICAgICB2aWEgdW5kZXJzY29yZS5qc1xuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBucyBhcyAkc2YubGliLmxhbmcud3JhcFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIGZ1bmN0aW9uXG4gICAgQHJldHVybiB7RnVuY3Rpb259XG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICB3cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgYXJncyA9IFtmdW5jXTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdpdmVuIGEgc3RyaW5nIG9mIEhUTUwgZXNjYXBlIHF1b3RlIG1hcmtzIGFuZCBzZXBlcmF0ZSBzY3JpcHQgdGFncyBzbyB0aGF0IGJyb3dzZXJzIGRvbid0IGdldCB0cmlwcGVkIHVwXG4gICAgZHVyaW5nIHByb2Nlc3NpbmcuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGpzc2FmZV9odG1sIGFzICRzZi5saWIubGFuZy5qc3NhZmVfaHRtbFxuICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBzdHJpbmcgb2YgSFRNTCBtYXJrdXAgdG8gYmUgcHJvY2Vzc2VkXG4gICAgQHJldHVybiB7U3RyaW5nfVxuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgICovXG4gICAgZW50aXR5TWFwID0ge1xuICAgICAgZXNjYXBlOiB7XG4gICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgICB9XG4gICAgfTtcbiAgICBlbnRpdHlNYXAudW5lc2NhcGUgPSB7fTtcbiAgICBfcmVmID0gZW50aXR5TWFwLmVzY2FwZTtcbiAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgdiA9IF9yZWZba107XG4gICAgICBlbnRpdHlNYXAudW5lc2NhcGVbdl0gPSBrO1xuICAgIH1cbiAgICBlbnRpdHlSZWdleGVzID0ge1xuICAgICAgZXNjYXBlOiBuZXcgUmVnRXhwKCdbJyArIGtleXMoZW50aXR5TWFwLmVzY2FwZSkuam9pbignJykgKyAnXScsICdnJyksXG4gICAgICB1bmVzY2FwZTogbmV3IFJlZ0V4cCgnKCcgKyBrZXlzKGVudGl0eU1hcC51bmVzY2FwZSkuam9pbignfCcpICsgJyknLCAnZycpXG4gICAgfTtcbiAgICBqc3NhZmVfaHRtbCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJcIiArIHN0cikucmVwbGFjZShlbnRpdHlSZWdleGVzLmVzY2FwZSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcC5lc2NhcGVbbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBqc3Vuc2FmZV9odG1sID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcIlwiICsgc3RyKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXMudW5lc2NhcGUsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHlNYXAudW5lc2NhcGVbbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQGNsYXNzIEludGFudGlhYmxlIGNsYXNzIHVzZWQgdG8gY29udmVydCBhIGRlbGltaXRlZCBzdHJpbmcgaW50byBhbiBvYmplY3QuPGJyIC8+XG4gICAgRm9yIGV4YW1wbGUgcXVlcnlzdHJpbmdzOiBcIm5hbWVfMT12YWx1ZV8xJm5hbWVfMj12YWx1ZV8yXCIgPT0+IHtuYW1lXzE6dmFsdWVfMSxuYW1lXzI6dmFsdWVfMn07PGJyLz48YnIgLz5cbiAgICBcbiAgICBOb3RlIHRoYXQgcHJvcGVydHkgdmFsdWVzIGNvdWxkIGFsc28gY29udGFpbiB0aGUgc2FtZSBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSBzdHJpbmdzLiAgUHJvcGVyIHN0cmluZyBlbmNvZGluZyBzaG91bGQgb2NjdXJcbiAgICB0byBub3QgdHJpcCB1cCB0aGUgcGFyc2luZyBvZiB0aGUgc3RyaW5nLiAgU2FpZCB2YWx1ZXMgbWF5IGJlIGFzY2lpIGVzY2FwZWQsIGFuZCBpbiB0dXJuLCBhbG9uZyB3aXRoIHRoZSA8aT48Yj5iUmVjdXJzZTwvYj48L2k+IGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzZXQgdG8gdHJ1ZSwgd2lsbCBjYXVzZSBuZXN0ZWQgUGFyYW1IYXNoIG9iamVjdHMgdG8gYmUgY3JlYXRlZC5cbiAgICBcbiAgICBAY29uc3RydWN0b3JcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgUGFyYW1IYXNoIGFzICRzZi5saWIubGFuZy5QYXJhbUhhc2hcbiAgICBAcGFyYW0ge1N0cmluZ30gW3NTdHJpbmddICBUaGUgZGVsaW1pdGVkIHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAgICBAcGFyYW0ge1N0cmluZ30gW3NQcm9wRGVsaW09XCImXCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlciB1c2VkIHRvIHNlcGVyYXRlIHByb3BlcnRpZXMuIERlZmF1bHQgaXMgXCImXCIuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzVmFsdWVEZWxpbT1cIj1cIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVkIHVzZWQgdG8gc2VwZXJhdGUgdmFsdWVzLiAgRGVmYXVsdCBpcyBcIj1cIi5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtiTm9PdmVyd3JpdGU9ZmFsc2VdICBJZiB0cnVlLCB3aGVuIGEgbmFtZSBpcyBlbmNvdW50ZXJlZCBtb3JlIHRoYW4gMSB0aW1lIGluIHRoZSBzdHJpbmcgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2JSZWN1cnNlPWZhbHNlXSAgSWYgdHJ1ZSwgd2hlbiBhIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCBpcyBwYXJzZWQgYWxzbyBoYXMgYm90aCB0aGUgc1Byb3BEZWxpbSBhbmQgc1ZhbHVlRGVsaW0gaW5zaWRlLCBjb252ZXJ0IHRoYXQgdmFsdWUgdG8gYW5vdGhlciBQYXJhbUhhc2ggb2JqZWN0IGF1dG9tYXRpY2FsbHlcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieD0xJnk9MSZ6PTFcIik7XG4gICAgYWxlcnQocGgueCk7IC8vID09IDFcbiAgICBhbGVydChwaC55KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnopOyAvLyA9PSAxXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng6MTt5OjI7ejozXCIsIFwiO1wiLCBcIjpcIik7XG4gICAgYWxlcnQocGgueCk7IC8vID09IDFcbiAgICBhbGVydChwaC55KTsgLy8gPT0gMlxuICAgIGFsZXJ0KHBoLnopOyAvLyA9PSAzXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng9MSZ5PTEmej0xJno9MlwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyAxXG4gICAgYWxlcnQocGgueik7IC8vTm90ZSB0aGF0IHogPT0gMiBiL2Mgb2YgMiBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4PTEmeT0xJno9MSZ6PTJcIixudWxsLG51bGwsdHJ1ZSk7IC8vbnVsbCBmb3Igc1Byb3BEZWxpbSBhbmQgc1ZhbHVlRGVsaW0gPT0gdXNlIGRlZmF1bHQgdmFsdWVzIG9mIFwiJlwiIGFuZCBcIj1cIiByZXNwZWN0aXZlbHlcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyAxXG4gICAgYWxlcnQocGgueik7IC8vTm90ZSB0aGF0IHogPT0gMSBiL2MgYk5vT3ZlcndyaXRlIHdhcyBzZXQgdG8gdHJ1ZVxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgLy9Zb3UgY2FuIGFsc28gZG8gcmVjdXJzaXZlIHByb2Nlc3NpbmcgaWYgbmVlZCBiZVxuICAgIHZhciBwb2ludHNcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKSxcbiAgICBwb2ludF8xXHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKCksXG4gICAgcG9pbnRfMlx0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpO1xuICAgIFxuICAgIHBvaW50XzEueCA9IDEwMDtcbiAgICBwb2ludF8xLnkgPSA3NTtcbiAgICBcbiAgICBwb2ludF8yLnggPSAyMDA7XG4gICAgcG9pbnRfMi55ID0gMTUwO1xuICAgIFxuICAgIHBvaW50cy5wb2ludF8xXHQ9IHBvaW50XzE7XG4gICAgcG9pbnRzLnBvaW50XzJcdD0gcG9pbnRfMjtcbiAgICBcbiAgICB2YXIgcG9pbnRfc3RyXHQ9IHBvaW50cy50b1N0cmluZygpOyAgLy8gPT0gXCJwb2ludF8xPXglM0QxMDAlMjZ5JTNENzUlMjYmcG9pbnRfMj14JTNEMjAwJTI2eSUzRDE1MCUyNiZcIjtcbiAgICB2YXIgcG9pbnRzX2NvcHlcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2gocG9pbnRfc3RyLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTsgLy9ub3RlIHBhc3NpbmcgdHJ1ZSwgYi9jIHdlIHdhbnQgdG8gcmVjdXJzZVxuICAgIFxuICAgIGFsZXJ0KHBvaW50c19jb3B5LnBvaW50XzEueCkgLy8gPT0gXCIxMDBcIjtcbiAgICAgKi9cbiAgICBQYXJhbUhhc2ggPSBmdW5jdGlvbihzU3RyaW5nLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSkge1xuICAgICAgdmFyIGFkZGVkLCBjbnQsIGRvQWRkLCBpZHgsIGlkeDIsIGlkeDMsIGlvLCBsZW4sIGxlbjIsIG1lLCBubSwgbnYsIG9iaiwgcGFpcnMsIHNUZW1wLCBzVGVtcDIsIHNUZW1wMywgc3M7XG4gICAgICBtZSA9IHRoaXM7XG4gICAgICBpbyA9IFwiaW5kZXhPZlwiO1xuICAgICAgc3MgPSBcInN1YnN0cmluZ1wiO1xuICAgICAgZG9BZGQgPSBmYWxzZTtcbiAgICAgIGlmICghKG1lIGluc3RhbmNlb2YgUGFyYW1IYXNoKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFtSGFzaChzU3RyaW5nLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgfVxuICAgICAgaWYgKHNTdHJpbmcgJiYgdHlwZW9mIHNTdHJpbmcgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIG1peChuZXcgUGFyYW1IYXNoKFwiXCIsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKSwgc1N0cmluZyk7XG4gICAgICB9XG4gICAgICBzU3RyaW5nID0gY3N0cihzU3RyaW5nKTtcbiAgICAgIHNQcm9wRGVsaW0gPSBjc3RyKHNQcm9wRGVsaW0pIHx8IFwiJlwiO1xuICAgICAgc1ZhbHVlRGVsaW0gPSBjc3RyKHNWYWx1ZURlbGltKSB8fCBcIj1cIjtcbiAgICAgIGlmICghc1N0cmluZykge1xuICAgICAgICByZXR1cm4gbWU7XG4gICAgICB9XG4gICAgICBpZiAoc1Byb3BEZWxpbSAhPT0gXCI/XCIgJiYgc1ZhbHVlRGVsaW0gIT09IFwiP1wiICYmIHNTdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikge1xuICAgICAgICBzU3RyaW5nID0gc1N0cmluZ1tzc10oMSk7XG4gICAgICB9XG4gICAgICBpZHggPSBzU3RyaW5nW2lvXShcIj9cIik7XG4gICAgICBpZHgyID0gc1N0cmluZ1tpb10oc1ZhbHVlRGVsaW0pO1xuICAgICAgaWYgKGlkeCAhPT0gLTEgJiYgaWR4MiAhPT0gLTEgJiYgaWR4ID4gaWR4Mikge1xuICAgICAgICBzVGVtcCA9IF9lcyhzU3RyaW5nW3NzXShpZHgyICsgMSkpO1xuICAgICAgICBzVGVtcDIgPSBzU3RyaW5nLnN1YnN0cigwLCBpZHgyICsgMSk7XG4gICAgICAgIHNTdHJpbmcgPSBzVGVtcDIgKyBzVGVtcDtcbiAgICAgIH0gZWxzZSBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBzU3RyaW5nID0gc1N0cmluZ1tzc10oaWR4ICsgMSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1IYXNoKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNTdHJpbmcuY2hhckF0KDApID09PSBzUHJvcERlbGltKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXSgxKTtcbiAgICAgIH1cbiAgICAgIHBhaXJzID0gc1N0cmluZy5zcGxpdChzUHJvcERlbGltKTtcbiAgICAgIGNudCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGlkeCA9IDA7XG4gICAgICB3aGlsZSAoY250LS0pIHtcbiAgICAgICAgc1RlbXAgPSBwYWlyc1tpZHgrK107XG4gICAgICAgIGFkZGVkID0gZmFsc2U7XG4gICAgICAgIGRvQWRkID0gZmFsc2U7XG4gICAgICAgIGlmIChzVGVtcCkge1xuICAgICAgICAgIG52ID0gc1RlbXAuc3BsaXQoc1ZhbHVlRGVsaW0pO1xuICAgICAgICAgIGxlbiA9IG52Lmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgICAgbm0gPSBfdWUobnZbMF0pO1xuICAgICAgICAgICAgbnYuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChiUmVjdXJzZSkge1xuICAgICAgICAgICAgICBzVGVtcDIgPSBubSArIHNWYWx1ZURlbGltO1xuICAgICAgICAgICAgICBpZHgyID0gc1N0cmluZ1tpb10oc1RlbXAyKTtcbiAgICAgICAgICAgICAgbGVuID0gc1RlbXAyW0xFTl07XG4gICAgICAgICAgICAgIHNUZW1wMyA9IHNTdHJpbmdbc3NdKGlkeDIgKyBsZW4pO1xuICAgICAgICAgICAgICBzVGVtcDIgPSBzUHJvcERlbGltICsgc1Byb3BEZWxpbTtcbiAgICAgICAgICAgICAgbGVuMiA9IHNUZW1wMltMRU5dO1xuICAgICAgICAgICAgICBpZHgzID0gc1RlbXAzW2lvXShzVGVtcDIpO1xuICAgICAgICAgICAgICBpZiAoaWR4MyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzVGVtcDMgPSBzU3RyaW5nLnN1YnN0cihpZHgyICsgbGVuLCBpZHgzICsgbGVuMik7XG4gICAgICAgICAgICAgICAgb2JqID0gbmV3IFBhcmFtSGFzaChzVGVtcDMsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgICAgICAgICAgICBzVGVtcDMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChzVGVtcDMgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlkeCArPSBsZW4gLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzVGVtcCA9IG9iajtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzVGVtcCA9IF91ZShudi5qb2luKHNWYWx1ZURlbGltKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNUZW1wID0gX3VlKG52LmpvaW4oc1ZhbHVlRGVsaW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvQWRkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgbm0gPSBfdWUobnZbMF0pO1xuICAgICAgICAgICAgc1RlbXAgPSBfdWUobnZbMV0pO1xuICAgICAgICAgICAgZG9BZGQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9BZGQpIHtcbiAgICAgICAgICAgIGlmIChiTm9PdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEobm0gaW4gbWUpKSB7XG4gICAgICAgICAgICAgICAgbWVbbm1dID0gc1RlbXA7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZVtubV0gPSBzVGVtcDtcbiAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJSZWN1cnNlICYmIGFkZGVkICYmIG5tICYmIHNUZW1wICYmIHR5cGVvZiBzVGVtcCAhPT0gXCJvYmplY3RcIiAmJiAoc1RlbXBbaW9dKHNQcm9wRGVsaW0pID49IDAgfHwgc1RlbXBbaW9dKHNWYWx1ZURlbGltKSA+PSAwKSkge1xuICAgICAgICAgICAgICBtZVtubV0gPSBuZXcgUGFyYW1IYXNoKHNUZW1wLCBzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgYk5vT3ZlcndyaXRlLCBiUmVjdXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQ29udmVydHMgYSBQYXJhbUhhc2ggb2JqZWN0IGJhY2sgaW50byBhIHN0cmluZyB1c2luZyB0aGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlbGltaXRlcnMgc3BlY2lmZWQgKGRlZmF1bHRzIHRvIFwiJlwiIGFuZCBcIj1cIikuXG4gICAgQWdhaW4gdGhpcyBtZXRob2Qgd29ya3MgcmVjdXJzaXZlbHkuICBJZiBhbiBvYmplY3QgaXMgZm91bmQgYXMgYSBwcm9wZXJ0eSwgaXQgd2lsbCBjb252ZXJ0IHRoYXQgb2JqZWN0IGludG8gYSBQYXJhbUhhc2ggc3RyaW5nXG4gICAgYW5kIHRoZW4gZXNjYXBlIGl0LiBOb3RlIGFsc28gdGhhdCB0aGlzIGNsYXNzJ3MgdmFsdWVPZiBtZXRob2QgaXMgZXF1YWwgdG8gdGhpcyBtZXRob2QuXG4gICAgXG4gICAgQG1ldGhvZE9mIFBhcmFtSGFzaCNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzUHJvcERlbGltPVwiJlwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZXIgdXNlZCB0byBzZXBlcmF0ZSBwcm9wZXJ0aWVzLiBEZWZhdWx0IGlzIFwiJlwiLlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1ZhbHVlRGVsaW09XCI9XCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlZCB1c2VkIHRvIHNlcGVyYXRlIHZhbHVlcy4gIERlZmF1bHQgaXMgXCI9XCIuXG4gICAgQHBhcmFtIHtCb29sZWFufSBbZXNjYXBlUHJvcD1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gYXNjaWkgZXNjYXBlIHRoZSBuYW1lIG9mIGEgcHJvcGVydHlcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtkb250RXNjYXBlVmFsdWU9ZmFsc2VdIERvIG5vdCBlc2NhcGUgdmFsdWVzIG9yIHByb3BlcnRpZXMgYXV0b21hdGljYWxseVxuICAgIEByZXR1cm4ge1N0cmluZ30gdGhlIGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcgPSBmdW5jdGlvbihzUHJvcERlbGltLCBzVmFsdWVEZWxpbSwgZXNjYXBlUHJvcCwgZG9udEVzY2FwZVZhbHVlKSB7XG4gICAgICB2YXIgYnVmZmVyLCBpdGVtLCBpdGVtVHlwZSwgbWUsIHByb3A7XG4gICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgYnVmZmVyID0gW107XG4gICAgICBtZSA9IHRoaXM7XG4gICAgICBpdGVtVHlwZSA9IHZvaWQgMDtcbiAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICBzUHJvcERlbGltID0gc1Byb3BEZWxpbSB8fCBcIiZcIjtcbiAgICAgIHNWYWx1ZURlbGltID0gc1ZhbHVlRGVsaW0gfHwgXCI9XCI7XG4gICAgICBmb3IgKHByb3AgaW4gbWUpIHtcbiAgICAgICAgaXRlbSA9IG1lW3Byb3BdO1xuICAgICAgICBpdGVtVHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbVR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpdGVtID0gdG9TdHJpbmcuYXBwbHkoaXRlbSwgW3NQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBlc2NhcGVQcm9wLCBkb250RXNjYXBlVmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXNjYXBlUHJvcCkge1xuICAgICAgICAgIHByb3AgPSBfZXMocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb250RXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpdGVtID0gX2VzKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHByb3AsIHNWYWx1ZURlbGltLCBpdGVtLCBzUHJvcERlbGltKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3RyKGJ1ZmZlcik7XG4gICAgfTtcbiAgICBwcm90byA9IFBhcmFtSGFzaC5wcm90b3R5cGU7XG4gICAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IHRyaW07XG4gICAgfVxuXG4gICAgLypcbiAgICBAaWdub3JlXG4gICAgICovXG4gICAgcHJvdG8udG9TdHJpbmcgPSBwcm90by52YWx1ZU9mID0gdG9TdHJpbmc7XG4gICAgbGFuZyA9IHtcbiAgICAgIFBhcmFtSGFzaDogUGFyYW1IYXNoLFxuICAgICAgY3N0cjogY3N0cixcbiAgICAgIGNudW06IGNudW0sXG4gICAgICBjYm9vbDogY2Jvb2wsXG4gICAgICBub29wOiBub29wLFxuICAgICAgdHJpbTogdHJpbSxcbiAgICAgIGNhbGxhYmxlOiBjYWxsYWJsZSxcbiAgICAgIGd1aWQ6IGd1aWQsXG4gICAgICBtaXg6IG1peCxcbiAgICAgIHRpbWU6IHRpbWUsXG4gICAgICByYW5kOiByYW5kLFxuICAgICAgZGVmOiBkZWYsXG4gICAgICBuczogbnMsXG4gICAgICBqc3NhZmVfaHRtbDoganNzYWZlX2h0bWwsXG4gICAgICBqc3Vuc2FmZV9odG1sOiBqc3Vuc2FmZV9odG1sLFxuICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgIHdyYXA6IHdyYXAsXG4gICAgICBrZXlzOiBrZXlzXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgZXhwb3J0cyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMubGFuZyA9IGxhbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGxvZ0Vycm9yLCBsb2dJbmZvLCB3aW47XG4gICAgd2luID0gd2luZG93O1xuXG4gICAgLypcbiAgICBXcml0ZSBhbiBlbnRyeSB0byB0aGUgY29uc29sZSBsb2cgYW5kIGZpcmUgYW55IGxvZyBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbWVzc2FnZSAgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nSW5mbyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh3aW4uY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBXcml0ZSBhbiBlbnRyeSB0byB0aGUgY29uc29sZSBlcnJvciBsb2cgYW5kIGZpcmUgYW55IGxvZyBsaXN0ZW5lcnNcbiAgICBcbiAgICBAbWVzc2FnZSAgVGhlIGxvZyBtZXNzYWdlXG4gICAgICovXG4gICAgbG9nRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBpZiAod2luLmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdpbi5jb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBpbmZvOiBsb2dJbmZvLFxuICAgICAgZXJyb3I6IGxvZ0Vycm9yXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihhKSAmJiBCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQpID8gc2VsZi5sZW5ndGggOiBOdW1iZXIoZW5kKVxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaGFzaDogaGFzaCB9O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBzaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgcm5nID0gcmVxdWlyZSgnLi9ybmcnKVxudmFyIG1kNSA9IHJlcXVpcmUoJy4vbWQ1JylcblxudmFyIGFsZ29yaXRobXMgPSB7XG4gIHNoYTE6IHNoYSxcbiAgc2hhMjU2OiBzaGEyNTYsXG4gIG1kNTogbWQ1XG59XG5cbnZhciBibG9ja3NpemUgPSA2NFxudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKVxuZnVuY3Rpb24gaG1hYyhmbiwga2V5LCBkYXRhKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG5cbiAgaWYoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGZuKGtleSlcbiAgfSBlbHNlIGlmKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIHplcm9CdWZmZXJdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKSwgb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB2YXIgaGFzaCA9IGZuKEJ1ZmZlci5jb25jYXQoW2lwYWQsIGRhdGFdKSlcbiAgcmV0dXJuIGZuKEJ1ZmZlci5jb25jYXQoW29wYWQsIGhhc2hdKSlcbn1cblxuZnVuY3Rpb24gaGFzaChhbGcsIGtleSkge1xuICBhbGcgPSBhbGcgfHwgJ3NoYTEnXG4gIHZhciBmbiA9IGFsZ29yaXRobXNbYWxnXVxuICB2YXIgYnVmcyA9IFtdXG4gIHZhciBsZW5ndGggPSAwXG4gIGlmKCFmbikgZXJyb3IoJ2FsZ29yaXRobTonLCBhbGcsICdpcyBub3QgeWV0IHN1cHBvcnRlZCcpXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgICAgICAgXG4gICAgICBidWZzLnB1c2goZGF0YSlcbiAgICAgIGxlbmd0aCArPSBkYXRhLmxlbmd0aFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmcylcbiAgICAgIHZhciByID0ga2V5ID8gaG1hYyhmbiwga2V5LCBidWYpIDogZm4oYnVmKVxuICAgICAgYnVmcyA9IG51bGxcbiAgICAgIHJldHVybiBlbmMgPyByLnRvU3RyaW5nKGVuYykgOiByXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7IHJldHVybiBoYXNoKGFsZykgfVxuZXhwb3J0cy5jcmVhdGVIbWFjID0gZnVuY3Rpb24gKGFsZywga2V5KSB7IHJldHVybiBoYXNoKGFsZywga2V5KSB9XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIG5ldyBCdWZmZXIocm5nKHNpemUpKSlcbiAgICB9IGNhdGNoIChlcnIpIHsgY2FsbGJhY2soZXJyKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIocm5nKHNpemUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYSwgZikge1xuICBmb3IodmFyIGkgaW4gYSlcbiAgICBmKGFbaV0sIGkpXG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlQ2lwaGVyJ1xuLCAnY3JlYXRlQ2lwaGVyaXYnXG4sICdjcmVhdGVEZWNpcGhlcidcbiwgJ2NyZWF0ZURlY2lwaGVyaXYnXG4sICdjcmVhdGVTaWduJ1xuLCAnY3JlYXRlVmVyaWZ5J1xuLCAnY3JlYXRlRGlmZmllSGVsbG1hbidcbiwgJ3Bia2RmMiddLCBmdW5jdGlvbiAobmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdzb3JyeSwnLCBuYW1lLCAnaXMgbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cbn0pXG4iLCIvKlxyXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXHJcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXHJcbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cclxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxyXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcclxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cclxuICovXHJcblxyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5cclxuLypcclxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBtZDVfdm1fdGVzdCgpXHJcbntcclxuICByZXR1cm4gaGV4X21kNShcImFiY1wiKSA9PSBcIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCI7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcclxuICovXHJcbmZ1bmN0aW9uIGNvcmVfbWQ1KHgsIGxlbilcclxue1xyXG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXHJcbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XHJcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xyXG5cclxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xyXG4gIHZhciBiID0gLTI3MTczMzg3OTtcclxuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xyXG4gIHZhciBkID0gIDI3MTczMzg3ODtcclxuXHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxyXG4gIHtcclxuICAgIHZhciBvbGRhID0gYTtcclxuICAgIHZhciBvbGRiID0gYjtcclxuICAgIHZhciBvbGRjID0gYztcclxuICAgIHZhciBvbGRkID0gZDtcclxuXHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcclxuXHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcclxuXHJcbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XHJcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XHJcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XHJcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcclxuXHJcbn1cclxuXHJcbi8qXHJcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcclxufVxyXG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcclxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cclxuICovXHJcbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXHJcbntcclxuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xyXG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcclxuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcclxufVxyXG5cclxuLypcclxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxyXG4gKi9cclxuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcclxue1xyXG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZDUoYnVmKSB7XHJcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XHJcbn07XHJcbiIsIi8vIE9yaWdpbmFsIGNvZGUgYWRhcHRlZCBmcm9tIFJvYmVydCBLaWVmZmVyLlxuLy8gZGV0YWlscyBhdCBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgdmFyIG1hdGhSTkcsIHdoYXR3Z1JORztcblxuICAvLyBOT1RFOiBNYXRoLnJhbmRvbSgpIGRvZXMgbm90IGd1YXJhbnRlZSBcImNyeXB0b2dyYXBoaWMgcXVhbGl0eVwiXG4gIG1hdGhSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciByO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBieXRlc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICBpZiAoX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHdoYXR3Z1JORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aGF0d2dSTkcgfHwgbWF0aFJORztcblxufSgpKVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX3NoYTEoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuXG4gIHZhciB3ID0gQXJyYXkoODApO1xuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcbiAgdmFyIGUgPSAtMTAwOTU4OTc3NjtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgdmFyIG9sZGUgPSBlO1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspXG4gICAge1xuICAgICAgaWYoaiA8IDE2KSB3W2pdID0geFtpICsgal07XG4gICAgICBlbHNlIHdbal0gPSByb2wod1tqLTNdIF4gd1tqLThdIF4gd1tqLTE0XSBeIHdbai0xNl0sIDEpO1xuICAgICAgdmFyIHQgPSBzYWZlX2FkZChzYWZlX2FkZChyb2woYSwgNSksIHNoYTFfZnQoaiwgYiwgYywgZCkpLFxuICAgICAgICAgICAgICAgICAgICAgICBzYWZlX2FkZChzYWZlX2FkZChlLCB3W2pdKSwgc2hhMV9rdChqKSkpO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSByb2woYiwgMzApO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgZSA9IHNhZmVfYWRkKGUsIG9sZGUpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcblxufVxuXG4vKlxuICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAqIGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpXG57XG4gIGlmKHQgPCAyMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpO1xuICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgcmV0dXJuIGIgXiBjIF4gZDtcbn1cblxuLypcbiAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgYWRkaXRpdmUgY29uc3RhbnQgZm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2t0KHQpXG57XG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTEoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX3NoYTEsIDIwLCB0cnVlKTtcbn07XG4iLCJcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgc2FmZV9hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59O1xuXG52YXIgUyA9IGZ1bmN0aW9uKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKSB8IChYIDw8ICgzMiAtIG4pKTtcbn07XG5cbnZhciBSID0gZnVuY3Rpb24oWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pO1xufTtcblxudmFyIENoID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKTtcbn07XG5cbnZhciBNYWogPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopKTtcbn07XG5cbnZhciBTaWdtYTAyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCAyKSBeIFMoeCwgMTMpIF4gUyh4LCAyMikpO1xufTtcblxudmFyIFNpZ21hMTI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSk7XG59O1xuXG52YXIgR2FtbWEwMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgNykgXiBTKHgsIDE4KSBeIFIoeCwgMykpO1xufTtcblxudmFyIEdhbW1hMTI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDE3KSBeIFMoeCwgMTkpIF4gUih4LCAxMCkpO1xufTtcblxudmFyIGNvcmVfc2hhMjU2ID0gZnVuY3Rpb24obSwgbCkge1xuICB2YXIgSyA9IG5ldyBBcnJheSgweDQyOEEyRjk4LDB4NzEzNzQ0OTEsMHhCNUMwRkJDRiwweEU5QjVEQkE1LDB4Mzk1NkMyNUIsMHg1OUYxMTFGMSwweDkyM0Y4MkE0LDB4QUIxQzVFRDUsMHhEODA3QUE5OCwweDEyODM1QjAxLDB4MjQzMTg1QkUsMHg1NTBDN0RDMywweDcyQkU1RDc0LDB4ODBERUIxRkUsMHg5QkRDMDZBNywweEMxOUJGMTc0LDB4RTQ5QjY5QzEsMHhFRkJFNDc4NiwweEZDMTlEQzYsMHgyNDBDQTFDQywweDJERTkyQzZGLDB4NEE3NDg0QUEsMHg1Q0IwQTlEQywweDc2Rjk4OERBLDB4OTgzRTUxNTIsMHhBODMxQzY2RCwweEIwMDMyN0M4LDB4QkY1OTdGQzcsMHhDNkUwMEJGMywweEQ1QTc5MTQ3LDB4NkNBNjM1MSwweDE0MjkyOTY3LDB4MjdCNzBBODUsMHgyRTFCMjEzOCwweDREMkM2REZDLDB4NTMzODBEMTMsMHg2NTBBNzM1NCwweDc2NkEwQUJCLDB4ODFDMkM5MkUsMHg5MjcyMkM4NSwweEEyQkZFOEExLDB4QTgxQTY2NEIsMHhDMjRCOEI3MCwweEM3NkM1MUEzLDB4RDE5MkU4MTksMHhENjk5MDYyNCwweEY0MEUzNTg1LDB4MTA2QUEwNzAsMHgxOUE0QzExNiwweDFFMzc2QzA4LDB4Mjc0ODc3NEMsMHgzNEIwQkNCNSwweDM5MUMwQ0IzLDB4NEVEOEFBNEEsMHg1QjlDQ0E0RiwweDY4MkU2RkYzLDB4NzQ4RjgyRUUsMHg3OEE1NjM2RiwweDg0Qzg3ODE0LDB4OENDNzAyMDgsMHg5MEJFRkZGQSwweEE0NTA2Q0VCLDB4QkVGOUEzRjcsMHhDNjcxNzhGMik7XG4gIHZhciBIQVNIID0gbmV3IEFycmF5KDB4NkEwOUU2NjcsIDB4QkI2N0FFODUsIDB4M0M2RUYzNzIsIDB4QTU0RkY1M0EsIDB4NTEwRTUyN0YsIDB4OUIwNTY4OEMsIDB4MUY4M0Q5QUIsIDB4NUJFMENEMTkpO1xuICAgIHZhciBXID0gbmV3IEFycmF5KDY0KTtcbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgajtcbiAgICB2YXIgVDEsIFQyO1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICBtW2wgPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsICUgMzIpO1xuICBtWygobCArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIGEgPSBIQVNIWzBdOyBiID0gSEFTSFsxXTsgYyA9IEhBU0hbMl07IGQgPSBIQVNIWzNdOyBlID0gSEFTSFs0XTsgZiA9IEhBU0hbNV07IGcgPSBIQVNIWzZdOyBoID0gSEFTSFs3XTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgV1tqXSA9IG1baiArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgV1tqXSA9IHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKEdhbW1hMTI1NihXW2ogLSAyXSksIFdbaiAtIDddKSwgR2FtbWEwMjU2KFdbaiAtIDE1XSkpLCBXW2ogLSAxNl0pO1xuICAgICAgfVxuICAgICAgVDEgPSBzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChoLCBTaWdtYTEyNTYoZSkpLCBDaChlLCBmLCBnKSksIEtbal0pLCBXW2pdKTtcbiAgICAgIFQyID0gc2FmZV9hZGQoU2lnbWEwMjU2KGEpLCBNYWooYSwgYiwgYykpO1xuICAgICAgaCA9IGc7IGcgPSBmOyBmID0gZTsgZSA9IHNhZmVfYWRkKGQsIFQxKTsgZCA9IGM7IGMgPSBiOyBiID0gYTsgYSA9IHNhZmVfYWRkKFQxLCBUMik7XG4gICAgfVxuICAgIEhBU0hbMF0gPSBzYWZlX2FkZChhLCBIQVNIWzBdKTsgSEFTSFsxXSA9IHNhZmVfYWRkKGIsIEhBU0hbMV0pOyBIQVNIWzJdID0gc2FmZV9hZGQoYywgSEFTSFsyXSk7IEhBU0hbM10gPSBzYWZlX2FkZChkLCBIQVNIWzNdKTtcbiAgICBIQVNIWzRdID0gc2FmZV9hZGQoZSwgSEFTSFs0XSk7IEhBU0hbNV0gPSBzYWZlX2FkZChmLCBIQVNIWzVdKTsgSEFTSFs2XSA9IHNhZmVfYWRkKGcsIEhBU0hbNl0pOyBIQVNIWzddID0gc2FmZV9hZGQoaCwgSEFTSFs3XSk7XG4gIH1cbiAgcmV0dXJuIEhBU0g7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTI1NihidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfc2hhMjU2LCAzMiwgdHJ1ZSk7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iXX0=
