(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var AdJS, AdRequest, Page, advertiser, config, engagement, inPubFrame, inPubframe, sf, utils;

  inPubframe = false;

  if (window.parent === window.top && window !== window.top && window["$sf"]) {
    sf = $sf;
    inPubFrame = true;
  } else {
    if (!window["$sf"]) {
      sf = require('../node_modules/safeframe/lib/js/host/host')(true);
    }
  }

  engagement = require('./shared/engagement');

  Page = require('./shared/page');

  AdJS = require('./publisher/slot');

  config = require('./shared/config');

  utils = require('./shared/utils');

  AdRequest = require('./shared/ad_request');

  advertiser = require('./shared/advertiser');

  (function(window) {
    var adframeUrl, controllerUrl, doRender, initSafeFrame, pageDuration, pageLoadMs, renderAd, renderController, safeframeUrl, sessionObj, sfDom, startTicks;
    sessionObj = null;
    if (window === window.top) {
      sessionObj = new Page();
    } else {
      sessionObj = new AdRequest();
    }
    startTicks = utils.now();
    pageLoadMs = 0;
    pageDuration = 0;
    safeframeUrl = config.cdn_url;
    controllerUrl = config.controller_url;
    adframeUrl = config.ad_url;
    sfDom = $sf.lib.dom;
    sfDom.attach("beforeunload", function() {
      pageDuration = utils.now() - startTicks;
      return true;
    });
    doRender = function(cb) {
      var d, div, divs, sfPositions, _i, _len;
      sfPositions = {};
      if (!sfDom.ready()) {
        sfDom.wait(function() {
          var args;
          pageLoadMs = utils.now() - startTicks;
          doRender.apply(null, args);
          return args = null;
        });
      } else {
        renderController();
        divs = (function() {
          var _i, _len, _ref, _results;
          _ref = document.getElementsByTagName("div");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            div = _ref[_i];
            _results.push(div);
          }
          return _results;
        })();
        for (_i = 0, _len = divs.length; _i < _len; _i++) {
          d = divs[_i];
          if (sfDom.attr(d, "data-adjs")) {
            (function(d) {
              return AdJS.create(d, sessionObj);
            })(d);
          }
        }
        return typeof cb === "function" ? cb() : void 0;
      }
    };
    initSafeFrame = function() {
      return $sf.host.Config({
        renderFile: window === window.top ? safeframeUrl : adframeUrl,
        positions: {},
        onStartPosRender: function() {},
        onFailure: function() {},
        onAdLoad: function(id) {
          return AdJS(id).load();
        },
        onBeforePosMsg: function() {},
        onPosMsg: function(id, msg, content) {
          return AdJS(id).handleMessage(msg, content);
        }
      });
    };
    renderController = function() {
      var div, parent;
      div = document.createElement("div");
      parent = document.createElement("div");
      parent.appendChild(div);
      parent.style.display = "none";
      div.id = sf.lib.lang.guid("controller");
      document.body.appendChild(parent);
      return AdJS("controller").create(div, '', {
        width: 10,
        height: 10,
        supports: ["write-cookie", "read-cookie"],
        renderFile: controllerUrl,
        page: sessionObj.serialize(),
        pageReferrer: document.referrer,
        ignoreEvents: true
      });
    };
    renderAd = function() {
      var div, parent;
      div = document.createElement("div");
      parent = document.createElement("div");
      parent.appendChild(div);
      parent.style.display = "none";
      div.id = sf.lib.lang.guid("creative");
      document.body.appendChild(parent);
      return AdJS("creative").create(div, '', {
        width: 10,
        height: 10,
        renderFile: adframeUrl,
        page: sessionObj.serialize(),
        pageReferrer: document.referrer,
        ignoreEvents: true
      });
    };
    AdJS.render = function(cb) {
      var adJsScript, clientId, s;
      adJsScript = ((function() {
        var _i, _len, _ref, _results;
        _ref = document.getElementsByTagName("script");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (sfDom.attr(s, "data-adjs")) {
            _results.push(s);
          }
        }
        return _results;
      })())[0];
      clientId = sfDom.attr(adJsScript, "data-client-id");
      sessionObj.set({
        client_id: clientId
      });
      if (!inPubFrame) {
        initSafeFrame();
      }
      if (window.top === window) {
        return doRender();
      } else if (inPubFrame) {
        sessionObj.set({
          depth_position: 0
        });
        return advertiser.work(sessionObj, window);
      } else {
        return renderAd();
      }
    };
    engagement.onEngagement(function() {
      var ad, _, _ref, _results;
      _ref = AdJS.slots;
      _results = [];
      for (_ in _ref) {
        ad = _ref[_];
        if (ad.currentlyInview() && !ad.engaged) {
          _results.push(ad.engage());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
    (function() {
      return AdJS.render();
    })();
    if (!inPubframe) {
      window.$ad = AdJS;
    }
    return AdJS;
  })(window);

}).call(this);

},{"../node_modules/safeframe/lib/js/host/host":20,"./publisher/slot":2,"./shared/ad_request":3,"./shared/advertiser":4,"./shared/config":6,"./shared/engagement":8,"./shared/page":10,"./shared/utils":12}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var events, sf, sfDom, sizes, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sf = require('safeframe');

  sizes = require('../shared/sizes');

  utils = require('../shared/utils');

  events = require('../shared/event')(["request", "click", "load", "view", "unload", "focus", "engage", "unfocus", "expand", "collapse", "refreshed", "cookie", "receive", "unview", "timeout"]);

  sfDom = sf.lib.dom;

  module.exports = (function(sf) {
    var SCRIPT_REGEX, Slot, TIMEOUT_TIME, oldTrigger, slots;
    TIMEOUT_TIME = 5000;
    slots = {};
    SCRIPT_REGEX = /<!--([\s\S]*)-->/;
    Slot = (function() {
      function Slot(adId) {
        this.trigger = __bind(this.trigger, this);
        if (this instanceof Slot) {
          return this.init(adId);
        } else {
          return new Slot(adId);
        }
      }

      Slot.prototype.init = function(adId) {
        if (slots[adId]) {
          return slots[adId];
        }
        this.id = adId;
        this.count = 1;
        slots[adId] = this;
        return this.initEvents();
      };

      Slot.prototype.startAutoRefresh = function(delay, cb) {
        if (delay == null) {
          delay = 60;
        }
        if (!this._isAutoRefreshing) {
          this._isAutoRefreshing = true;
          this._refreshInterval = setTimeout((function(_this) {
            return function() {
              _this._isAutoRefreshing = false;
              if (_this.loadTime) {
                return _this.refresh(cb);
              }
            };
          })(this), delay * 1000);
        }
        return this;
      };

      Slot.prototype.stopAutoRefresh = function() {
        clearTimeout(this._refreshInterval);
        this._isAutoRefreshing = false;
        this._refreshInterval = null;
        return this;
      };

      Slot.prototype.refresh = function(cb) {
        this.remove();
        this.count++;
        this.posMeta.setValue("load_n", "extended", this.count);
        sf.host.render(this.pos);
        this.frame = document.getElementById(this.posConfig.dest);
        if (typeof cb === "function") {
          cb(this);
        }
        this.refreshed();
        return this;
      };

      Slot.prototype.trigger = function(event) {
        var _ref;
        if (!((_ref = this.options) != null ? _ref.ignoreEvents : void 0)) {
          events.trigger.apply(this, arguments);
          Slot.trigger(event, this, arguments[1]);
        }
        return this;
      };

      Slot.prototype.handleMessage = function(msg, content) {
        switch (msg) {
          case "focus-change":
            if (content) {
              return this.focus();
            } else {
              return this.unfocus();
            }
            break;
          case "geom-update":
            return function() {};
          case "expand":
            return this.expand(content);
          case "collapse":
            return this.collapse(content);
          case "viewed":
            if (!this.viewed) {
              return this.view();
            }
            break;
          case "unviewed":
            if (!(this.unviewed && this.viewed)) {
              return this.unview();
            }
            break;
          case "clicked":
            if (!this.clicked) {
              return this.click();
            }
            break;
          case "requested":
            return this.request();
          case "cookie-write":
            return this.cookie({
              cookie: "write",
              content: content
            });
          case "cookie-read":
            return this.cookie({
              cookie: "read",
              content: content
            });
          case "reload":
            return this.reload();
          case "msg":
            return this.receive(decodeURIComponent(content));
          default:
            return null;
        }
      };

      Slot.prototype.initEvents = function() {
        this.request(function() {
          return this.requestTime = utils.now();
        });
        this.load(function() {
          this.loadChain = utils.countFrames(this.frame.contentWindow);
          return this.loadTime = utils.now();
        });
        this.view(function() {
          this.viewed = true;
          return this.viewTime = utils.now();
        });
        this.engage(function() {
          if (!this.engaged) {
            this.engaged = true;
            this.engageTime = utils.now();
            return this.notifyFrame("engaged");
          }
        });
        this.unview(function() {
          this.unviewed = true;
          return this.unviewTime = utils.now();
        });
        this.unload(function() {
          return this.unloadTime = utils.now();
        });
        return this.click(function() {
          return this.clicked = true;
        });
      };

      Slot.prototype.loadChain = 0;

      Slot.prototype.notifyFrame = function(cmd, data) {
        var msgObj;
        msgObj = sf.lib.lang.ParamHash();
        if (this.posConfig) {
          msgObj.pos = this.posConfig.id;
          msgObj.cmd = cmd;
          msgObj.value = escape(data);
          return sfDom.msghost.send(this.posConfig.dest, msgObj.toString());
        }
      };

      Slot.prototype.create = function(elem, html, options) {
        var height, s, supports, width, _i, _j, _len, _len1, _ref, _ref1;
        this.options = options != null ? options : {};
        width = this.options.width || elem.offsetWidth;
        height = this.options.height || elem.offsetHeight;
        supports = {};
        _ref = this.options.supports || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          supports[s] = true;
        }
        _ref1 = this.options.disables || [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          s = _ref1[_j];
          supports[s] = false;
        }
        if (this.elem) {
          return;
        }
        this.elem = elem;
        elem.id || (elem.id = sf.lib.lang.guid("pos"));
        this.posMeta = new sf.host.PosMeta(null, "extended", {
          inview: this.options.inview,
          page: this.options.page,
          host: document.location.hostname,
          referrer: this.options.referrer,
          location: document.location.href,
          slot_id: this.id,
          load_n: this.count
        });
        this.posConfig = new sf.host.PosConfig({
          id: this.id,
          dest: elem.id,
          w: width,
          h: height,
          supports: supports,
          renderFile: this.options.renderFile
        });
        this.pos = new sf.host.Position(this.posConfig.id, html, this.posMeta);
        if (this.options.refresh_oov) {
          this.unview(function() {
            return setTimeout((function(_this) {
              return function() {
                return _this.refresh();
              };
            })(this), 1);
          });
        }
        if (this.options.refresh_time != null) {
          this.refreshTime = sf.lib.lang.cnum(this.options.refresh_time, 0);
          if (this.refreshTime > 0) {
            this.load(function() {
              return this.startAutoRefresh(this.refreshTime);
            });
            this.timeout(function() {
              this.stopAutoRefresh();
              return this.refresh();
            });
          }
        }
        sf.host.render(this.pos);
        this.frame = document.getElementById(elem.id);
        return this;
      };

      Slot.prototype.remove = function(dontFire) {
        if (!dontFire) {
          this.unload();
        }
        clearTimeout(this._refreshInterval);
        this.viewed = false;
        this.engaged = false;
        this.unviewed = false;
        this.frame = null;
        this.frameCount = 0;
        this.requestTime = null;
        this.loadTime = null;
        this.viewTime = null;
        this.engageTime = null;
        this.unviewTime = null;
        this.unloadTime = null;
        sf.host.nuke(this.id);
        return this;
      };

      Slot.prototype.destroy = function() {
        this.stopAutoRefresh();
        this.remove();
        delete this.events;
        return delete slots[this.id];
      };

      Slot.prototype.reload = function() {
        if (this.options.inview) {
          this.remove(true);
          sf.host.render(this.pos);
          return this.frame = document.getElementById(this.posConfig.dest);
        }
      };

      Slot.prototype.currentlyInview = function() {
        return sf.host.inViewPercentage(this.id) > 50 && this.viewed;
      };

      Slot.prototype.inviewPercentage = function() {
        return sf.host.inViewPercentage(this.id);
      };

      return Slot;

    })();
    Slot.destroy = function() {
      var ad, _, _results;
      _results = [];
      for (_ in slots) {
        ad = slots[_];
        _results.push(ad.destroy());
      }
      return _results;
    };
    Slot.events = {};
    oldTrigger = Slot.prototype.trigger;
    sf.lib.lang.mix(Slot.prototype, events);
    Slot.prototype.trigger = oldTrigger;
    sf.lib.lang.mix(Slot, events);
    Slot.create = function(d, page) {
      var adId, disables, div, height, posId, size, supports, template, width, _base, _base1, _ref;
      template = ((_ref = d.innerHTML.match(SCRIPT_REGEX)) != null ? _ref[1] : void 0) || d.innerHTML;
      posId = sf.lib.lang.guid("pos");
      adId = d.id || posId;
      div = document.createElement("div");
      div.id = posId;
      d.appendChild(div);
      supports = [];
      disables = [];
      if (size = sizes[sfDom.attr(d, "data-ad-type")]) {
        width = size[0], height = size[1];
      }
      Slot(adId).create(div, template, {
        width: width || sfDom.attr(d, "data-width"),
        height: height || sfDom.attr(d, "data-height"),
        supports: typeof (_base = sfDom.attr(d, "data-supports")).split === "function" ? _base.split(",") : void 0,
        disables: typeof (_base1 = sfDom.attr(d, "data-disables")).split === "function" ? _base1.split(",") : void 0,
        inview: sf.lib.lang.cbool(sfDom.attr(d, "data-inview")),
        refresh_time: sfDom.attr(d, "data-refresh-time"),
        refresh_oov: sf.lib.lang.cbool(sfDom.attr(d, "data-refresh-oov")),
        page: page != null ? page.serialize() : void 0,
        referrer: sfDom.attr(d, "data-referrer"),
        ignoreEvents: sf.lib.lang.cbool(sfDom.attr(d, "data-ignore-events"))
      });
      return Slot(adId);
    };
    Slot.slots = slots;
    Slot.sizes = sizes;
    return Slot;
  })(sf);

}).call(this);

},{"../shared/event":9,"../shared/sizes":11,"../shared/utils":12,"safeframe":18}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Base = require('./base');

  module.exports = (function(window) {
    var AdRequest;
    AdRequest = (function(_super) {
      __extends(AdRequest, _super);

      function AdRequest(serializedParams) {
        AdRequest.__super__.constructor.apply(this, arguments);
        if (serializedParams) {
          this.deserialize(serializedParams);
        } else {
          this.set({
            full_url: window.document.location.href,
            referrer: window.document.referrer
          }, {
            silent: true
          });
        }
      }

      AdRequest.prototype.path = "/ad";

      AdRequest.prototype.constantFields = ["site_user_id", "page_id", "visit_id", "ad_id"];

      return AdRequest;

    })(Base);
    return AdRequest;
  })(window);

}).call(this);

},{"./base":5}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var endpoint, utils;

  endpoint = require('./endpoint');

  utils = require('./utils');

  module.exports = (function(window) {
    var work;
    work = function(adRequest, pubFrame) {
      var controller;
      controller = null;
      utils.defineProperty(window, "getDetails", {
        writeable: false,
        value: function() {
          return adRequest;
        },
        configurable: false
      });
      return endpoint.send(adRequest, function() {
        pubFrame.$ad.readAd(window);
        return utils.findController(function(ctrl) {
          controller = ctrl;
          return adRequest.change(function() {
            return controller.send(adRequest);
          });
        });
      });
    };
    return {
      work: work
    };
  })(window);

}).call(this);

},{"./endpoint":7,"./utils":12}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils, uuid;

  uuid = require('node-uuid');

  utils = require('./utils');

  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.id = uuid.v4();
        this.attributes || (this.attributes = {});
        this._events = [];
        this._dirty = {};
      }

      Base.prototype.set = function(attrs, options) {
        var changed, changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        if (typeof attrs !== "object") {
          throw "attrs must be an object";
        }
        changed = false;
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
            this._dirty[k] = v;
            this.attributes[k] = v;
          }
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      Base.prototype._cleanDirty = function() {
        return this._dirty = {};
      };

      Base.prototype.changedFields = function() {
        var field, k, params, v, _i, _len, _ref, _ref1;
        params = {};
        _ref = this._dirty;
        for (k in _ref) {
          v = _ref[k];
          params[k] = v;
        }
        _ref1 = this.constantFields;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          field = _ref1[_i];
          if (this.attributes[field]) {
            params[field] = this.attributes[field];
          }
        }
        this._cleanDirty();
        return params;
      };

      Base.prototype.serialize = function() {
        return utils.toQuery(this.attributes);
      };

      Base.prototype.deserialize = function(str) {
        return this.set(utils.fromQuery(str), {
          silent: true
        });
      };

      return Base;

    })();
  })();

}).call(this);

},{"./utils":12,"node-uuid":16}],6:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html',
        controller_url: "base/lib/html/controllerframe.html",
        ad_url: "base/lib/html/adframe.html",
        visit_expiry: 0.03,
        version: "0.0.1",
        domain: "localhost"
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//api.adjs.net/1",
        cdn_url: "//cdn.adjs.net/html/adjsframe.html",
        visit_expiry: 30,
        version: "0.0.1",
        domain: "adjs.net",
        controller_url: "//cdn.adjs.net/html/controllerframe.html",
        ad_url: "//cdn.adjs.net/html/adframe.html"
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html',
        visit_expiry: 3,
        version: "0.0.1",
        domain: "localhost",
        controller_url: "../lib/html/controllerframe.html",
        ad_url: "../lib/html/adframe.html"
      };
    }
  })();

}).call(this);

}).call(this,require("8DwohR"))
},{"8DwohR":35}],7:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var config, utils;

  config = require('./config');

  utils = require('./utils');

  module.exports = (function($sf) {
    var RETRY_TIMEOUT, combine, endpoint, error, isTimeout, pendingRequests, postData, prefix, send, sendData, sendingRequests, success, timeoutValue;
    prefix = config.api;
    pendingRequests = {};
    sendingRequests = {};
    RETRY_TIMEOUT = 100;
    isTimeout = false;
    timeoutValue = null;
    send = function(obj, cb) {
      pendingRequests[obj.id] = [obj, cb];
      return postData();
    };
    combine = function(req, adReq, cb, retry) {
      var attrs, f, requestParams, _i, _j, _len, _len1, _ref, _ref1;
      if (retry == null) {
        retry = 3;
      }
      attrs = {};
      if (req.attributes.req_id && adReq.attributes.ad_id) {
        _ref = adReq.constantFields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          f = _ref[_i];
          attrs[f] = adReq.attributes[f];
        }
        _ref1 = req.constantFields;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          f = _ref1[_j];
          attrs[f] = req.attributes[f];
        }
        requestParams = {
          data: attrs,
          success: function(resp) {
            return typeof cb === "function" ? cb(resp) : void 0;
          },
          error: function(err) {
            return typeof cb === "function" ? cb(err) : void 0;
          }
        };
        if (prefix.indexOf(document.location.hostname) >= 0) {
          requestParams.method = "post";
          requestParams.url = "event_ads";
        } else {
          requestParams.type = "jsonp";
          requestParams.url = prefix + "/event_ads";
        }
        return utils.sendRequest(requestParams);
      } else if (retry >= 0) {
        return setTimeout(((function(_this) {
          return function() {
            return combine(req, adReq, cb, retry - 1);
          };
        })(this)), 100);
      }
    };
    success = function(obj, resp, cb) {
      obj.set(resp, {
        silent: true
      });
      delete sendingRequests[obj.id];
      console.log("cb");
      return typeof cb === "function" ? cb(obj) : void 0;
    };
    error = function(obj, err, cb) {};
    sendData = function(params, obj, cb) {
      var requestParams;
      requestParams = {
        data: params,
        success: function(resp) {
          return success(obj, resp, cb);
        },
        error: function(err) {
          return error(obj, err, cb);
        }
      };
      if (prefix.indexOf(document.location.hostname) >= 0) {
        requestParams.method = "post";
        requestParams.url = obj.path;
      } else {
        requestParams.type = "jsonp";
        requestParams.url = prefix + obj.path;
      }
      return utils.sendRequest(requestParams);
    };
    postData = function() {
      var cb, id, k, obj, params, v, _ref, _ref1;
      for (id in pendingRequests) {
        _ref = pendingRequests[id], obj = _ref[0], cb = _ref[1];
        if (!sendingRequests[obj.id]) {
          delete pendingRequests[id];
          params = {};
          _ref1 = obj.changedFields();
          for (k in _ref1) {
            v = _ref1[k];
            params[k] = v;
          }
          sendingRequests[obj.id] = obj;
          sendData(params, obj, cb);
        }
      }
      if ($sf.lib.lang.keys(pendingRequests).length > 0 && !isTimeout) {
        isTimeout = true;
        return timeoutValue = setTimeout(function() {
          isTimeout = false;
          return postData();
        }, RETRY_TIMEOUT);
      }
    };
    endpoint = {
      send: send,
      combine: combine
    };
    if (process.env.ENV === "test") {
      endpoint.postData = postData;
      endpoint.sendData = sendData;
      endpoint.success = success;
      endpoint.error = error;
      endpoint.sendingRequests = sendingRequests;
      endpoint.pendingRequests = pendingRequests;
      endpoint.clear = function() {
        isTimeout = false;
        sendingRequests = {};
        pendingRequests = {};
        endpoint.sendingRequests = sendingRequests;
        endpoint.pendingRequests = pendingRequests;
        return clearTimeout(timeoutValue);
      };
    }
    return endpoint;
  })($sf);

}).call(this);

}).call(this,require("8DwohR"))
},{"./config":6,"./utils":12,"8DwohR":35}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils;

  utils = require('./utils');

  module.exports = (function(window, $sf) {
    var ENGAGEMENT_RESET, activityHandler, attach, disengageEvents, doc, engageEvents, engagement, engagementTimeout, lastEngaged, resetEngagement;
    attach = $sf.lib.dom.attach;
    engagement = {
      isEngaged: false
    };
    doc = window.document;
    engageEvents = [];
    disengageEvents = [];
    ENGAGEMENT_RESET = 3000;
    lastEngaged = void 0;
    engagement.onEngagement = function(f) {
      return engageEvents.push(f);
    };
    engagement.onDisengagement = function(f) {
      return disengageEvents.push(f);
    };
    activityHandler = function() {
      var f, _i, _len;
      engagement.isEngaged = true;
      engagement.lastEngaged = utils.now();
      for (_i = 0, _len = engageEvents.length; _i < _len; _i++) {
        f = engageEvents[_i];
        f();
      }
      resetEngagement();
      return true;
    };
    engagementTimeout = null;
    resetEngagement = function() {
      clearTimeout(engagementTimeout);
      return engagementTimeout = setTimeout(function() {
        var f, _i, _len;
        engagement.isEngaged = false;
        for (_i = 0, _len = disengageEvents.length; _i < _len; _i++) {
          f = disengageEvents[_i];
          f();
        }
        return disengageEvents = [];
      }, ENGAGEMENT_RESET);
    };
    attach(doc, 'click', activityHandler);
    attach(doc, 'mouseup', activityHandler);
    attach(doc, 'mousedown', activityHandler);
    attach(doc, 'mousemove', activityHandler);
    attach(doc, 'mousewheel', activityHandler);
    attach(doc, 'keypress', activityHandler);
    attach(doc, 'keydown', activityHandler);
    attach(doc, 'keyup', activityHandler);
    attach(window, 'DOMMouseScroll', activityHandler);
    attach(window, 'scroll', activityHandler);
    attach(window, 'resize', activityHandler);
    attach(window, 'focus', activityHandler);
    attach(window, 'blur', activityHandler);
    return engagement;
  })(window, $sf);

}).call(this);

},{"./utils":12}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = function(eventNames) {
    return (function() {
      var event, events, _i, _len;
      events = {
        on: function(event, cb) {
          var eventList;
          this.events || (this.events = {});
          eventList = this.events[event] || [];
          eventList.push(cb);
          this.events[event] = eventList;
          return this;
        },

        /*
          optionalData needs to be fixed
         */
        trigger: function(event, data, optionalData) {
          var e, ex, _i, _len, _ref;
          this.events || (this.events = {});
          _ref = this.events[event] || [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            try {
              e.call(this, data, optionalData);
            } catch (_error) {
              ex = _error;
            }
          }
          return this;
        }
      };
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        event = eventNames[_i];
        events[event] = (function(event) {
          var f;
          return f = function(data) {
            if (typeof data === "function") {
              return this.on(event, data);
            } else {
              return this.trigger(event, data);
            }
          };
        })(event);
      }
      return events;
    })();
  };

}).call(this);

},{}],10:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, config, cookies, moment, utils, uuid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  cookies = require('cookies-js');

  uuid = require('node-uuid');

  Base = require('./base');

  utils = require('./utils');

  config = require('./config');

  moment = require('moment');

  module.exports = (function($sf, window) {
    var COOKIE_KEY, Page;
    COOKIE_KEY = "_ajsk";
    Page = (function(_super) {
      __extends(Page, _super);

      function Page(serializedParams) {
        Page.__super__.constructor.call(this);
        if (serializedParams) {
          this.deserialize(serializedParams);
        } else {
          this.loadCookieData();
          this.initDefaultAttributes();
        }
      }

      Page.prototype.storeCookie = function() {
        var _ref;
        if (($sf != null ? (_ref = $sf.ext) != null ? _ref.cookie : void 0 : void 0) != null) {
          if (this.attributes.site_user_id) {
            $sf.ext.cookie("" + COOKIE_KEY + "_suid", {
              value: this.attributes.site_user_id,
              expires: moment().add("years", 1).toDate()
            });
          }
          if (this.attributes.visit_id) {
            return $sf.ext.cookie("" + COOKIE_KEY + "_vid", {
              value: this.attributes.visit_id,
              expires: moment().add("seconds", config.visit_expiry * 60).toDate()
            });
          }
        } else {
          if (this.attributes.site_user_id) {
            cookies.set("" + COOKIE_KEY + "_suid", this.attributes.site_user_id, {
              expires: moment().add("years", 1).toDate()
            });
          }
          if (this.attributes.visit_id) {
            return cookies.set("" + COOKIE_KEY + "_vid", this.attributes.visit_id, {
              expires: moment().add("seconds", config.visit_expiry * 60).toDate()
            });
          }
        }
      };

      Page.prototype.loadCookieData = function() {
        var _ref;
        if (($sf != null ? (_ref = $sf.ext) != null ? _ref.cookie : void 0 : void 0) != null) {
          return this.set({
            site_user_id: $sf.ext.cookie("" + COOKIE_KEY + "_suid"),
            visit_id: $sf.ext.cookie("" + COOKIE_KEY + "_vid")
          }, {
            silent: true
          });
        } else {
          return this.set({
            site_user_id: cookies.get("" + COOKIE_KEY + "_suid"),
            visit_id: cookies.get("" + COOKIE_KEY + "_vid")
          }, {
            silent: true
          });
        }
      };

      Page.prototype.set = function(attrs, options) {
        if (options == null) {
          options = {};
        }
        Page.__super__.set.call(this, attrs, options);
        return this.storeCookie();
      };

      Page.prototype.initDefaultAttributes = function() {
        if (window === window.top) {
          return this.set({
            full_url: window.document.location.href,
            referrer: window.document.referrer
          }, {
            silent: true
          });
        } else if (window.parent === window.top) {
          return this.set({
            full_url: window.document.referrer
          });
        }
      };

      Page.prototype.verifyUrl = function() {
        if (window.parent === window.top && window.document.referrer) {
          return true;
        }
      };

      Page.prototype.path = "/page";

      Page.prototype.constantFields = ["site_user_id", "page_id", "visit_id", "full_url"];

      return Page;

    })(Base);
    Page.VISITOR_EXPIRY = config.visit_expiry;
    if (process.env.ENV === "test" || ((typeof _TEST !== "undefined" && _TEST !== null) && _TEST)) {
      Page._COOKIE_KEY = COOKIE_KEY;
      Page.clearCookie = function() {
        cookies.set(COOKIE_KEY + "_suid", void 0);
        return cookies.set(COOKIE_KEY + "_vid", void 0);
      };
    }
    return Page;
  })($sf, window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./base":5,"./config":6,"./utils":12,"8DwohR":35,"cookies-js":13,"moment":15,"node-uuid":16}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    return {
      leaderboard: [728, 90],
      "medium-rectangle": [300, 250]
    };
  })();

}).call(this);

},{}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var reqwest;

  window.JSON || (window.JSON = require('json'));

  reqwest = require('reqwest');

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf) {
    var capitalizeString, countFrames, defineProperty, findController, fromQuery, getFramePosition, keys, nativeReduce, now, reduce, reduceError, sendRequest, toNumber, toQuery;
    sendRequest = function(options) {
      return reqwest(options);
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        } else {
          if (descriptor.value) {
            return obj[prop] = descriptor.value;
          }
        }
      } catch (_error) {
        e = _error;
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    getFramePosition = function(win) {
      var count;
      count = 0;
      if (win.parent !== win.top) {
        count = 1 + getFramePosition(win.parent);
      }
      return count;
    };
    nativeReduce = Array.prototype.reduce;
    reduceError = 'Reduce of empty array with no initial value';
    reduce = function(obj, iterator, memo, context) {
      var index, initial, value, _fn, _i, _len;
      initial = arguments.length > 2;
      if (obj == null) {
        obj = [];
      }
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) {
          iterator = _.bind(iterator, context);
        }
        return (initial ? obj.reduce(iterator, memo) : obj.reduce(iterator));
      }
      _fn = function(value, index, obj) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, obj);
        }
      };
      for (index = _i = 0, _len = obj.length; _i < _len; index = ++_i) {
        value = obj[index];
        _fn(value, index, obj);
      }
      if (!initial) {
        throw new TypeError(reduceError);
      }
      return memo;
    };
    keys = function(obj) {
      return $sf != null ? $sf.lib.lang.keys(obj) : void 0;
    };
    findController = function(cb, retry) {
      var controller, frame, _i, _len, _ref, _ref1;
      if (retry == null) {
        retry = 3;
      }
      controller = null;
      _ref = window.top.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        try {
          if ((_ref1 = frame.$ad) != null ? _ref1.isController : void 0) {
            controller = frame.$ad;
            break;
          }
        } catch (_error) {

        }
      }
      if (controller) {
        return cb(controller);
      } else {
        if (!(retry < 0)) {
          return setTimeout((function() {
            return findController(cb, retry - 1);
          }), 100);
        }
      }
    };
    capitalizeString = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return {
      sendRequest: sendRequest,
      toQuery: toQuery,
      fromQuery: fromQuery,
      toNumber: toNumber,
      now: now,
      defineProperty: defineProperty,
      countFrames: countFrames,
      capitalizeString: capitalizeString,
      keys: keys,
      getFramePosition: getFramePosition,
      reduce: reduce,
      findController: findController
    };
  })($sf);

}).call(this);

},{"json":14,"reqwest":17}],13:[function(require,module,exports){
/*!
 * Cookies.js - 0.3.1
 * Wednesday, April 24 2013 @ 2:28 AM EST
 *
 * Copyright (c) 2013, Scott Hamper
 * Licensed under the MIT license,
 * http://www.opensource.org/licenses/MIT
 */
(function (undefined) {
    'use strict';

    var Cookies = function (key, value, options) {
        return arguments.length === 1 ?
            Cookies.get(key) : Cookies.set(key, value, options);
    };

    // Allows for setter injection in unit tests
    Cookies._document = document;
    Cookies._navigator = navigator;

    Cookies.defaults = {
        path: '/'
    };

    Cookies.get = function (key) {
        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
            Cookies._renewCache();
        }

        return Cookies._cache[key];
    };

    Cookies.set = function (key, value, options) {
        options = Cookies._getExtendedOptions(options);
        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

        return Cookies;
    };

    Cookies.expire = function (key, options) {
        return Cookies.set(key, undefined, options);
    };

    Cookies._getExtendedOptions = function (options) {
        return {
            path: options && options.path || Cookies.defaults.path,
            domain: options && options.domain || Cookies.defaults.domain,
            expires: options && options.expires || Cookies.defaults.expires,
            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
        };
    };

    Cookies._isValidDate = function (date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    };

    Cookies._getExpiresDate = function (expires, now) {
        now = now || new Date();
        switch (typeof expires) {
            case 'number': expires = new Date(now.getTime() + expires * 1000); break;
            case 'string': expires = new Date(expires); break;
        }

        if (expires && !Cookies._isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    };

    Cookies._generateCookieString = function (key, value, options) {
        key = encodeURIComponent(key);
        value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toGMTString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    };

    Cookies._getCookieObjectFromString = function (documentCookie) {
        var cookieObject = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieObject[cookieKvp.key] === undefined) {
                cookieObject[cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieObject;
    };

    Cookies._getKeyValuePairFromCookieString = function (cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        return {
            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
        };
    };

    Cookies._renewCache = function () {
        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);
        Cookies._cachedDocumentCookie = Cookies._document.cookie;
    };

    Cookies._areEnabled = function () {
        return Cookies._navigator.cookieEnabled ||
            Cookies.set('cookies.js', 1).get('cookies.js') === '1';
    };

    Cookies.enabled = Cookies._areEnabled();

    // AMD support
    if (typeof define === 'function' && define.amd) {
        define(function () { return Cookies; });
    // CommonJS and Node.js module support.
    } else if (typeof exports !== 'undefined') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Cookies;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = Cookies;
    } else {
        window.Cookies = Cookies;
    }
})();
},{}],14:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],15:[function(require,module,exports){
(function (global){
//! moment.js
//! version : 2.7.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.7.0",
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _tzm : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
          s: 45,   //seconds to minutes
          m: 45,   //minutes to hours
          h: 22,   //hours to days
          dd: 25,  //days to month (month == 1)
          dm: 45,  //days to months (months > 1)
          dy: 345  //days to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error("Implement me");
        }
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = getLangDefinition(config._l).weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, lang;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            lang = getLangDefinition(config._l);
            dow = lang._week.dow;
            doy = lang._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < relativeTimeThresholds.s  && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= relativeTimeThresholds.dd && ['dd', days] ||
                days <= relativeTimeThresholds.dm && ['M'] ||
                days < relativeTimeThresholds.dy && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
        config._d = new Date(config._i);
    });

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function(threshold, limit) {
      if (relativeTimeThresholds[threshold] === undefined) {
        return false;
      }
      relativeTimeThresholds[threshold] = limit;
      return true;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string' && typeof val === 'string') {
                dur = moment.duration(isNaN(+val) ? +input : +val, isNaN(+val) ? val : input);
            } else if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string' && typeof val === 'string') {
                dur = moment.duration(isNaN(+val) ? +input : +val, isNaN(+val) ? val : input);
            } else if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: deprecate(
                 "moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                "moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    "Accessing Moment through the global scope is " +
                    "deprecated, and will be removed in an upcoming " +
                    "release.",
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],16:[function(require,module,exports){
(function (Buffer){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

}).call(this,require("buffer").Buffer)
},{"buffer":26,"crypto":30}],17:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require("./host/host")(false);

  (function(window, sf) {
    return window["$sf"] = sf;
  })(window, sf);

  module.exports = sf;

}).call(this);

},{"./host/host":20}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var sf;

  sf = require('../shared/base');

  module.exports = (function(window, sf) {
    var AUTO_BOOT_MAX_RETRIES, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, SF_TAG_TYPE, boot, boot_retries, d, doing_auto_boot, dom, has_booted, inline_tags_processed, lang, lib, win, _attr, _auto_boot, _clean_up_booted_tags, _create_pos_markup, _cstr, _elt, _guid, _log, _par, _purge, _ready, _tags;
    win = window != null ? window : this;
    _log = function(msg, is_err) {
      var err_tag, head_el, lib;
      try {
        lib = sf.lib;
        if (lib && lib.logger && win === top) {
          if (is_err) {
            lib.logger.error(msg);
          } else {
            lib.logger.log(msg);
          }
        } else {
          head_el = d.getElementsByTagName("head")[0];
          err_tag = d.createElement("script");
          err_tag.type = "text/plain";
          err_tag.text = "<!-- SafeFrame " + (is_err ? "error" : "log") + ": " + (msg || "unknown") + " -->";
          head_el.appendChild(head_el, err_tag);
        }
      } catch (_error) {}
    };

    /*
    Create the HTML markup for a position if a src property was used
    
    @name $sf.host-_create_pos_markup
    @function
    @private
    @static
    @return {String}
     */
    _create_pos_markup = function(src) {
      return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
    };
    _auto_boot = function() {
      var config, do_auto, doing_auto_boot, e, head, host_file, scr_tag, sf_host;
      do_auto = true;
      config = void 0;
      sf_host = void 0;
      host_file = void 0;
      head = void 0;
      scr_tag = void 0;
      if (has_booted) {
        return;
      }
      sf_host = sf && sf.host;
      if (win === top) {
        if (sf_host && !sf_host.boot) {
          sf_host.boot = boot;
        }
        try {
          config = sf_host && sf_host.Config();
        } catch (_error) {
          e = _error;
          config = null;
        }
        if (!config) {
          try {
            config = sf_host && sf_host.conf;
          } catch (_error) {
            e = _error;
            config = null;
          }
        }
        if (config) {
          if (("auto" in config) && config.auto === false) {
            do_auto = false;
          }
          if (!sf_host.render || !sf_host.Config) {
            host_file = config.hostFile;
            if (host_file) {
              head = _tags("head")[0];
              scr_tag = dom.make("script");
              scr_tag.id = "sf_host_lib";
              scr_tag.type = "text/javascript";
              scr_tag.className = "sf_lib";
              scr_tag.src = host_file;
              if (win.ActiveXObject) {
                scr_tag.onreadystatechange = function() {
                  var doing_auto_boot, rs;
                  rs = scr_tag.readyState;
                  if (rs === "loaded" || rs === "complete") {
                    doing_auto_boot = false;
                    if (do_auto) {
                      boot();
                    }
                    scr_tag.onreadystatechange = null;
                    scr_tag = head = sf_host = config = null;
                  }
                };
              } else {
                scr_tag.onload = function() {
                  var doing_auto_boot;
                  doing_auto_boot = false;
                  if (do_auto) {
                    boot();
                  }
                  scr_tag.onload = null;
                  scr_tag = head = sf_host = config = null;
                };
              }
              doing_auto_boot = true;
              head.appendChild(scr_tag);
              return;
            }
          }
        }
        if (do_auto) {
          if (config) {
            doing_auto_boot = true;
            boot();
            doing_auto_boot = false;
          } else {
            if (boot_retries++ <= AUTO_BOOT_MAX_RETRIES) {
              setTimeout(_auto_boot, 50);
            }
          }
        }
      } else {
        boot();
      }
    };

    /*
    Go through and remove any inline script tags that are our data-islands , which have already been boostrapped
    
    @name $sf.host-_clean_up_booted_tags
    @private
    @function
    @static
     */
    _clean_up_booted_tags = function() {
      var script_tag, script_tag_id;
      script_tag_id = void 0;
      script_tag = void 0;
      if (dom) {
        for (script_tag_id in inline_tags_processed) {
          script_tag = _elt(script_tag_id);
          if (script_tag) {
            _purge(script_tag);
            delete inline_tags_processed[script_tag_id];
          }
        }
      }
    };

    /*
    Search for SafeFrames tags and render them. This function is called
    automatically whenever the SafeFrames publisher library is loaded. However a configuration
    can be applied to not have SafeFrames tags automatically be rendered, requiring a controlled
    call to this function.
    
    @name $sf.host.boot
    @public
    @function
    @static
     */
    boot = function() {
      var boot_positions, data, e, err, errMsg, has_booted, html, idx, lib, meta_key, pos_conf, pos_dest_el, pos_meta, pos_meta_item, pos_obj, prv_meta, prv_meta_key, ret, script_tag, script_tag_id, script_tag_par, script_tags, sf_conf, sf_host, sf_inline_conf, sf_ocnf, shared_meta, typ;
      script_tags = (_tags && _tags("script")) || [];
      boot_positions = [];
      idx = 0;
      ret = false;
      errMsg = void 0;
      sf_host = sf && sf.host;
      sf_inline_conf = sf_host && sf_host.conf;
      script_tag = void 0;
      script_tag_par = void 0;
      script_tag_id = void 0;
      data = void 0;
      html = void 0;
      pos_obj = void 0;
      pos_conf = void 0;
      pos_dest_el = void 0;
      pos_meta = void 0;
      pos_meta_item = void 0;
      typ = void 0;
      shared_meta = void 0;
      prv_meta = void 0;
      prv_meta_key = void 0;
      meta_key = void 0;
      sf_ocnf = void 0;
      err = void 0;
      if (!sf || !lang || !dom) {
        _log("SafeFrame base library not found", true);
        return ret;
      }
      if (!lib) {
        lib = sf && sf.lib;
      }
      if (doing_auto_boot && has_booted) {
        _log("Automatic boot already invoked");
        return ret;
      }
      if (win === top) {
        try {
          sf_conf = sf_host.Config();
        } catch (_error) {
          err = _error;
          sf_conf = null;
        }
        if (sf_inline_conf && !sf_conf) {
          try {
            sf_conf = sf_host.Config(sf_inline_conf);
          } catch (_error) {
            e = _error;
            sf_conf = null;
          }
        }
        if (!sf_conf) {
          _log("No configuration found");
          return ret;
        }
      }
      while (script_tag = script_tags[idx++]) {
        if (script_tag.className === SF_DATATAG_CLASS || _attr(script_tag, "type") === SF_TAG_TYPE) {
          has_booted = true;
          script_tag_id = _attr(script_tag, "id");
          if (!script_tag_id) {
            script_tag_id = _guid("sf_data_element");
            _attr(script_tag, "id", script_tag_id);
          }
          if (inline_tags_processed[script_tag_id]) {
            continue;
          }
          data = script_tag.text || script_tag.innerHTML || script_tag.innerText;
          try {
            data = lang.trim(data);
            data = new Function("return " + data);
            data = data();
          } catch (_error) {
            err = _error;
            data = null;
            errMsg = "Error parsing tag configuration " + (err && err.message || "");
            _log(errMsg, true);
            continue;
          }
          if (data && data.id && (data.html || data.src)) {
            if (win !== top) {
              html = data.html || "";
              html = html || _create_pos_markup(data.src);
              if (!_ready()) {
                d.write(html);
              } else {
                _log("cannot write html content into already loaded document");
              }
            } else {
              script_tag_par = _par(script_tag);
              if (!script_tag_par) {
                _log("can't find parent element for script tag", true);
                continue;
              }
              pos_conf = sf_conf && sf_conf.positions[data.id];
              if (!pos_conf) {
                pos_conf = data.conf;
                pos_conf.id = data.id;
                if (pos_conf) {
                  pos_conf = new sf_host.PosConfig(pos_conf);
                }
              }
              if (!pos_conf) {
                _log("no position conf found pre-defined or inline for position " + data.id, true);
                continue;
              }
              if (!pos_conf.dest) {
                pos_conf = new sf_host.PosConfig(pos_conf, _guid(SF_POSELEM_WRAPPER_CLASS));
              }
              if (data.meta) {
                pos_meta = data.meta;
                meta_key = "";
                shared_meta = {};
                for (meta_key in pos_meta) {
                  pos_meta_item = pos_meta[meta_key];
                  typ = typeof pos_meta_item;
                  if (!prv_meta && typ === "object" && pos_meta_item) {
                    prv_meta = pos_meta_item;
                    prv_meta_key = meta_key;
                  }
                  if (typ !== "object" && typ !== "function") {
                    shared_meta[meta_key] = pos_meta_item;
                  }
                }
                pos_meta = new sf_host.PosMeta(shared_meta, prv_meta_key || "", (prv_meta_key && prv_meta ? prv_meta : null));
              }
              pos_obj = new sf_host.Position(data, null, pos_meta, pos_conf);
              inline_tags_processed[script_tag_id] = script_tag_id;
              pos_dest_el = _elt(pos_conf.dest);
              if (!pos_dest_el) {
                if (_ready()) {
                  pos_dest_el = dom.make("div");
                  _attr(pos_dest_el, "id", pos_conf.dest);
                  try {
                    script_tag_par.insertBefore(pos_dest_el);
                  } catch (_error) {
                    err = _error;
                    _log("failed auto-adding destination element " + err.message, true);
                    continue;
                  }
                } else {
                  d.write("<div id='", pos_conf.dest, "'></div>");
                }
              }
              boot_positions.push(pos_obj);
            }
          } else {
            _log("no content or id property found in the inline position object", true);
          }
        }
      }
      if (boot_positions.length) {
        try {
          sf_host.render(boot_positions);
        } catch (_error) {
          e = _error;
          _log("failed during rendering " + e.message);
        }
      } else {
        _log("no positions to boot");
      }
      dom.wait(_clean_up_booted_tags);
    };
    SF_DATATAG_CLASS = "sf_data";
    SF_TAG_TYPE = "text/x-safeframe";
    AUTO_BOOT_MAX_RETRIES = 100;
    SF_POSELEM_WRAPPER_CLASS = "sf_position";
    d = win && win.document;
    lib = sf.lib;
    lang = lib.lang;
    dom = lib.dom;
    _cstr = lang.cstr;
    _guid = lang.guid;
    _elt = dom.elt;
    _par = dom.par;
    _tags = dom.tags;
    _attr = dom.attr;
    _purge = dom.purge;
    _ready = dom.ready;
    inline_tags_processed = {};
    boot_retries = 0;
    has_booted = false;
    doing_auto_boot = false;
    setTimeout(_auto_boot, 50);
    return sf;
  })(window, sf);

}).call(this);

},{"../shared/base":21}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@namespace $sf.host Defines the Publisher side api, and helper functions
@name $sf.host
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.2
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require('./boot');

  module.exports = function(allowNotTop) {
    if (allowNotTop == null) {
      allowNotTop = false;
    }
    return (function(window, sf) {
      var ATTACH, AUTO, AUTO_BOOT_MAX_RETRIES, BF_POS_MSG, CLIP, COLLAPSE_COMMAND, COMPARE_DOC_POS, COMPAT_MODE, CONTAINS, Config, DEFAULT_RENDER_TIMEOUT, DEFAULT_ZINDEX, DETACH, DOC, DOC_EL, EL_FROM_PT, ERROR_COMMAND, EXPAND_COMMAND, FLASH_MIME, GEOM_UPDATE_INTRVAL, GUID, HEIGHT, HIDDEN, IE_BORDER_ADJ, INTERSECT_FACTOR, LEN, M, MSG, NODE_TYPE, NOTIFY_COLLAPSE, NOTIFY_EXPAND, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, OBJ, ONSCROLL, OVER, PMSG, POS_ID_AUTO_PREFIX, POS_MSG, POS_REL_BOX_ID_PREFIX, PX, ParamHash, PosConfig, PosMeta, Position, SCROLL, SF_DATATAG_CLASS, SF_POSELEM_WRAPPER_CLASS, ST, STR, SUPPORTS_FEATURES, TFXD, VERSION, WIDTH, XCOM_RESP_DELAY, attach_iframe_msging, bounds, canUseHTML5, complete_ifrs, config, contains, currentStyle, current_status, dc, detach_iframe_msging, docRect, dom, env, flashActiveXVersions, flash_ver, focus_update_timer, geckVer, geom_update_timer, get, html5Bound, ieVer, ifr_dest_id_map, iframes, inViewPercentage, initID, isIE, lang, lib, loc, locHost, mgr_bounds_details, msg_pipes, msghostfb, nuke, operaVer, overlaps, pending_ifrs, prep_iframe_msging, render, rendered_ifrs, scroll_parents_attached, send_msg_to_child_iframe, status, ua, usingHTML5, wbVer, win, winRect, win_events_attached, _attr, _build_geom, _calcBorders, _call_xmsg_host_fb, _callable, _cbool, _check_html5_init, _clear_focus_update_timer, _clear_geom_update_timer, _cnum, _collapse_safeframe, _cookieHash, _cookies_enabled_test, _create_pos_markup, _cstr, _doc, _docNode, _elt, _es, _expand_safeframe, _fire_pub_callback, _getClip, _getGeom, _getRectIE, _getRectNonIE, _get_doc_scroll, _get_flash_version, _guid, _handle_frame_load, _handle_msg_evt, _handle_msg_from_outside, _handle_node_scroll, _handle_render_timeout, _handle_unload, _handle_win_blur, _handle_win_focus, _handle_win_geom_resize, _handle_win_geom_scroll, _has_pending_renders, _ifr_view, _isPX, _max, _min, _mix, _noop, _par, _purge, _read_cookie, _ready, _record_error, _rect, _round, _send_generic_response, _send_response, _set_focus_update_timer, _set_geom_update_timer, _shim_frame, _strippedEncodedLocation, _tagName, _tags, _update_focus, _update_geom, _update_geom_win_resize, _update_geom_win_scroll, _view, _write_cookie;
      win = window;
      DEFAULT_RENDER_TIMEOUT = 60000;
      POS_ID_AUTO_PREFIX = "sf_pos";
      POS_REL_BOX_ID_PREFIX = "sf_pos_rel_el";
      SF_DATATAG_CLASS = "sf_data";
      SF_POSELEM_WRAPPER_CLASS = "sf_position";
      AUTO_BOOT_MAX_RETRIES = 100;
      GEOM_UPDATE_INTRVAL = 100;
      XCOM_RESP_DELAY = 1;
      IE_BORDER_ADJ = 2;
      INTERSECT_FACTOR = 10;
      BF_POS_MSG = "onBeforePosMsg";
      POS_MSG = "onPosMsg";
      SUPPORTS_FEATURES = {
        "exp-ovr": 1,
        "exp-push": 0,
        bg: 0,
        pin: 0,
        "read-cookie": 0,
        "write-cookie": 0
      };
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_EXPAND = "expand";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_FOCUS_CHANGE = "focus-change";
      DEFAULT_ZINDEX = 3000;
      OBJ = "object";
      STR = "string";
      ST = "style";
      LEN = "length";
      WIDTH = "width";
      HEIGHT = "height";
      PX = "PX";
      CLIP = "clip";
      SCROLL = "scroll";
      ONSCROLL = "onscroll";
      COMPAT_MODE = "compatMode";
      DOC_EL = "documentElement";
      DOC = "document";
      NODE_TYPE = "nodeType";
      CONTAINS = "contains";
      COMPARE_DOC_POS = "compareDocumentPosition";
      EL_FROM_PT = "elementFromPoint";
      AUTO = "auto";
      HIDDEN = "hidden";
      OVER = "overflow";
      TFXD = "toFixed";
      ATTACH = "attach";
      DETACH = "detach";
      MSG = "message";
      PMSG = "postMessage";
      GUID = "guid";
      FLASH_MIME = "application/x-shockwave-flash";
      VERSION = sf.ver;
      env = sf.env;
      ua = env.ua;
      lib = sf.lib;
      lang = lib.lang;
      dom = lib.dom;
      iframes = dom.iframes;
      _cbool = lang.cbool;
      _cnum = lang.cnum;
      _cstr = lang.cstr;
      _callable = lang.callable;
      _noop = lang.noop;
      _guid = lang[GUID];
      _mix = lang.mix;
      _elt = dom.elt;
      _par = dom.par;
      _tags = dom.tags;
      _attr = dom.attr;
      _doc = dom.doc;
      _tagName = dom.tagName;
      _view = dom.view;
      _ifr_view = iframes.view;
      _purge = dom.purge;
      _ready = dom.ready;
      _es = win && win.escape;
      M = win && win.Math;
      _max = M.max;
      _min = M.min;
      _round = M.round;
      _rect = null;
      ParamHash = lang && lang.ParamHash;
      dc = win && win[DOC];
      isIE = env && env.isIE;
      ieVer = (ua && ua.ie) || 0;
      wbVer = (ua && ua.webkit) || 0;
      geckVer = (ua && ua.gecko) || 0;
      operaVer = (ua && ua.opera) || 0;
      loc = win.location;
      locHost = loc && ((loc.protocol + "//" + (loc.host || loc.hostname)) || "");
      rendered_ifrs = {};
      msg_pipes = {};
      ifr_dest_id_map = {};
      pending_ifrs = {};
      complete_ifrs = {};
      scroll_parents_attached = {};
      mgr_bounds_details = false;
      canUseHTML5 = false;
      html5Bound = false;
      win_events_attached = false;
      geom_update_timer = 0;
      focus_update_timer = 0;
      current_status = null;
      msghostfb = null;
      flash_ver = null;
      config = null;
      flashActiveXVersions = ["ShockwaveFlash.ShockwaveFlash.11", "ShockwaveFlash.ShockwaveFlash.8", "ShockwaveFlash.ShockwaveFlash.7", "ShockwaveFlash.ShockwaveFlash.6", "ShockwaveFlash.ShockwaveFlash"];
      initID = void 0;

      /*
      Configure the base-level settings for the SafeFrames library
      Note that only one configuration can be active at a given time.
      Therefore you cannot change the configuration by creating a new $sf.host.Config while
      the SafeFrames library is busy (however you can add new position configurations).
      Instatiating a new config, when the library is not busy will destroy / remove all currently
      managed positions and there configurations.
      
      @name $sf.host.Config
      @constructor
      @public
      @param {Object} conf An object containing properties for configuration
      @param {Boolean} [conf.auto] Whether or not to have SafeFrames automatically boostrap an render any SafeFrames tags within the page
      @param {String} conf.cdn The protocol,host name, and port parts of a URI, that is a 2ndary origin, used with SafeFrames to render content. For example JS files would be loaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/[filename]"
      @param {Boolean} [conf.debug] Whether or not debug mode is on or off
      @param {String} conf.root The root path part of the URI that is a 2ndary origin, used with SafeFrames to render content. For example the HTML file for rendering content into would beloaded from conf.cdn+"/"+conf.root+"/"+conf.version+"/"+conf.renderFile
      @param {String} conf.renderFile The filename (may also include path info), for which to render content into via a SafeFrame.
      @param {String} [conf.msgFile] The filename (may also include path info), for which to use as a proxy for x-domain messaging whenever HTML5 messaging is not available. Only required if supporting older browsers.
      @param {Number} [conf.to] The maximum amount of time in milliseconds to wait for a SafeFrame to finish rendering, defaults to 60 seconds.
      @param {Function} [conf.onBeforePosMsg] A callback function that gets fired before any cancellable action is requested to be peformed from a a SafeFrame, such as expansion, etc.  Return true out of this callback function to cancel/disallow the action in question.
      @param {Function} [conf.onPosMsg] A callback function that gets fired when an action requested by a SafeFrame is performed
      @param {Function} [conf.onStartPosRender] A callback function that gets fired when a SafeFrame starts to render 3rd party content.
      @param {Function} [conf.onEndPosRender] A callback function that gets fired when a SafeFrame finishes rendering 3rd party content.
      @param {Object} [conf.positions] A map of positions to automatically configure, where each key equals the id of the $sf.host.PosConfig object, and the value is an object containing said object's settings.
       */
      Config = function(conf) {
        var boot_up, conf_pos_map, me, posID, pos_conf, pos_id, pos_map;
        me = this;
        if (!arguments.length) {
          return (config ? _mix({}, config) : null);
        }
        if (!(me instanceof Config)) {
          return new Config(conf);
        }
        if (!conf) {
          config = null;
          return null;
        }
        boot_up = !!config;
        me.auto = ("auto" in conf ? _cbool(conf.auto) : true);
        me.cdn = _cstr(conf.cdn);
        me.debug = _cbool(conf.debug);
        me.root = _cstr(conf.root);
        me.renderFile = _cstr(conf.renderFile);
        me.msgFile = _cstr(conf.msgFile);
        me.to = _cnum(conf.to, DEFAULT_RENDER_TIMEOUT);
        me.ver = _cstr(conf.ver) || VERSION;
        me.onBeforePosMsg = (_callable(conf.onBeforePosMsg) ? conf.onBeforePosMsg : _noop);
        me.onPosMsg = (_callable(conf.onPosMsg) ? conf.onPosMsg : _noop);
        me.onStartPosRender = (_callable(conf.onStartPosRender) ? conf.onStartPosRender : _noop);
        me.onEndPosRender = (_callable(conf.onEndPosRender) ? conf.onEndPosRender : _noop);
        me.onFailure = (_callable(conf.onFailure) ? conf.onFailure : _noop);
        me.onAdLoad = (_callable(conf.onAdLoad) ? conf.onAdLoad : _noop);
        me.onReadCookie = (_callable(conf.onReadCookie) ? conf.onReadCookie : _noop);
        me.onWriteCookie = (_callable(conf.onWriteCookie) ? conf.onWriteCookie : _noop);
        conf_pos_map = conf.positions;
        me.positions = pos_map = {};
        if (conf_pos_map) {
          for (posID in conf_pos_map) {
            pos_conf = conf_pos_map[posID];
            if (pos_conf && typeof pos_conf === OBJ) {
              pos_id = posID || pos_conf.id || _guid(POS_ID_AUTO_PREFIX);
              pos_map[pos_id] = new PosConfig(pos_conf);
            }
          }
        }
        config = me;
        boot_up = !!(boot_up && me.auto && (sf.host.boot != null));
        try {
          if (boot_up) {
            sf.host.boot();
          }
        } catch (_error) {}
        return _mix({}, config);
      };

      /*
      Configure a particualar position for rendering a SafeFrame
      Each $sf.host.PosConfig object has an id property that should be unique.  Creating a new $sf.host.PosConfig with an id, that has already been
      used results in changing the old $sf.host.PosConfig settings, and can only be done if the SafeFrames library is not busy.
      Automatically ads to the position map of the $sf.host.Config object if said config has already been created.
      
      @name $sf.host.PosConfig
      @public
      @constructor
      @param {Object|String} posIDorObj The id of the $sf.host.PosConfig instance, or an object containing all settings that are to be used for the instance.
      @param {String} [posIDorObj.id] The id of the $sf.host.PosConfig instance, if not specified one will be generated automatically.
      @param {String} [posIDorObj.dest] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
      @param {String} [posIDorObj.bg] The color of the background to be used inside the SafeFrame. Default equals "transparent".
      @param {String} [posIDorObj.tgt] The name of the target window where hyperlinks inside a SafeFrame will navigate too...Note that "_self" is not allowed and always converted to "_top". Allowed values are any string value not prefixed with "_", or "_top" or "_blank".
      @param {String} [posIDorObj.css] A string of CSS rules, or a URL that points to a CSS style sheet to be used inside the SafeFrame
      @param {Number} [posIDorObj.w] The width of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
      @param {Number} [posIDorObj.h] The height of the SafeFrame, specified in pixels. Cannot be specified in em, % or another values.
      @param {String} [posIDorObj.size] A string formated as "widthXheight", that defines the width and height of the SafeFrame. The delimiter character "X" is can be specified as lower or upper case.
      @param {String} [posIDorObj.z] The z-index of the SafeFrame.
      @param {Object} [posIDorObj.supports] An object containing key/value pairs for what features/actions are supported by the SafeFrame, and its corresponding value represents a boolean detereming whether that feature can be used.  Currently supported keys are "exp-ovr" == SafeFrame can expand in overlay mode, "exp-push" == SafeFrame can expand in push mode, and "bg" == SafeFrame can change the background of the publisher / host.
      @param {String} [destID] The HTML element id attribute of the HTML element in the document where a SafeFrame will be rendered. Said element MUST exist within the page prior to a render.
      @param {Object} [baseConf] An object representing a $sf.host.Config object to automatically use / create for the SafeFrames library. Note that baseConf can only be used one time, otherwise you have to use the $sf.host.Config object directly.
       */
      PosConfig = function(posIDorObj, destID, baseConf) {
        var me, sz, sz_split, typ;
        me = this;
        typ = (posIDorObj && typeof posIDorObj) || "";
        if (!(me instanceof PosConfig)) {
          return new PosConfig(posIDorObj, destID, baseConf);
        }
        if (typ === OBJ) {
          me.id = _cstr(posIDorObj.id);
          me.dest = _cstr(posIDorObj.dest || destID);
          me.bg = _cstr(posIDorObj.bg) || "transparent";
          me.tgt = _cstr(posIDorObj.tgt) || "_top";
          me.css = _cstr(posIDorObj.css);
          me.w = _cnum(posIDorObj.w, 0);
          me.h = _cnum(posIDorObj.h, 0);
          me.z = _cnum(posIDorObj.z, 0);
          me.renderFile = _cstr(posIDorObj.renderFile) || null;
          me.supports = _mix({}, posIDorObj.supports || SUPPORTS_FEATURES, true, true, true);
          if (!me.w || !me.h) {
            sz = _cstr(posIDorObj.size);
            if (sz) {
              sz_split = sz.split(/x/g);
              me.w = _cnum(sz_split[0], 0);
              me.h = _cnum(sz_split[1], 0);
              me.size = sz;
            } else {
              me.size = "";
            }
          } else {
            me.size = me.w + "x" + me.h;
          }
        } else if (typ === "string") {
          me.id = _cstr(posIDorObj);
          me.dest = _cstr(destID);
        } else {
          me.dest = "";
          me.bg = "transparent";
          me.tgt = "_top";
          me.css = "";
          me.w = 0;
          me.h = 0;
          me.size = "";
          me.z = 0;
          me.supports = {};
        }
        me.id = me.id || _guid(POS_ID_AUTO_PREFIX);
        if (!config && baseConf) {
          Config(baseConf);
        }
        if (config) {
          config.positions[me.id] = me;
        }
        return _mix({}, me);
      };

      /*
      Construct a set of dynamic key/value pairs that can be shared as meta-data with the 3rd party content inside a SafeFrame.
      All data is treated as protected, and can only be specfied during construction of this object.
      
      @exports PosMeta as $sf.host.PosMeta#
      @public
      @constructor
      @class
      @param {Object} shared_object An object containing keys and values to be shared as meta-data inside the SafeFrame
      @param {String} [owner_key] A key name to be used to hold pseudo private keys / values of meta data.
      @param {Object} [owned_obj] An object containing psuedo private keys and values to be shared as meta-data inside the SafeFrame.
      @example
      var shared_data 		 = {content_id:8978098,partner_id:99},
      private_data_key	 = "rmx",
      private_data      = {section_id:2342,site_id:23904},
      meta_data		 = new $sf.host.PosMeta(shared_data, private_data_key, private_data);
      
      //show section id on host side
      alert(meta_data.value("rmx", "site_id")); //== 23904
      
      @example
      //now retrieve this information inside the safe frame
      
      var content_id = $sf.vend.meta("content_id"); //== 8978098
      
      var rmx_section_id = $sf.vend.meta("rmx", "section_id") //== 2342, but note that vendor side code must know the "owner_key" upfront.
       */
      PosMeta = function(shared_obj, owner_key, owned_obj) {

        /*
        A method retrieves a meta data value from this object.
        
        @exports get_value as $sf.host.PosMeta#value
        @param {String} propKey The name of the value to retrieve
        @param {String} [owner_key] The name of the owner key of the meta data value. By default, it is assumed to be shared, so nothing needs to be passed in unless looking for a specific proprietary value
        @return {String|Number|Boolean}
        @default {String} ""
        @public
        @function
         */
        var get_value, me, non_shared, old, posConf, serialize, set_value, shared;
        get_value = function(propKey, owner_key) {
          var ret;
          ret = "";
          if (!propKey || typeof propKey !== STR) {
            return ret;
          }
          if (!owner_key || typeof owner_key !== STR) {
            owner_key = "shared";
          }
          if (owner_key === "shared") {
            ret = shared[propKey] || "";
          } else {
            ret = (propKey in non_shared ? non_shared[prop_key] || "" : "");
          }
          return ret;
        };

        /*
        Return a serialized string representation (in url query string format) of the meta data object
        
        @exports serialize as $sf.host.PosMeta#toString
        @function
        @public
         */
        serialize = function() {
          var obj;
          obj = new ParamHash();
          obj.shared = shared;
          obj.non_shared = non_shared;
          return obj.toString();
        };
        set_value = function(propKey, ownerKey, value) {
          non_shared[ownerKey] || (non_shared[ownerKey] = {});
          return non_shared[ownerKey][propKey] = value;
        };
        me = this;
        shared = void 0;
        non_shared = void 0;
        old = void 0;
        posConf = void 0;
        if (!(me instanceof PosMeta)) {
          return new PosMeta(key, owned_obj, pos, shared_obj);
        }
        shared = {};
        non_shared = {};
        if (!owner_key || typeof owner_key !== STR) {
          return me;
        }
        if (shared_obj && typeof shared_obj === OBJ) {
          shared = _mix(shared, shared_obj);
        }
        if (owned_obj && typeof owned_obj === OBJ) {
          non_shared[owner_key] = owned_obj;
        }
        me.toString = serialize;
        me.value = get_value;
        me.setValue = set_value;
      };

      /*
      Create the HTML markup for a position if a src property was used
      
      @name $sf.host-_create_pos_markup
      @function
      @private
      @static
      @return {String}
       */
      _create_pos_markup = function(src) {
        var ckVal, fVer;
        if (src) {
          if (src.indexOf("${sf_ver}") > -1) {
            src = src.replace(/\${sf_ver}/g, $sf.ver);
          }
          if (src.indexOf("${ck_on}") > -1) {
            ckVal = (_cookies_enabled_test() ? "1" : "0");
            src = src.replace(/\${ck_on}/g, ckVal);
          }
          if (src.indexOf("${flash_ver}") > -1) {
            fVer = _get_flash_version();
            src = src.replace(/\${flash_ver}/g, fVer);
          }
        }
        return _cstr(["<scr", "ipt type='text/javascript', src='", src, "'></scr", "ipt>"]);
      };

      /*
      Get the falsh version number
       */
      _get_flash_version = function() {
        var err, getActiveXVersion, i, mimeTypes, obj, p, tmpVer;
        if (flash_ver !== null) {
          return flash_ver;
        }
        if (navigator.plugins && navigator.plugins.length > 0) {
          mimeTypes = navigator.mimeTypes;
          if (mimeTypes && mimeTypes[FLASH_MIME] && mimeTypes[FLASH_MIME].enabledPlugin && mimeTypes[FLASH_MIME].enabledPlugin.description) {
            flash_ver = mimeTypes[FLASH_MIME].enabledPlugin.version;
          }
        } else if (sf.env.isIE) {
          i = 0;
          while (i < flashActiveXVersions.length) {
            try {
              obj = new ActiveXObject(flashActiveXVersions[i]);
              tmpVer = obj.GetVariable("$version");
              p = tmpVer.indexOf(" ");
              if (p > -1) {
                flash_ver = tmpVer.substr(p + 1).replace(/,/g, ".");
              } else {
                flash_ver = tmpVer.replace(/,/g, ".");
              }
              break;
            } catch (_error) {
              err = _error;
              obj = null;
              flash_ver = 0;
              continue;
            }
            i++;
          }
        } else {
          flash_ver = 0;
        }
        return flash_ver;
        getActiveXVersion = function(activeXObj) {
          var version;
          version = -1;
          try {
            version = activeXObj.GetVariable("$version");
          } catch (_error) {}
          return version;
        };
      };

      /*
      Test to see if cookies are enabled
       */
      _cookies_enabled_test = function() {
        var cookieEnabled;
        cookieEnabled = (navigator.cookieEnabled ? true : false);
        if (typeof navigator.cookieEnabled === "undefined" && !cookieEnabled) {
          document.cookie = "testcookie";
          cookieEnabled = (document.cookie.indexOf("testcookie") !== -1 ? true : false);
          if (navigator) {
            navigator.cookieEnabled = cookieEnabled;
          }
        }
        return cookieEnabled;
      };

      /*
      Construction a postion content object that contains HTML, optionally meta-data, and optionally a position configuration to use.
      The id specified must match an id for a $sf.host.PosConfig (although said config could be specfied directly here via arguments).
      
      @name $sf.host.Position
      @constructor
      @public
      @param {Object|String} posIDorObj The id of the position which maps to its configuration, or an object represeting the various values of an $sf.host.Position instance.
      @param {String} [posIDorObj.id] The id of the position which maps to its configuration.
      @param {String} [posIDorObj.html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
      @param {String} [posIDorObj.src] An optional URL to be used for redering inside the SafeFrame which will automatically generate a SCRIPT tag with the specified URL.
      @param {$sf.host.PosMeta} [posIDorObj.meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
      @param {Object} [posIDorObj.conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
      @param {String} [html] The HTML content to be rendered inside the SafeFrame. Note that HTML strings which have SCRIPT tags or other special characters may need to be properly escaped in order to avoid JavaScript syntax errors.
      @param {$sf.host.PosMeta} [meta] An optional instance of the $sf.host.PosMeta object to be passed along into the SafeFrame
      @param {Object} [conf] An optional representation of an $sf.host.PosConfig object to be used as the configuration for the SafeFrame position.
       */
      Position = function(posIDorObj, html, meta, conf) {
        var id, me, msg, origHtml, typ;
        me = this;
        typ = posIDorObj && typeof posIDorObj;
        origHtml = html;
        if (!(me instanceof Position)) {
          return new Position(posIDorObj, html, meta, conf);
        }
        if (config == null) {
          msg = "Publisher Config not initialized - abort";
          sf.lib.logger.error(msg);
          sf.info.errs.push(msg);
          return;
        }
        if (typ === OBJ) {
          _mix(me, posIDorObj);
        } else {
          id = me.id = _cstr(posIDorObj) || _guid(POS_ID_AUTO_PREFIX);
        }
        if (!html) {
          if (me.src) {
            me.html = _create_pos_markup(me.src);
          } else {
            me.html = me.html || "";
            me.src = "";
          }
        } else {
          me.html = html;
          me.src = "";
        }
        if (!me.html) {
          me.html = "";
        }
        me.meta = meta || me.meta || {};
        me.conf = conf || me.conf || {};
        if (id) {
          if (config && config.positions[id]) {
            me.conf = config.positions[id];
          } else {
            if (conf) {
              conf.id = id;
              me.conf = new PosConfig(conf);
            }
          }
        }
      };

      /*
      @namespace $sf.lib.dom.msghost Contains functionality to reside in the top level page for sending and receiving x-domain messages to SafeFrame containers
      @name $sf.lib.dom.msghost
       */

      /*
      Returns the root document HTMLElement / node
      @name $sf.lib.dom-_docNode
      @private
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as a reference for finding the root document element.
      @returns {HTMLElement}
       */
      _docNode = function(el) {
        var compatMode, d, root;
        d = (el && _doc(el)) || dc;
        compatMode = d[COMPAT_MODE];
        root = d[DOC_EL];
        if (compatMode && !operaVer && compatMode !== "CSS1Compat") {
          root = d.body;
        }
        return root;
      };

      /*
      Returns whether or not a value is specified in pixels
      @name $sf.lib.dom-_isPX
      @private
      @static
      @function
      @param {String} val A css value of size
      @returns {Boolean}
       */
      _isPX = function(val) {
        val = _cstr(val);
        if (val && val.search(/\D+/g) === -1) {
          return true;
        }
        if (val && val.search(/px/g) !== -1) {
          return true;
        }
      };

      /*
      Return an array of values of clipping region information. Array represents top, right, bottom, left values respectively.
      If values are not specified in pixels, or no clip region is defined for that element, -1 is returned for each value.
      
      @name $sf.lib.dom-_getClip
      @private
      @function
      @static
      @param {HTMLStyleObject} curSt The current style object of an HTMLElement
      @return {Array}
       */
      _getClip = function(curSt) {
        var clipVal, idx, len, prop, props, ret, val;
        ret = [-1, -1, -1, -1];
        props = [CLIP + "Top", CLIP + "Right", CLIP + "Bottom", CLIP + "Left"];
        idx = 0;
        clipVal = void 0;
        prop = void 0;
        val = void 0;
        len = void 0;
        if (!curSt) {
          return ret;
        }
        if (ieVer) {
          while (prop = props[idx]) {
            clipVal = curSt[prop];
            if (_isPX(clipVal)) {
              clipVal = _cnum(clipVal, -1);
              if (clipVal >= 0) {
                ret[idx] = clipVal;
              }
            }
            idx++;
          }
        } else {
          clipVal = curSt[CLIP];
          if (clipVal && clipVal.search(/\d+/g) !== -1) {
            clipVal = clipVal.replace(/\w+\(([^\)]*?)\)/g, "$1");
            ret = clipVal.split(" ");
            ret = (ret[LEN] <= 1 ? ret.split(",") : ret);
            len = ret[LEN];
            idx = 0;
            while (len--) {
              val = ret[idx];
              if (!_isPX(val)) {
                ret[idx] = -1;
              } else {
                ret[idx] = _cnum(val, -1);
              }
              idx++;
            }
          }
        }
        return ret;
      };

      /*
      Returns border values in pixels if possible to help calculate geometry of an element
      
      @name $sf.lib.dom-_calcBorders
      @private
      @static
      @function
      @param {HTMLElement} el The HTMLElement for which to look at. . .
      @param {Object} rect The rect object generated for the HTMLElement in question to be adjusted
      @returns {Object} rect
       */
      _calcBorders = function(el, rect) {
        var l, re, st, t;
        t = 0;
        l = 0;
        st = void 0;
        re = /^t(?:able|d|h|r|head|foot)$/i;
        st = currentStyle(el);
        if (st) {
          t = st["borderTopWidth"];
          l = st["borderLeftWidth"];
          t = (_isPX(t) ? _cnum(t, 0) : 0);
          l = (_isPX(l) ? _cnum(l, 0) : 0);
          if (geckVer && re.test(_tagName(el))) {
            t = l = 0;
          }
        }
        rect = rect || {
          t: 0,
          l: 0
        };
        rect.t += t;
        rect.l += l;
        return rect;
      };

      /*
      Retrieve scroll values of a document
      
      @name $sf.lib.dom-_get_doc_scroll
      @private
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as a reference document rather than the default main document
      @return {Object} Contains x, y, w, h properties for scrolling
       */
      _get_doc_scroll = function(el) {
        var d, db, de, def, dv, offsetX, offsetY, pos;
        pos = {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        };
        def = {
          scrollLeft: 0,
          scrollTop: 0,
          scrollWidth: 0,
          scrollHeight: 0
        };
        d = void 0;
        de = void 0;
        dv = void 0;
        db = void 0;
        offsetX = 0;
        offsetY = 0;
        d = _doc(el) || dc;
        de = d[DOC_EL] || def;
        db = d.body || def;
        dv = d.defaultView;
        if (dv) {
          offsetX = _cnum(dv.pageXOffset, 0);
          offsetY = _cnum(dv.pageYOffset, 0);
        }
        pos.x = _max(de.scrollLeft, db.scrollLeft, offsetX);
        pos.y = _max(de.scrollTop, db.scrollTop, offsetY);
        pos.w = _max(de.scrollWidth, db.scrollWidth, 0);
        pos.h = _max(de.scrollHeight, db.scrollHeight, 0);
        return pos;
      };

      /*
      Calculate a geometric rectangle for a given element. Note that for IE browsers
      we can use the "getBoundingClientRect" function which saves us some time / increases
      peformance. . however it really can only be called if the DOM is completely loaded,
      and if that is the case we fallback to the brute-force / non-IE method.
      
      @name $sf.lib.dom-_getRectIE
      @private
      @static
      @function
      @param {HTMLElement} el  The element for which to derive a rectangle object
      @returns {Object} An object representing the rectangle for the given HTMLElement
       */
      _getRectIE = function(el) {
        var adjustX, adjustY, bLeft, bTop, box, compatMode, d, de, e, rect, scroll, st, _back;
        rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          w: 0,
          h: 0,
          z: 0
        };
        _back = "BackCompat";
        scroll = void 0;
        box = void 0;
        d = void 0;
        de = void 0;
        compatMode = void 0;
        st = void 0;
        adjustX = void 0;
        adjustY = void 0;
        bLeft = void 0;
        bTop = void 0;
        if (el && el[NODE_TYPE] === 1) {
          try {
            d = _doc(el) || dc;
            if (!dom.ready()) {
              return _getRectNonIE(el);
            }
            scroll = _get_doc_scroll(el);
            box = el.getBoundingClientRect();
            rect.t = box.top;
            rect.l = box.left;
            adjustX = adjustY = IE_BORDER_ADJ;
            compatMode = d[COMPAT_MODE];
            de = d[DOC_EL];
            st = currentStyle(de);
            bLeft = st["borderLeftWidth"];
            bTop = st["borderTopWidth"];
            if (ieVer === 6) {
              if (compatMode !== _back) {
                adjustX = adjustY = 0;
              }
            }
            if (compatMode === _back) {
              bLeft = (_isPX(bLeft) ? _cnum(bLeft, 0) : 0);
              adjustX = bLeft;
              bTop = (_isPX(bTop) ? _cnum(bTop, 0) : 0);
              adjustY = bTop;
              rect.t -= adjustX;
              rect.l -= adjustY;
            }
            rect.t += scroll.y;
            rect.l += scroll.x;
            rect.b = rect.t + el.offsetHeight;
            rect.r = rect.l + el.offsetWidth;
            rect.w = _max(rect.r - rect.l, 0);
            rect.h = _max(rect.b - rect.t, 0);
            rect.z = currentStyle(el, "zIndex");
          } catch (_error) {
            e = _error;
            rect = {
              t: 0,
              l: 0,
              r: 0,
              b: 0,
              w: 0,
              h: 0,
              z: 0
            };
          }
        }
        return rect;
      };

      /*
      Calculate a geometric rectangle for a given element. For non-IE browsers, we must use
      brute-force and walk up the offsetParent tree. Also takes in consideration for some
      other slight variations in browsers.
      
      @name $sf.lib.dom-_getRectNonIE
      @private
      @static
      @function
      @param {HTMLElement} el  The element for which to derive a rectangle object
      @returns {Object} An object representing the rectangle for the given HTMLElement
       */
      _getRectNonIE = function(el) {
        var bCheck, e, h, parentNode, rect, root, scroll, scrollLeft, scrollTop, w;
        rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          w: 0,
          h: 0,
          z: 0
        };
        scrollTop = 0;
        scrollLeft = 0;
        bCheck = false;
        root = _docNode(el);
        scroll = _get_doc_scroll(el);
        parentNode = void 0;
        w = void 0;
        h = void 0;
        if (el && el[NODE_TYPE] === 1) {
          try {
            rect.l = el.offsetLeft || 0;
            rect.t = el.offsetTop || 0;
            parentNode = el;
            bCheck = geckVer || wbVer > 519;
            while (parentNode = parentNode.offsetParent) {
              rect.t += parentNode.offsetTop || 0;
              rect.l += parentNode.offsetLeft || 0;
              if (bCheck) {
                _calcBorders(parentNode, rect);
              }
              if (parentNode === root) {
                break;
              }
            }
            parentNode = el;
            if (currentStyle(parentNode, "position") !== "fixed") {
              parentNode = el;
              while (parentNode = _par(parentNode)) {
                if (parentNode[NODE_TYPE] === 1) {
                  scrollTop = parentNode.scrollTop || 0;
                  scrollLeft = parentNode.scrollLeft || 0;
                  if (geckVer && currentStyle(parentNode, OVER) !== "visible") {
                    _calcBorders(parentNode, rect);
                  }
                  rect.l -= scrollLeft;
                  rect.t -= scrollTop;
                }
                if (parentNode === root) {
                  break;
                }
              }
              rect.t += scroll.y;
              rect.l += scroll.x;
            } else {
              rect.t += scroll.y;
              rect.l += scroll.x;
            }
            if (!ieVer && el === _docNode(el)) {
              h = el.clientHeight;
              w = el.clientWidth;
            } else {
              h = el.offsetHeight;
              w = el.offsetWidth;
            }
            rect.b = rect.t + h;
            rect.r = rect.l + w;
            rect.w = _max(rect.r - rect.l, 0);
            rect.h = _max(rect.b - rect.t, 0);
            rect.z = currentStyle(el, "zIndex");
          } catch (_error) {
            e = _error;
            rect = {
              t: 0,
              l: 0,
              r: 0,
              b: 0,
              w: 0,
              h: 0,
              z: 0
            };
          }
        }
        return rect;
      };

      /*
      Returns an object that represents a rectangle with the geometric information of an HTMLDocument
      (includes scroll width / height)
      
      @name $sf.lib.dom.docRect
      @public
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as the reference for an HTMLDocument
      @returns {Object}
       */
      docRect = function(el) {
        var h, root, w;
        root = _docNode(el);
        w = 0;
        h = 0;
        if (root) {
          w = root.scrollWidth || 0;
          h = root.scrollHeight || 0;
        }
        return {
          t: 0,
          l: 0,
          b: h,
          r: w,
          w: w,
          h: h
        };
      };

      /*
      Returns an object that represents a rectangle with the geometric information of an HTMLWindow
      (does not include scroll width / height)
      
      @name $sf.lib.dom.winRect
      @public
      @static
      @function
      @param {HTMLElement} [el] An HTMLElement to use as the references for an HTMLWindow
      @returns {Object}
       */
      winRect = function(el) {
        var b, h, l, r, root, t, w, wi;
        wi = (el && _view(el)) || win;
        h = wi.innerHeight || 0;
        w = wi.innerWidth || 0;
        t = wi.screenY || wi.screenTop || 0;
        b = h + t;
        l = wi.screenX || wi.screenLeft || 0;
        r = w + l;
        root = _docNode(el);
        if (!h && !w && root) {
          h = root.clientHeight || 0;
          w = root.clientWidth || 0;
          r = l + w;
          b = t + h;
        }
        return {
          t: t,
          l: l,
          b: b,
          r: r,
          w: w,
          h: h
        };
      };

      /*
      Returns whether or not an HTMLElement is contained within another HTMLElement
      
      @name $sf.lib.dom.contains
      @public
      @static
      @function
      @param {HTMLElement} element The HTMLElement reference to search within
      @param {HTMLElement} needle The HTMLElement for which you want to check if its contained by the 1st parameter
      @returns {Boolean}
       */
      contains = function(element, needle) {
        var el_node_type, needle_node_type, ret;
        ret = false;
        el_node_type = (element && element[NODE_TYPE]) || -1;
        needle_node_type = (needle && needle[NODE_TYPE]) || -1;
        if (el_node_type === 1 && needle_node_type !== -1) {
          if (element[CONTAINS]) {
            if (operaVer || needle_node_type === 1) {
              ret = element[CONTAINS](needle);
            } else {
              while (needle) {
                if (element === needle) {
                  ret = true;
                  break;
                }
                needle = needle.parentNode;
              }
            }
          } else {
            if (element[COMPARE_DOC_POS]) {
              ret = element === needle || !!(element[COMPARE_DOC_POS](needle) & 16);
            }
          }
        }
        return ret;
      };

      /*
      Returns the current value of a style attribute, or the current style object in its entirety depending on whether an attribute parameter is specified
      
      @name $sf.lib.dom.currentStyle
      @public
      @static
      @function
      @param {HTMLElement} el The HTMLElement for which to retrieve style information
      @param {String} [attr] The style attribute (in JavaScript notation, e.g. 'backgroundColor' rather than 'background-color') to fetch.
      @return {HTMLStyleObject} An HTMLStyleObject containing all current style attribute values
      @return {String} The value of an style attribute (only if attr parameter is specified).
       */
      currentStyle = function(el, attr) {
        var comp, e, hasAttr, val;
        val = "";
        hasAttr = !!(arguments.length && attr);
        comp = "getComputedStyle";
        e = void 0;
        if (hasAttr) {
          if (ieVer) {
            try {
              val = el.currentStyle[attr];
            } catch (_error) {
              e = _error;
              val = "";
            }
          } else {
            try {
              val = _view(el)[comp](el, null)[attr];
            } catch (_error) {
              e = _error;
              val = "";
            }
          }
        } else {
          if (ieVer) {
            try {
              val = el.currentStyle;
            } catch (_error) {
              e = _error;
              val = null;
            }
          } else {
            try {
              val = _view(el)[comp](el, null);
            } catch (_error) {
              e = _error;
              val = null;
            }
          }
        }
        return val;
      };

      /*
      Calculate the surrounding boundaries of an HTMLElement, and whether or not the HTMLElement is "in-view" of the user
      
      @name $sf.lib.dom.bounds
      @public
      @static
      @function
      @param {HTMLElement} el The element for which to calculate information
      @param {Object} [details] An object reference used as an output parameter in which further details about the boundaries of the element are specified
      @param {Boolean} [check_3D] Check the element within 3 dimensional space such that any elements covering said element are also take into consideration
      @returns {Object} info An object containing information about the element boundaries
       */
      bounds = function(el, details, check_3D) {
        var b, client_height, client_width, clip, clip_rect, cur_st, doc_rect, el_rect, exp_rect, h, is_scroll_node, is_using_doc_root_b, is_using_doc_root_r, l, offset_height, offset_width, over_x_val, over_y_val, par, r, ref_node, root, root_rect, root_scroll, scroll_height, scroll_left, scroll_top, scroll_width, t, temp_rect, w, x_hidden, xsb_h, y_hidden, ysb_w;
        par = el && _par(el);
        root = _docNode(el);
        el_rect = _rect(el);
        root_rect = _rect(root);
        root_scroll = _get_doc_scroll(root);
        doc_rect = docRect(el);
        clip_rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          w: 0,
          h: 0
        };
        exp_rect = {
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          xs: 0,
          ys: 0,
          xiv: 0,
          yiv: 0,
          iv: 0,
          w: 0,
          h: 0
        };
        xsb_h = 0;
        ysb_w = 0;
        is_scroll_node = false;
        is_using_doc_root_r = false;
        is_using_doc_root_b = false;
        cur_st = void 0;
        w = void 0;
        h = void 0;
        t = void 0;
        l = void 0;
        r = void 0;
        b = void 0;
        scroll_width = void 0;
        offset_width = void 0;
        client_width = void 0;
        scroll_height = void 0;
        offset_height = void 0;
        client_height = void 0;
        over_x_val = void 0;
        scroll_left = void 0;
        scroll_top = void 0;
        over_y_val = void 0;
        clip = void 0;
        x_hidden = void 0;
        y_hidden = void 0;
        ref_node = void 0;
        temp_rect = void 0;
        is_scroll_node = false;
        details = (details && typeof details === OBJ ? details : {});
        if (par) {
          while (cur_st = currentStyle(par)) {
            if (cur_st["display"] === "block" || cur_st["position"] === "absolute" || cur_st["float"] !== "none" || cur_st["clear"] !== "none") {
              over_x_val = cur_st[OVER + "X"];
              over_y_val = cur_st[OVER + "Y"];
              clip = _getClip(cur_st);
              if (par === root) {
                scroll_width = root_scroll.w;
                scroll_height = root_scroll.h;
              } else {
                scroll_width = par.scrollWidth;
                scroll_height = par.scrollHeight;
              }
              offset_width = par.offsetWidth;
              offset_height = par.offsetHeight;
              client_width = par.clientWidth;
              client_height = par.clientHeight;
              if (over_x_val === HIDDEN || clip[1] > 0 || clip[3] > 0) {
                if (!ref_node) {
                  x_hidden = 1;
                  ref_node = par;
                }
              }
              if (over_y_val === HIDDEN || clip[0] > 0 || clip[2] > 0) {
                if (!ref_node) {
                  y_hidden = 1;
                  ref_node = par;
                }
              }
              if (over_x_val === SCROLL) {
                ref_node = par;
                xsb_h = offset_height - client_height;
                is_scroll_node = true;
              }
              if (over_y_val === SCROLL) {
                if (!ref_node) {
                  ref_node = par;
                }
                ysb_w = offset_width - client_width;
                is_scroll_node = true;
              }
              if (over_x_val === AUTO) {
                if (!ref_node) {
                  ref_node = par;
                }
                if (scroll_width > client_width) {
                  xsb_h = offset_height - client_height;
                }
                is_scroll_node = true;
              }
              if (over_y_val === AUTO) {
                if (!ref_node) {
                  ref_node = par;
                }
                if (scroll_height > client_height) {
                  ysb_w = offset_width - client_width;
                }
                is_scroll_node = true;
              }
              if (ref_node) {
                break;
              }
            }
            if (par === root) {
              if (scroll_width > client_width) {
                h = (win.innerHeight || 0) || offset_height;
                xsb_h = h - client_height;
              }
              if (scroll_height > client_height) {
                w = (win.innerWidth || 0) || offset_width;
                ysb_w = w - client_width;
              }
              is_scroll_node = true;
            }
            par = _par(par);
            if (!par || par[NODE_TYPE] !== 1) {
              break;
            }
          }
        }
        if (el_rect.w && el_rect.h) {
          if (!ref_node || ref_node === root) {
            exp_rect.t = _max(el_rect.t, 0);
            exp_rect.l = _max(el_rect.l, 0);
            if (ieVer && dc[COMPAT_MODE] === "BackCompat" && _attr(root, SCROLL) === "no") {
              y_hidden = x_hidden = 1;
            } else {
              cur_st = currentStyle(root);
              if (cur_st) {
                x_hidden = cur_st[OVER + "X"] === HIDDEN;
                y_hidden = cur_st[OVER + "Y"] === HIDDEN;
              }
            }
            if (root_scroll.h > root.clientHeight) {
              if (y_hidden) {
                exp_rect.b = 0;
              } else {
                is_using_doc_root_b = true;
                exp_rect.b = _max(((doc_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
              }
            } else {
              exp_rect.b = _max(((root_rect.h - el_rect.h) - xsb_h) - el_rect.t, 0);
            }
            if (root_scroll.w > root.clientWidth) {
              if (x_hidden) {
                exp_rect.r = 0;
              } else {
                is_using_doc_root_r = true;
                exp_rect.r = _max(((doc_rect.w - el_rect.w) - ysb_w) - el_rect.l, 0);
              }
            } else {
              exp_rect.r = _max(((root_rect.r - el_rect.w) - ysb_w) - el_rect.l, 0);
            }
          } else {
            cur_st = currentStyle(ref_node);
            if (_tagName(ref_node) === "body") {
              ref_node = root;
              t = el_rect.t;
              l = el_rect.l;
            } else {
              t = l = 0;
            }
            clip_rect = _rect(ref_node);
            if (clip[1] > 0) {
              clip_rect.w = clip[1];
              clip_rect.r = clip_rect.l + clip_rect.w;
            }
            if (clip[3] > 0) {
              clip_rect.l = clip_rect.l + clip[3];
              clip_rect.w = clip_rect.w - clip[3];
            }
            if (clip[2] > 0) {
              clip_rect.h = clip[2];
              clip_rect.b = clip_rect.t + clip_rect.h;
            }
            if (clip[0] > 0) {
              clip_rect.t = clip_rect.t + clip[0];
              clip_rect.h = clip_rect.h - clip[0];
            }
            if (el_rect.t > clip_rect.t && clip_rect.t > 0) {
              t = el_rect.t - clip_rect.t;
            }
            if (el_rect.l > clip_rect.l && clip_rect.l > 0) {
              l = el_rect.l - clip_rect.l;
            }
            scroll_top = ref_node.scrollTop;
            scroll_left = ref_node.scrollLeft;
            scroll_height = ref_node.scrollHeight;
            scroll_width = ref_node.scrollWidth;
            exp_rect.t = _max(t, 0);
            exp_rect.l = _max(l, 0);
            if (cur_st) {
              x_hidden = cur_st[OVER + "X"] === HIDDEN || clip[1] > 0 || clip[3] > 0;
              y_hidden = cur_st[OVER + "Y"] === HIDDEN || clip[0] > 0 || clip[2] > 0;
            }
            if (el_rect.t >= clip_rect.b) {
              exp_rect.b = 0;
            } else {
              if (!y_hidden && el_rect.t >= clip_rect.b) {
                y_hidden = 1;
              }
              if (scroll_height > ref_node.clientHeight) {
                if (y_hidden) {
                  exp_rect.b = 0;
                } else {
                  exp_rect.b = _max(((scroll_height - el_rect.h) - xsb_h) - t, 0);
                }
              } else {
                exp_rect.b = _max(((clip_rect.h - el_rect.h) - xsb_h) - t, 0);
              }
            }
            if (el_rect.l >= clip_rect.r) {
              exp_rect.r = 0;
            } else {
              if (!x_hidden && el_rect.l >= clip_rect.r) {
                x_hidden = 1;
              }
              if (scroll_width > ref_node.clientWidth) {
                if (x_hidden) {
                  exp_rect.r = 0;
                } else {
                  exp_rect.r = _max(((scroll_width - el_rect.w) - ysb_w) - l, 0);
                }
              } else {
                exp_rect.r = _max(((clip_rect.w - el_rect.w) - ysb_w) - l, 0);
              }
            }
          }
          exp_rect.xs = (xsb_h ? 1 : 0);
          exp_rect.ys = (ysb_w ? 1 : 0);
          exp_rect.w = exp_rect.r + exp_rect.l;
          exp_rect.h = exp_rect.t + exp_rect.b;
          if (!ref_node || ref_node === root) {
            temp_rect = root_rect;
            ref_node = root;
          } else {
            temp_rect = clip_rect;
          }
          l = _max(el_rect.l, temp_rect.l);
          r = _min(el_rect.r, (is_using_doc_root_r ? _min(doc_rect.r, temp_rect.r) : temp_rect.r));
          w = _max(r - l, 0);
          t = _max(el_rect.t, temp_rect.t);
          b = _min(el_rect.b, (is_using_doc_root_b ? _min(doc_rect.b, temp_rect.b) : temp_rect.b));
          h = _max(b - t, 0);
          exp_rect.xiv = _cnum((w / el_rect.w)[TFXD](2));
          exp_rect.yiv = _cnum((h / el_rect.h)[TFXD](2));
          exp_rect.iv = _cnum(((w * h) / (el_rect.w * el_rect.h))[TFXD](2));
        }
        details.refNode = ref_node || root;
        details.isRoot = ref_node === root;
        details.canScroll = is_scroll_node;
        details.refRect = (!ref_node || ref_node === root ? root_rect : clip_rect);
        details.expRect = exp_rect;
        details.rect = el_rect;
        if (check_3D) {
          (function() {
            var arOvrlaps, el_area, el_h, el_w, idx, len, new_iv, new_xiv, new_yiv, ovr_area, ovr_node, ovr_node_rect;
            idx = 0;
            len = 0;
            arOvrlaps = void 0;
            el_w = void 0;
            el_h = void 0;
            el_area = void 0;
            ovr_node = void 0;
            ovr_node_rect = void 0;
            t = void 0;
            b = void 0;
            l = void 0;
            r = void 0;
            h = void 0;
            w = void 0;
            ovr_area = void 0;
            new_iv = void 0;
            new_xiv = void 0;
            new_yiv = void 0;
            if (exp_rect.iv > .5) {
              mgr_bounds_details = details;
              arOvrlaps = overlaps(el, _cnum(check_3D, 1, 1));
              mgr_bounds_details = null;
              len = arOvrlaps[LEN];
              el_w = el_rect.w;
              el_h = el_rect.h;
              el_area = el_w * el_h;
              if (len) {
                while (ovr_node = arOvrlaps[idx++]) {
                  ovr_node_rect = _rect(ovr_node);
                  l = _max(el_rect.l, ovr_node_rect.l);
                  r = _min(el_rect.r, ovr_node_rect.r);
                  t = _max(el_rect.t, ovr_node_rect.t);
                  b = _min(el_rect.b, ovr_node_rect.b);
                  w = r - l;
                  h = b - t;
                  ovr_area = w * h;
                  new_xiv = (1 - (w / el_w))[TFXD](2);
                  new_yiv = (1 - (h / el_h))[TFXD](2);
                  new_iv = (1 - (ovr_area / el_area))[TFXD](2);
                  if ((new_xiv > 0 && new_xiv < exp_rect.xiv) || (new_yiv > 0 && new_yiv < exp_rect.yiv)) {
                    exp_rect.xiv = new_xiv;
                    exp_rect.yiv = new_yiv;
                    exp_rect.iv = new_iv;
                  }
                }
              }
            }
          })();
        }
        return exp_rect;
      };

      /*
      Find any HTMLElements that are covering a given HTMLElement.
      
      @name $sf.lib.dom.overlaps
      @public
      @static
      @function
      @param {HTMLElement} el The HTMLElement for which to find any other elements that may be covering it.
      @param {Number} [limit] The maximum number of covering elements to return
      @returns {Array} An array of elements that are covering the given element
       */
      overlaps = function(el, limit) {
        var baseH, baseW, checkEl, curH, curW, doc, factor, h, id, idx, l, maxX, maxY, par_details, points, pt, rect, ref_par_node, ref_par_rect, ret, root, seen, t, w, x, y;
        rect = _rect(el);
        doc = _doc(el);
        root = _docNode(doc);
        t = rect.t;
        l = rect.l;
        w = rect.r - rect.l;
        h = rect.b - rect.t;
        factor = INTERSECT_FACTOR;
        ret = [];
        baseW = _round(w / factor);
        baseH = _round(h / factor);
        curW = baseW;
        curH = baseH;
        seen = {};
        par_details = {};
        points = [];
        idx = 0;
        x = void 0;
        y = void 0;
        pt = void 0;
        id = void 0;
        checkEl = void 0;
        ref_par_node = void 0;
        ref_par_rect = void 0;
        maxX = void 0;
        maxY = void 0;
        if (mgr_bounds_details) {
          par_details = mgr_bounds_details;
        } else {
          bounds(el, par_details, true);
        }
        ref_par_node = par_details.refNode;
        ref_par_rect = par_details.refRect;
        if (ref_par_rect && ref_par_node && ref_par_node !== root) {
          maxX = ref_par_rect.r;
          maxY = ref_par_rect.b;
        } else {
          maxX = l + w;
          maxY = t + h;
        }
        if (doc && root && doc[EL_FROM_PT]) {
          while (curW < w) {
            curH = baseH;
            while (curH < h) {
              x = l + curW;
              y = t + curH;
              if (x < maxX && y < maxY) {
                points.push([x, y]);
              }
              curH += baseH;
            }
            curW += baseW;
          }
          limit = _cnum(limit, points[LEN]);
          while (pt = points[idx++]) {
            checkEl = doc[EL_FROM_PT](pt[0], pt[1]);
            try {
              if (checkEl && checkEl.nodeType === 1 && checkEl !== root && checkEl !== el && !contains(el, checkEl)) {
                id = _attr(checkEl, "id");
                if (!id) {
                  id = lang.guid("geom_inter");
                  _attr(checkEl, "id", id);
                }
                if (!seen[id] && ret[LEN] < limit) {
                  seen[id] = 1;
                  ret.push(checkEl);
                }
              }
            } catch (_error) {}
          }
        }
        id = "";
        for (id in seen) {
          if (id.indexOf("geom_inter") === 0) {
            checkEl = _elt(id);
            if (checkEl) {
              _attr(checkEl, "id", null);
            }
          }
        }
        return ret;
      };

      /*
      A proxy wrapper for calling into the cross-domain messaging host fall back library
      Looks for namespace will be $sf.lib.dom.msghost_fb
      Said library is used in cases where there is not HTML5 style messaging (i.e. no postMessage method available).
      
      @name $sf.lib.dom.msghost-_call_xmsg_host_fb
      @private
      @static
      @function
      @param {String} methName The method name in the msg host library to call
      @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
      @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
      @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
      @returns {*} whatever comes back from the method
       */
      _call_xmsg_host_fb = function(methName, arg1, arg2, arg3) {
        if (!msghostfb) {
          msghostfb = dom.msghost_fb;
        }
        return methName && msghostfb && msghostfb[methName] && msghostfb[methName](arg1, arg2, arg3);
      };

      /*
      Listen for an initial HTML5 postMessage event, to validate that HTML5 style
      messaging can be used
      
      @name $sf.lib.dom.msghost-_check_html5_init
      @private
      @static
      @function
      @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
       */
      _check_html5_init = function(evt) {
        if (!canUseHTML5 && evt && evt.data === initID) {
          canUseHTML5 = true;
          dom.evtCncl(evt);
          dom[DETACH](win, MSG, _check_html5_init);
        }
      };

      /*
      Listen for onmessage events in the main window. Validate that message is for us, and if so
      pass it through to the rest of the code and cancel further handling.
      
      @name $sf.lib.dom.msghost-_handle_msg_from_outside
      @private
      @static
      @function
      @param {HTMLEvent} evt The raw HTML event object received from the postMessage call
       */
      _handle_msg_from_outside = function(evt) {
        var cb, data, dataGUID, e, fr_win, ifr, msg_win, params, pipe, pipeGUID, ret, tgtID;
        data = evt && evt.data;
        msg_win = evt && evt.source;
        params = data && (data.indexOf(GUID) !== -1) && ParamHash(data);
        tgtID = params && params.id;
        ifr = tgtID && _elt(tgtID);
        fr_win = ifr && _ifr_view(ifr);
        pipe = tgtID && msg_pipes[tgtID];
        dataGUID = params && params[GUID];
        pipeGUID = pipe && pipe[GUID];
        cb = pipe && pipe._xmsgcb;
        ret = false;
        if (pipeGUID && dataGUID && dataGUID === pipeGUID && msg_win && fr_win && fr_win === msg_win) {
          try {
            ret = cb(params.msg);
          } catch (_error) {
            e = _error;
            ret = false;
          }
        }
        if (ret) {
          dom.evtCncl(evt);
        }
        return ret;
      };

      /*
      Send a message to a child iframe.
      
      @name $sf.lib.dom.msghost.send
      @public
      @static
      @function
      @param {String} tgtID The HTML id attribute of the iframe element for which to send a message
      @param {String} data The string of data to send to the given iframe
      @returns {Boolean} Whether or not message was send succesfully (note that this does not mean message was handled / recevied, only that sending was ok).
       */
      send_msg_to_child_iframe = function(tgtID, data) {
        var e, el, msgObj, pipe, success, w;
        pipe = tgtID && msg_pipes[tgtID];
        success = false;
        msgObj = void 0;
        w = void 0;
        el = void 0;
        e = void 0;
        if (!pipe) {
          success = _call_xmsg_host_fb("send", tgtID, data);
        } else {
          if (pipe) {
            msgObj = ParamHash();
            msgObj.msg = data;
            msgObj.guid = pipe.guid;
            if (usingHTML5()) {
              el = _elt(tgtID);
              w = _ifr_view(el);
              try {
                w[PMSG](_cstr(msgObj), pipe.srcHost || "*");
                success = true;
              } catch (_error) {
                e = _error;
                success = false;
              }
            } else {
              success = _call_xmsg_host_fb("send", tgtID, data);
            }
          }
        }
        msgObj = w = el = null;
        return success;
      };

      /*
      Get whether or not HTML5 style messaging can be used
      
      @name $sf.lib.dom.msghost.usingHTML5
      @public
      @static
      @function
      @returns {Boolean}
       */
      usingHTML5 = function() {
        return canUseHTML5;
      };

      /*
      Gets a location of the hosting page, stripped of the search hash,
      but leaving query parameters, port, host, path, etc.
       */
      _strippedEncodedLocation = function() {
        var cleaned, pos;
        cleaned = void 0;
        pos = loc.href.indexOf("#");
        if (pos > -1) {
          cleaned = loc.href.substr(0, pos);
        } else {
          cleaned = loc.href;
        }
        pos = cleaned.indexOf("?");
        if (pos > -1) {
          cleaned = cleaned.substr(0, pos);
        }
        return escape(cleaned);
      };

      /*
      Prepare an iframe in the top level window to be able to send / receive cross-domain messages
      Generally this method is called from $sf.lib.iframes.  The attrs object in question should
      represent key/value pairs of HTML attributes for the iframe. Note that the attrs object passed
      in will be modified with a new "name" property, to send information into the iframe and setup
      messaging.
      
      @name $sf.lib.dom.msghost.prep
      @public
      @static
      @function
      @param {Object} attrs Information required to set up the cross-domain messaging channel
      @param {String} attrs.id The IFRAME HTML id attribute
      @param {String} attrs.src The URL / src attribute of the IFRAME
      @param {String} [attrs.guid] The guid / signature to use to validate that messages sent/ received can be accepted. If not specified, one will be created automatically.
      @param {String} [attrs.name] The IFRAME HTML name attribute which will be used to send an intial message to the HTML document inside the IFRAME.
      @returns {Object} An object with various properties detailing the messaging pipe-line.
       */
      prep_iframe_msging = function(attrs) {
        var iframeName, locStripped, nameParams, newPipe, pipe, src, srcHost;
        pipe = null;
        iframeName = void 0;
        nameParams = void 0;
        src = void 0;
        srcHost = void 0;
        newPipe = void 0;
        locStripped = _strippedEncodedLocation();
        if (attrs) {
          iframeName = attrs.name;
          nameParams = ParamHash(iframeName);
          src = _cstr(attrs.src);
          srcHost = src && src.substring(0, src.indexOf("/", 9));
          srcHost = (srcHost.search(/http/g) !== 0 ? "" : srcHost);
          pipe = ParamHash(nameParams);
          pipe.id = attrs.id || ("iframe_" + _guid());
          pipe.src = src;
          pipe.srcHost = srcHost;
          pipe[GUID] = pipe[GUID] || _guid();
          pipe.host = locHost;
          pipe.loc = locStripped;
          pipe.proxyID = "";
          if (usingHTML5()) {
            pipe.html5 = 1;
            pipe.proxyPath = "";
          } else {
            newPipe = _call_xmsg_host_fb("prep", pipe);
            if (newPipe) {
              pipe = newPipe;
            }
          }
          attrs.name = pipe;
        }
        return pipe;
      };

      /*
      Listen for messages from an IFRAME. Note that on the host / publisher side
      this library only allows for one message handler to be attached to a given
      IFRAME.
      
      @name $sf.lib.dom.msghost.attach
      @public
      @static
      @function
      @param {HTMLElement} el The IFRAME reference to attach a listener callback too. .
      @param {Object} pipe The message pipe object created from $sf.lib.dom.msghost.prep
      @param {Function} cb The callback function to fire when a message is received
       */
      attach_iframe_msging = function(el, pipe, cb) {
        var tgtID;
        tgtID = void 0;
        if (_tagName(el) === "iframe") {
          tgtID = _attr(el, "id");
          if (tgtID && pipe && (pipe instanceof ParamHash) && tgtID === pipe.id) {
            if (usingHTML5()) {
              msg_pipes[tgtID] = pipe;
              pipe._xmsgcb = cb;
              if (!html5Bound) {
                dom[ATTACH](win, MSG, _handle_msg_from_outside);
                html5Bound = true;
              }
            } else {
              _call_xmsg_host_fb(ATTACH, el, pipe, cb);
            }
          }
        }
      };

      /*
      Detach listening for messages from an IFRAME
      
      @name $sf.lib.dom.msghost.detach
      @public
      @static
      @function
      @param {HTMLElement} el The IFRAME reference to detach a listener
       */
      detach_iframe_msging = function(el) {
        var empty, id, pipe, w;
        id = _attr(el, "id");
        pipe = id && msg_pipes[id];
        w = null;
        empty = true;
        if (!pipe) {
          _call_xmsg_host_fb(DETACH, el);
          return;
        }
        if (pipe) {
          pipe._xmsgcb = msg_pipes[id] = null;
          pipe = null;
          delete msg_pipes[id];
        }
        id = "";
        for (id in msg_pipes) {
          pipe = msg_pipes[id];
          if (pipe && pipe[GUID]) {
            empty = false;
            break;
          }
        }
        if (empty && usingHTML5() && html5Bound) {
          html5Bound = false;
          dom[DETACH](win, MSG, _handle_msg_from_outside);
        }
        el = w = pipe = null;
      };

      /*
      Fire the specifed callback out to the publisher. Note that other arguments beyond the 1st argument are passed throug to the callback.
      
      @name $sf.host-_fire_pub_callback
      @static
      @private
      @function
      @param {String} cb_name The callback name to fire
       */
      _fire_pub_callback = function(cb_name) {
        var a, args, cb_args, e, f, idx, len, ret;
        cb_args = [];
        args = arguments;
        len = args[LEN];
        idx = 0;
        f = void 0;
        ret = false;
        e = void 0;
        a = void 0;
        if (config) {
          f = config[cb_name];
          if (f) {
            while (len--) {
              a = args[idx++];
              if (a !== cb_name) {
                cb_args.push(a);
              }
            }
            try {
              ret = f.apply(null, cb_args);
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Nuke the position an report that said position took too long to render
      
      @name $sf.host-_handle_render_timeout
      @static
      @private
      @function
      @param {String} pos_id The position id that has taken too long
       */
      _handle_render_timeout = function(pos_id) {
        var pend;
        pend = pos_id && pending_ifrs[pos_id];
        if (pend) {
          clearTimeout(pend);
          nuke(pos_id);
          _fire_pub_callback(POS_MSG, "render-timeout", pos_id);
        }
        if (!_has_pending_renders()) {
          current_status = "";
        }
      };

      /*
      Clear the timer that fires every so often to update the geometry in side
      of SafeFrames
      
      @name $sf.host-_clear_geom_update_timer
      @static
      @private
      @function
       */
      _clear_geom_update_timer = function() {
        if (geom_update_timer) {
          clearTimeout(geom_update_timer);
          geom_update_timer = 0;
        }
      };

      /*
      +	 * Clear the timer that fires every so often to update the geometry in side
      +	 * of SafeFrames
      +	 *
      +	 * @name $sf.host-_clear_geom_update_timer
      +	 * @static
      +	 * @private
      +	 * @function
      +	 *
      +
       */
      _clear_focus_update_timer = function() {
        if (focus_update_timer) {
          clearTimeout(focus_update_timer);
          focus_update_timer = 0;
        }
      };
      _set_focus_update_timer = function(in_focus) {
        _clear_focus_update_timer();
        focus_update_timer = setTimeout(function() {
          _update_focus(in_focus);
        }, 2);
      };

      /*
      Set up the timer function that updates each SafeFrame with up to date geometric information
      
      @name $sf.host-_set_geom_update_timer
      @static
      @private
      @function
       */
      _set_geom_update_timer = function(is_win_scroll) {
        _clear_geom_update_timer();
        if (is_win_scroll) {
          geom_update_timer = setTimeout(_update_geom_win_scroll, GEOM_UPDATE_INTRVAL);
        } else {
          geom_update_timer = setTimeout(_update_geom_win_resize, GEOM_UPDATE_INTRVAL);
        }
      };

      /*
      Update all SafeFrames with updated geometric information
      
      @name $sf.host-_update_geom
      @static
      @private
      @function
      @param {Boolean} is_win_scroll Whether or not we are updating due to the main window being scrolled
       */
      _update_geom = function(is_win_scroll) {
        var g, id, ifr, msgObj, params, posID;
        posID = void 0;
        params = void 0;
        msgObj = void 0;
        id = void 0;
        ifr = void 0;
        g = void 0;
        for (posID in rendered_ifrs) {
          if (is_win_scroll && (posID in scroll_parents_attached)) {
            continue;
          }
          params = rendered_ifrs[posID];
          id = params && params.dest;
          ifr = id && _elt(id);
          if (ifr && params) {
            g = _build_geom(posID, ifr, true);
            msgObj = ParamHash();
            msgObj.pos = posID;
            msgObj.cmd = NOTIFY_GEOM_UPDATE;
            msgObj.geom = _es(g);
            _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
            _send_response(params, msgObj);
          }
        }
        _clear_geom_update_timer();
      };

      /*
      Update all SafeFrames with updated geometric information due to a window resize
      event.
      
      @name $sf.host-_update_geom_win_resize
      @static
      @private
      @function
       */
      _update_geom_win_resize = function() {
        _update_geom();
      };

      /*
      Update all SafeFrames with updated geometric information due to a window scroll event
      
      @name $sf.host-_update_geom_win_scroll
      @static
      @private
      @function
       */
      _update_geom_win_scroll = function() {
        _update_geom(true);
      };

      /*
      Update a SafeFrame that has new geometric information due to its parent HTML element
      scrolling.
      
      @name $sf.host-_handle_node_scroll
      @static
      @private
      @function
       */
      _handle_node_scroll = function(evt, posID, node) {
        var g, scr_handle;
        scr_handle = scroll_parents_attached[posID];
        g = void 0;
        if (scr_handle) {
          if (scr_handle.tID) {
            clearTimeout(scr_handle.tID);
            delete scr_handle.tID;
          }
          scr_handle.tID = setTimeout(function() {
            var id, ifr, msgObj, params;
            params = rendered_ifrs[posID];
            id = params && params.dest;
            ifr = id && _elt(id);
            g = void 0;
            msgObj = void 0;
            if (ifr && params) {
              g = _build_geom(posID, ifr, true);
              msgObj = ParamHash();
              msgObj.pos = posID;
              msgObj.cmd = NOTIFY_GEOM_UPDATE;
              msgObj.geom = _es(g);
              _fire_pub_callback(POS_MSG, posID, NOTIFY_GEOM_UPDATE, g);
              _send_response(params, msgObj);
            }
            delete scr_handle.tID;
          }, GEOM_UPDATE_INTRVAL);
        }
      };

      /*
      Handle the window onscroll event, eventually leading to a geometric update
      
      @name $sf.host-_handle_win_geom_scroll
      @static
      @private
      @function
      @param {HTMLEvent} evt The raw event object
       */
      _handle_win_geom_scroll = function(evt) {
        _set_geom_update_timer(1);
      };

      /*
      Handle the window onresize event, eventually leading to a geometric update
      once the window events are slowed down
      
      @name $sf.host-_handle_win_geom_resize
      @static
      @private
      @function
      @param {HTMLEvent} evt The raw event object
       */
      _handle_win_geom_resize = function(evt) {
        _set_geom_update_timer();
      };

      /*
      Update all SafeFrames with updated focus information
      
      @name $sf.host-_update_focus
      @static
      @private
      @function
      @param {Boolean} in_focus True when the window has gained focus
       */
      _update_focus = function(in_focus) {
        var data, id, ifr, msgObj, params, posID;
        posID = void 0;
        params = void 0;
        msgObj = void 0;
        id = void 0;
        ifr = void 0;
        for (posID in rendered_ifrs) {
          params = rendered_ifrs[posID];
          id = params && params.dest;
          ifr = id && _elt(id);
          if (ifr && params) {
            msgObj = ParamHash();
            data = ParamHash();
            msgObj.pos = posID;
            msgObj.cmd = data.cmd = NOTIFY_FOCUS_CHANGE;
            msgObj.value = in_focus;
            _fire_pub_callback(POS_MSG, posID, NOTIFY_FOCUS_CHANGE, in_focus);
            _send_response(params, msgObj);
          }
        }
        _clear_focus_update_timer();
      };

      /*
      Handle the window focus event, which notifies ads of the change
       */
      _handle_win_focus = function(evt) {
        _set_focus_update_timer(true);
      };

      /*
      Handle the window blur event, which notifies ads of the change
       */
      _handle_win_blur = function(evt) {
        _set_focus_update_timer(false);
      };

      /*
      Handle the window unload event, clearing up our state
      
      @name $sf.host-_handle_unload
      @static
      @private
      @function
      @param {HTMLEvent} evt The raw event object
       */
      _handle_unload = function(evt) {
        var e, prop, scr_handle;
        prop = void 0;
        scr_handle = void 0;
        e = void 0;
        _clear_geom_update_timer();
        try {
          dom.detach(win, SCROLL, _handle_win_geom_scroll);
          dom.detach(win, "resize", _handle_win_geom_resize);
          dom.detach(win, "unload", _handle_unload);
          dom.detach(win, "focus", _handle_win_focus);
          dom.detach(win, "blur", _handle_win_blur);
          for (prop in scroll_parents_attached) {
            scr_handle = scroll_parents_attached[prop];
            if (scr_handle) {
              if (scr_handle.tID) {
                clearTimeout(scr_handle.tID);
              }
              dom.detach(scroll_parents_attached[prop], SCROLL, scr_handle[ONSCROLL]);
              scr_handle[ONSCROLL] = scr_handle.node = null;
            }
            scroll_parents_attached[prop] = null;
            delete scroll_parents_attached[prop];
          }
          win_events_attached = false;
        } catch (_error) {}
      };

      /*
      Handle the window message event, passed from raw event handling of the msghost code.
      Pass through the data to our format handling functions for expand, etc.
      
      @name $sf.host-_handle_msg_evt
      @static
      @private
      @function
      @param {String|Object} data the message to be handled
      @return {Boolean} return whether or not the message was handled
       */
      _handle_msg_evt = function(data) {
        var canRead, canWrite, info, msgObj, ret;
        msgObj = void 0;
        ret = false;
        info = void 0;
        msgObj = ParamHash(data, null, null, true, true);
        if (msgObj && msgObj.pos) {
          info = rendered_ifrs[msgObj.pos];
          if (info) {
            ret = (function() {
              switch (msgObj.cmd) {
                case "exp-push":
                  _expand_safeframe(msgObj, true);
                  return true;
                case "exp-ovr":
                  _expand_safeframe(msgObj);
                  return true;
                case "collapse":
                  _collapse_safeframe(msgObj);
                  return true;
                case "msg":
                case "clicked":
                case "viewed":
                case "requested":
                case "unviewed":
                case "reload":
                  _fire_pub_callback(POS_MSG, msgObj.pos, msgObj.cmd, msgObj.msg);
                  _send_generic_response(msgObj.pos, msgObj.cmd);
                  return true;
                case "loaded":
                  _fire_pub_callback("onAdLoad", msgObj.pos, msgObj);
                  _send_generic_response(msgObj.pos, msgObj.cmd);
                  return true;
                case ERROR_COMMAND:
                  _record_error(msgObj);
                  return true;
                case NOTIFY_GEOM_UPDATE:
                  sf.lib.logger.log("Geom update complete: " + msgObj.pos);
                  return true;
                case "read-cookie":
                  canRead = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                  if (canRead) {
                    _read_cookie(msgObj);
                    _fire_pub_callback("onCookieRead", msgObj.pos, msgObj.cookie);
                    return true;
                  } else {
                    return false;
                  }
                  break;
                case "write-cookie":
                  canWrite = info.conf && info.conf.supports && info.conf.supports[msgObj.cmd] && info.conf.supports[msgObj.cmd] !== "0";
                  if (canWrite) {
                    _write_cookie(msgObj);
                    _fire_pub_callback("onCookieWrite", msgObj.pos, msgObj.cookie);
                    return true;
                  } else {
                    return false;
                  }
              }
            })();
          }
        }
        return ret;
      };

      /*
      Check whether or not there are any SafeFrames being rendered
      
      @name $sf.host-_has_pending_renders
      @static
      @private
      @function
       */
      _has_pending_renders = function() {
        var all_renders_done, pos_id;
        all_renders_done = true;
        pos_id = void 0;
        for (pos_id in pending_ifrs) {
          all_renders_done = false;
          break;
        }
        return all_renders_done;
      };

      /*
      Send a response back down to the SafeFrame after a message was handled
      
      @name $sf.host-_send_response
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} params The parameters object stored for a rendered SafeFrame holding state information
      @param {$sf.lib.lang.ParamHash} msgObj The message to send back down into the SafeFrame
       */
      _send_response = function(params, msgObj) {

        /*
        @ignore
         */
        current_status = "sending-msg-down-" + msgObj.cmd;
        setTimeout((function() {
          var id;
          id = params && params.dest;
          if (id && msgObj) {
            send_msg_to_child_iframe(id, msgObj.toString());
          }
          current_status = "";
          msgObj = id = params = null;
        }), XCOM_RESP_DELAY);
      };

      /*
      Handle the onload event from the IFRAME tag created for a SafeFrame.
      Note that b/c we used our own library to create the IFRAME ($sf.lib.dom.iframes),
      the "this" keyword will now properly point to the IFRAME in question.
      
      @name $sf.host-_handle_frame_load
      @private
      @static
      @function
       */
      _handle_frame_load = function() {
        var all_renders_done, el, pos_id;
        el = this;
        pos_id = dom.attr(el, "_pos_id");
        all_renders_done = true;
        if (pending_ifrs[pos_id]) {
          clearTimeout(pending_ifrs[pos_id]);
          delete pending_ifrs[pos_id];
          complete_ifrs[pos_id] = pos_id;
          dom.attr(el, "_pos_id", null);
          dom.attr(el, "name", null);
          el[ST].visibility = "inherit";
          el[ST].display = "block";
          _fire_pub_callback("onEndPosRender", pos_id);
        }
        if (!_has_pending_renders()) {
          current_status = "";
        }
      };

      /*
      Build an extra IFRAME to put behind any iframe that is expanding, to protect
      against painting issues in IE with window'd mode flash.
      
      @name $sf.host-_shim_frame
      @private
      @static
      @function
       */
      _shim_frame = function(id, showIt, w, h, z) {
        var ifr, shmFrm, shmID;
        if (!isIE) {
          return;
        }
        ifr = _elt(id);
        shmID = "shm_" + id;
        shmFrm = _elt(shmID);
        if (showIt) {
          if (shmFrm) {
            shmFrm[ST].visibility = "visible";
            return;
          }
          shmFrm = iframes.clone(ifr, {
            id: shmID,
            src: "",
            name: shmID
          }, [WIDTH, ":", w, PX, ";position:absolute;", HEIGHT, ":", h, PX, ";z-index:", z - 1, ";filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0)"]);
          dom.append(_par(ifr), shmFrm);
        } else {
          if (!showIt && shmFrm) {
            shmFrm[ST].visibility = "hidden";
          }
        }
      };

      /*
      Build a geometry info object for a particular SafeFrame position, and also
      may attach an onscroll event listener to a parent HTML element if said parent element
      is scrollable but not the root document node / body
      
      @name $sf.host-_build_geom
      @private
      @static
      @function
      @return {Object} With information about the geometry around a given SafeFrame
       */
      _build_geom = function(posID, dest, dont_attach_scroll_evt) {
        var details, e, ex, info, new_ref_node, node, s, scr_handle;
        bounds = void 0;
        info = ParamHash();
        details = {};
        scr_handle = void 0;
        node = void 0;
        new_ref_node = void 0;
        ex = void 0;
        s = void 0;
        e = void 0;
        try {
          bounds = dom.bounds(dest, details, true);
          if (!dont_attach_scroll_evt && !details.isRoot && details.canScroll) {
            ex = details.expRect;
            if (ex.xs || ex.ys) {
              scr_handle = scroll_parents_attached[posID];
              new_ref_node = details.refNode;
              if (scr_handle && scr_handle.node !== new_ref_node) {
                if (scr_handle.tID) {
                  clearTimeout(scr_handle.tID);
                }
                dom.detach(node, SCROLL, scr_handle[ONSCROLL]);
                scr_handle.node = scr_handle[ONSCROLL] = null;
                scroll_parents_attached[posID] = null;
                delete scroll_parents_attached[posID];
              }
              if (!scroll_parents_attached[posID]) {
                scr_handle = {};
                scr_handle.node = new_ref_node;

                /*
                @ignore
                 */
                scr_handle[ONSCROLL] = function(evt) {
                  _handle_node_scroll(evt, posID);
                };
                scroll_parents_attached[posID] = scr_handle;
                dom.attach(new_ref_node, SCROLL, scr_handle[ONSCROLL]);
              }
            }
          }
        } catch (_error) {
          e = _error;
          info = null;
        }
        try {
          if (info) {
            info.win = ParamHash(dom.winRect());
            info.par = ParamHash(details.refRect);
            ex = ParamHash(details.expRect);
            s = ParamHash(details.rect);
            s.iv = ex.iv;
            s.xiv = ex.xiv;
            s.yiv = ex.yiv;
            delete ex.iv;
            delete ex.xiv;
            delete ex.yiv;
            info.exp = ex;
            info.self = s;
          }
        } catch (_error) {
          e = _error;
          info = null;
        }
        return info;
      };

      /*
      Expands a given SafeFrame based on a command from the 3rd party content
      
      @name $sf.host-_expand_safeframe
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj Details about how to do the expansion
      
      TODO, handle omni-directional and push
       */
      _expand_safeframe = function(msgObj, push) {
        var b, delta, dx, dy, exp, id, ifr, ifrSt, l, nHt, nWd, orHt, orWd, par, parSt, params, params_conf, posID, r, scr_handle, t, xn, yn, z;
        xn = false;
        yn = false;
        posID = msgObj && msgObj.pos;
        params = void 0;
        params_conf = void 0;
        ifr = void 0;
        par = void 0;
        ifrSt = void 0;
        parSt = void 0;
        orWd = void 0;
        orHt = void 0;
        dx = void 0;
        dy = void 0;
        nWd = void 0;
        nHt = void 0;
        id = void 0;
        t = void 0;
        l = void 0;
        r = void 0;
        b = void 0;
        exp = void 0;
        z = void 0;
        delta = void 0;
        scr_handle = void 0;
        if (!posID) {
          return;
        }
        params = rendered_ifrs[posID];
        params_conf = params && params.conf;
        if (!params || !params_conf) {
          return;
        }
        id = params.dest;
        ifr = _elt(id);
        par = _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
        if (!ifr || !par) {
          return;
        }
        ifrSt = ifr[ST];
        parSt = par[ST];
        if (!ifrSt) {
          return;
        }
        scr_handle = scroll_parents_attached[posID];
        if (scr_handle && scr_handle.tID) {
          clearTimeout(scr_handle.tID);
        }
        _clear_geom_update_timer();
        exp = msgObj.exp_obj;
        orWd = params_conf.w;
        orHt = params_conf.h;
        if (!exp) {
          dx = params.dx = _cnum(msgObj.dx);
          dy = params.dy = _cnum(msgObj.dy);
          xn = dx < 0;
          yn = dy < 0;
          nWd = (xn ? orWd + (dx * -1) : orWd + dx);
          nHt = (yn ? orHt + (dy * -1) : orHt + dy);
        } else {
          t = _cnum(exp.t, 0, 0);
          l = _cnum(exp.l, 0, 0);
          r = _cnum(exp.r, 0, 0);
          b = _cnum(exp.b, 0, 0);
          nWd = _cnum(orWd + l + r, 0, 0);
          nHt = _cnum(orHt + t + b, 0, 0);
          if (t) {
            dy = t * -1;
            yn = true;
          } else {
            dy = 0;
          }
          if (l) {
            dx = l * -1;
            xn = true;
          } else {
            dx = 0;
          }
        }
        if (nWd <= orWd && nHt <= orHt) {
          return;
        }
        if (_fire_pub_callback(BF_POS_MSG, posID, EXPAND_COMMAND, dx, dy)) {
          return;
        }
        ifrSt[WIDTH] = nWd + PX;
        ifrSt[HEIGHT] = nHt + PX;
        if (xn) {
          ifrSt.left = dx + PX;
        }
        if (yn) {
          ifrSt.top = dy + PX;
        }
        z = _cnum(params.z, 0);
        if (!z) {
          z = DEFAULT_ZINDEX;
        }
        ifrSt.zIndex = z;
        _shim_frame(id, true, nWd, nHt, z - 1);
        if (push) {
          parSt[WIDTH] = nWd + PX;
          parSt[HEIGHT] = nHt + PX;
        } else {
          parSt[WIDTH] = orWd + PX;
          parSt[HEIGHT] = orHt + PX;
        }
        params.expanded = true;
        msgObj.dx = dx;
        msgObj.dy = dy;
        msgObj.w = nWd;
        msgObj.h = nHt;
        msgObj.cmd = "expand";
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        _fire_pub_callback(POS_MSG, posID, EXPAND_COMMAND, dx, dy);
        _send_response(params, msgObj);
        ifrSt = par = ifr = params = msgObj = null;
      };

      /*
      Collapse a SafeFrame after it has been expanded
      
      @name $sf.host-_collapse_safeframe
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame to collapse
      @param {Boolean} [isOutside] Whether or not the collapse command came from the publisher
      @param {Boolean} [noMsging] Whether or not to send a message of response back to the SafeFrame being collapsed
       */
      _collapse_safeframe = function(msgObj, isOutside, noMsging) {
        var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
        ifrSt = ifr && ifr[ST];
        parSt = par && par[ST];
        scr_handle = void 0;
        if (!posID || !params || !ifr || !par) {
          return;
        }
        if (!params.expanded) {
          return;
        }
        scr_handle = scroll_parents_attached[posID];
        if (scr_handle && scr_handle.tID) {
          clearTimeout(scr_handle.tID);
        }
        _clear_geom_update_timer();
        if (!noMsging) {
          if (_fire_pub_callback(BF_POS_MSG, posID, COLLAPSE_COMMAND, 0, 0)) {
            return;
          }
        }
        ifrSt.left = ifrSt.top = "0px";
        parSt[WIDTH] = ifrSt[WIDTH] = params_conf.w + PX;
        parSt[HEIGHT] = ifrSt[HEIGHT] = params_conf.h + PX;
        ifrSt.zIndex = params.dx = params.dy = 0;
        _shim_frame(id);
        if (!noMsging) {
          _fire_pub_callback(POS_MSG, posID, COLLAPSE_COMMAND, 0, 0);
          msgObj.cmd = (isOutside ? "collapsed" : "collapse");
          msgObj.geom = _es(_build_geom(posID, ifr, true));
          _send_response(params, msgObj);
        }
        ifr = ifrSt = par = parSt = params = msgObj = null;
      };

      /*
      Records a reported error message to $sf.info.errors and fires any listeners
      
      @name $sf.host-_record_error
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame having an error
       */
      _record_error = function(msgObj) {
        var id, ifr, ifrSt, par, parSt, params, params_conf, posID, scr_handle;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        par = ifr && _elt(POS_REL_BOX_ID_PREFIX + "_" + posID);
        ifrSt = ifr && ifr[ST];
        parSt = par && par[ST];
        scr_handle = void 0;
        if (sf && sf.info && sf.info.errs) {
          sf.info.errs.push(msgObj);
        }
        _fire_pub_callback(POS_MSG, posID, ERROR_COMMAND, msgObj);
      };

      /*
      Returns the current document cookies as a hash
      @name $sf.lib._cookieHash
      @private
      @static
      @function
      @returns {Object}
       */
      _cookieHash = function() {
        var c, cookies, cooks, i, key;
        cooks = void 0;
        key = void 0;
        i = void 0;
        cookies = {};
        c = void 0;
        cooks = document.cookie.split("; ");
        i = cooks.length - 1;
        while (i >= 0) {
          c = cooks[i].split("=");
          cookies[c[0]] = c[1];
          i--;
        }
        return cookies;
      };

      /*
      Read a host domain cookie
      
      @name $sf.host-_read_cookie
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
      @param {Boolean} [isOutside] Whether or not the read-cookie command came from the publisher
       */
      _read_cookie = function(msgObj, isOutside) {
        var canRead, command, cookies, id, ifr, key, params, params_conf, posID;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        key = void 0;
        cookies = void 0;
        command = "read-cookie";
        canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
        if (!canRead) {
          return;
        }
        if (!posID || !params || !ifr) {
          return;
        }
        key = msgObj.cookie;
        if (!key) {
          return;
        }
        cookies = _cookieHash();
        _fire_pub_callback(POS_MSG, command, posID, 0, 0);
        msgObj.cmd = command;
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        msgObj.value = cookies[key];
        _send_response(params, msgObj);
        ifr = params = msgObj = null;
      };

      /*
      Write a host domain cookie
      
      @name $sf.host-_write_cookie
      @private
      @static
      @function
      @param {$sf.lib.lang.ParamHash} msgObj The details about the message send from the SafeFrame
      @param {Boolean} [isOutside] Whether or not the write-cookie command came from the publisher
       */
      _write_cookie = function(msgObj, isOutside) {
        var c_value, canRead, command, cookies, exdate, id, ifr, key, newCookies, newValue, params, params_conf, posID;
        posID = msgObj && msgObj.pos;
        params = posID && rendered_ifrs[posID];
        params_conf = params && params.conf;
        id = params_conf && params_conf.dest;
        ifr = id && _elt(id);
        key = void 0;
        newValue = void 0;
        cookies = void 0;
        newCookies = void 0;
        command = "write-cookie";
        canRead = params_conf.supports && params_conf.supports[command] && params_conf.supports[command] !== "0";
        if (!canRead) {
          return;
        }
        if (!posID || !params || !ifr) {
          return;
        }
        key = msgObj.cookie;
        if (!key) {
          return;
        }
        newValue = escape(msgObj.value);
        exdate = new Date();
        exdate.setDate(exdate.getDate() + 1);
        c_value = newValue + "; expires=" + exdate.toUTCString();
        document.cookie = key + "=" + c_value;
        _fire_pub_callback(POS_MSG, command, posID, 0, 0);
        msgObj.cmd = command;
        msgObj.geom = _es(_build_geom(posID, ifr, true));
        msgObj.info = newValue;
        msgObj.value = "";
        _send_response(params, msgObj);
        ifr = params = msgObj = null;
      };

      /*
      Remove / destroy one or more SafeFrames from the publisher page
      
      @name $sf.host.nuke
      @static
      @function
      @public
      @param {String} pos_id* One or more position ids to remove from the page. If no arguments are specifed, all positions currently rendered are removed.
       */
      nuke = function() {
        var args, el, el_id, empty, idx, par, pos, pos_id, sb_rel;
        idx = 0;
        empty = true;
        args = arguments;
        pos_id = void 0;
        pos = void 0;
        el_id = void 0;
        el = void 0;
        sb_rel = void 0;
        par = void 0;
        if (!args[LEN] || args[idx] === "*") {
          args = [];
          for (pos_id in rendered_ifrs) {
            args.push(pos_id);
          }
        }
        while (pos_id = args[idx++]) {
          pos = rendered_ifrs[pos_id];
          if (pos) {
            if (pos_id in pending_ifrs) {
              clearTimeout(pending_ifrs[pos_id]);
              delete pending_ifrs[pos_id];
            }
            if (pos_id in complete_ifrs) {
              delete complete_ifrs[pos_id];
            }
            el_id = pos.dest;
            el = el_id && _elt(el_id);
            par = el && _par(el);
            if (dom.attr(par, "id").indexOf(POS_REL_BOX_ID_PREFIX) !== -1) {
              sb_rel = par;
              par = _par(sb_rel);
            }
            dom.purge(el);
            if (sb_rel) {
              dom.purge(sb_rel);
            }
            rendered_ifrs[pos_id] = null;
            delete rendered_ifrs[pos_id];
            el = dom.make("div");
            dom.attr(el, "id", el_id);
            dom.append(par, el);
          }
        }
        pos_id = "";
        for (pos_id in rendered_ifrs) {
          empty = false;
          break;
        }
        if (empty) {
          current_status = "";
          _handle_unload();
        }
      };

      /*
      Render one or more $sf.host.Position objects into the page
      
      @name $sf.host.render
      @public
      @static
      @function
      @param {$sf.host.Position} pos* An instance of an $sf.host.Position object to render. Note that said object must have a corresponding $sf.host.PosConfig, as well as $sf.host.Config must have been set
       */
      render = function() {
        var args, css_txt, dest_el, dest_id, dest_rel_id, e, finalCSSEnd, finalCSSPos, firstCSSPos, h, idx, name_params, new_dest_el, par_el, pend, pos, pos_conf, pos_id, rel_el, st, w;
        idx = 0;
        args = arguments;
        firstCSSPos = "relative";
        finalCSSPos = "absolute";
        finalCSSEnd = "top:0px;left:0px;visibility:hidden;display:none;";
        pos = void 0;
        pos_id = void 0;
        pos_conf = void 0;
        dest_el = void 0;
        new_dest_el = void 0;
        rel_el = void 0;
        par_el = void 0;
        name_params = void 0;
        dest_id = void 0;
        dest_rel_id = void 0;
        css_txt = void 0;
        w = void 0;
        h = void 0;
        st = void 0;
        e = void 0;
        pend = void 0;
        if (!config) {
          return false;
        }
        if (!dom.ready()) {
          dom.wait(function() {
            render.apply(null, args);
            args = null;
          });
          return null;
        }
        if ((args[0] instanceof Array) && args[LEN] === 1) {
          args = args[0];
        }
        while (pos = args[idx++]) {
          pos_id = pos.id;
          pos_conf = (pos_id ? config.positions[pos_id] : null);
          if (pos_conf) {
            dest_id = pos_conf.dest;
            dest_el = dest_id && _elt(dest_id);
            if (dest_el) {
              w = pos_conf.w;
              h = pos_conf.h;
              if (!w) {
                try {
                  w = dest_el.offsetWidth;
                } catch (_error) {
                  e = _error;
                  w = 0;
                }
                if (w) {
                  pos_conf.w = w;
                }
              }
              if (!h) {
                try {
                  h = dest_el.offsetHeight;
                } catch (_error) {
                  e = _error;
                  h = 0;
                }
                if (h) {
                  pos_conf.h = h;
                }
              }
              if (w && h) {
                name_params = new ParamHash();
                dest_rel_id = POS_REL_BOX_ID_PREFIX + "_" + pos_id;
                rel_el = _elt(dest_rel_id);
                par_el = _par(dest_el);
                if (rel_el && par_el === rel_el) {
                  par_el = _par(rel_el);
                }
                _shim_frame(dest_id);

                /*
                @ignore
                 */
                pend = pending_ifrs[pos_id];
                if (pend) {
                  clearTimeout(pend);
                }
                pend = complete_ifrs[pos_id];
                if (pend) {
                  delete complete_ifrs[pos_id];
                }
                pending_ifrs[pos_id] = setTimeout(function() {
                  _handle_render_timeout(pos_id);
                }, config.to);
                current_status = "rendering";
                _fire_pub_callback("onStartPosRender", pos_id, pos_conf, pos);
                css_txt = ["position:", "", ";z-index:0;", WIDTH, ":", w, PX, ";", HEIGHT, ":", h, PX, ";", "visibility:inherit;"];
                if (!rel_el) {
                  css_txt[1] = firstCSSPos;
                  rel_el = dom.make("div");
                  rel_el.id = dest_rel_id;
                  rel_el.className = "iab_sf";
                  new_dest_el = dest_el.cloneNode(false);
                  dom.css(new_dest_el, css_txt);
                  rel_el.appendChild(new_dest_el);
                  dom.css(rel_el, css_txt);
                  par_el.replaceChild(rel_el, dest_el);
                  dest_el = _elt(dest_id);
                } else {
                  st = rel_el[ST];
                  st.width = w + PX;
                  st.height = h + PX;
                  st = dest_el && dest_el[ST];
                  st.width = w + PX;
                  st.height = h + PX;
                }
                name_params.id = pos_id;
                name_params.dest = dest_id;
                name_params.conf = ParamHash(pos_conf);
                name_params.meta = pos.meta.toString();
                name_params.html = _es(pos.html);
                name_params.geom = _es(_build_geom(pos_id, dest_el));
                name_params.src = pos_conf.renderFile || config.renderFile;
                name_params.has_focus = lang.cstr(document.hasFocus());
                css_txt[1] = finalCSSPos;
                css_txt[13] = finalCSSEnd;
                if (!win_events_attached) {
                  dom.attach(win, SCROLL, _handle_win_geom_scroll);
                  dom.attach(win, "resize", _handle_win_geom_resize);
                  dom.attach(win, "unload", _handle_unload);
                  dom.attach(win, "focus", _handle_win_focus);
                  dom.attach(win, "blur", _handle_win_blur);
                  win_events_attached = true;
                }
                iframes.replace({
                  id: dest_id,
                  name: name_params,
                  src: pos_conf.renderFile || config.renderFile,
                  _pos_id: pos_id
                }, css_txt, rel_el, _handle_frame_load, _handle_msg_evt);
                rendered_ifrs[pos_id] = name_params;
              }
            }
          }
        }
      };

      /*
      Gets a copy of the Position configuration, content, and meta data for a given SafeFrame
      
      @name $sf.host.get
      @public
      @function
      @static
      @return {Object}
       */
      get = function(positionId) {
        var obj;
        obj = rendered_ifrs[positionId];
        if (!obj) {
          return null;
        }
        return _mix({}, obj);
      };

      /*
      Returns a string as to whether or not the library is busy, empty string is returned on idle
      
      @name $sf.host.status
      @public
      @function
      @static
      @return {String}
       */
      status = function() {
        return current_status;
      };
      _send_generic_response = function(posID, command) {
        var msgObj, params;
        msgObj = new ParamHash();
        params = posID && rendered_ifrs[posID];
        msgObj.cmd = command;
        msgObj.pos = posID;
        return _send_response(params, msgObj);
      };
      _getGeom = function(posID) {
        var g, id, ifr, params;
        params = rendered_ifrs[posID];
        id = params && params.dest;
        ifr = id && _elt(id);
        g = _build_geom(posID, ifr, true);
        return g;
      };
      inViewPercentage = function(posID) {
        var geom_info, iv, tv, _ref;
        geom_info = _getGeom(posID);
        iv = _cnum(geom_info != null ? (_ref = geom_info.self) != null ? _ref.iv : void 0 : void 0, -1, 0);
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      if (lang) {
        if (win === top || allowNotTop) {
          _rect = (ieVer ? _getRectIE : _getRectNonIE);
          _mix(dom, {
            rect: _rect,
            currentStyle: currentStyle,
            contains: contains,
            docRect: docRect,
            winRect: winRect,
            bounds: bounds,
            overlaps: overlaps
          });

          /*
          @ignore
           */
          (function() {
            var e;
            e = void 0;
            dom.msghost = {
              prep: prep_iframe_msging,
              attach: attach_iframe_msging,
              detach: detach_iframe_msging,
              usingHTML5: usingHTML5,
              send: send_msg_to_child_iframe
            };
            dom[ATTACH](win, MSG, _check_html5_init);
            initID = "xdm-html5-init-" + _guid();
            locHost = (locHost.indexOf("file") === 0 ? locHost = "file" : locHost);
            try {
              win[PMSG](initID, (locHost === "file" ? "*" : locHost));
            } catch (_error) {
              e = _error;
              dom[DETACH](win, MSG, _check_html5_init);
            }
          })();
          _mix(sf.host, {
            Config: Config,
            PosConfig: PosConfig,
            PosMeta: PosMeta,
            Position: Position,
            nuke: nuke,
            get: get,
            render: render,
            status: status,
            inViewPercentage: inViewPercentage
          });
        }
      }
      if (allowNotTop) {
        window["$sf"] = sf;
      }
      return sf;
    })(window, sf);
  };

}).call(this);

},{"./boot":19}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":22,"./env":23,"./lang":24,"./logger":25}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":23,"./lang":24}],23:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("8DwohR"))
},{"./lang":24,"8DwohR":35}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, keys, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, wrap, _es, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray,
      wrap: wrap,
      keys: keys
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],26:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":27,"ieee754":28}],27:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],28:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],29:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":26}],30:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":31,"./rng":32,"./sha":33,"./sha256":34,"buffer":26}],31:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":29}],32:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],33:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":29}],34:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":29}],35:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3B1Ymxpc2hlci5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3B1Ymxpc2hlci9zbG90LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL2FkX3JlcXVlc3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvYWR2ZXJ0aXNlci5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9iYXNlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL2NvbmZpZy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9lbmRwb2ludC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbGliL3NoYXJlZC9lbmdhZ2VtZW50LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL2V2ZW50LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9saWIvc2hhcmVkL3BhZ2UuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvc2l6ZXMuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL2xpYi9zaGFyZWQvdXRpbHMuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9jb29raWVzLWpzL3NyYy9jb29raWVzLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvanNvbi9qc29uMi5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9ub2RlLXV1aWQvdXVpZC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3JlcXdlc3QvcmVxd2VzdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvaG9zdC5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvaG9zdC9ib290LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9ob3N0L2hvc3QuanMiLCIvVXNlcnMvamFzb25mZXJ0ZWwvcHJvamVjdHMvYWRqcy9hZGpzL25vZGVfbW9kdWxlcy9zYWZlZnJhbWUvbGliL2pzL3NoYXJlZC9iYXNlLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvZG9tLmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvZW52LmpzIiwiL1VzZXJzL2phc29uZmVydGVsL3Byb2plY3RzL2FkanMvYWRqcy9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9zaGFyZWQvbGFuZy5qcyIsIi9Vc2Vycy9qYXNvbmZlcnRlbC9wcm9qZWN0cy9hZGpzL2FkanMvbm9kZV9tb2R1bGVzL3NhZmVmcmFtZS9saWIvanMvc2hhcmVkL2xvZ2dlci5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2hlbHBlcnMuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3JuZy5qcyIsIi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhLmpzIiwiL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEyNTYuanMiLCIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWpDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzduQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIEFkSlMsIEFkUmVxdWVzdCwgUGFnZSwgYWR2ZXJ0aXNlciwgY29uZmlnLCBlbmdhZ2VtZW50LCBpblB1YkZyYW1lLCBpblB1YmZyYW1lLCBzZiwgdXRpbHM7XG5cbiAgaW5QdWJmcmFtZSA9IGZhbHNlO1xuXG4gIGlmICh3aW5kb3cucGFyZW50ID09PSB3aW5kb3cudG9wICYmIHdpbmRvdyAhPT0gd2luZG93LnRvcCAmJiB3aW5kb3dbXCIkc2ZcIl0pIHtcbiAgICBzZiA9ICRzZjtcbiAgICBpblB1YkZyYW1lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXdpbmRvd1tcIiRzZlwiXSkge1xuICAgICAgc2YgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvc2FmZWZyYW1lL2xpYi9qcy9ob3N0L2hvc3QnKSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBlbmdhZ2VtZW50ID0gcmVxdWlyZSgnLi9zaGFyZWQvZW5nYWdlbWVudCcpO1xuXG4gIFBhZ2UgPSByZXF1aXJlKCcuL3NoYXJlZC9wYWdlJyk7XG5cbiAgQWRKUyA9IHJlcXVpcmUoJy4vcHVibGlzaGVyL3Nsb3QnKTtcblxuICBjb25maWcgPSByZXF1aXJlKCcuL3NoYXJlZC9jb25maWcnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4vc2hhcmVkL3V0aWxzJyk7XG5cbiAgQWRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9zaGFyZWQvYWRfcmVxdWVzdCcpO1xuXG4gIGFkdmVydGlzZXIgPSByZXF1aXJlKCcuL3NoYXJlZC9hZHZlcnRpc2VyJyk7XG5cbiAgKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBhZGZyYW1lVXJsLCBjb250cm9sbGVyVXJsLCBkb1JlbmRlciwgaW5pdFNhZmVGcmFtZSwgcGFnZUR1cmF0aW9uLCBwYWdlTG9hZE1zLCByZW5kZXJBZCwgcmVuZGVyQ29udHJvbGxlciwgc2FmZWZyYW1lVXJsLCBzZXNzaW9uT2JqLCBzZkRvbSwgc3RhcnRUaWNrcztcbiAgICBzZXNzaW9uT2JqID0gbnVsbDtcbiAgICBpZiAod2luZG93ID09PSB3aW5kb3cudG9wKSB7XG4gICAgICBzZXNzaW9uT2JqID0gbmV3IFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vzc2lvbk9iaiA9IG5ldyBBZFJlcXVlc3QoKTtcbiAgICB9XG4gICAgc3RhcnRUaWNrcyA9IHV0aWxzLm5vdygpO1xuICAgIHBhZ2VMb2FkTXMgPSAwO1xuICAgIHBhZ2VEdXJhdGlvbiA9IDA7XG4gICAgc2FmZWZyYW1lVXJsID0gY29uZmlnLmNkbl91cmw7XG4gICAgY29udHJvbGxlclVybCA9IGNvbmZpZy5jb250cm9sbGVyX3VybDtcbiAgICBhZGZyYW1lVXJsID0gY29uZmlnLmFkX3VybDtcbiAgICBzZkRvbSA9ICRzZi5saWIuZG9tO1xuICAgIHNmRG9tLmF0dGFjaChcImJlZm9yZXVubG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHBhZ2VEdXJhdGlvbiA9IHV0aWxzLm5vdygpIC0gc3RhcnRUaWNrcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRvUmVuZGVyID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciBkLCBkaXYsIGRpdnMsIHNmUG9zaXRpb25zLCBfaSwgX2xlbjtcbiAgICAgIHNmUG9zaXRpb25zID0ge307XG4gICAgICBpZiAoIXNmRG9tLnJlYWR5KCkpIHtcbiAgICAgICAgc2ZEb20ud2FpdChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncztcbiAgICAgICAgICBwYWdlTG9hZE1zID0gdXRpbHMubm93KCkgLSBzdGFydFRpY2tzO1xuICAgICAgICAgIGRvUmVuZGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBhcmdzID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJDb250cm9sbGVyKCk7XG4gICAgICAgIGRpdnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIik7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGRpdiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChkaXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGl2cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGQgPSBkaXZzW19pXTtcbiAgICAgICAgICBpZiAoc2ZEb20uYXR0cihkLCBcImRhdGEtYWRqc1wiKSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFkSlMuY3JlYXRlKGQsIHNlc3Npb25PYmopO1xuICAgICAgICAgICAgfSkoZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIiA/IGNiKCkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0U2FmZUZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJHNmLmhvc3QuQ29uZmlnKHtcbiAgICAgICAgcmVuZGVyRmlsZTogd2luZG93ID09PSB3aW5kb3cudG9wID8gc2FmZWZyYW1lVXJsIDogYWRmcmFtZVVybCxcbiAgICAgICAgcG9zaXRpb25zOiB7fSxcbiAgICAgICAgb25TdGFydFBvc1JlbmRlcjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb25GYWlsdXJlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBvbkFkTG9hZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICByZXR1cm4gQWRKUyhpZCkubG9hZCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZVBvc01zZzogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb25Qb3NNc2c6IGZ1bmN0aW9uKGlkLCBtc2csIGNvbnRlbnQpIHtcbiAgICAgICAgICByZXR1cm4gQWRKUyhpZCkuaGFuZGxlTWVzc2FnZShtc2csIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJlbmRlckNvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaXYsIHBhcmVudDtcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICBwYXJlbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgZGl2LmlkID0gc2YubGliLmxhbmcuZ3VpZChcImNvbnRyb2xsZXJcIik7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudCk7XG4gICAgICByZXR1cm4gQWRKUyhcImNvbnRyb2xsZXJcIikuY3JlYXRlKGRpdiwgJycsIHtcbiAgICAgICAgd2lkdGg6IDEwLFxuICAgICAgICBoZWlnaHQ6IDEwLFxuICAgICAgICBzdXBwb3J0czogW1wid3JpdGUtY29va2llXCIsIFwicmVhZC1jb29raWVcIl0sXG4gICAgICAgIHJlbmRlckZpbGU6IGNvbnRyb2xsZXJVcmwsXG4gICAgICAgIHBhZ2U6IHNlc3Npb25PYmouc2VyaWFsaXplKCksXG4gICAgICAgIHBhZ2VSZWZlcnJlcjogZG9jdW1lbnQucmVmZXJyZXIsXG4gICAgICAgIGlnbm9yZUV2ZW50czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZW5kZXJBZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpdiwgcGFyZW50O1xuICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIHBhcmVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBkaXYuaWQgPSBzZi5saWIubGFuZy5ndWlkKFwiY3JlYXRpdmVcIik7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudCk7XG4gICAgICByZXR1cm4gQWRKUyhcImNyZWF0aXZlXCIpLmNyZWF0ZShkaXYsICcnLCB7XG4gICAgICAgIHdpZHRoOiAxMCxcbiAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgcmVuZGVyRmlsZTogYWRmcmFtZVVybCxcbiAgICAgICAgcGFnZTogc2Vzc2lvbk9iai5zZXJpYWxpemUoKSxcbiAgICAgICAgcGFnZVJlZmVycmVyOiBkb2N1bWVudC5yZWZlcnJlcixcbiAgICAgICAgaWdub3JlRXZlbnRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIEFkSlMucmVuZGVyID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciBhZEpzU2NyaXB0LCBjbGllbnRJZCwgcztcbiAgICAgIGFkSnNTY3JpcHQgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHMgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoc2ZEb20uYXR0cihzLCBcImRhdGEtYWRqc1wiKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSlbMF07XG4gICAgICBjbGllbnRJZCA9IHNmRG9tLmF0dHIoYWRKc1NjcmlwdCwgXCJkYXRhLWNsaWVudC1pZFwiKTtcbiAgICAgIHNlc3Npb25PYmouc2V0KHtcbiAgICAgICAgY2xpZW50X2lkOiBjbGllbnRJZFxuICAgICAgfSk7XG4gICAgICBpZiAoIWluUHViRnJhbWUpIHtcbiAgICAgICAgaW5pdFNhZmVGcmFtZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdy50b3AgPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gZG9SZW5kZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5QdWJGcmFtZSkge1xuICAgICAgICBzZXNzaW9uT2JqLnNldCh7XG4gICAgICAgICAgZGVwdGhfcG9zaXRpb246IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhZHZlcnRpc2VyLndvcmsoc2Vzc2lvbk9iaiwgd2luZG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZW5kZXJBZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZW5nYWdlbWVudC5vbkVuZ2FnZW1lbnQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWQsIF8sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IEFkSlMuc2xvdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfIGluIF9yZWYpIHtcbiAgICAgICAgYWQgPSBfcmVmW19dO1xuICAgICAgICBpZiAoYWQuY3VycmVudGx5SW52aWV3KCkgJiYgIWFkLmVuZ2FnZWQpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkLmVuZ2FnZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQWRKUy5yZW5kZXIoKTtcbiAgICB9KSgpO1xuICAgIGlmICghaW5QdWJmcmFtZSkge1xuICAgICAgd2luZG93LiRhZCA9IEFkSlM7XG4gICAgfVxuICAgIHJldHVybiBBZEpTO1xuICB9KSh3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnRzLCBzZiwgc2ZEb20sIHNpemVzLCB1dGlscyxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIHNmID0gcmVxdWlyZSgnc2FmZWZyYW1lJyk7XG5cbiAgc2l6ZXMgPSByZXF1aXJlKCcuLi9zaGFyZWQvc2l6ZXMnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4uL3NoYXJlZC91dGlscycpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJy4uL3NoYXJlZC9ldmVudCcpKFtcInJlcXVlc3RcIiwgXCJjbGlja1wiLCBcImxvYWRcIiwgXCJ2aWV3XCIsIFwidW5sb2FkXCIsIFwiZm9jdXNcIiwgXCJlbmdhZ2VcIiwgXCJ1bmZvY3VzXCIsIFwiZXhwYW5kXCIsIFwiY29sbGFwc2VcIiwgXCJyZWZyZXNoZWRcIiwgXCJjb29raWVcIiwgXCJyZWNlaXZlXCIsIFwidW52aWV3XCIsIFwidGltZW91dFwiXSk7XG5cbiAgc2ZEb20gPSBzZi5saWIuZG9tO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHNmKSB7XG4gICAgdmFyIFNDUklQVF9SRUdFWCwgU2xvdCwgVElNRU9VVF9USU1FLCBvbGRUcmlnZ2VyLCBzbG90cztcbiAgICBUSU1FT1VUX1RJTUUgPSA1MDAwO1xuICAgIHNsb3RzID0ge307XG4gICAgU0NSSVBUX1JFR0VYID0gLzwhLS0oW1xcc1xcU10qKS0tPi87XG4gICAgU2xvdCA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIFNsb3QoYWRJZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBfX2JpbmQodGhpcy50cmlnZ2VyLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTbG90KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdChhZElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNsb3QoYWRJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgU2xvdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGFkSWQpIHtcbiAgICAgICAgaWYgKHNsb3RzW2FkSWRdKSB7XG4gICAgICAgICAgcmV0dXJuIHNsb3RzW2FkSWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBhZElkO1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgc2xvdHNbYWRJZF0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0RXZlbnRzKCk7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5zdGFydEF1dG9SZWZyZXNoID0gZnVuY3Rpb24oZGVsYXksIGNiKSB7XG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVsYXkgPSA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzQXV0b1JlZnJlc2hpbmcpIHtcbiAgICAgICAgICB0aGlzLl9pc0F1dG9SZWZyZXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBfdGhpcy5faXNBdXRvUmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoX3RoaXMubG9hZFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVmcmVzaChjYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkodGhpcyksIGRlbGF5ICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5zdG9wQXV0b1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2lzQXV0b1JlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaEludGVydmFsID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB0aGlzLnBvc01ldGEuc2V0VmFsdWUoXCJsb2FkX25cIiwgXCJleHRlbmRlZFwiLCB0aGlzLmNvdW50KTtcbiAgICAgICAgc2YuaG9zdC5yZW5kZXIodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5wb3NDb25maWcuZGVzdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNiKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICBpZiAoISgoX3JlZiA9IHRoaXMub3B0aW9ucykgIT0gbnVsbCA/IF9yZWYuaWdub3JlRXZlbnRzIDogdm9pZCAwKSkge1xuICAgICAgICAgIGV2ZW50cy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgU2xvdC50cmlnZ2VyKGV2ZW50LCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZywgY29udGVudCkge1xuICAgICAgICBzd2l0Y2ggKG1zZykge1xuICAgICAgICAgIGNhc2UgXCJmb2N1cy1jaGFuZ2VcIjpcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZ2VvbS11cGRhdGVcIjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgIGNhc2UgXCJleHBhbmRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZChjb250ZW50KTtcbiAgICAgICAgICBjYXNlIFwiY29sbGFwc2VcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlKGNvbnRlbnQpO1xuICAgICAgICAgIGNhc2UgXCJ2aWV3ZWRcIjpcbiAgICAgICAgICAgIGlmICghdGhpcy52aWV3ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInVudmlld2VkXCI6XG4gICAgICAgICAgICBpZiAoISh0aGlzLnVudmlld2VkICYmIHRoaXMudmlld2VkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjbGlja2VkXCI6XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpY2tlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlcXVlc3RlZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCgpO1xuICAgICAgICAgIGNhc2UgXCJjb29raWUtd3JpdGVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvb2tpZSh7XG4gICAgICAgICAgICAgIGNvb2tpZTogXCJ3cml0ZVwiLFxuICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwiY29va2llLXJlYWRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvb2tpZSh7XG4gICAgICAgICAgICAgIGNvb2tpZTogXCJyZWFkXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJyZWxvYWRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgIGNhc2UgXCJtc2dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmUoZGVjb2RlVVJJQ29tcG9uZW50KGNvbnRlbnQpKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmluaXRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5sb2FkQ2hhaW4gPSB1dGlscy5jb3VudEZyYW1lcyh0aGlzLmZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy52aWV3ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdUaW1lID0gdXRpbHMubm93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVuZ2FnZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZW5nYWdlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmdhZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW5nYWdlVGltZSA9IHV0aWxzLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5RnJhbWUoXCJlbmdhZ2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW52aWV3KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudW52aWV3ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnVudmlld1RpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5sb2FkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVubG9hZFRpbWUgPSB1dGlscy5ub3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsaWNrZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmxvYWRDaGFpbiA9IDA7XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLm5vdGlmeUZyYW1lID0gZnVuY3Rpb24oY21kLCBkYXRhKSB7XG4gICAgICAgIHZhciBtc2dPYmo7XG4gICAgICAgIG1zZ09iaiA9IHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpO1xuICAgICAgICBpZiAodGhpcy5wb3NDb25maWcpIHtcbiAgICAgICAgICBtc2dPYmoucG9zID0gdGhpcy5wb3NDb25maWcuaWQ7XG4gICAgICAgICAgbXNnT2JqLmNtZCA9IGNtZDtcbiAgICAgICAgICBtc2dPYmoudmFsdWUgPSBlc2NhcGUoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIHNmRG9tLm1zZ2hvc3Quc2VuZCh0aGlzLnBvc0NvbmZpZy5kZXN0LCBtc2dPYmoudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW0sIGh0bWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgcywgc3VwcG9ydHMsIHdpZHRoLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICB3aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aCB8fCBlbGVtLm9mZnNldFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLm9wdGlvbnMuaGVpZ2h0IHx8IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBzdXBwb3J0cyA9IHt9O1xuICAgICAgICBfcmVmID0gdGhpcy5vcHRpb25zLnN1cHBvcnRzIHx8IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBzID0gX3JlZltfaV07XG4gICAgICAgICAgc3VwcG9ydHNbc10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF9yZWYxID0gdGhpcy5vcHRpb25zLmRpc2FibGVzIHx8IFtdO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICBzID0gX3JlZjFbX2pdO1xuICAgICAgICAgIHN1cHBvcnRzW3NdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWxlbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICBlbGVtLmlkIHx8IChlbGVtLmlkID0gc2YubGliLmxhbmcuZ3VpZChcInBvc1wiKSk7XG4gICAgICAgIHRoaXMucG9zTWV0YSA9IG5ldyBzZi5ob3N0LlBvc01ldGEobnVsbCwgXCJleHRlbmRlZFwiLCB7XG4gICAgICAgICAgaW52aWV3OiB0aGlzLm9wdGlvbnMuaW52aWV3LFxuICAgICAgICAgIHBhZ2U6IHRoaXMub3B0aW9ucy5wYWdlLFxuICAgICAgICAgIGhvc3Q6IGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgICAgIHJlZmVycmVyOiB0aGlzLm9wdGlvbnMucmVmZXJyZXIsXG4gICAgICAgICAgbG9jYXRpb246IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgc2xvdF9pZDogdGhpcy5pZCxcbiAgICAgICAgICBsb2FkX246IHRoaXMuY291bnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9zQ29uZmlnID0gbmV3IHNmLmhvc3QuUG9zQ29uZmlnKHtcbiAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICBkZXN0OiBlbGVtLmlkLFxuICAgICAgICAgIHc6IHdpZHRoLFxuICAgICAgICAgIGg6IGhlaWdodCxcbiAgICAgICAgICBzdXBwb3J0czogc3VwcG9ydHMsXG4gICAgICAgICAgcmVuZGVyRmlsZTogdGhpcy5vcHRpb25zLnJlbmRlckZpbGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9zID0gbmV3IHNmLmhvc3QuUG9zaXRpb24odGhpcy5wb3NDb25maWcuaWQsIGh0bWwsIHRoaXMucG9zTWV0YSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmcmVzaF9vb3YpIHtcbiAgICAgICAgICB0aGlzLnVudmlldyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHRoaXMpLCAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZnJlc2hfdGltZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZWZyZXNoVGltZSA9IHNmLmxpYi5sYW5nLmNudW0odGhpcy5vcHRpb25zLnJlZnJlc2hfdGltZSwgMCk7XG4gICAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRpbWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0QXV0b1JlZnJlc2godGhpcy5yZWZyZXNoVGltZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNmLmhvc3QucmVuZGVyKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW0uaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGRvbnRGaXJlKSB7XG4gICAgICAgIGlmICghZG9udEZpcmUpIHtcbiAgICAgICAgICB0aGlzLnVubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLnZpZXdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZ2FnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnZpZXdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMubG9hZFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmdhZ2VUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy51bnZpZXdUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmxvYWRUaW1lID0gbnVsbDtcbiAgICAgICAgc2YuaG9zdC5udWtlKHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzO1xuICAgICAgICByZXR1cm4gZGVsZXRlIHNsb3RzW3RoaXMuaWRdO1xuICAgICAgfTtcblxuICAgICAgU2xvdC5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aWV3KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUodHJ1ZSk7XG4gICAgICAgICAgc2YuaG9zdC5yZW5kZXIodGhpcy5wb3MpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5wb3NDb25maWcuZGVzdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFNsb3QucHJvdG90eXBlLmN1cnJlbnRseUludmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2YuaG9zdC5pblZpZXdQZXJjZW50YWdlKHRoaXMuaWQpID4gNTAgJiYgdGhpcy52aWV3ZWQ7XG4gICAgICB9O1xuXG4gICAgICBTbG90LnByb3RvdHlwZS5pbnZpZXdQZXJjZW50YWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZi5ob3N0LmluVmlld1BlcmNlbnRhZ2UodGhpcy5pZCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU2xvdDtcblxuICAgIH0pKCk7XG4gICAgU2xvdC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWQsIF8sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoXyBpbiBzbG90cykge1xuICAgICAgICBhZCA9IHNsb3RzW19dO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGFkLmRlc3Ryb3koKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcbiAgICBTbG90LmV2ZW50cyA9IHt9O1xuICAgIG9sZFRyaWdnZXIgPSBTbG90LnByb3RvdHlwZS50cmlnZ2VyO1xuICAgIHNmLmxpYi5sYW5nLm1peChTbG90LnByb3RvdHlwZSwgZXZlbnRzKTtcbiAgICBTbG90LnByb3RvdHlwZS50cmlnZ2VyID0gb2xkVHJpZ2dlcjtcbiAgICBzZi5saWIubGFuZy5taXgoU2xvdCwgZXZlbnRzKTtcbiAgICBTbG90LmNyZWF0ZSA9IGZ1bmN0aW9uKGQsIHBhZ2UpIHtcbiAgICAgIHZhciBhZElkLCBkaXNhYmxlcywgZGl2LCBoZWlnaHQsIHBvc0lkLCBzaXplLCBzdXBwb3J0cywgdGVtcGxhdGUsIHdpZHRoLCBfYmFzZSwgX2Jhc2UxLCBfcmVmO1xuICAgICAgdGVtcGxhdGUgPSAoKF9yZWYgPSBkLmlubmVySFRNTC5tYXRjaChTQ1JJUFRfUkVHRVgpKSAhPSBudWxsID8gX3JlZlsxXSA6IHZvaWQgMCkgfHwgZC5pbm5lckhUTUw7XG4gICAgICBwb3NJZCA9IHNmLmxpYi5sYW5nLmd1aWQoXCJwb3NcIik7XG4gICAgICBhZElkID0gZC5pZCB8fCBwb3NJZDtcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuaWQgPSBwb3NJZDtcbiAgICAgIGQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIHN1cHBvcnRzID0gW107XG4gICAgICBkaXNhYmxlcyA9IFtdO1xuICAgICAgaWYgKHNpemUgPSBzaXplc1tzZkRvbS5hdHRyKGQsIFwiZGF0YS1hZC10eXBlXCIpXSkge1xuICAgICAgICB3aWR0aCA9IHNpemVbMF0sIGhlaWdodCA9IHNpemVbMV07XG4gICAgICB9XG4gICAgICBTbG90KGFkSWQpLmNyZWF0ZShkaXYsIHRlbXBsYXRlLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCB8fCBzZkRvbS5hdHRyKGQsIFwiZGF0YS13aWR0aFwiKSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgc2ZEb20uYXR0cihkLCBcImRhdGEtaGVpZ2h0XCIpLFxuICAgICAgICBzdXBwb3J0czogdHlwZW9mIChfYmFzZSA9IHNmRG9tLmF0dHIoZCwgXCJkYXRhLXN1cHBvcnRzXCIpKS5zcGxpdCA9PT0gXCJmdW5jdGlvblwiID8gX2Jhc2Uuc3BsaXQoXCIsXCIpIDogdm9pZCAwLFxuICAgICAgICBkaXNhYmxlczogdHlwZW9mIChfYmFzZTEgPSBzZkRvbS5hdHRyKGQsIFwiZGF0YS1kaXNhYmxlc1wiKSkuc3BsaXQgPT09IFwiZnVuY3Rpb25cIiA/IF9iYXNlMS5zcGxpdChcIixcIikgOiB2b2lkIDAsXG4gICAgICAgIGludmlldzogc2YubGliLmxhbmcuY2Jvb2woc2ZEb20uYXR0cihkLCBcImRhdGEtaW52aWV3XCIpKSxcbiAgICAgICAgcmVmcmVzaF90aW1lOiBzZkRvbS5hdHRyKGQsIFwiZGF0YS1yZWZyZXNoLXRpbWVcIiksXG4gICAgICAgIHJlZnJlc2hfb292OiBzZi5saWIubGFuZy5jYm9vbChzZkRvbS5hdHRyKGQsIFwiZGF0YS1yZWZyZXNoLW9vdlwiKSksXG4gICAgICAgIHBhZ2U6IHBhZ2UgIT0gbnVsbCA/IHBhZ2Uuc2VyaWFsaXplKCkgOiB2b2lkIDAsXG4gICAgICAgIHJlZmVycmVyOiBzZkRvbS5hdHRyKGQsIFwiZGF0YS1yZWZlcnJlclwiKSxcbiAgICAgICAgaWdub3JlRXZlbnRzOiBzZi5saWIubGFuZy5jYm9vbChzZkRvbS5hdHRyKGQsIFwiZGF0YS1pZ25vcmUtZXZlbnRzXCIpKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gU2xvdChhZElkKTtcbiAgICB9O1xuICAgIFNsb3Quc2xvdHMgPSBzbG90cztcbiAgICBTbG90LnNpemVzID0gc2l6ZXM7XG4gICAgcmV0dXJuIFNsb3Q7XG4gIH0pKHNmKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIEJhc2UsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBBZFJlcXVlc3Q7XG4gICAgQWRSZXF1ZXN0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzKEFkUmVxdWVzdCwgX3N1cGVyKTtcblxuICAgICAgZnVuY3Rpb24gQWRSZXF1ZXN0KHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgQWRSZXF1ZXN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgICAgICAgIHRoaXMuZGVzZXJpYWxpemUoc2VyaWFsaXplZFBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgICAgZnVsbF91cmw6IHdpbmRvdy5kb2N1bWVudC5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgcmVmZXJyZXI6IHdpbmRvdy5kb2N1bWVudC5yZWZlcnJlclxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEFkUmVxdWVzdC5wcm90b3R5cGUucGF0aCA9IFwiL2FkXCI7XG5cbiAgICAgIEFkUmVxdWVzdC5wcm90b3R5cGUuY29uc3RhbnRGaWVsZHMgPSBbXCJzaXRlX3VzZXJfaWRcIiwgXCJwYWdlX2lkXCIsIFwidmlzaXRfaWRcIiwgXCJhZF9pZFwiXTtcblxuICAgICAgcmV0dXJuIEFkUmVxdWVzdDtcblxuICAgIH0pKEJhc2UpO1xuICAgIHJldHVybiBBZFJlcXVlc3Q7XG4gIH0pKHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBlbmRwb2ludCwgdXRpbHM7XG5cbiAgZW5kcG9pbnQgPSByZXF1aXJlKCcuL2VuZHBvaW50Jyk7XG5cbiAgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIHdvcms7XG4gICAgd29yayA9IGZ1bmN0aW9uKGFkUmVxdWVzdCwgcHViRnJhbWUpIHtcbiAgICAgIHZhciBjb250cm9sbGVyO1xuICAgICAgY29udHJvbGxlciA9IG51bGw7XG4gICAgICB1dGlscy5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiZ2V0RGV0YWlsc1wiLCB7XG4gICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYWRSZXF1ZXN0O1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbmRwb2ludC5zZW5kKGFkUmVxdWVzdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHB1YkZyYW1lLiRhZC5yZWFkQWQod2luZG93KTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmZpbmRDb250cm9sbGVyKGZ1bmN0aW9uKGN0cmwpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gY3RybDtcbiAgICAgICAgICByZXR1cm4gYWRSZXF1ZXN0LmNoYW5nZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnNlbmQoYWRSZXF1ZXN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB3b3JrOiB3b3JrXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIHV0aWxzLCB1dWlkO1xuXG4gIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgQmFzZTtcbiAgICByZXR1cm4gQmFzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEJhc2UoKSB7XG4gICAgICAgIHRoaXMuaWQgPSB1dWlkLnY0KCk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyB8fCAodGhpcy5hdHRyaWJ1dGVzID0ge30pO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB7fTtcbiAgICAgIH1cblxuICAgICAgQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzLCBmLCBrLCB2LCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IFwiYXR0cnMgbXVzdCBiZSBhbiBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvciAoayBpbiBhdHRycykge1xuICAgICAgICAgIHYgPSBhdHRyc1trXTtcbiAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW2tdICE9PSB2KSB7XG4gICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlcy5wdXNoKGspO1xuICAgICAgICAgICAgdGhpcy5fZGlydHlba10gPSB2O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiBjaGFuZ2VkQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmLmFwcGx5KHRoaXMsIFt0aGlzLCBjaGFuZ2VkQXR0cmlidXRlc10pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBCYXNlLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIGlmIChmICYmIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWYpIHtcbiAgICAgICAgICBfcmVmID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmID0gX3JlZltfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuX2NsZWFuRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5ID0ge307XG4gICAgICB9O1xuXG4gICAgICBCYXNlLnByb3RvdHlwZS5jaGFuZ2VkRmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWVsZCwgaywgcGFyYW1zLCB2LCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfcmVmID0gdGhpcy5fZGlydHk7XG4gICAgICAgIGZvciAoayBpbiBfcmVmKSB7XG4gICAgICAgICAgdiA9IF9yZWZba107XG4gICAgICAgICAgcGFyYW1zW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICBfcmVmMSA9IHRoaXMuY29uc3RhbnRGaWVsZHM7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBmaWVsZCA9IF9yZWYxW19pXTtcbiAgICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW2ZpZWxkXSkge1xuICAgICAgICAgICAgcGFyYW1zW2ZpZWxkXSA9IHRoaXMuYXR0cmlidXRlc1tmaWVsZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFuRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH07XG5cbiAgICAgIEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXRpbHMudG9RdWVyeSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgfTtcblxuICAgICAgQmFzZS5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHV0aWxzLmZyb21RdWVyeShzdHIpLCB7XG4gICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEJhc2U7XG5cbiAgICB9KSgpO1xuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJ2Jhc2UvbGliL2h0bWwvYWRqc2ZyYW1lLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyX3VybDogXCJiYXNlL2xpYi9odG1sL2NvbnRyb2xsZXJmcmFtZS5odG1sXCIsXG4gICAgICAgIGFkX3VybDogXCJiYXNlL2xpYi9odG1sL2FkZnJhbWUuaHRtbFwiLFxuICAgICAgICB2aXNpdF9leHBpcnk6IDAuMDMsXG4gICAgICAgIHZlcnNpb246IFwiMC4wLjFcIixcbiAgICAgICAgZG9tYWluOiBcImxvY2FsaG9zdFwiXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBpOiBcIi8vYXBpLmFkanMubmV0LzFcIixcbiAgICAgICAgY2RuX3VybDogXCIvL2Nkbi5hZGpzLm5ldC9odG1sL2FkanNmcmFtZS5odG1sXCIsXG4gICAgICAgIHZpc2l0X2V4cGlyeTogMzAsXG4gICAgICAgIHZlcnNpb246IFwiMC4wLjFcIixcbiAgICAgICAgZG9tYWluOiBcImFkanMubmV0XCIsXG4gICAgICAgIGNvbnRyb2xsZXJfdXJsOiBcIi8vY2RuLmFkanMubmV0L2h0bWwvY29udHJvbGxlcmZyYW1lLmh0bWxcIixcbiAgICAgICAgYWRfdXJsOiBcIi8vY2RuLmFkanMubmV0L2h0bWwvYWRmcmFtZS5odG1sXCJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogJy8vZW5kcG9pbnQuYWRqcy5kZXY6ODA4MC8xJyxcbiAgICAgICAgY2RuX3VybDogJy4uL2xpYi9odG1sL2FkanNmcmFtZS5odG1sJyxcbiAgICAgICAgdmlzaXRfZXhwaXJ5OiAzLFxuICAgICAgICB2ZXJzaW9uOiBcIjAuMC4xXCIsXG4gICAgICAgIGRvbWFpbjogXCJsb2NhbGhvc3RcIixcbiAgICAgICAgY29udHJvbGxlcl91cmw6IFwiLi4vbGliL2h0bWwvY29udHJvbGxlcmZyYW1lLmh0bWxcIixcbiAgICAgICAgYWRfdXJsOiBcIi4uL2xpYi9odG1sL2FkZnJhbWUuaHRtbFwiXG4gICAgICB9O1xuICAgIH1cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGNvbmZpZywgdXRpbHM7XG5cbiAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuICB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigkc2YpIHtcbiAgICB2YXIgUkVUUllfVElNRU9VVCwgY29tYmluZSwgZW5kcG9pbnQsIGVycm9yLCBpc1RpbWVvdXQsIHBlbmRpbmdSZXF1ZXN0cywgcG9zdERhdGEsIHByZWZpeCwgc2VuZCwgc2VuZERhdGEsIHNlbmRpbmdSZXF1ZXN0cywgc3VjY2VzcywgdGltZW91dFZhbHVlO1xuICAgIHByZWZpeCA9IGNvbmZpZy5hcGk7XG4gICAgcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgc2VuZGluZ1JlcXVlc3RzID0ge307XG4gICAgUkVUUllfVElNRU9VVCA9IDEwMDtcbiAgICBpc1RpbWVvdXQgPSBmYWxzZTtcbiAgICB0aW1lb3V0VmFsdWUgPSBudWxsO1xuICAgIHNlbmQgPSBmdW5jdGlvbihvYmosIGNiKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdHNbb2JqLmlkXSA9IFtvYmosIGNiXTtcbiAgICAgIHJldHVybiBwb3N0RGF0YSgpO1xuICAgIH07XG4gICAgY29tYmluZSA9IGZ1bmN0aW9uKHJlcSwgYWRSZXEsIGNiLCByZXRyeSkge1xuICAgICAgdmFyIGF0dHJzLCBmLCByZXF1ZXN0UGFyYW1zLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMTtcbiAgICAgIGlmIChyZXRyeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHJ5ID0gMztcbiAgICAgIH1cbiAgICAgIGF0dHJzID0ge307XG4gICAgICBpZiAocmVxLmF0dHJpYnV0ZXMucmVxX2lkICYmIGFkUmVxLmF0dHJpYnV0ZXMuYWRfaWQpIHtcbiAgICAgICAgX3JlZiA9IGFkUmVxLmNvbnN0YW50RmllbGRzO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBmID0gX3JlZltfaV07XG4gICAgICAgICAgYXR0cnNbZl0gPSBhZFJlcS5hdHRyaWJ1dGVzW2ZdO1xuICAgICAgICB9XG4gICAgICAgIF9yZWYxID0gcmVxLmNvbnN0YW50RmllbGRzO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICBmID0gX3JlZjFbX2pdO1xuICAgICAgICAgIGF0dHJzW2ZdID0gcmVxLmF0dHJpYnV0ZXNbZl07XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICBkYXRhOiBhdHRycyxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIgPyBjYihyZXNwKSA6IHZvaWQgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIiA/IGNiKGVycikgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJlZml4LmluZGV4T2YoZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWUpID49IDApIHtcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zLm1ldGhvZCA9IFwicG9zdFwiO1xuICAgICAgICAgIHJlcXVlc3RQYXJhbXMudXJsID0gXCJldmVudF9hZHNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zLnR5cGUgPSBcImpzb25wXCI7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtcy51cmwgPSBwcmVmaXggKyBcIi9ldmVudF9hZHNcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2VuZFJlcXVlc3QocmVxdWVzdFBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHJldHJ5ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21iaW5lKHJlcSwgYWRSZXEsIGNiLCByZXRyeSAtIDEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKSwgMTAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbihvYmosIHJlc3AsIGNiKSB7XG4gICAgICBvYmouc2V0KHJlc3AsIHtcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBzZW5kaW5nUmVxdWVzdHNbb2JqLmlkXTtcbiAgICAgIGNvbnNvbGUubG9nKFwiY2JcIik7XG4gICAgICByZXR1cm4gdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIgPyBjYihvYmopIDogdm9pZCAwO1xuICAgIH07XG4gICAgZXJyb3IgPSBmdW5jdGlvbihvYmosIGVyciwgY2IpIHt9O1xuICAgIHNlbmREYXRhID0gZnVuY3Rpb24ocGFyYW1zLCBvYmosIGNiKSB7XG4gICAgICB2YXIgcmVxdWVzdFBhcmFtcztcbiAgICAgIHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgIGRhdGE6IHBhcmFtcyxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHJldHVybiBzdWNjZXNzKG9iaiwgcmVzcCwgY2IpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKG9iaiwgZXJyLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAocHJlZml4LmluZGV4T2YoZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWUpID49IDApIHtcbiAgICAgICAgcmVxdWVzdFBhcmFtcy5tZXRob2QgPSBcInBvc3RcIjtcbiAgICAgICAgcmVxdWVzdFBhcmFtcy51cmwgPSBvYmoucGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RQYXJhbXMudHlwZSA9IFwianNvbnBcIjtcbiAgICAgICAgcmVxdWVzdFBhcmFtcy51cmwgPSBwcmVmaXggKyBvYmoucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGlscy5zZW5kUmVxdWVzdChyZXF1ZXN0UGFyYW1zKTtcbiAgICB9O1xuICAgIHBvc3REYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2IsIGlkLCBrLCBvYmosIHBhcmFtcywgdiwgX3JlZiwgX3JlZjE7XG4gICAgICBmb3IgKGlkIGluIHBlbmRpbmdSZXF1ZXN0cykge1xuICAgICAgICBfcmVmID0gcGVuZGluZ1JlcXVlc3RzW2lkXSwgb2JqID0gX3JlZlswXSwgY2IgPSBfcmVmWzFdO1xuICAgICAgICBpZiAoIXNlbmRpbmdSZXF1ZXN0c1tvYmouaWRdKSB7XG4gICAgICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1tpZF07XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgX3JlZjEgPSBvYmouY2hhbmdlZEZpZWxkcygpO1xuICAgICAgICAgIGZvciAoayBpbiBfcmVmMSkge1xuICAgICAgICAgICAgdiA9IF9yZWYxW2tdO1xuICAgICAgICAgICAgcGFyYW1zW2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VuZGluZ1JlcXVlc3RzW29iai5pZF0gPSBvYmo7XG4gICAgICAgICAgc2VuZERhdGEocGFyYW1zLCBvYmosIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCRzZi5saWIubGFuZy5rZXlzKHBlbmRpbmdSZXF1ZXN0cykubGVuZ3RoID4gMCAmJiAhaXNUaW1lb3V0KSB7XG4gICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aW1lb3V0VmFsdWUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBwb3N0RGF0YSgpO1xuICAgICAgICB9LCBSRVRSWV9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGVuZHBvaW50ID0ge1xuICAgICAgc2VuZDogc2VuZCxcbiAgICAgIGNvbWJpbmU6IGNvbWJpbmVcbiAgICB9O1xuICAgIGlmIChwcm9jZXNzLmVudi5FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICBlbmRwb2ludC5wb3N0RGF0YSA9IHBvc3REYXRhO1xuICAgICAgZW5kcG9pbnQuc2VuZERhdGEgPSBzZW5kRGF0YTtcbiAgICAgIGVuZHBvaW50LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgZW5kcG9pbnQuZXJyb3IgPSBlcnJvcjtcbiAgICAgIGVuZHBvaW50LnNlbmRpbmdSZXF1ZXN0cyA9IHNlbmRpbmdSZXF1ZXN0cztcbiAgICAgIGVuZHBvaW50LnBlbmRpbmdSZXF1ZXN0cyA9IHBlbmRpbmdSZXF1ZXN0cztcbiAgICAgIGVuZHBvaW50LmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICBzZW5kaW5nUmVxdWVzdHMgPSB7fTtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgICAgIGVuZHBvaW50LnNlbmRpbmdSZXF1ZXN0cyA9IHNlbmRpbmdSZXF1ZXN0cztcbiAgICAgICAgZW5kcG9pbnQucGVuZGluZ1JlcXVlc3RzID0gcGVuZGluZ1JlcXVlc3RzO1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXRWYWx1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZW5kcG9pbnQ7XG4gIH0pKCRzZik7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiOER3b2hSXCIpKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIHV0aWxzO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdywgJHNmKSB7XG4gICAgdmFyIEVOR0FHRU1FTlRfUkVTRVQsIGFjdGl2aXR5SGFuZGxlciwgYXR0YWNoLCBkaXNlbmdhZ2VFdmVudHMsIGRvYywgZW5nYWdlRXZlbnRzLCBlbmdhZ2VtZW50LCBlbmdhZ2VtZW50VGltZW91dCwgbGFzdEVuZ2FnZWQsIHJlc2V0RW5nYWdlbWVudDtcbiAgICBhdHRhY2ggPSAkc2YubGliLmRvbS5hdHRhY2g7XG4gICAgZW5nYWdlbWVudCA9IHtcbiAgICAgIGlzRW5nYWdlZDogZmFsc2VcbiAgICB9O1xuICAgIGRvYyA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICBlbmdhZ2VFdmVudHMgPSBbXTtcbiAgICBkaXNlbmdhZ2VFdmVudHMgPSBbXTtcbiAgICBFTkdBR0VNRU5UX1JFU0VUID0gMzAwMDtcbiAgICBsYXN0RW5nYWdlZCA9IHZvaWQgMDtcbiAgICBlbmdhZ2VtZW50Lm9uRW5nYWdlbWVudCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBlbmdhZ2VFdmVudHMucHVzaChmKTtcbiAgICB9O1xuICAgIGVuZ2FnZW1lbnQub25EaXNlbmdhZ2VtZW50ID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGRpc2VuZ2FnZUV2ZW50cy5wdXNoKGYpO1xuICAgIH07XG4gICAgYWN0aXZpdHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZiwgX2ksIF9sZW47XG4gICAgICBlbmdhZ2VtZW50LmlzRW5nYWdlZCA9IHRydWU7XG4gICAgICBlbmdhZ2VtZW50Lmxhc3RFbmdhZ2VkID0gdXRpbHMubm93KCk7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGVuZ2FnZUV2ZW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBmID0gZW5nYWdlRXZlbnRzW19pXTtcbiAgICAgICAgZigpO1xuICAgICAgfVxuICAgICAgcmVzZXRFbmdhZ2VtZW50KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGVuZ2FnZW1lbnRUaW1lb3V0ID0gbnVsbDtcbiAgICByZXNldEVuZ2FnZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dChlbmdhZ2VtZW50VGltZW91dCk7XG4gICAgICByZXR1cm4gZW5nYWdlbWVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZiwgX2ksIF9sZW47XG4gICAgICAgIGVuZ2FnZW1lbnQuaXNFbmdhZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZGlzZW5nYWdlRXZlbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgZiA9IGRpc2VuZ2FnZUV2ZW50c1tfaV07XG4gICAgICAgICAgZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNlbmdhZ2VFdmVudHMgPSBbXTtcbiAgICAgIH0sIEVOR0FHRU1FTlRfUkVTRVQpO1xuICAgIH07XG4gICAgYXR0YWNoKGRvYywgJ2NsaWNrJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2goZG9jLCAnbW91c2V1cCcsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ21vdXNlZG93bicsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ21vdXNlbW92ZScsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ21vdXNld2hlZWwnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaChkb2MsICdrZXlwcmVzcycsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKGRvYywgJ2tleWRvd24nLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaChkb2MsICdrZXl1cCcsIGFjdGl2aXR5SGFuZGxlcik7XG4gICAgYXR0YWNoKHdpbmRvdywgJ0RPTU1vdXNlU2Nyb2xsJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAnc2Nyb2xsJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAncmVzaXplJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICBhdHRhY2god2luZG93LCAnZm9jdXMnLCBhY3Rpdml0eUhhbmRsZXIpO1xuICAgIGF0dGFjaCh3aW5kb3csICdibHVyJywgYWN0aXZpdHlIYW5kbGVyKTtcbiAgICByZXR1cm4gZW5nYWdlbWVudDtcbiAgfSkod2luZG93LCAkc2YpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV2ZW50TmFtZXMpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCBldmVudHMsIF9pLCBfbGVuO1xuICAgICAgZXZlbnRzID0ge1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdDtcbiAgICAgICAgICB0aGlzLmV2ZW50cyB8fCAodGhpcy5ldmVudHMgPSB7fSk7XG4gICAgICAgICAgZXZlbnRMaXN0ID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGV2ZW50TGlzdC5wdXNoKGNiKTtcbiAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBldmVudExpc3Q7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICBvcHRpb25hbERhdGEgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhLCBvcHRpb25hbERhdGEpIHtcbiAgICAgICAgICB2YXIgZSwgZXgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICAgIHRoaXMuZXZlbnRzIHx8ICh0aGlzLmV2ZW50cyA9IHt9KTtcbiAgICAgICAgICBfcmVmID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgZSA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZS5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbmFsRGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXggPSBfZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBldmVudE5hbWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnROYW1lc1tfaV07XG4gICAgICAgIGV2ZW50c1tldmVudF0gPSAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICByZXR1cm4gZiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSkoKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBCYXNlLCBjb25maWcsIGNvb2tpZXMsIG1vbWVudCwgdXRpbHMsIHV1aWQsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgY29va2llcyA9IHJlcXVpcmUoJ2Nvb2tpZXMtanMnKTtcblxuICB1dWlkID0gcmVxdWlyZSgnbm9kZS11dWlkJyk7XG5cbiAgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG4gIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4gIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbiAgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oJHNmLCB3aW5kb3cpIHtcbiAgICB2YXIgQ09PS0lFX0tFWSwgUGFnZTtcbiAgICBDT09LSUVfS0VZID0gXCJfYWpza1wiO1xuICAgIFBhZ2UgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMoUGFnZSwgX3N1cGVyKTtcblxuICAgICAgZnVuY3Rpb24gUGFnZShzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgICAgIFBhZ2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvYWRDb29raWVEYXRhKCk7XG4gICAgICAgICAgdGhpcy5pbml0RGVmYXVsdEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBQYWdlLnByb3RvdHlwZS5zdG9yZUNvb2tpZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgaWYgKCgkc2YgIT0gbnVsbCA/IChfcmVmID0gJHNmLmV4dCkgIT0gbnVsbCA/IF9yZWYuY29va2llIDogdm9pZCAwIDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy5zaXRlX3VzZXJfaWQpIHtcbiAgICAgICAgICAgICRzZi5leHQuY29va2llKFwiXCIgKyBDT09LSUVfS0VZICsgXCJfc3VpZFwiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmF0dHJpYnV0ZXMuc2l0ZV91c2VyX2lkLFxuICAgICAgICAgICAgICBleHBpcmVzOiBtb21lbnQoKS5hZGQoXCJ5ZWFyc1wiLCAxKS50b0RhdGUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMudmlzaXRfaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkc2YuZXh0LmNvb2tpZShcIlwiICsgQ09PS0lFX0tFWSArIFwiX3ZpZFwiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmF0dHJpYnV0ZXMudmlzaXRfaWQsXG4gICAgICAgICAgICAgIGV4cGlyZXM6IG1vbWVudCgpLmFkZChcInNlY29uZHNcIiwgY29uZmlnLnZpc2l0X2V4cGlyeSAqIDYwKS50b0RhdGUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuc2l0ZV91c2VyX2lkKSB7XG4gICAgICAgICAgICBjb29raWVzLnNldChcIlwiICsgQ09PS0lFX0tFWSArIFwiX3N1aWRcIiwgdGhpcy5hdHRyaWJ1dGVzLnNpdGVfdXNlcl9pZCwge1xuICAgICAgICAgICAgICBleHBpcmVzOiBtb21lbnQoKS5hZGQoXCJ5ZWFyc1wiLCAxKS50b0RhdGUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMudmlzaXRfaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29raWVzLnNldChcIlwiICsgQ09PS0lFX0tFWSArIFwiX3ZpZFwiLCB0aGlzLmF0dHJpYnV0ZXMudmlzaXRfaWQsIHtcbiAgICAgICAgICAgICAgZXhwaXJlczogbW9tZW50KCkuYWRkKFwic2Vjb25kc1wiLCBjb25maWcudmlzaXRfZXhwaXJ5ICogNjApLnRvRGF0ZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFBhZ2UucHJvdG90eXBlLmxvYWRDb29raWVEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICBpZiAoKCRzZiAhPSBudWxsID8gKF9yZWYgPSAkc2YuZXh0KSAhPSBudWxsID8gX3JlZi5jb29raWUgOiB2b2lkIDAgOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgICAgc2l0ZV91c2VyX2lkOiAkc2YuZXh0LmNvb2tpZShcIlwiICsgQ09PS0lFX0tFWSArIFwiX3N1aWRcIiksXG4gICAgICAgICAgICB2aXNpdF9pZDogJHNmLmV4dC5jb29raWUoXCJcIiArIENPT0tJRV9LRVkgKyBcIl92aWRcIilcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgICAgc2l0ZV91c2VyX2lkOiBjb29raWVzLmdldChcIlwiICsgQ09PS0lFX0tFWSArIFwiX3N1aWRcIiksXG4gICAgICAgICAgICB2aXNpdF9pZDogY29va2llcy5nZXQoXCJcIiArIENPT0tJRV9LRVkgKyBcIl92aWRcIilcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgUGFnZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBQYWdlLl9fc3VwZXJfXy5zZXQuY2FsbCh0aGlzLCBhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlQ29va2llKCk7XG4gICAgICB9O1xuXG4gICAgICBQYWdlLnByb3RvdHlwZS5pbml0RGVmYXVsdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHdpbmRvdyA9PT0gd2luZG93LnRvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBmdWxsX3VybDogd2luZG93LmRvY3VtZW50LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICByZWZlcnJlcjogd2luZG93LmRvY3VtZW50LnJlZmVycmVyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LnBhcmVudCA9PT0gd2luZG93LnRvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBmdWxsX3VybDogd2luZG93LmRvY3VtZW50LnJlZmVycmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFBhZ2UucHJvdG90eXBlLnZlcmlmeVVybCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93LnBhcmVudCA9PT0gd2luZG93LnRvcCAmJiB3aW5kb3cuZG9jdW1lbnQucmVmZXJyZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgUGFnZS5wcm90b3R5cGUucGF0aCA9IFwiL3BhZ2VcIjtcblxuICAgICAgUGFnZS5wcm90b3R5cGUuY29uc3RhbnRGaWVsZHMgPSBbXCJzaXRlX3VzZXJfaWRcIiwgXCJwYWdlX2lkXCIsIFwidmlzaXRfaWRcIiwgXCJmdWxsX3VybFwiXTtcblxuICAgICAgcmV0dXJuIFBhZ2U7XG5cbiAgICB9KShCYXNlKTtcbiAgICBQYWdlLlZJU0lUT1JfRVhQSVJZID0gY29uZmlnLnZpc2l0X2V4cGlyeTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuRU5WID09PSBcInRlc3RcIiB8fCAoKHR5cGVvZiBfVEVTVCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfVEVTVCAhPT0gbnVsbCkgJiYgX1RFU1QpKSB7XG4gICAgICBQYWdlLl9DT09LSUVfS0VZID0gQ09PS0lFX0tFWTtcbiAgICAgIFBhZ2UuY2xlYXJDb29raWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29va2llcy5zZXQoQ09PS0lFX0tFWSArIFwiX3N1aWRcIiwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvb2tpZXMuc2V0KENPT0tJRV9LRVkgKyBcIl92aWRcIiwgdm9pZCAwKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBQYWdlO1xuICB9KSgkc2YsIHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiOER3b2hSXCIpKSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlYWRlcmJvYXJkOiBbNzI4LCA5MF0sXG4gICAgICBcIm1lZGl1bS1yZWN0YW5nbGVcIjogWzMwMCwgMjUwXVxuICAgIH07XG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciByZXF3ZXN0O1xuXG4gIHdpbmRvdy5KU09OIHx8ICh3aW5kb3cuSlNPTiA9IHJlcXVpcmUoJ2pzb24nKSk7XG5cbiAgcmVxd2VzdCA9IHJlcXVpcmUoJ3JlcXdlc3QnKTtcblxuICB3aW5kb3cuSlNPTiB8fCAod2luZG93LkpTT04gPSByZXF1aXJlKCdqc29uJykpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCRzZikge1xuICAgIHZhciBjYXBpdGFsaXplU3RyaW5nLCBjb3VudEZyYW1lcywgZGVmaW5lUHJvcGVydHksIGZpbmRDb250cm9sbGVyLCBmcm9tUXVlcnksIGdldEZyYW1lUG9zaXRpb24sIGtleXMsIG5hdGl2ZVJlZHVjZSwgbm93LCByZWR1Y2UsIHJlZHVjZUVycm9yLCBzZW5kUmVxdWVzdCwgdG9OdW1iZXIsIHRvUXVlcnk7XG4gICAgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxd2VzdChvcHRpb25zKTtcbiAgICB9O1xuICAgIGZyb21RdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5LCBkZWxpbSkge1xuICAgICAgdmFyIGl0ZW0sIGtleSwgcGFyYW1zLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKHF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgcXVlcnkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGltID09IG51bGwpIHtcbiAgICAgICAgZGVsaW0gPSBcIiZcIjtcbiAgICAgIH1cbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgX3JlZiA9IHF1ZXJ5LnNwbGl0KGRlbGltKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpdGVtID0gX3JlZltfaV07XG4gICAgICAgIF9yZWYxID0gaXRlbS5zcGxpdChcIj1cIiksIGtleSA9IF9yZWYxWzBdLCB2YWx1ZSA9IF9yZWYxWzFdO1xuICAgICAgICBwYXJhbXNba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgdG9RdWVyeSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiByZXF3ZXN0LnRvUXVlcnlTdHJpbmcoYXR0cmlidXRlcyk7XG4gICAgfTtcbiAgICB0b051bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICRzZiAhPSBudWxsID8gJHNmLmxpYi5sYW5nLmNudW0odmFsLCAwKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIG5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgdmFyIGU7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXCJkZWZpbmVQcm9wZXJ0eVwiIGluIE9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIl9fZGVmaW5lR2V0dGVyX19cIiBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18ocHJvcCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci53cml0YWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai5fX2RlZmluZVNldHRlcl9fKHByb3AsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvdW50RnJhbWVzID0gZnVuY3Rpb24od2luKSB7XG4gICAgICB2YXIgY291bnQsIGZyYW1lLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGNvdW50ID0gd2luLmZyYW1lcy5sZW5ndGg7XG4gICAgICBfcmVmID0gd2luLmZyYW1lcztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBmcmFtZSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoZnJhbWUgIT09IHdpbikge1xuICAgICAgICAgIGNvdW50ICs9IGNvdW50RnJhbWVzKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgZ2V0RnJhbWVQb3NpdGlvbiA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgdmFyIGNvdW50O1xuICAgICAgY291bnQgPSAwO1xuICAgICAgaWYgKHdpbi5wYXJlbnQgIT09IHdpbi50b3ApIHtcbiAgICAgICAgY291bnQgPSAxICsgZ2V0RnJhbWVQb3NpdGlvbih3aW4ucGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuICAgIG5hdGl2ZVJlZHVjZSA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2U7XG4gICAgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG4gICAgcmVkdWNlID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgICAgdmFyIGluZGV4LCBpbml0aWFsLCB2YWx1ZSwgX2ZuLCBfaSwgX2xlbjtcbiAgICAgIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICBvYmogPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcikpO1xuICAgICAgfVxuICAgICAgX2ZuID0gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmopIHtcbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgbWVtbyA9IHZhbHVlO1xuICAgICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvciAoaW5kZXggPSBfaSA9IDAsIF9sZW4gPSBvYmoubGVuZ3RoOyBfaSA8IF9sZW47IGluZGV4ID0gKytfaSkge1xuICAgICAgICB2YWx1ZSA9IG9ialtpbmRleF07XG4gICAgICAgIF9mbih2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICB9XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICAgIGtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAkc2YgIT0gbnVsbCA/ICRzZi5saWIubGFuZy5rZXlzKG9iaikgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBmaW5kQ29udHJvbGxlciA9IGZ1bmN0aW9uKGNiLCByZXRyeSkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIsIGZyYW1lLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAocmV0cnkgPT0gbnVsbCkge1xuICAgICAgICByZXRyeSA9IDM7XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyID0gbnVsbDtcbiAgICAgIF9yZWYgPSB3aW5kb3cudG9wLmZyYW1lcztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBmcmFtZSA9IF9yZWZbX2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICgoX3JlZjEgPSBmcmFtZS4kYWQpICE9IG51bGwgPyBfcmVmMS5pc0NvbnRyb2xsZXIgOiB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBmcmFtZS4kYWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiBjYihjb250cm9sbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHJldHJ5IDwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZENvbnRyb2xsZXIoY2IsIHJldHJ5IC0gMSk7XG4gICAgICAgICAgfSksIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNhcGl0YWxpemVTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VuZFJlcXVlc3Q6IHNlbmRSZXF1ZXN0LFxuICAgICAgdG9RdWVyeTogdG9RdWVyeSxcbiAgICAgIGZyb21RdWVyeTogZnJvbVF1ZXJ5LFxuICAgICAgdG9OdW1iZXI6IHRvTnVtYmVyLFxuICAgICAgbm93OiBub3csXG4gICAgICBkZWZpbmVQcm9wZXJ0eTogZGVmaW5lUHJvcGVydHksXG4gICAgICBjb3VudEZyYW1lczogY291bnRGcmFtZXMsXG4gICAgICBjYXBpdGFsaXplU3RyaW5nOiBjYXBpdGFsaXplU3RyaW5nLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGdldEZyYW1lUG9zaXRpb246IGdldEZyYW1lUG9zaXRpb24sXG4gICAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICAgIGZpbmRDb250cm9sbGVyOiBmaW5kQ29udHJvbGxlclxuICAgIH07XG4gIH0pKCRzZik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKiFcclxuICogQ29va2llcy5qcyAtIDAuMy4xXHJcbiAqIFdlZG5lc2RheSwgQXByaWwgMjQgMjAxMyBAIDI6MjggQU0gRVNUXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMywgU2NvdHQgSGFtcGVyXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSxcclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuICovXHJcbihmdW5jdGlvbiAodW5kZWZpbmVkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIENvb2tpZXMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cclxuICAgICAgICAgICAgQ29va2llcy5nZXQoa2V5KSA6IENvb2tpZXMuc2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBbGxvd3MgZm9yIHNldHRlciBpbmplY3Rpb24gaW4gdW5pdCB0ZXN0c1xyXG4gICAgQ29va2llcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgIENvb2tpZXMuX25hdmlnYXRvciA9IG5hdmlnYXRvcjtcclxuXHJcbiAgICBDb29raWVzLmRlZmF1bHRzID0ge1xyXG4gICAgICAgIHBhdGg6ICcvJ1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoQ29va2llcy5fY2FjaGVkRG9jdW1lbnRDb29raWUgIT09IENvb2tpZXMuX2RvY3VtZW50LmNvb2tpZSkge1xyXG4gICAgICAgICAgICBDb29raWVzLl9yZW5ld0NhY2hlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gQ29va2llcy5fY2FjaGVba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgQ29va2llcy5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBDb29raWVzLl9nZXRFeHRlbmRlZE9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgb3B0aW9ucy5leHBpcmVzID0gQ29va2llcy5fZ2V0RXhwaXJlc0RhdGUodmFsdWUgPT09IHVuZGVmaW5lZCA/IC0xIDogb3B0aW9ucy5leHBpcmVzKTtcclxuXHJcbiAgICAgICAgQ29va2llcy5fZG9jdW1lbnQuY29va2llID0gQ29va2llcy5fZ2VuZXJhdGVDb29raWVTdHJpbmcoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJldHVybiBDb29raWVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLmV4cGlyZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gQ29va2llcy5zZXQoa2V5LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLl9nZXRFeHRlbmRlZE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBhdGg6IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoIHx8IENvb2tpZXMuZGVmYXVsdHMucGF0aCxcclxuICAgICAgICAgICAgZG9tYWluOiBvcHRpb25zICYmIG9wdGlvbnMuZG9tYWluIHx8IENvb2tpZXMuZGVmYXVsdHMuZG9tYWluLFxyXG4gICAgICAgICAgICBleHBpcmVzOiBvcHRpb25zICYmIG9wdGlvbnMuZXhwaXJlcyB8fCBDb29raWVzLmRlZmF1bHRzLmV4cGlyZXMsXHJcbiAgICAgICAgICAgIHNlY3VyZTogb3B0aW9ucyAmJiBvcHRpb25zLnNlY3VyZSAhPT0gdW5kZWZpbmVkID8gIG9wdGlvbnMuc2VjdXJlIDogQ29va2llcy5kZWZhdWx0cy5zZWN1cmVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLl9pc1ZhbGlkRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmICFpc05hTihkYXRlLmdldFRpbWUoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dldEV4cGlyZXNEYXRlID0gZnVuY3Rpb24gKGV4cGlyZXMsIG5vdykge1xyXG4gICAgICAgIG5vdyA9IG5vdyB8fCBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGV4cGlyZXMpIHtcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzogZXhwaXJlcyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyBleHBpcmVzICogMTAwMCk7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOiBleHBpcmVzID0gbmV3IERhdGUoZXhwaXJlcyk7IGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV4cGlyZXMgJiYgIUNvb2tpZXMuX2lzVmFsaWREYXRlKGV4cGlyZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGV4cGlyZXNgIHBhcmFtZXRlciBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgdmFsaWQgRGF0ZSBpbnN0YW5jZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGV4cGlyZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dlbmVyYXRlQ29va2llU3RyaW5nID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICBrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSArICcnKS5yZXBsYWNlKC9bXiEjJCYtK1xcLS06PC1cXFtcXF0tfl0vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGNvb2tpZVN0cmluZyA9IGtleSArICc9JyArIHZhbHVlO1xyXG4gICAgICAgIGNvb2tpZVN0cmluZyArPSBvcHRpb25zLnBhdGggPyAnO3BhdGg9JyArIG9wdGlvbnMucGF0aCA6ICcnO1xyXG4gICAgICAgIGNvb2tpZVN0cmluZyArPSBvcHRpb25zLmRvbWFpbiA/ICc7ZG9tYWluPScgKyBvcHRpb25zLmRvbWFpbiA6ICcnO1xyXG4gICAgICAgIGNvb2tpZVN0cmluZyArPSBvcHRpb25zLmV4cGlyZXMgPyAnO2V4cGlyZXM9JyArIG9wdGlvbnMuZXhwaXJlcy50b0dNVFN0cmluZygpIDogJyc7XHJcbiAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMuc2VjdXJlID8gJztzZWN1cmUnIDogJyc7XHJcblxyXG4gICAgICAgIHJldHVybiBjb29raWVTdHJpbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuX2dldENvb2tpZU9iamVjdEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoZG9jdW1lbnRDb29raWUpIHtcclxuICAgICAgICB2YXIgY29va2llT2JqZWN0ID0ge307XHJcbiAgICAgICAgdmFyIGNvb2tpZXNBcnJheSA9IGRvY3VtZW50Q29va2llID8gZG9jdW1lbnRDb29raWUuc3BsaXQoJzsgJykgOiBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvb2tpZUt2cCA9IENvb2tpZXMuX2dldEtleVZhbHVlUGFpckZyb21Db29raWVTdHJpbmcoY29va2llc0FycmF5W2ldKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb29raWVPYmplY3RbY29va2llS3ZwLmtleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29va2llT2JqZWN0W2Nvb2tpZUt2cC5rZXldID0gY29va2llS3ZwLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29va2llT2JqZWN0O1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLl9nZXRLZXlWYWx1ZVBhaXJGcm9tQ29va2llU3RyaW5nID0gZnVuY3Rpb24gKGNvb2tpZVN0cmluZykge1xyXG4gICAgICAgIC8vIFwiPVwiIGlzIGEgdmFsaWQgY2hhcmFjdGVyIGluIGEgY29va2llIHZhbHVlIGFjY29yZGluZyB0byBSRkM2MjY1LCBzbyBjYW5ub3QgYHNwbGl0KCc9JylgXHJcbiAgICAgICAgdmFyIHNlcGFyYXRvckluZGV4ID0gY29va2llU3RyaW5nLmluZGV4T2YoJz0nKTtcclxuXHJcbiAgICAgICAgLy8gSUUgb21pdHMgdGhlIFwiPVwiIHdoZW4gdGhlIGNvb2tpZSB2YWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmdcclxuICAgICAgICBzZXBhcmF0b3JJbmRleCA9IHNlcGFyYXRvckluZGV4IDwgMCA/IGNvb2tpZVN0cmluZy5sZW5ndGggOiBzZXBhcmF0b3JJbmRleDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5OiBkZWNvZGVVUklDb21wb25lbnQoY29va2llU3RyaW5nLnN1YnN0cigwLCBzZXBhcmF0b3JJbmRleCkpLFxyXG4gICAgICAgICAgICB2YWx1ZTogZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVN0cmluZy5zdWJzdHIoc2VwYXJhdG9ySW5kZXggKyAxKSlcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLl9yZW5ld0NhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIENvb2tpZXMuX2NhY2hlID0gQ29va2llcy5fZ2V0Q29va2llT2JqZWN0RnJvbVN0cmluZyhDb29raWVzLl9kb2N1bWVudC5jb29raWUpO1xyXG4gICAgICAgIENvb2tpZXMuX2NhY2hlZERvY3VtZW50Q29va2llID0gQ29va2llcy5fZG9jdW1lbnQuY29va2llO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb29raWVzLl9hcmVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBDb29raWVzLl9uYXZpZ2F0b3IuY29va2llRW5hYmxlZCB8fFxyXG4gICAgICAgICAgICBDb29raWVzLnNldCgnY29va2llcy5qcycsIDEpLmdldCgnY29va2llcy5qcycpID09PSAnMSc7XHJcbiAgICB9O1xyXG5cclxuICAgIENvb2tpZXMuZW5hYmxlZCA9IENvb2tpZXMuX2FyZUVuYWJsZWQoKTtcclxuXHJcbiAgICAvLyBBTUQgc3VwcG9ydFxyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBDb29raWVzOyB9KTtcclxuICAgIC8vIENvbW1vbkpTIGFuZCBOb2RlLmpzIG1vZHVsZSBzdXBwb3J0LlxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBTdXBwb3J0IE5vZGUuanMgc3BlY2lmaWMgYG1vZHVsZS5leHBvcnRzYCAod2hpY2ggY2FuIGJlIGEgZnVuY3Rpb24pXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENvb2tpZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJ1dCBhbHdheXMgc3VwcG9ydCBDb21tb25KUyBtb2R1bGUgMS4xLjEgc3BlYyAoYGV4cG9ydHNgIGNhbm5vdCBiZSBhIGZ1bmN0aW9uKVxyXG4gICAgICAgIGV4cG9ydHMuQ29va2llcyA9IENvb2tpZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5Db29raWVzID0gQ29va2llcztcclxuICAgIH1cclxufSkoKTsiLCIvKlxuICAgIGh0dHA6Ly93d3cuSlNPTi5vcmcvanNvbjIuanNcbiAgICAyMDExLTAyLTIzXG5cbiAgICBQdWJsaWMgRG9tYWluLlxuXG4gICAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuXG4gICAgU2VlIGh0dHA6Ly93d3cuSlNPTi5vcmcvanMuaHRtbFxuXG5cbiAgICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuICAgIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuICAgIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4gICAgTk9UIENPTlRST0wuXG5cblxuICAgIFRoaXMgZmlsZSBjcmVhdGVzIGEgZ2xvYmFsIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIG1ldGhvZHM6IHN0cmluZ2lmeVxuICAgIGFuZCBwYXJzZS5cblxuICAgICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuICAgICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuXG4gICAgICAgICAgICByZXBsYWNlciAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZXRlcm1pbmVzIGhvdyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuXG4gICAgICAgICAgICBzcGFjZSAgICAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvZiBuZXN0ZWQgc3RydWN0dXJlcy4gSWYgaXQgaXMgb21pdHRlZCwgdGhlIHRleHQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgYmUgcGFja2VkIHdpdGhvdXQgZXh0cmEgd2hpdGVzcGFjZS4gSWYgaXQgaXMgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIHNwZWNpZnkgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gaW5kZW50IGF0IGVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLiBJZiBpdCBpcyBhIHN0cmluZyAoc3VjaCBhcyAnXFx0JyBvciAnJm5ic3A7JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuXG4gICAgICAgICAgICBUaGlzIG1ldGhvZCBwcm9kdWNlcyBhIEpTT04gdGV4dCBmcm9tIGEgSmF2YVNjcmlwdCB2YWx1ZS5cblxuICAgICAgICAgICAgV2hlbiBhbiBvYmplY3QgdmFsdWUgaXMgZm91bmQsIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYSB0b0pTT05cbiAgICAgICAgICAgIG1ldGhvZCwgaXRzIHRvSlNPTiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuICAgICAgICAgICAgc3RyaW5naWZpZWQuIEEgdG9KU09OIG1ldGhvZCBkb2VzIG5vdCBzZXJpYWxpemU6IGl0IHJldHVybnMgdGhlXG4gICAgICAgICAgICB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgbmFtZS92YWx1ZSBwYWlyIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICBvciB1bmRlZmluZWQgaWYgbm90aGluZyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIHRvSlNPTiBtZXRob2RcbiAgICAgICAgICAgIHdpbGwgYmUgcGFzc2VkIHRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSB2YWx1ZSwgYW5kIHRoaXMgd2lsbCBiZVxuICAgICAgICAgICAgYm91bmQgdG8gdGhlIHZhbHVlXG5cbiAgICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuICAgICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuICAgICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4gICAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuICAgICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4gICAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4gICAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuICAgICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuICAgICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3JcbiAgICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4gICAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2VcbiAgICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZC5cblxuICAgICAgICAgICAgVGhlIG9wdGlvbmFsIHNwYWNlIHBhcmFtZXRlciBwcm9kdWNlcyBhIHN0cmluZ2lmaWNhdGlvbiBvZiB0aGVcbiAgICAgICAgICAgIHZhbHVlIHRoYXQgaXMgZmlsbGVkIHdpdGggbGluZSBicmVha3MgYW5kIGluZGVudGF0aW9uIHRvIG1ha2UgaXRcbiAgICAgICAgICAgIGVhc2llciB0byByZWFkLlxuXG4gICAgICAgICAgICBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbm9uLWVtcHR5IHN0cmluZywgdGhlbiB0aGF0IHN0cmluZyB3aWxsXG4gICAgICAgICAgICBiZSB1c2VkIGZvciBpbmRlbnRhdGlvbi4gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgdGhlblxuICAgICAgICAgICAgdGhlIGluZGVudGF0aW9uIHdpbGwgYmUgdGhhdCBtYW55IHNwYWNlcy5cblxuICAgICAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFsnZScsIHtwbHVyaWJ1czogJ3VudW0nfV0pO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoWydlJywge3BsdXJpYnVzOiAndW51bSd9XSwgbnVsbCwgJ1xcdCcpO1xuICAgICAgICAgICAgLy8gdGV4dCBpcyAnW1xcblxcdFwiZVwiLFxcblxcdHtcXG5cXHRcXHRcInBsdXJpYnVzXCI6IFwidW51bVwiXFxuXFx0fVxcbl0nXG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbbmV3IERhdGUoKV0sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGUgP1xuICAgICAgICAgICAgICAgICAgICAnRGF0ZSgnICsgdGhpc1trZXldICsgJyknIDogdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcIkRhdGUoLS0tY3VycmVudCB0aW1lLS0tKVwiXSdcblxuXG4gICAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbiAgICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuICAgICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuICAgICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4gICAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuICAgICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4gICAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4gICAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9XG4vXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pVChcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0oPzpcXC5cXGQqKT8pWiQvLmV4ZWModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKCthWzFdLCArYVsyXSAtIDEsICthWzNdLCArYVs0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArYVs1XSwgK2FbNl0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSgnW1wiRGF0ZSgwOS8wOS8yMDAxKVwiXScsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSAnRGF0ZSgnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgtMSkgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICBkID0gbmV3IERhdGUodmFsdWUuc2xpY2UoNSwgLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICBUaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLiBZb3UgYXJlIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBvclxuICAgIHJlZGlzdHJpYnV0ZS5cbiovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHN0cmljdDogZmFsc2UsIHJlZ2V4cDogZmFsc2UgKi9cblxuLyptZW1iZXJzIFwiXCIsIFwiXFxiXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxmXCIsIFwiXFxyXCIsIFwiXFxcIlwiLCBKU09OLCBcIlxcXFxcIiwgYXBwbHksXG4gICAgY2FsbCwgY2hhckNvZGVBdCwgZ2V0VVRDRGF0ZSwgZ2V0VVRDRnVsbFllYXIsIGdldFVUQ0hvdXJzLFxuICAgIGdldFVUQ01pbnV0ZXMsIGdldFVUQ01vbnRoLCBnZXRVVENTZWNvbmRzLCBoYXNPd25Qcm9wZXJ0eSwgam9pbixcbiAgICBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiAgICB0ZXN0LCB0b0pTT04sIHRvU3RyaW5nLCB2YWx1ZU9mXG4qL1xuXG5cbi8vIENyZWF0ZSBhIEpTT04gb2JqZWN0IG9ubHkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuIFdlIGNyZWF0ZSB0aGVcbi8vIG1ldGhvZHMgaW4gYSBjbG9zdXJlIHRvIGF2b2lkIGNyZWF0aW5nIGdsb2JhbCB2YXJpYWJsZXMuXG5cbnZhciBKU09OO1xuaWYgKCFKU09OKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGdsb2JhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcbiAgICAgICwgSlNPTiA9IGdsb2JhbC5KU09OXG4gICAgICA7XG5cbiAgICBpZiAoIUpTT04pIHtcbiAgICAgIEpTT04gPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9KU09OICE9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodGhpcy52YWx1ZU9mKCkpID9cbiAgICAgICAgICAgICAgICB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICAgICsgJy0nICtcbiAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgJ1QnICtcbiAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgJzonICtcbiAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgJ1onIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBTdHJpbmcucHJvdG90eXBlLnRvSlNPTiAgICAgID1cbiAgICAgICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OICA9XG4gICAgICAgICAgICBCb29sZWFuLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZ2FwLFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgIH0sXG4gICAgICAgIHJlcDtcblxuXG4gICAgZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG5cbi8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbi8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4vLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbi8vIHNlcXVlbmNlcy5cblxuICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICAgICAgcGFydGlhbCxcbiAgICAgICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgICAgfVxuXG4vLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbi8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG5cbi8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG5cbi8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbi8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4vLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuLy8gSWYgdGhlIHR5cGUgaXMgJ29iamVjdCcsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcblxuLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cbi8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbi8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4vLyBicmFja2V0cy5cblxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbi8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHN0cmluZ2lmeSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cbi8vIFRoZSBzdHJpbmdpZnkgbWV0aG9kIHRha2VzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHJlcGxhY2VyLCBhbmQgYW4gb3B0aW9uYWxcbi8vIHNwYWNlIHBhcmFtZXRlciwgYW5kIHJldHVybnMgYSBKU09OIHRleHQuIFRoZSByZXBsYWNlciBjYW4gYmUgYSBmdW5jdGlvblxuLy8gdGhhdCBjYW4gcmVwbGFjZSB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHNlbGVjdCB0aGUga2V5cy5cbi8vIEEgZGVmYXVsdCByZXBsYWNlciBtZXRob2QgY2FuIGJlIHByb3ZpZGVkLiBVc2Ugb2YgdGhlIHNwYWNlIHBhcmFtZXRlciBjYW5cbi8vIHByb2R1Y2UgdGV4dCB0aGF0IGlzIG1vcmUgZWFzaWx5IHJlYWRhYmxlLlxuXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGdhcCA9ICcnO1xuICAgICAgICAgICAgaW5kZW50ID0gJyc7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBwYXJzZSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnBhcnNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEpTT04ucGFyc2UgPSBmdW5jdGlvbiAodGV4dCwgcmV2aXZlcikge1xuXG4vLyBUaGUgcGFyc2UgbWV0aG9kIHRha2VzIGEgdGV4dCBhbmQgYW4gb3B0aW9uYWwgcmV2aXZlciBmdW5jdGlvbiwgYW5kIHJldHVybnNcbi8vIGEgSmF2YVNjcmlwdCB2YWx1ZSBpZiB0aGUgdGV4dCBpcyBhIHZhbGlkIEpTT04gdGV4dC5cblxuICAgICAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcblxuLy8gVGhlIHdhbGsgbWV0aG9kIGlzIHVzZWQgdG8gcmVjdXJzaXZlbHkgd2FsayB0aGUgcmVzdWx0aW5nIHN0cnVjdHVyZSBzb1xuLy8gdGhhdCBtb2RpZmljYXRpb25zIGNhbiBiZSBtYWRlLlxuXG4gICAgICAgICAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgY3gubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChjeC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShjeCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuLy8gSW4gdGhlIHNlY29uZCBzdGFnZSwgd2UgcnVuIHRoZSB0ZXh0IGFnYWluc3QgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGxvb2tcbi8vIGZvciBub24tSlNPTiBwYXR0ZXJucy4gV2UgYXJlIGVzcGVjaWFsbHkgY29uY2VybmVkIHdpdGggJygpJyBhbmQgJ25ldydcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kICc9JyBiZWNhdXNlIGl0IGNhbiBjYXVzZSBtdXRhdGlvbi5cbi8vIEJ1dCBqdXN0IHRvIGJlIHNhZmUsIHdlIHdhbnQgdG8gcmVqZWN0IGFsbCB1bmV4cGVjdGVkIGZvcm1zLlxuXG4vLyBXZSBzcGxpdCB0aGUgc2Vjb25kIHN0YWdlIGludG8gNCByZWdleHAgb3BlcmF0aW9ucyBpbiBvcmRlciB0byB3b3JrIGFyb3VuZFxuLy8gY3JpcHBsaW5nIGluZWZmaWNpZW5jaWVzIGluIElFJ3MgYW5kIFNhZmFyaSdzIHJlZ2V4cCBlbmdpbmVzLiBGaXJzdCB3ZVxuLy8gcmVwbGFjZSB0aGUgSlNPTiBiYWNrc2xhc2ggcGFpcnMgd2l0aCAnQCcgKGEgbm9uLUpTT04gY2hhcmFjdGVyKS4gU2Vjb25kLCB3ZVxuLy8gcmVwbGFjZSBhbGwgc2ltcGxlIHZhbHVlIHRva2VucyB3aXRoICddJyBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yICddJyBvclxuLy8gJywnIG9yICc6JyBvciAneycgb3IgJ30nLiBJZiB0aGF0IGlzIHNvLCB0aGVuIHRoZSB0ZXh0IGlzIHNhZmUgZm9yIGV2YWwuXG5cbiAgICAgICAgICAgIGlmICgvXltcXF0sOnt9XFxzXSokL1xuICAgICAgICAgICAgICAgICAgICAudGVzdCh0ZXh0LnJlcGxhY2UoL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZywgJ0AnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLCAnXScpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csICcnKSkpIHtcblxuLy8gSW4gdGhlIHRoaXJkIHN0YWdlIHdlIHVzZSB0aGUgZXZhbCBmdW5jdGlvbiB0byBjb21waWxlIHRoZSB0ZXh0IGludG8gYVxuLy8gSmF2YVNjcmlwdCBzdHJ1Y3R1cmUuIFRoZSAneycgb3BlcmF0b3IgaXMgc3ViamVjdCB0byBhIHN5bnRhY3RpYyBhbWJpZ3VpdHlcbi8vIGluIEphdmFTY3JpcHQ6IGl0IGNhbiBiZWdpbiBhIGJsb2NrIG9yIGFuIG9iamVjdCBsaXRlcmFsLiBXZSB3cmFwIHRoZSB0ZXh0XG4vLyBpbiBwYXJlbnMgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHkuXG5cbiAgICAgICAgICAgICAgICBqID0gZXZhbCgnKCcgKyB0ZXh0ICsgJyknKTtcblxuLy8gSW4gdGhlIG9wdGlvbmFsIGZvdXJ0aCBzdGFnZSwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSwgcGFzc2luZ1xuLy8gZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gYSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbi5cblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIHdhbGsoeycnOiBqfSwgJycpIDogajtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHRleHQgaXMgbm90IEpTT04gcGFyc2VhYmxlLCB0aGVuIGEgU3ludGF4RXJyb3IgaXMgdGhyb3duLlxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0pTT04ucGFyc2UnKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnbG9iYWwuSlNPTiA9IEpTT047XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBKU09OO1xufSgpKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi43LjBcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG4oZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbW9tZW50LFxuICAgICAgICBWRVJTSU9OID0gXCIyLjcuMFwiLFxuICAgICAgICAvLyB0aGUgZ2xvYmFsLXNjb3BlIHRoaXMgaXMgTk9UIHRoZSBnbG9iYWwgb2JqZWN0IGluIE5vZGUuanNcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsXG4gICAgICAgIG9sZEdsb2JhbE1vbWVudCxcbiAgICAgICAgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICBpLFxuXG4gICAgICAgIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcblxuICAgICAgICAvLyBtb21lbnQgaW50ZXJuYWwgcHJvcGVydGllc1xuICAgICAgICBtb21lbnRQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgX2lzQU1vbWVudE9iamVjdDogbnVsbCxcbiAgICAgICAgICAgIF9pIDogbnVsbCxcbiAgICAgICAgICAgIF9mIDogbnVsbCxcbiAgICAgICAgICAgIF9sIDogbnVsbCxcbiAgICAgICAgICAgIF9zdHJpY3QgOiBudWxsLFxuICAgICAgICAgICAgX3R6bSA6IG51bGwsXG4gICAgICAgICAgICBfaXNVVEMgOiBudWxsLFxuICAgICAgICAgICAgX29mZnNldCA6IG51bGwsICAvLyBvcHRpb25hbC4gQ29tYmluZSB3aXRoIF9pc1VUQ1xuICAgICAgICAgICAgX3BmIDogbnVsbCxcbiAgICAgICAgICAgIF9sYW5nIDogbnVsbCAgLy8gb3B0aW9uYWxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXG4gICAgICAgIGhhc01vZHVsZSA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyksXG5cbiAgICAgICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2ksXG4gICAgICAgIGFzcE5ldFRpbWVTcGFuSnNvblJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LyxcblxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgICAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgICAgIGlzb0R1cmF0aW9uUmVnZXggPSAvXigtKT9QKD86KD86KFswLTksLl0qKVkpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopRCk/KD86VCg/OihbMC05LC5dKilIKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKVMpPyk/fChbMC05LC5dKilXKSQvLFxuXG4gICAgICAgIC8vIGZvcm1hdCB0b2tlbnNcbiAgICAgICAgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDR9fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFR8TEw/TD9MP3xsezEsNH0pL2csXG5cbiAgICAgICAgLy8gcGFyc2luZyB0b2tlbiByZWdleGVzXG4gICAgICAgIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cyA9IC9cXGRcXGQ/LywgLy8gMCAtIDk5XG4gICAgICAgIHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzID0gL1xcZHsxLDN9LywgLy8gMCAtIDk5OVxuICAgICAgICBwYXJzZVRva2VuT25lVG9Gb3VyRGlnaXRzID0gL1xcZHsxLDR9LywgLy8gMCAtIDk5OTlcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzID0gL1srXFwtXT9cXGR7MSw2fS8sIC8vIC05OTksOTk5IC0gOTk5LDk5OVxuICAgICAgICBwYXJzZVRva2VuRGlnaXRzID0gL1xcZCsvLCAvLyBub256ZXJvIG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgcGFyc2VUb2tlbldvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaSwgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAgIHBhcnNlVG9rZW5UaW1lem9uZSA9IC9afFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBwYXJzZVRva2VuVCA9IC9UL2ksIC8vIFQgKElTTyBzZXBhcmF0b3IpXG4gICAgICAgIHBhcnNlVG9rZW5UaW1lc3RhbXBNcyA9IC9bXFwrXFwtXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICBwYXJzZVRva2VuT3JkaW5hbCA9IC9cXGR7MSwyfS8sXG5cbiAgICAgICAgLy9zdHJpY3QgcGFyc2luZyByZWdleGVzXG4gICAgICAgIHBhcnNlVG9rZW5PbmVEaWdpdCA9IC9cXGQvLCAvLyAwIC0gOVxuICAgICAgICBwYXJzZVRva2VuVHdvRGlnaXRzID0gL1xcZFxcZC8sIC8vIDAwIC0gOTlcbiAgICAgICAgcGFyc2VUb2tlblRocmVlRGlnaXRzID0gL1xcZHszfS8sIC8vIDAwMCAtIDk5OVxuICAgICAgICBwYXJzZVRva2VuRm91ckRpZ2l0cyA9IC9cXGR7NH0vLCAvLyAwMDAwIC0gOTk5OVxuICAgICAgICBwYXJzZVRva2VuU2l4RGlnaXRzID0gL1srLV0/XFxkezZ9LywgLy8gLTk5OSw5OTkgLSA5OTksOTk5XG4gICAgICAgIHBhcnNlVG9rZW5TaWduZWROdW1iZXIgPSAvWystXT9cXGQrLywgLy8gLWluZiAtIGluZlxuXG4gICAgICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgICAgICBpc29SZWdleCA9IC9eXFxzKig/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyhbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG5cbiAgICAgICAgaXNvRm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJyxcblxuICAgICAgICBpc29EYXRlcyA9IFtcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZHsyfS1cXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZHsyfS9dLFxuICAgICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L11cbiAgICAgICAgXSxcblxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvKFR8IClcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIJywgLyhUfCApXFxkXFxkL11cbiAgICAgICAgXSxcblxuICAgICAgICAvLyB0aW1lem9uZSBjaHVua2VyIFwiKzEwOjAwXCIgPiBbXCIxMFwiLCBcIjAwXCJdIG9yIFwiLTE1MzBcIiA+IFtcIi0xNVwiLCBcIjMwXCJdXG4gICAgICAgIHBhcnNlVGltZXpvbmVDaHVua2VyID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpLFxuXG4gICAgICAgIC8vIGdldHRlciBhbmQgc2V0dGVyIG5hbWVzXG4gICAgICAgIHByb3h5R2V0dGVyc0FuZFNldHRlcnMgPSAnRGF0ZXxIb3Vyc3xNaW51dGVzfFNlY29uZHN8TWlsbGlzZWNvbmRzJy5zcGxpdCgnfCcpLFxuICAgICAgICB1bml0TWlsbGlzZWNvbmRGYWN0b3JzID0ge1xuICAgICAgICAgICAgJ01pbGxpc2Vjb25kcycgOiAxLFxuICAgICAgICAgICAgJ1NlY29uZHMnIDogMWUzLFxuICAgICAgICAgICAgJ01pbnV0ZXMnIDogNmU0LFxuICAgICAgICAgICAgJ0hvdXJzJyA6IDM2ZTUsXG4gICAgICAgICAgICAnRGF5cycgOiA4NjRlNSxcbiAgICAgICAgICAgICdNb250aHMnIDogMjU5MmU2LFxuICAgICAgICAgICAgJ1llYXJzJyA6IDMxNTM2ZTZcbiAgICAgICAgfSxcblxuICAgICAgICB1bml0QWxpYXNlcyA9IHtcbiAgICAgICAgICAgIG1zIDogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgIHMgOiAnc2Vjb25kJyxcbiAgICAgICAgICAgIG0gOiAnbWludXRlJyxcbiAgICAgICAgICAgIGggOiAnaG91cicsXG4gICAgICAgICAgICBkIDogJ2RheScsXG4gICAgICAgICAgICBEIDogJ2RhdGUnLFxuICAgICAgICAgICAgdyA6ICd3ZWVrJyxcbiAgICAgICAgICAgIFcgOiAnaXNvV2VlaycsXG4gICAgICAgICAgICBNIDogJ21vbnRoJyxcbiAgICAgICAgICAgIFEgOiAncXVhcnRlcicsXG4gICAgICAgICAgICB5IDogJ3llYXInLFxuICAgICAgICAgICAgREREIDogJ2RheU9mWWVhcicsXG4gICAgICAgICAgICBlIDogJ3dlZWtkYXknLFxuICAgICAgICAgICAgRSA6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgICAgIGdnOiAnd2Vla1llYXInLFxuICAgICAgICAgICAgR0c6ICdpc29XZWVrWWVhcidcbiAgICAgICAgfSxcblxuICAgICAgICBjYW1lbEZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIGRheW9meWVhciA6ICdkYXlPZlllYXInLFxuICAgICAgICAgICAgaXNvd2Vla2RheSA6ICdpc29XZWVrZGF5JyxcbiAgICAgICAgICAgIGlzb3dlZWsgOiAnaXNvV2VlaycsXG4gICAgICAgICAgICB3ZWVreWVhciA6ICd3ZWVrWWVhcicsXG4gICAgICAgICAgICBpc293ZWVreWVhciA6ICdpc29XZWVrWWVhcidcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtYXQgZnVuY3Rpb24gc3RyaW5nc1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcblxuICAgICAgICAvLyBkZWZhdWx0IHJlbGF0aXZlIHRpbWUgdGhyZXNob2xkc1xuICAgICAgICByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzID0ge1xuICAgICAgICAgIHM6IDQ1LCAgIC8vc2Vjb25kcyB0byBtaW51dGVzXG4gICAgICAgICAgbTogNDUsICAgLy9taW51dGVzIHRvIGhvdXJzXG4gICAgICAgICAgaDogMjIsICAgLy9ob3VycyB0byBkYXlzXG4gICAgICAgICAgZGQ6IDI1LCAgLy9kYXlzIHRvIG1vbnRoIChtb250aCA9PSAxKVxuICAgICAgICAgIGRtOiA0NSwgIC8vZGF5cyB0byBtb250aHMgKG1vbnRocyA+IDEpXG4gICAgICAgICAgZHk6IDM0NSAgLy9kYXlzIHRvIHllYXJcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0b2tlbnMgdG8gb3JkaW5hbGl6ZSBhbmQgcGFkXG4gICAgICAgIG9yZGluYWxpemVUb2tlbnMgPSAnREREIHcgVyBNIEQgZCcuc3BsaXQoJyAnKSxcbiAgICAgICAgcGFkZGVkVG9rZW5zID0gJ00gRCBIIGggbSBzIHcgVycuc3BsaXQoJyAnKSxcblxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHtcbiAgICAgICAgICAgIE0gICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTU1NICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNTU1NIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBEREQgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGQgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGQgICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZGQgIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGRkZCA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3ICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWsoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBXICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWsoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWSAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy55ZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWVlZIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCksIHNpZ24gPSB5ID49IDAgPyAnKycgOiAnLSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyBsZWZ0WmVyb0ZpbGwoTWF0aC5hYnMoeSksIDYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnZ2cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCksIDQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdnZ2dnIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy53ZWVrWWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHRyAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpICUgMTAwLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHR0dHIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpLCA0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBHR0dHRyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMuaXNvV2Vla1llYXIoKSwgNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgRSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrZGF5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTUyAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodG9JbnQodGhpcy5taWxsaXNlY29uZHMoKSAvIDEwKSwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1NTICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNTU1MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLm1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBaICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gLXRoaXMuem9uZSgpLFxuICAgICAgICAgICAgICAgICAgICBiID0gXCIrXCI7XG4gICAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IFwiLVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGxlZnRaZXJvRmlsbCh0b0ludChhIC8gNjApLCAyKSArIFwiOlwiICsgbGVmdFplcm9GaWxsKHRvSW50KGEpICUgNjAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFpaICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBcIitcIjtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICBiID0gXCItXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiICsgbGVmdFplcm9GaWxsKHRvSW50KGEgLyA2MCksIDIpICsgbGVmdFplcm9GaWxsKHRvSW50KGEpICUgNjAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHogOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9uZUFiYnIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6eiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56b25lTmFtZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5peCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFEgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVhcnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RzID0gWydtb250aHMnLCAnbW9udGhzU2hvcnQnLCAnd2Vla2RheXMnLCAnd2Vla2RheXNTaG9ydCcsICd3ZWVrZGF5c01pbiddO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLiBkZmwgY29tZXMgZnJvbVxuICAgIC8vIGRlZmF1bHQuXG4gICAgZnVuY3Rpb24gZGZsKGEsIGIsIGMpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBhICE9IG51bGwgPyBhIDogYjtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIGEgIT0gbnVsbCA/IGEgOiBiICE9IG51bGwgPyBiIDogYztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkltcGxlbWVudCBtZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdCwgYW5kIGVzNSBzdGFuZGFyZCBpcyBub3QgdmVyeVxuICAgICAgICAvLyBoZWxwZnVsLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93IDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgICAgICBmdW5jdGlvbiBwcmludE1zZygpIHtcbiAgICAgICAgICAgIGlmIChtb21lbnQuc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRpb24gd2FybmluZzogXCIgKyBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHByaW50TXNnKCk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRva2VuKGZ1bmMsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbChmdW5jLmNhbGwodGhpcywgYSksIGNvdW50KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3JkaW5hbGl6ZVRva2VuKGZ1bmMsIHBlcmlvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmcoKS5vcmRpbmFsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgcGVyaW9kKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB3aGlsZSAob3JkaW5hbGl6ZVRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaSA9IG9yZGluYWxpemVUb2tlbnMucG9wKCk7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW2kgKyAnbyddID0gb3JkaW5hbGl6ZVRva2VuKGZvcm1hdFRva2VuRnVuY3Rpb25zW2ldLCBpKTtcbiAgICB9XG4gICAgd2hpbGUgKHBhZGRlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaSA9IHBhZGRlZFRva2Vucy5wb3AoKTtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbaSArIGldID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbaV0sIDIpO1xuICAgIH1cbiAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucy5EREREID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnMuRERELCAzKTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdHJ1Y3RvcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBMYW5ndWFnZSgpIHtcblxuICAgIH1cblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8vIER1cmF0aW9uIENvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAzNmU1OyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZU9mXCIpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZU1vbWVudChtKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fSwgaTtcbiAgICAgICAgZm9yIChpIGluIG0pIHtcbiAgICAgICAgICAgIGlmIChtLmhhc093blByb3BlcnR5KGkpICYmIG1vbWVudFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBtW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsZWZ0IHplcm8gZmlsbCBhIG51bWJlclxuICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9sZWZ0LXplcm8tZmlsbGluZyBmb3IgcGVyZm9ybWFuY2UgY29tcGFyaXNvblxuICAgIGZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG5cbiAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArIG91dHB1dDtcbiAgICB9XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIF8uYWRkVGltZSBhbmQgXy5zdWJ0cmFjdFRpbWVcbiAgICBmdW5jdGlvbiBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgcmF3U2V0dGVyKG1vbSwgJ0RhdGUnLCByYXdHZXR0ZXIobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICByYXdNb250aFNldHRlcihtb20sIHJhd0dldHRlcihtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBpcyBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nIHx8XG4gICAgICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgbG93ZXJlZCA9IHVuaXRzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKC4pcyQvLCAnJDEnKTtcbiAgICAgICAgICAgIHVuaXRzID0gdW5pdEFsaWFzZXNbdW5pdHNdIHx8IGNhbWVsRnVuY3Rpb25zW2xvd2VyZWRdIHx8IGxvd2VyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMaXN0KGZpZWxkKSB7XG4gICAgICAgIHZhciBjb3VudCwgc2V0dGVyO1xuXG4gICAgICAgIGlmIChmaWVsZC5pbmRleE9mKCd3ZWVrJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gNztcbiAgICAgICAgICAgIHNldHRlciA9ICdkYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLmluZGV4T2YoJ21vbnRoJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gMTI7XG4gICAgICAgICAgICBzZXR0ZXIgPSAnbW9udGgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9tZW50W2ZpZWxkXSA9IGZ1bmN0aW9uIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaSwgZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG1vbWVudC5mbi5fbGFuZ1tmaWVsZF0sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBtb21lbnQoKS51dGMoKS5zZXQoc2V0dGVyLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwobW9tZW50LmZuLl9sYW5nLCBtLCBmb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXR0ZXIoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VkTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5jZWlsKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tZW50KFt5ZWFyLCAxMSwgMzEgKyBkb3cgLSBkb3ldKSwgZG93LCBkb3kpLndlZWs7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgaWYgKG0uX2EgJiYgbS5fcGYub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgbS5fYVtNT05USF0gPCAwIHx8IG0uX2FbTU9OVEhdID4gMTEgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgbS5fYVtEQVRFXSA8IDEgfHwgbS5fYVtEQVRFXSA+IGRheXNJbk1vbnRoKG0uX2FbWUVBUl0sIG0uX2FbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIG0uX2FbSE9VUl0gPCAwIHx8IG0uX2FbSE9VUl0gPiAyMyA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIG0uX2FbTUlOVVRFXSA8IDAgfHwgbS5fYVtNSU5VVEVdID4gNTkgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIG0uX2FbU0VDT05EXSA8IDAgfHwgbS5fYVtTRUNPTkRdID4gNTkgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIG0uX2FbTUlMTElTRUNPTkRdIDwgMCB8fCBtLl9hW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKG0uX3BmLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG0uX3BmLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBtLl9wZi5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLnVzZXJJbnZhbGlkYXRlZDtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBtLl9pc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIG0uX3BmLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMYW5ndWFnZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gbWFrZUFzKGlucHV0LCBtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuX2lzVVRDID8gbW9tZW50KGlucHV0KS56b25lKG1vZGVsLl9vZmZzZXQgfHwgMCkgOlxuICAgICAgICAgICAgbW9tZW50KGlucHV0KS5sb2NhbCgpO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgTGFuZ3VhZ2VzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBleHRlbmQoTGFuZ3VhZ2UucHJvdG90eXBlLCB7XG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9tb250aHMgOiBcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIiksXG4gICAgICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzW20ubW9udGgoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21vbnRoc1Nob3J0IDogXCJKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlY1wiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW9udGhzUGFyc2UgOiBmdW5jdGlvbiAobW9udGhOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBtb20gPSBtb21lbnQudXRjKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWtkYXlzIDogXCJTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheVwiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgd2Vla2RheXMgOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrZGF5c1Nob3J0IDogXCJTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXRcIi5zcGxpdChcIl9cIiksXG4gICAgICAgIHdlZWtkYXlzU2hvcnQgOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWtkYXlzTWluIDogXCJTdV9Nb19UdV9XZV9UaF9Gcl9TYVwiLnNwbGl0KFwiX1wiKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtkYXlzUGFyc2UgOiBmdW5jdGlvbiAod2Vla2RheU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9tID0gbW9tZW50KFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9sb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUIDogXCJoOm1tIEFcIixcbiAgICAgICAgICAgIEwgOiBcIk1NL0REL1lZWVlcIixcbiAgICAgICAgICAgIExMIDogXCJNTU1NIEQgWVlZWVwiLFxuICAgICAgICAgICAgTExMIDogXCJNTU1NIEQgWVlZWSBMVFwiLFxuICAgICAgICAgICAgTExMTCA6IFwiZGRkZCwgTU1NTSBEIFlZWVkgTFRcIlxuICAgICAgICB9LFxuICAgICAgICBsb25nRGF0ZUZvcm1hdCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgICAgICAgICAgaWYgKCFvdXRwdXQgJiYgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbWVyaWRpZW1QYXJzZSA6IC9bYXBdXFwuP20/XFwuPy9pLFxuICAgICAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9jYWxlbmRhciA6IHtcbiAgICAgICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgICAgICB9LFxuICAgICAgICBjYWxlbmRhciA6IGZ1bmN0aW9uIChrZXksIG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG91dHB1dC5hcHBseShtb20pIDogb3V0cHV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgICAgICBmdXR1cmUgOiBcImluICVzXCIsXG4gICAgICAgICAgICBwYXN0IDogXCIlcyBhZ29cIixcbiAgICAgICAgICAgIHMgOiBcImEgZmV3IHNlY29uZHNcIixcbiAgICAgICAgICAgIG0gOiBcImEgbWludXRlXCIsXG4gICAgICAgICAgICBtbSA6IFwiJWQgbWludXRlc1wiLFxuICAgICAgICAgICAgaCA6IFwiYW4gaG91clwiLFxuICAgICAgICAgICAgaGggOiBcIiVkIGhvdXJzXCIsXG4gICAgICAgICAgICBkIDogXCJhIGRheVwiLFxuICAgICAgICAgICAgZGQgOiBcIiVkIGRheXNcIixcbiAgICAgICAgICAgIE0gOiBcImEgbW9udGhcIixcbiAgICAgICAgICAgIE1NIDogXCIlZCBtb250aHNcIixcbiAgICAgICAgICAgIHkgOiBcImEgeWVhclwiLFxuICAgICAgICAgICAgeXkgOiBcIiVkIHllYXJzXCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVsYXRpdmVUaW1lIDogZnVuY3Rpb24gKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSA/XG4gICAgICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgICAgICB9LFxuICAgICAgICBwYXN0RnV0dXJlIDogZnVuY3Rpb24gKGRpZmYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZShcIiVkXCIsIG51bWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIF9vcmRpbmFsIDogXCIlZFwiLFxuXG4gICAgICAgIHByZXBhcnNlIDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfSxcblxuICAgICAgICBwb3N0Zm9ybWF0IDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrIDogZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfSxcblxuICAgICAgICBfaW52YWxpZERhdGU6ICdJbnZhbGlkIGRhdGUnLFxuICAgICAgICBpbnZhbGlkRGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMb2FkcyBhIGxhbmd1YWdlIGRlZmluaXRpb24gaW50byB0aGUgYGxhbmd1YWdlc2AgY2FjaGUuICBUaGUgZnVuY3Rpb25cbiAgICAvLyB0YWtlcyBhIGtleSBhbmQgb3B0aW9uYWxseSB2YWx1ZXMuICBJZiBub3QgaW4gdGhlIGJyb3dzZXIgYW5kIG5vIHZhbHVlc1xuICAgIC8vIGFyZSBwcm92aWRlZCwgaXQgd2lsbCBsb2FkIHRoZSBsYW5ndWFnZSBmaWxlIG1vZHVsZS4gIEFzIGEgY29udmVuaWVuY2UsXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIHJldHVybnMgdGhlIGxhbmd1YWdlIHZhbHVlcy5cbiAgICBmdW5jdGlvbiBsb2FkTGFuZyhrZXksIHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuYWJiciA9IGtleTtcbiAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgbGFuZ3VhZ2VzW2tleV0gPSBuZXcgTGFuZ3VhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsYW5ndWFnZXNba2V5XS5zZXQodmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trZXldO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhIGxhbmd1YWdlIGZyb20gdGhlIGBsYW5ndWFnZXNgIGNhY2hlLiBNb3N0bHkgdXNlZnVsIGluIHRlc3RzLlxuICAgIGZ1bmN0aW9uIHVubG9hZExhbmcoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBsYW5ndWFnZXNba2V5XTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmVzIHdoaWNoIGxhbmd1YWdlIGRlZmluaXRpb24gdG8gdXNlIGFuZCByZXR1cm5zIGl0LlxuICAgIC8vXG4gICAgLy8gV2l0aCBubyBwYXJhbWV0ZXJzLCBpdCB3aWxsIHJldHVybiB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWYgeW91XG4gICAgLy8gcGFzcyBpbiBhIGxhbmd1YWdlIGtleSwgc3VjaCBhcyAnZW4nLCBpdCB3aWxsIHJldHVybiB0aGVcbiAgICAvLyBkZWZpbml0aW9uIGZvciAnZW4nLCBzbyBsb25nIGFzICdlbicgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgdXNpbmdcbiAgICAvLyBtb21lbnQubGFuZy5cbiAgICBmdW5jdGlvbiBnZXRMYW5nRGVmaW5pdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBsYW5nLCBuZXh0LCBzcGxpdCxcbiAgICAgICAgICAgIGdldCA9IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYW5ndWFnZXNba10gJiYgaGFzTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xhbmcvJyArIGspO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZm4uX2xhbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbGFuZyA9IGdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGxhbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9waWNrIHRoZSBsYW5ndWFnZSBmcm9tIHRoZSBhcnJheVxuICAgICAgICAvL3RyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgICAgIC8vc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgICAgICB3aGlsZSAoaSA8IGtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTGFuZ3VhZ2Uoa2V5W2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMYW5ndWFnZShrZXlbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxhbmcgPSBnZXQoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5fbGFuZztcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZvcm1hdHRpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csIFwiXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuXG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxhbmcoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sYW5nKCkpO1xuXG4gICAgICAgIGlmICghZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbGFuZykge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZy5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFBhcnNpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIGdldCB0aGUgcmVnZXggdG8gZmluZCB0aGUgbmV4dCB0b2tlblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIHZhciBhLCBzdHJpY3QgPSBjb25maWcuX3N0cmljdDtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lRGlnaXQ7XG4gICAgICAgIGNhc2UgJ0REREQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSAnWVlZWSc6XG4gICAgICAgIGNhc2UgJ0dHR0cnOlxuICAgICAgICBjYXNlICdnZ2dnJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuRm91ckRpZ2l0cyA6IHBhcnNlVG9rZW5PbmVUb0ZvdXJEaWdpdHM7XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblNpZ25lZE51bWJlcjtcbiAgICAgICAgY2FzZSAnWVlZWVlZJzpcbiAgICAgICAgY2FzZSAnWVlZWVknOlxuICAgICAgICBjYXNlICdHR0dHRyc6XG4gICAgICAgIGNhc2UgJ2dnZ2dnJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuU2l4RGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzO1xuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHsgcmV0dXJuIHBhcnNlVG9rZW5PbmVEaWdpdDsgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdTUyc6XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7IHJldHVybiBwYXJzZVRva2VuVHdvRGlnaXRzOyB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ1NTUyc6XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7IHJldHVybiBwYXJzZVRva2VuVGhyZWVEaWdpdHM7IH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lVG9UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSAnTU1NJzpcbiAgICAgICAgY2FzZSAnTU1NTSc6XG4gICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgY2FzZSAnZGRkJzpcbiAgICAgICAgY2FzZSAnZGRkZCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbldvcmQ7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJldHVybiBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLl9tZXJpZGllbVBhcnNlO1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXN0YW1wTXM7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICBjYXNlICdaWic6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRpbWV6b25lO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVDtcbiAgICAgICAgY2FzZSAnU1NTUyc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbkRpZ2l0cztcbiAgICAgICAgY2FzZSAnTU0nOlxuICAgICAgICBjYXNlICdERCc6XG4gICAgICAgIGNhc2UgJ1lZJzpcbiAgICAgICAgY2FzZSAnR0cnOlxuICAgICAgICBjYXNlICdnZyc6XG4gICAgICAgIGNhc2UgJ0hIJzpcbiAgICAgICAgY2FzZSAnaGgnOlxuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgY2FzZSAnd3cnOlxuICAgICAgICBjYXNlICdXVyc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gcGFyc2VUb2tlblR3b0RpZ2l0cyA6IHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cztcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cztcbiAgICAgICAgY2FzZSAnRG8nOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PcmRpbmFsO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIGEgPSBuZXcgUmVnRXhwKHJlZ2V4cEVzY2FwZSh1bmVzY2FwZUZvcm1hdCh0b2tlbi5yZXBsYWNlKCdcXFxcJywgJycpKSwgXCJpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nIHx8IFwiXCI7XG4gICAgICAgIHZhciBwb3NzaWJsZVR6TWF0Y2hlcyA9IChzdHJpbmcubWF0Y2gocGFyc2VUb2tlblRpbWV6b25lKSB8fCBbXSksXG4gICAgICAgICAgICB0ekNodW5rID0gcG9zc2libGVUek1hdGNoZXNbcG9zc2libGVUek1hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW10sXG4gICAgICAgICAgICBwYXJ0cyA9ICh0ekNodW5rICsgJycpLm1hdGNoKHBhcnNlVGltZXpvbmVDaHVua2VyKSB8fCBbJy0nLCAwLCAwXSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gLW1pbnV0ZXMgOiBtaW51dGVzO1xuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgc3RyaW5nIGlucHV0IHRvIGRhdGVcbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICB2YXIgYSwgZGF0ZVBhcnRBcnJheSA9IGNvbmZpZy5fYTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIFFVQVJURVJcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNT05USFxuICAgICAgICBjYXNlICdNJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBNTVxuICAgICAgICBjYXNlICdNTScgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTU1NJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBNTU1NXG4gICAgICAgIGNhc2UgJ01NTU0nIDpcbiAgICAgICAgICAgIGEgPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLm1vbnRoc1BhcnNlKGlucHV0KTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEQVkgT0YgTU9OVEhcbiAgICAgICAgY2FzZSAnRCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gRERcbiAgICAgICAgY2FzZSAnREQnIDpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtEQVRFXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdEbycgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQocGFyc2VJbnQoaW5wdXQsIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gREFZIE9GIFlFQVJcbiAgICAgICAgY2FzZSAnREREJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBEREREXG4gICAgICAgIGNhc2UgJ0REREQnIDpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBZRUFSXG4gICAgICAgIGNhc2UgJ1lZJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gbW9tZW50LnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdZWVlZJyA6XG4gICAgICAgIGNhc2UgJ1lZWVlZJyA6XG4gICAgICAgIGNhc2UgJ1lZWVlZWScgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtZRUFSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBTSAvIFBNXG4gICAgICAgIGNhc2UgJ2EnIDogLy8gZmFsbCB0aHJvdWdoIHRvIEFcbiAgICAgICAgY2FzZSAnQScgOlxuICAgICAgICAgICAgY29uZmlnLl9pc1BtID0gZ2V0TGFuZ0RlZmluaXRpb24oY29uZmlnLl9sKS5pc1BNKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyAyNCBIT1VSXG4gICAgICAgIGNhc2UgJ0gnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ0hIJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBoaFxuICAgICAgICBjYXNlICdoJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBoaFxuICAgICAgICBjYXNlICdoaCcgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNSU5VVEVcbiAgICAgICAgY2FzZSAnbScgOiAvLyBmYWxsIHRocm91Z2ggdG8gbW1cbiAgICAgICAgY2FzZSAnbW0nIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUNPTkRcbiAgICAgICAgY2FzZSAncycgOiAvLyBmYWxsIHRocm91Z2ggdG8gc3NcbiAgICAgICAgY2FzZSAnc3MnIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNSUxMSVNFQ09ORFxuICAgICAgICBjYXNlICdTJyA6XG4gICAgICAgIGNhc2UgJ1NTJyA6XG4gICAgICAgIGNhc2UgJ1NTUycgOlxuICAgICAgICBjYXNlICdTU1NTJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVU5JWCBUSU1FU1RBTVAgV0lUSCBNU1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVElNRVpPTkVcbiAgICAgICAgY2FzZSAnWicgOiAvLyBmYWxsIHRocm91Z2ggdG8gWlpcbiAgICAgICAgY2FzZSAnWlonIDpcbiAgICAgICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gV0VFS0RBWSAtIGh1bWFuXG4gICAgICAgIGNhc2UgJ2RkJzpcbiAgICAgICAgY2FzZSAnZGRkJzpcbiAgICAgICAgY2FzZSAnZGRkZCc6XG4gICAgICAgICAgICBhID0gZ2V0TGFuZ0RlZmluaXRpb24oY29uZmlnLl9sKS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25maWcuX3dbJ2QnXSA9IGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBXRUVLLCBXRUVLIERBWSAtIG51bWVyaWNcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ3d3JzpcbiAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgIGNhc2UgJ1dXJzpcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdnZ2dnJzpcbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fd1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ2cnOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjb25maWcuX3dbdG9rZW5dID0gbW9tZW50LnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgbGFuZztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRmbCh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobW9tZW50KCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRmbCh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRmbCh3LkUsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFuZyA9IGdldExhbmdEZWZpbml0aW9uKGNvbmZpZy5fbCk7XG4gICAgICAgICAgICBkb3cgPSBsYW5nLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGxhbmcuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRmbCh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobW9tZW50KCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZmwody53LCAxKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IGRvdykge1xuICAgICAgICAgICAgICAgICAgICArK3dlZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xuXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGRhdGVGcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRmbChjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gbWFrZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBtYWtlVVRDRGF0ZSA6IG1ha2VEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHpvbmUgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpICsgY29uZmlnLl90em0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQ7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gW1xuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnllYXIsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQubW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuZGF5LFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LmhvdXIsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQubWludXRlLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnNlY29uZCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZFxuICAgICAgICBdO1xuXG4gICAgICAgIGRhdGVGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRGF0ZSgpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcblxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBtb21lbnQuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIHBhcnNlSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgY29uZmlnLl9wZi5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIGxhbmcgPSBnZXRMYW5nRGVmaW5pdGlvbihjb25maWcuX2wpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBsYW5nKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGNvbmZpZy5fcGYuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgYW0gcG1cbiAgICAgICAgaWYgKGNvbmZpZy5faXNQbSAmJiBjb25maWcuX2FbSE9VUl0gPCAxMikge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGlzIDEyIGFtLCBjaGFuZ2UgaG91cnMgdG8gMFxuICAgICAgICBpZiAoY29uZmlnLl9pc1BtID09PSBmYWxzZSAmJiBjb25maWcuX2FbSE9VUl0gPT09IDEyKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHJlZ2V4cEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gZXh0ZW5kKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgdGVtcENvbmZpZy5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSB0ZW1wQ29uZmlnLl9wZi5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBDb25maWcuX3BmLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgdGVtcENvbmZpZy5fcGYuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gcGFyc2VJU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBpc29SZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFs1XSBzaG91bGQgYmUgXCJUXCIgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGlzb0RhdGVzW2ldWzBdICsgKG1hdGNoWzZdIHx8IFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mICs9IGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKHBhcnNlVG9rZW5UaW1lem9uZSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gXCJaXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHBhcnNlSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgbW9tZW50LmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGlucHV0KTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IGlucHV0LnNsaWNlKDApO1xuICAgICAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRlRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9tZW50LmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIGRvZXNuJ3QgYWNjZXB0IHllYXJzIDwgMTk3MFxuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVVUQ0RhdGUoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsYW5ndWFnZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGxhbmd1YWdlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBSZWxhdGl2ZSBUaW1lXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbGFuZykge1xuICAgICAgICByZXR1cm4gbGFuZy5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG1pbGxpc2Vjb25kcywgd2l0aG91dFN1ZmZpeCwgbGFuZykge1xuICAgICAgICB2YXIgc2Vjb25kcyA9IHJvdW5kKE1hdGguYWJzKG1pbGxpc2Vjb25kcykgLyAxMDAwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChzZWNvbmRzIC8gNjApLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChtaW51dGVzIC8gNjApLFxuICAgICAgICAgICAgZGF5cyA9IHJvdW5kKGhvdXJzIC8gMjQpLFxuICAgICAgICAgICAgeWVhcnMgPSByb3VuZChkYXlzIC8gMzY1KSxcbiAgICAgICAgICAgIGFyZ3MgPSBzZWNvbmRzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5zICAmJiBbJ3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgJiYgWydtJ10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzID09PSAxICYmIFsnaCddIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPT09IDEgJiYgWydkJ10gfHxcbiAgICAgICAgICAgICAgICBkYXlzIDw9IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuZGQgJiYgWydkZCcsIGRheXNdIHx8XG4gICAgICAgICAgICAgICAgZGF5cyA8PSByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLmRtICYmIFsnTSddIHx8XG4gICAgICAgICAgICAgICAgZGF5cyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuZHkgJiYgWydNTScsIHJvdW5kKGRheXMgLyAzMCldIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgPT09IDEgJiYgWyd5J10gfHwgWyd5eScsIHllYXJzXTtcbiAgICAgICAgYXJnc1syXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFyZ3NbM10gPSBtaWxsaXNlY29uZHMgPiAwO1xuICAgICAgICBhcmdzWzRdID0gbGFuZztcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KHt9LCBhcmdzKTtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgV2VlayBvZiBZZWFyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IG1vbWVudChtb20pLmFkZCgnZCcsIGRheXNUb0RheU9mV2Vlayk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgdmFyIGQgPSBtYWtlVVRDRGF0ZSh5ZWFyLCAwLCAxKS5nZXRVVENEYXkoKSwgZGF5c1RvQWRkLCBkYXlPZlllYXI7XG5cbiAgICAgICAgZCA9IGQgPT09IDAgPyA3IDogZDtcbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcbiAgICAgICAgZGF5c1RvQWRkID0gZmlyc3REYXlPZldlZWsgLSBkICsgKGQgPiBmaXJzdERheU9mV2Vla09mWWVhciA/IDcgOiAwKSAtIChkIDwgZmlyc3REYXlPZldlZWsgPyA3IDogMCk7XG4gICAgICAgIGRheU9mWWVhciA9IDcgKiAod2VlayAtIDEpICsgKHdlZWtkYXkgLSBmaXJzdERheU9mV2VlaykgKyBkYXlzVG9BZGQgKyAxO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiBkYXlPZlllYXIgPiAwID8geWVhciA6IHllYXIgLSAxLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiBkYXlPZlllYXIgPiAwID8gIGRheU9mWWVhciA6IGRheXNJblllYXIoeWVhciAtIDEpICsgZGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBUb3AgTGV2ZWwgRnVuY3Rpb25zXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbWFrZU1vbWVudChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5pbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGdldExhbmdEZWZpbml0aW9uKCkucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNsb25lTW9tZW50KGlucHV0KTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK2lucHV0Ll9kKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjb25maWcpO1xuICAgIH1cblxuICAgIG1vbWVudCA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYW5nKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxhbmc7XG4gICAgICAgICAgICBsYW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjID0ge307XG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fbCA9IGxhbmc7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYy5faXNVVEMgPSBmYWxzZTtcbiAgICAgICAgYy5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG5cbiAgICAgICAgcmV0dXJuIG1ha2VNb21lbnQoYyk7XG4gICAgfTtcblxuICAgIG1vbWVudC5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcblxuICAgIG1vbWVudC5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgIFwibW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgXCIgK1xuICAgICAgICAgICAgXCJkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yIFwiICtcbiAgICAgICAgICAgIFwicmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvIFwiICtcbiAgICAgICAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pKTtcbiAgICB9KTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG1vbWVudC5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfTtcblxuICAgIG1vbWVudC5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRpbmcgd2l0aCB1dGNcbiAgICBtb21lbnQudXRjID0gZnVuY3Rpb24gKGlucHV0LCBmb3JtYXQsIGxhbmcsIHN0cmljdCkge1xuICAgICAgICB2YXIgYztcblxuICAgICAgICBpZiAodHlwZW9mKGxhbmcpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc3RyaWN0ID0gbGFuZztcbiAgICAgICAgICAgIGxhbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMgPSB7fTtcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgYy5faXNVVEMgPSB0cnVlO1xuICAgICAgICBjLl9sID0gbGFuZztcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGMuX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuXG4gICAgICAgIHJldHVybiBtYWtlTW9tZW50KGMpLnV0YygpO1xuICAgIH07XG5cbiAgICAvLyBjcmVhdGluZyB3aXRoIHVuaXggdGltZXN0YW1wIChpbiBzZWNvbmRzKVxuICAgIG1vbWVudC51bml4ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBtb21lbnQoaW5wdXQgKiAxMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gZHVyYXRpb25cbiAgICBtb21lbnQuZHVyYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgcGFyc2VJc287XG5cbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXM6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTTogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRUaW1lU3Bhbkpzb25SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09IFwiLVwiKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KG1hdGNoW01JTExJU0VDT05EXSkgKiBzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvRHVyYXRpb25SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09IFwiLVwiKSA/IC0xIDogMTtcbiAgICAgICAgICAgIHBhcnNlSXNvID0gZnVuY3Rpb24gKGlucCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgICAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgICAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdKSxcbiAgICAgICAgICAgICAgICBkOiBwYXJzZUlzbyhtYXRjaFs0XSksXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJc28obWF0Y2hbNV0pLFxuICAgICAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzZdKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUlzbyhtYXRjaFs3XSksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbOF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24oaW5wdXQpICYmIGlucHV0Lmhhc093blByb3BlcnR5KCdfbGFuZycpKSB7XG4gICAgICAgICAgICByZXQuX2xhbmcgPSBpbnB1dC5fbGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbW9tZW50LnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gZGVmYXVsdCBmb3JtYXRcbiAgICBtb21lbnQuZGVmYXVsdEZvcm1hdCA9IGlzb0Zvcm1hdDtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBtb21lbnQuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIG1vbWVudC5tb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50UHJvcGVydGllcztcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBtb21lbnQudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBtb21lbnQucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZnVuY3Rpb24odGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgaWYgKHJlbGF0aXZlVGltZVRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlVGltZVRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxhbmd1YWdlcyBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsYW5ndWFnZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsYW5ndWFnZSBrZXkuXG4gICAgbW9tZW50LmxhbmcgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmZuLl9sYW5nLl9hYmJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGxvYWRMYW5nKG5vcm1hbGl6ZUxhbmd1YWdlKGtleSksIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB1bmxvYWRMYW5nKGtleSk7XG4gICAgICAgICAgICBrZXkgPSAnZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByID0gbW9tZW50LmR1cmF0aW9uLmZuLl9sYW5nID0gbW9tZW50LmZuLl9sYW5nID0gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICAgICAgcmV0dXJuIHIuX2FiYnI7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgbGFuZ3VhZ2UgZGF0YVxuICAgIG1vbWVudC5sYW5nRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xhbmcgJiYga2V5Ll9sYW5nLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xhbmcuX2FiYnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldExhbmdEZWZpbml0aW9uKGtleSk7XG4gICAgfTtcblxuICAgIC8vIGNvbXBhcmUgbW9tZW50IG9iamVjdFxuICAgIG1vbWVudC5pc01vbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fFxuICAgICAgICAgICAgKG9iaiAhPSBudWxsICYmICBvYmouaGFzT3duUHJvcGVydHkoJ19pc0FNb21lbnRPYmplY3QnKSk7XG4gICAgfTtcblxuICAgIC8vIGZvciB0eXBlY2hlY2tpbmcgRHVyYXRpb24gb2JqZWN0c1xuICAgIG1vbWVudC5pc0R1cmF0aW9uID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfTtcblxuICAgIGZvciAoaSA9IGxpc3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1ha2VMaXN0KGxpc3RzW2ldKTtcbiAgICB9XG5cbiAgICBtb21lbnQubm9ybWFsaXplVW5pdHMgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICB9O1xuXG4gICAgbW9tZW50LmludmFsaWQgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBtb21lbnQudXRjKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQobS5fcGYsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0uX3BmLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgbW9tZW50LnBhcnNlWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH07XG5cbiAgICBtb21lbnQucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBNb21lbnQgUHJvdG90eXBlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICBleHRlbmQobW9tZW50LmZuID0gTW9tZW50LnByb3RvdHlwZSwge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLl9kICsgKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5peCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCt0aGlzIC8gMTAwMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxhbmcoJ2VuJykuZm9ybWF0KFwiZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlpcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9EYXRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA/IG5ldyBEYXRlKCt0aGlzKSA6IHRoaXMuX2Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9JU09TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG1vbWVudCh0aGlzKS51dGMoKTtcbiAgICAgICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9BcnJheSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICAgICAgbS5tb250aCgpLFxuICAgICAgICAgICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICAgICAgICAgIG0uaG91cnMoKSxcbiAgICAgICAgICAgICAgICBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgICAgICBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzVmFsaWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0RTVFNoaWZ0ZWQgOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpICYmIGNvbXBhcmVBcnJheXModGhpcy5fYSwgKHRoaXMuX2lzVVRDID8gbW9tZW50LnV0Yyh0aGlzLl9hKSA6IG1vbWVudCh0aGlzLl9hKSkudG9BcnJheSgpKSA+IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzaW5nRmxhZ3MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLl9wZik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52YWxpZEF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGYub3ZlcmZsb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXRjIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9uZSgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2NhbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgbW9tZW50LmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZygpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQgOiBmdW5jdGlvbiAoaW5wdXQsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGR1cjtcbiAgICAgICAgICAgIC8vIHN3aXRjaCBhcmdzIHRvIHN1cHBvcnQgYWRkKCdzJywgMSkgYW5kIGFkZCgxLCAncycpXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpc05hTigrdmFsKSA/ICtpbnB1dCA6ICt2YWwsIGlzTmFOKCt2YWwpID8gdmFsIDogaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKCt2YWwsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkT3JTdWJ0cmFjdER1cmF0aW9uRnJvbU1vbWVudCh0aGlzLCBkdXIsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAoaW5wdXQsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGR1cjtcbiAgICAgICAgICAgIC8vIHN3aXRjaCBhcmdzIHRvIHN1cHBvcnQgc3VidHJhY3QoJ3MnLCAxKSBhbmQgc3VidHJhY3QoMSwgJ3MnKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkdXIgPSBtb21lbnQuZHVyYXRpb24oaXNOYU4oK3ZhbCkgPyAraW5wdXQgOiArdmFsLCBpc05hTigrdmFsKSA/IHZhbCA6IGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbigrdmFsLCBpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpbnB1dCwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQodGhpcywgZHVyLCAtMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaWZmIDogZnVuY3Rpb24gKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSBtYWtlQXMoaW5wdXQsIHRoaXMpLFxuICAgICAgICAgICAgICAgIHpvbmVEaWZmID0gKHRoaXMuem9uZSgpIC0gdGhhdC56b25lKCkpICogNmU0LFxuICAgICAgICAgICAgICAgIGRpZmYsIG91dHB1dDtcblxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgLy8gYXZlcmFnZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhzIGluIHRoZSBnaXZlbiBkYXRlc1xuICAgICAgICAgICAgICAgIGRpZmYgPSAodGhpcy5kYXlzSW5Nb250aCgpICsgdGhhdC5kYXlzSW5Nb250aCgpKSAqIDQzMmU1OyAvLyAyNCAqIDYwICogNjAgKiAxMDAwIC8gMlxuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKCh0aGlzLnllYXIoKSAtIHRoYXQueWVhcigpKSAqIDEyKSArICh0aGlzLm1vbnRoKCkgLSB0aGF0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdCBieSB0YWtpbmcgZGlmZmVyZW5jZSBpbiBkYXlzLCBhdmVyYWdlIG51bWJlciBvZiBkYXlzXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRzdCBpbiB0aGUgZ2l2ZW4gbW9udGhzLlxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAoKHRoaXMgLSBtb21lbnQodGhpcykuc3RhcnRPZignbW9udGgnKSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoYXQgLSBtb21lbnQodGhhdCkuc3RhcnRPZignbW9udGgnKSkpIC8gZGlmZjtcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aXRoIHpvbmVzLCB0byBuZWdhdGUgYWxsIGRzdFxuICAgICAgICAgICAgICAgIG91dHB1dCAtPSAoKHRoaXMuem9uZSgpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ21vbnRoJykuem9uZSgpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhhdC56b25lKCkgLSBtb21lbnQodGhhdCkuc3RhcnRPZignbW9udGgnKS56b25lKCkpKSAqIDZlNCAvIGRpZmY7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gKHRoaXMgLSB0aGF0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkaWZmIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkaWZmIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkaWZmIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkaWZmIC0gem9uZURpZmYpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICAgIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic1JvdW5kKG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnJvbSA6IGZ1bmN0aW9uICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHRoaXMuZGlmZih0aW1lKSkubGFuZyh0aGlzLmxhbmcoKS5fYWJicikuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZyb21Ob3cgOiBmdW5jdGlvbiAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShtb21lbnQoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIHpvbmUnZCBvciBub3QuXG4gICAgICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBtb21lbnQoKSxcbiAgICAgICAgICAgICAgICBzb2QgPSBtYWtlQXMobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5sYW5nKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNMZWFwWWVhciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0RTVCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy56b25lKCkgPCB0aGlzLmNsb25lKCkubW9udGgoMCkuem9uZSgpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKCkgPCB0aGlzLmNsb25lKCkubW9udGgoNSkuem9uZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sYW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh7IGQgOiBpbnB1dCAtIGRheSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb250aCA6IG1ha2VBY2Nlc3NvcignTW9udGgnLCB0cnVlKSxcblxuICAgICAgICBzdGFydE9mOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgICAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZE9mOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKCh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpLCAxKS5zdWJ0cmFjdCgnbXMnLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0FmdGVyOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCc7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSA+ICttb21lbnQoaW5wdXQpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQmVmb3JlOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCc7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSA8ICttb21lbnQoaW5wdXQpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzU2FtZTogZnVuY3Rpb24gKGlucHV0LCB1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSB1bml0cyB8fCAnbXMnO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykgPT09ICttYWtlQXMoaW5wdXQsIHRoaXMpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjogZGVwcmVjYXRlKFxuICAgICAgICAgICAgICAgICBcIm1vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OFwiLFxuICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgIG90aGVyID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICApLFxuXG4gICAgICAgIG1heDogZGVwcmVjYXRlKFxuICAgICAgICAgICAgICAgIFwibW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4XCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgICAgIC8vIGtlZXBUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXQgYWZmZWN0aW5nXG4gICAgICAgIC8vIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3pvbmUoMiwgdHJ1ZSldLS0+IDU6MzE6MjYgKzAyMDBcbiAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3QgaW50IHpvbmUgKzAyMDAsIHNvIHdlXG4gICAgICAgIC8vIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAgICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAgICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgICAgIHpvbmUgOiBmdW5jdGlvbiAoaW5wdXQsIGtlZXBUaW1lKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aW1lem9uZU1pbnV0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3JTdWJ0cmFjdER1cmF0aW9uRnJvbU1vbWVudCh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb21lbnQuZHVyYXRpb24ob2Zmc2V0IC0gaW5wdXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IHRoaXMuX2QuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHpvbmVBYmJyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gXCJVVENcIiA6IFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgem9uZU5hbWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBcIkNvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lXCIgOiBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlWm9uZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUodGhpcy5fdHptKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKHRoaXMuX2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQWxpZ25lZEhvdXJPZmZzZXQgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudChpbnB1dCkuem9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuem9uZSgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF5c0luTW9udGggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF5T2ZZZWFyIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZGF5T2ZZZWFyID0gcm91bmQoKG1vbWVudCh0aGlzKS5zdGFydE9mKCdkYXknKSAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoXCJkXCIsIChpbnB1dCAtIGRheU9mWWVhcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHF1YXJ0ZXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIHRoaXMubGFuZygpLl93ZWVrLmRvdywgdGhpcy5sYW5nKCkuX3dlZWsuZG95KS55ZWFyO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoXCJ5XCIsIChpbnB1dCAtIHllYXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLnllYXI7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZChcInlcIiwgKGlucHV0IC0geWVhcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWsgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrID0gdGhpcy5sYW5nKCkud2Vlayh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKFwiZFwiLCAoaW5wdXQgLSB3ZWVrKSAqIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWsgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoXCJkXCIsIChpbnB1dCAtIHdlZWspICogNyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxhbmcoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKFwiZFwiLCBpbnB1dCAtIHdlZWtkYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWtkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHRoaXMuZGF5KCkgfHwgNyA6IHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gaW5wdXQgOiBpbnB1dCAtIDcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzb1dlZWtzSW5ZZWFyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrc0luWWVhciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMuX2xhbmcuX3dlZWs7XG4gICAgICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbdW5pdHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSWYgcGFzc2VkIGEgbGFuZ3VhZ2Uga2V5LCBpdCB3aWxsIHNldCB0aGUgbGFuZ3VhZ2UgZm9yIHRoaXNcbiAgICAgICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgbGFuZyA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYW5nID0gZ2V0TGFuZ0RlZmluaXRpb24oa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmF3TW9udGhTZXR0ZXIobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIGhlcmUhXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sYW5nKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmF3R2V0dGVyKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmF3U2V0dGVyKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICdNb250aCcpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdNb250aFNldHRlcihtb20sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFjY2Vzc29yKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmF3U2V0dGVyKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd0dldHRlcih0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb21lbnQuZm4ubWlsbGlzZWNvbmQgPSBtb21lbnQuZm4ubWlsbGlzZWNvbmRzID0gbWFrZUFjY2Vzc29yKCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG4gICAgbW9tZW50LmZuLnNlY29uZCA9IG1vbWVudC5mbi5zZWNvbmRzID0gbWFrZUFjY2Vzc29yKCdTZWNvbmRzJywgZmFsc2UpO1xuICAgIG1vbWVudC5mbi5taW51dGUgPSBtb21lbnQuZm4ubWludXRlcyA9IG1ha2VBY2Nlc3NvcignTWludXRlcycsIGZhbHNlKTtcbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIG1vbWVudC5mbi5ob3VyID0gbW9tZW50LmZuLmhvdXJzID0gbWFrZUFjY2Vzc29yKCdIb3VycycsIHRydWUpO1xuICAgIC8vIG1vbWVudC5mbi5tb250aCBpcyBkZWZpbmVkIHNlcGFyYXRlbHlcbiAgICBtb21lbnQuZm4uZGF0ZSA9IG1ha2VBY2Nlc3NvcignRGF0ZScsIHRydWUpO1xuICAgIG1vbWVudC5mbi5kYXRlcyA9IGRlcHJlY2F0ZShcImRhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuXCIsIG1ha2VBY2Nlc3NvcignRGF0ZScsIHRydWUpKTtcbiAgICBtb21lbnQuZm4ueWVhciA9IG1ha2VBY2Nlc3NvcignRnVsbFllYXInLCB0cnVlKTtcbiAgICBtb21lbnQuZm4ueWVhcnMgPSBkZXByZWNhdGUoXCJ5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkLlwiLCBtYWtlQWNjZXNzb3IoJ0Z1bGxZZWFyJywgdHJ1ZSkpO1xuXG4gICAgLy8gYWRkIHBsdXJhbCBtZXRob2RzXG4gICAgbW9tZW50LmZuLmRheXMgPSBtb21lbnQuZm4uZGF5O1xuICAgIG1vbWVudC5mbi5tb250aHMgPSBtb21lbnQuZm4ubW9udGg7XG4gICAgbW9tZW50LmZuLndlZWtzID0gbW9tZW50LmZuLndlZWs7XG4gICAgbW9tZW50LmZuLmlzb1dlZWtzID0gbW9tZW50LmZuLmlzb1dlZWs7XG4gICAgbW9tZW50LmZuLnF1YXJ0ZXJzID0gbW9tZW50LmZuLnF1YXJ0ZXI7XG5cbiAgICAvLyBhZGQgYWxpYXNlZCBmb3JtYXQgbWV0aG9kc1xuICAgIG1vbWVudC5mbi50b0pTT04gPSBtb21lbnQuZm4udG9JU09TdHJpbmc7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIER1cmF0aW9uIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZXh0ZW5kKG1vbWVudC5kdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZSwge1xuXG4gICAgICAgIF9idWJibGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgICAgICBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICAgICAgc2Vjb25kcyA9IGFic1JvdW5kKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgICAgICBtaW51dGVzID0gYWJzUm91bmQoc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICAgICAgaG91cnMgPSBhYnNSb3VuZChtaW51dGVzIC8gNjApO1xuICAgICAgICAgICAgZGF0YS5ob3VycyA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgICAgIGRheXMgKz0gYWJzUm91bmQoaG91cnMgLyAyNCk7XG4gICAgICAgICAgICBkYXRhLmRheXMgPSBkYXlzICUgMzA7XG5cbiAgICAgICAgICAgIG1vbnRocyArPSBhYnNSb3VuZChkYXlzIC8gMzApO1xuICAgICAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHMgJSAxMjtcblxuICAgICAgICAgICAgeWVhcnMgPSBhYnNSb3VuZChtb250aHMgLyAxMik7XG4gICAgICAgICAgICBkYXRhLnllYXJzID0geWVhcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla3MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzUm91bmQodGhpcy5kYXlzKCkgLyA3KTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2O1xuICAgICAgICB9LFxuXG4gICAgICAgIGh1bWFuaXplIDogZnVuY3Rpb24gKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gK3RoaXMsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lKGRpZmZlcmVuY2UsICF3aXRoU3VmZml4LCB0aGlzLmxhbmcoKSk7XG5cbiAgICAgICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5sYW5nKCkucGFzdEZ1dHVyZShkaWZmZXJlbmNlLCBvdXRwdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5nKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQobW9tZW50KVxuICAgICAgICAgICAgdmFyIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpbnB1dCwgdmFsKTtcblxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICs9IGR1ci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgdGhpcy5fZGF5cyArPSBkdXIuX2RheXM7XG4gICAgICAgICAgICB0aGlzLl9tb250aHMgKz0gZHVyLl9tb250aHM7XG5cbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGZ1bmN0aW9uIChpbnB1dCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xuXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgLT0gZHVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgICAgICB0aGlzLl9kYXlzIC09IGR1ci5fZGF5cztcbiAgICAgICAgICAgIHRoaXMuX21vbnRocyAtPSBkdXIuX21vbnRocztcblxuICAgICAgICAgICAgdGhpcy5fYnViYmxlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0cy50b0xvd2VyQ2FzZSgpICsgJ3MnXSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFzIDogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWydhcycgKyB1bml0cy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHVuaXRzLnNsaWNlKDEpICsgJ3MnXSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxhbmcgOiBtb21lbnQuZm4ubGFuZyxcblxuICAgICAgICB0b0lzb1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgICAgICB2YXIgeWVhcnMgPSBNYXRoLmFicyh0aGlzLnllYXJzKCkpLFxuICAgICAgICAgICAgICAgIG1vbnRocyA9IE1hdGguYWJzKHRoaXMubW9udGhzKCkpLFxuICAgICAgICAgICAgICAgIGRheXMgPSBNYXRoLmFicyh0aGlzLmRheXMoKSksXG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLmFicyh0aGlzLmhvdXJzKCkpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyh0aGlzLm1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGguYWJzKHRoaXMuc2Vjb25kcygpICsgdGhpcy5taWxsaXNlY29uZHMoKSAvIDEwMDApO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXNTZWNvbmRzKCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFzU2Vjb25kcygpIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICAgICAoeWVhcnMgPyB5ZWFycyArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKG1vbnRocyA/IG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKGRheXMgPyBkYXlzICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICAgICAoKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgICAgIChob3VycyA/IGhvdXJzICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgICAgICAobWludXRlcyA/IG1pbnV0ZXMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgICAgIChzZWNvbmRzID8gc2Vjb25kcyArICdTJyA6ICcnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWFrZUR1cmF0aW9uR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgbW9tZW50LmR1cmF0aW9uLmZuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUR1cmF0aW9uQXNHZXR0ZXIobmFtZSwgZmFjdG9yKSB7XG4gICAgICAgIG1vbWVudC5kdXJhdGlvbi5mblsnYXMnICsgbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgLyBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpIGluIHVuaXRNaWxsaXNlY29uZEZhY3RvcnMpIHtcbiAgICAgICAgaWYgKHVuaXRNaWxsaXNlY29uZEZhY3RvcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG1ha2VEdXJhdGlvbkFzR2V0dGVyKGksIHVuaXRNaWxsaXNlY29uZEZhY3RvcnNbaV0pO1xuICAgICAgICAgICAgbWFrZUR1cmF0aW9uR2V0dGVyKGkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYWtlRHVyYXRpb25Bc0dldHRlcignV2Vla3MnLCA2MDQ4ZTUpO1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc01vbnRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgrdGhpcyAtIHRoaXMueWVhcnMoKSAqIDMxNTM2ZTYpIC8gMjU5MmU2ICsgdGhpcy55ZWFycygpICogMTI7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEZWZhdWx0IExhbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIFNldCBkZWZhdWx0IGxhbmd1YWdlLCBvdGhlciBsYW5ndWFnZXMgd2lsbCBpbmhlcml0IGZyb20gRW5nbGlzaC5cbiAgICBtb21lbnQubGFuZygnZW4nLCB7XG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiBFTUJFRF9MQU5HVUFHRVMgKi9cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRXhwb3NpbmcgTW9tZW50XG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gbWFrZUdsb2JhbChzaG91bGREZXByZWNhdGUpIHtcbiAgICAgICAgLypnbG9iYWwgZW5kZXI6ZmFsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbGRHbG9iYWxNb21lbnQgPSBnbG9iYWxTY29wZS5tb21lbnQ7XG4gICAgICAgIGlmIChzaG91bGREZXByZWNhdGUpIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlLm1vbWVudCA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICAgICAgICAgXCJBY2Nlc3NpbmcgTW9tZW50IHRocm91Z2ggdGhlIGdsb2JhbCBzY29wZSBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicmVsZWFzZS5cIixcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlLm1vbWVudCA9IG1vbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbW1vbkpTIG1vZHVsZSBpcyBkZWZpbmVkXG4gICAgaWYgKGhhc01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG1vbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcIm1vbWVudFwiLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmNvbmZpZyAmJiBtb2R1bGUuY29uZmlnKCkgJiYgbW9kdWxlLmNvbmZpZygpLm5vR2xvYmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSB0aGUgZ2xvYmFsIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gb2xkR2xvYmFsTW9tZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgbWFrZUdsb2JhbCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYWtlR2xvYmFsKCk7XG4gICAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyAgICAgdXVpZC5qc1xuLy9cbi8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuICAvLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuICB2YXIgX3JuZztcblxuICAvLyBOb2RlLmpzIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vbm9kZWpzLm9yZy9kb2NzL3YwLjYuMi9hcGkvY3J5cHRvLmh0bWxcbiAgLy9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgaWYgKHR5cGVvZihyZXF1aXJlKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmIgPSByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICAgIF9ybmcgPSBfcmIgJiYgZnVuY3Rpb24oKSB7cmV0dXJuIF9yYigxNik7fTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoIV9ybmcgJiYgX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vXG4gICAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgICByZXR1cm4gX3JuZHM4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIV9ybmcpIHtcbiAgICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gICAgLy9cbiAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAgIC8vIHF1YWxpdHkuXG4gICAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9ybmRzO1xuICAgIH07XG4gIH1cblxuICAvLyBCdWZmZXIgY2xhc3MgdG8gdXNlXG4gIHZhciBCdWZmZXJDbGFzcyA9IHR5cGVvZihCdWZmZXIpID09ICdmdW5jdGlvbicgPyBCdWZmZXIgOiBBcnJheTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgICBidWYgPSBidWYgfHwgW107XG4gICAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgICAgaWYgKGlpIDwgMTYpIHsgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICAgIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgICBidWZbaSArIGlpKytdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG4gIGZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IG9mZnNldCB8fCAwLCBidGggPSBfYnl0ZVRvSGV4O1xuICAgIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW1xuICAgIF9zZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbiAgXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsIF9sYXN0TlNlY3MgPSAwO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPSBudWxsID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAgIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gICAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICAgIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICAgIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAgIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICAgIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAgIC8vIHRpbWUgaW50ZXJ2YWxcbiAgICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT0gbnVsbCkge1xuICAgICAgbnNlY3MgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICAgIH1cblxuICAgIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAgIC8vIGB0aW1lX2xvd2BcbiAgICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gICAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9taWRgXG4gICAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICAgIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gICAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gICAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gICAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gICAgLy8gYG5vZGVgXG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgYltpICsgbl0gPSBub2RlW25dO1xuICAgIH1cblxuICAgIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xuICB9XG5cbiAgLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQnVmZmVyQ2xhc3MoMTYpIDogbnVsbDtcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG4gIHV1aWQuQnVmZmVyQ2xhc3MgPSBCdWZmZXJDbGFzcztcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUHVibGlzaCBhcyBBTUQgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge3JldHVybiB1dWlkO30pO1xuICB9IGVsc2UgaWYgKHR5cGVvZihtb2R1bGUpICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gUHVibGlzaCBhcyBub2RlLmpzIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBQdWJsaXNoIGFzIGdsb2JhbCAoaW4gYnJvd3NlcnMpXG4gICAgdmFyIF9wcmV2aW91c1Jvb3QgPSBfZ2xvYmFsLnV1aWQ7XG5cbiAgICAvLyAqKmBub0NvbmZsaWN0KClgIC0gKGJyb3dzZXIgb25seSkgdG8gcmVzZXQgZ2xvYmFsICd1dWlkJyB2YXIqKlxuICAgIHV1aWQubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX2dsb2JhbC51dWlkID0gX3ByZXZpb3VzUm9vdDtcbiAgICAgIHJldHVybiB1dWlkO1xuICAgIH07XG5cbiAgICBfZ2xvYmFsLnV1aWQgPSB1dWlkO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiLyohXG4gICogUmVxd2VzdCEgQSBnZW5lcmFsIHB1cnBvc2UgWEhSIGNvbm5lY3Rpb24gbWFuYWdlclxuICAqIGxpY2Vuc2UgTUlUIChjKSBEdXN0aW4gRGlheiAyMDE0XG4gICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9yZXF3ZXN0XG4gICovXG5cbiFmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0oJ3JlcXdlc3QnLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHdpbiA9IHdpbmRvd1xuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIHR3b0h1bmRvID0gL14oMjBcXGR8MTIyMykkL1xuICAgICwgYnlUYWcgPSAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnXG4gICAgLCByZWFkeVN0YXRlID0gJ3JlYWR5U3RhdGUnXG4gICAgLCBjb250ZW50VHlwZSA9ICdDb250ZW50LVR5cGUnXG4gICAgLCByZXF1ZXN0ZWRXaXRoID0gJ1gtUmVxdWVzdGVkLVdpdGgnXG4gICAgLCBoZWFkID0gZG9jW2J5VGFnXSgnaGVhZCcpWzBdXG4gICAgLCB1bmlxaWQgPSAwXG4gICAgLCBjYWxsYmFja1ByZWZpeCA9ICdyZXF3ZXN0XycgKyAoK25ldyBEYXRlKCkpXG4gICAgLCBsYXN0VmFsdWUgLy8gZGF0YSBzdG9yZWQgYnkgdGhlIG1vc3QgcmVjZW50IEpTT05QIGNhbGxiYWNrXG4gICAgLCB4bWxIdHRwUmVxdWVzdCA9ICdYTUxIdHRwUmVxdWVzdCdcbiAgICAsIHhEb21haW5SZXF1ZXN0ID0gJ1hEb21haW5SZXF1ZXN0J1xuICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbiAgICAsIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gQXJyYXkuaXNBcnJheVxuICAgICAgICA6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgfVxuXG4gICAgLCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICAgICAgICAnY29udGVudFR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAsICdyZXF1ZXN0ZWRXaXRoJzogeG1sSHR0cFJlcXVlc3RcbiAgICAgICAgLCAnYWNjZXB0Jzoge1xuICAgICAgICAgICAgICAnKic6ICAndGV4dC9qYXZhc2NyaXB0LCB0ZXh0L2h0bWwsIGFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwsICovKidcbiAgICAgICAgICAgICwgJ3htbCc6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCdcbiAgICAgICAgICAgICwgJ2h0bWwnOiAndGV4dC9odG1sJ1xuICAgICAgICAgICAgLCAndGV4dCc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgLCAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICAsICdqcyc6ICAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQsIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsIHhociA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgLy8gaXMgaXQgeC1kb21haW5cbiAgICAgICAgaWYgKG9bJ2Nyb3NzT3JpZ2luJ10gPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgeGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbFxuICAgICAgICAgIGlmICh4aHIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyXG4gICAgICAgICAgfSBlbHNlIGlmICh3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2luW3htbEh0dHBSZXF1ZXN0XSkge1xuICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCBnbG9iYWxTZXR1cE9wdGlvbnMgPSB7XG4gICAgICAgIGRhdGFGaWx0ZXI6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlYWR5U3RhdGUociwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdXNlIF9hYm9ydGVkIHRvIG1pdGlnYXRlIGFnYWluc3QgSUUgZXJyIGMwMGMwMjNmXG4gICAgICAvLyAoY2FuJ3QgcmVhZCBwcm9wcyBvbiBhYm9ydGVkIHJlcXVlc3Qgb2JqZWN0cylcbiAgICAgIGlmIChyLl9hYm9ydGVkKSByZXR1cm4gZXJyb3Ioci5yZXF1ZXN0KVxuICAgICAgaWYgKHIucmVxdWVzdCAmJiByLnJlcXVlc3RbcmVhZHlTdGF0ZV0gPT0gNCkge1xuICAgICAgICByLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcFxuICAgICAgICBpZiAodHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSkgc3VjY2VzcyhyLnJlcXVlc3QpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlcnJvcihyLnJlcXVlc3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGVhZGVycyhodHRwLCBvKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBvWydoZWFkZXJzJ10gfHwge31cbiAgICAgICwgaFxuXG4gICAgaGVhZGVyc1snQWNjZXB0J10gPSBoZWFkZXJzWydBY2NlcHQnXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddW29bJ3R5cGUnXV1cbiAgICAgIHx8IGRlZmF1bHRIZWFkZXJzWydhY2NlcHQnXVsnKiddXG5cbiAgICAvLyBicmVha3MgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIHdpdGggbGVnYWN5IGJyb3dzZXJzXG4gICAgaWYgKCFvWydjcm9zc09yaWdpbiddICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnNbJ3JlcXVlc3RlZFdpdGgnXVxuICAgIGlmICghaGVhZGVyc1tjb250ZW50VHlwZV0pIGhlYWRlcnNbY29udGVudFR5cGVdID0gb1snY29udGVudFR5cGUnXSB8fCBkZWZhdWx0SGVhZGVyc1snY29udGVudFR5cGUnXVxuICAgIGZvciAoaCBpbiBoZWFkZXJzKVxuICAgICAgaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoKSAmJiAnc2V0UmVxdWVzdEhlYWRlcicgaW4gaHR0cCAmJiBodHRwLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pIHtcbiAgICBpZiAodHlwZW9mIG9bJ3dpdGhDcmVkZW50aWFscyddICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhb1snd2l0aENyZWRlbnRpYWxzJ11cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2soZGF0YSkge1xuICAgIGxhc3RWYWx1ZSA9IGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHVybGFwcGVuZCAodXJsLCBzKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKSB7XG4gICAgdmFyIHJlcUlkID0gdW5pcWlkKytcbiAgICAgICwgY2JrZXkgPSBvWydqc29ucENhbGxiYWNrJ10gfHwgJ2NhbGxiYWNrJyAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICwgY2J2YWwgPSBvWydqc29ucENhbGxiYWNrTmFtZSddIHx8IHJlcXdlc3QuZ2V0Y2FsbGJhY2tQcmVmaXgocmVxSWQpXG4gICAgICAsIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpXG4gICAgICAsIG1hdGNoID0gdXJsLm1hdGNoKGNicmVnKVxuICAgICAgLCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICwgbG9hZGVkID0gMFxuICAgICAgLCBpc0lFMTAgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgMTAuMCcpICE9PSAtMVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAobWF0Y2hbM10gPT09ICc/Jykge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCkgLy8gd2lsZGNhcmQgY2FsbGJhY2sgZnVuYyBuYW1lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYnZhbCA9IG1hdGNoWzNdIC8vIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBjYmtleSArICc9JyArIGNidmFsKSAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgfVxuXG4gICAgd2luW2NidmFsXSA9IGdlbmVyYWxDYWxsYmFja1xuXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlICE9PSAndW5kZWZpbmVkJyAmJiAhaXNJRTEwKSB7XG4gICAgICAvLyBuZWVkIHRoaXMgZm9yIElFIGR1ZSB0byBvdXQtb2Ytb3JkZXIgb25yZWFkeXN0YXRlY2hhbmdlKCksIGJpbmRpbmcgc2NyaXB0XG4gICAgICAvLyBleGVjdXRpb24gdG8gYW4gZXZlbnQgbGlzdGVuZXIgZ2l2ZXMgdXMgY29udHJvbCBvdmVyIHdoZW4gdGhlIHNjcmlwdFxuICAgICAgLy8gaXMgZXhlY3V0ZWQuIFNlZSBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkID0gJ19yZXF3ZXN0XycgKyByZXFJZFxuICAgIH1cblxuICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKChzY3JpcHRbcmVhZHlTdGF0ZV0gJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnY29tcGxldGUnICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2xvYWRlZCcpIHx8IGxvYWRlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgc2NyaXB0Lm9uY2xpY2sgJiYgc2NyaXB0Lm9uY2xpY2soKVxuICAgICAgLy8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayB3aXRoIHRoZSBsYXN0IHZhbHVlIHN0b3JlZCBhbmQgY2xlYW4gdXAgdmFsdWVzIGFuZCBzY3JpcHRzLlxuICAgICAgZm4obGFzdFZhbHVlKVxuICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICAgIGxvYWRlZCA9IDFcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHNjcmlwdCB0byB0aGUgRE9NIGhlYWRcbiAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcblxuICAgIC8vIEVuYWJsZSBKU09OUCB0aW1lb3V0XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSlcbiAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgICAgICBsb2FkZWQgPSAxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdChmbiwgZXJyKSB7XG4gICAgdmFyIG8gPSB0aGlzLm9cbiAgICAgICwgbWV0aG9kID0gKG9bJ21ldGhvZCddIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG4gICAgICAsIHVybCA9IHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgICAgLy8gY29udmVydCBub24tc3RyaW5nIG9iamVjdHMgdG8gcXVlcnktc3RyaW5nIGZvcm0gdW5sZXNzIG9bJ3Byb2Nlc3NEYXRhJ10gaXMgZmFsc2VcbiAgICAgICwgZGF0YSA9IChvWydwcm9jZXNzRGF0YSddICE9PSBmYWxzZSAmJiBvWydkYXRhJ10gJiYgdHlwZW9mIG9bJ2RhdGEnXSAhPT0gJ3N0cmluZycpXG4gICAgICAgID8gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKG9bJ2RhdGEnXSlcbiAgICAgICAgOiAob1snZGF0YSddIHx8IG51bGwpXG4gICAgICAsIGh0dHBcbiAgICAgICwgc2VuZFdhaXQgPSBmYWxzZVxuXG4gICAgLy8gaWYgd2UncmUgd29ya2luZyBvbiBhIEdFVCByZXF1ZXN0IGFuZCB3ZSBoYXZlIGRhdGEgdGhlbiB3ZSBzaG91bGQgYXBwZW5kXG4gICAgLy8gcXVlcnkgc3RyaW5nIHRvIGVuZCBvZiBVUkwgYW5kIG5vdCBwb3N0IGRhdGFcbiAgICBpZiAoKG9bJ3R5cGUnXSA9PSAnanNvbnAnIHx8IG1ldGhvZCA9PSAnR0VUJykgJiYgZGF0YSkge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgZGF0YSlcbiAgICAgIGRhdGEgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKG9bJ3R5cGUnXSA9PSAnanNvbnAnKSByZXR1cm4gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKVxuXG4gICAgLy8gZ2V0IHRoZSB4aHIgZnJvbSB0aGUgZmFjdG9yeSBpZiBwYXNzZWRcbiAgICAvLyBpZiB0aGUgZmFjdG9yeSByZXR1cm5zIG51bGwsIGZhbGwtYmFjayB0byBvdXJzXG4gICAgaHR0cCA9IChvLnhociAmJiBvLnhocihvKSkgfHwgeGhyKG8pXG5cbiAgICBodHRwLm9wZW4obWV0aG9kLCB1cmwsIG9bJ2FzeW5jJ10gPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKVxuICAgIHNldEhlYWRlcnMoaHR0cCwgbylcbiAgICBzZXRDcmVkZW50aWFscyhodHRwLCBvKVxuICAgIGlmICh3aW5beERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiB3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgIGh0dHAub25sb2FkID0gZm5cbiAgICAgICAgaHR0cC5vbmVycm9yID0gZXJyXG4gICAgICAgIC8vIE5PVEU6IHNlZVxuICAgICAgICAvLyBodHRwOi8vc29jaWFsLm1zZG4ubWljcm9zb2Z0LmNvbS9Gb3J1bXMvZW4tVVMvaWV3ZWJkZXZlbG9wbWVudC90aHJlYWQvMzBlZjNhZGQtNzY3Yy00NDM2LWI4YTktZjFjYTE5YjQ4MTJlXG4gICAgICAgIGh0dHAub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge31cbiAgICAgICAgc2VuZFdhaXQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlUmVhZHlTdGF0ZSh0aGlzLCBmbiwgZXJyKVxuICAgIH1cbiAgICBvWydiZWZvcmUnXSAmJiBvWydiZWZvcmUnXShodHRwKVxuICAgIGlmIChzZW5kV2FpdCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0dHAuc2VuZChkYXRhKVxuICAgICAgfSwgMjAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICB9XG4gICAgcmV0dXJuIGh0dHBcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXdlc3QobywgZm4pIHtcbiAgICB0aGlzLm8gPSBvXG4gICAgdGhpcy5mbiA9IGZuXG5cbiAgICBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFR5cGUoaGVhZGVyKSB7XG4gICAgLy8ganNvbiwgamF2YXNjcmlwdCwgdGV4dC9wbGFpbiwgdGV4dC9odG1sLCB4bWxcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqc29uJykpIHJldHVybiAnanNvbidcbiAgICBpZiAoaGVhZGVyLm1hdGNoKCdqYXZhc2NyaXB0JykpIHJldHVybiAnanMnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgndGV4dCcpKSByZXR1cm4gJ2h0bWwnXG4gICAgaWYgKGhlYWRlci5tYXRjaCgneG1sJykpIHJldHVybiAneG1sJ1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdChvLCBmbikge1xuXG4gICAgdGhpcy51cmwgPSB0eXBlb2YgbyA9PSAnc3RyaW5nJyA/IG8gOiBvWyd1cmwnXVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcblxuICAgIC8vIHdoZXRoZXIgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQgZm9yIHB1cnBvc2VcbiAgICAvLyBvZiB0cmFja2luZyB0aGUgUHJvbWlzZXNcbiAgICB0aGlzLl9mdWxmaWxsZWQgPSBmYWxzZVxuICAgIC8vIHN1Y2Nlc3MgaGFuZGxlcnNcbiAgICB0aGlzLl9zdWNjZXNzSGFuZGxlciA9IGZ1bmN0aW9uKCl7fVxuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMgPSBbXVxuICAgIC8vIGVycm9yIGhhbmRsZXJzXG4gICAgdGhpcy5fZXJyb3JIYW5kbGVycyA9IFtdXG4gICAgLy8gY29tcGxldGUgKGJvdGggc3VjY2VzcyBhbmQgZmFpbCkgaGFuZGxlcnNcbiAgICB0aGlzLl9jb21wbGV0ZUhhbmRsZXJzID0gW11cbiAgICB0aGlzLl9lcnJlZCA9IGZhbHNlXG4gICAgdGhpcy5fcmVzcG9uc2VBcmdzID0ge31cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fVxuXG4gICAgaWYgKG9bJ3RpbWVvdXQnXSkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYWJvcnQoKVxuICAgICAgfSwgb1sndGltZW91dCddKVxuICAgIH1cblxuICAgIGlmIChvWydzdWNjZXNzJ10pIHtcbiAgICAgIHRoaXMuX3N1Y2Nlc3NIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydzdWNjZXNzJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvWydlcnJvciddKSB7XG4gICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBvWydlcnJvciddLmFwcGx5KG8sIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG9bJ2NvbXBsZXRlJ10pIHtcbiAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ2NvbXBsZXRlJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSAocmVzcCkge1xuICAgICAgb1sndGltZW91dCddICYmIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG4gICAgICBzZWxmLnRpbWVvdXQgPSBudWxsXG4gICAgICB3aGlsZSAoc2VsZi5fY29tcGxldGVIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuX2NvbXBsZXRlSGFuZGxlcnMuc2hpZnQoKShyZXNwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1Y2Nlc3MgKHJlc3ApIHtcbiAgICAgIHZhciB0eXBlID0gb1sndHlwZSddIHx8IHNldFR5cGUocmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykpXG4gICAgICByZXNwID0gKHR5cGUgIT09ICdqc29ucCcpID8gc2VsZi5yZXF1ZXN0IDogcmVzcFxuICAgICAgLy8gdXNlIGdsb2JhbCBkYXRhIGZpbHRlciBvbiByZXNwb25zZSB0ZXh0XG4gICAgICB2YXIgZmlsdGVyZWRSZXNwb25zZSA9IGdsb2JhbFNldHVwT3B0aW9ucy5kYXRhRmlsdGVyKHJlc3AucmVzcG9uc2VUZXh0LCB0eXBlKVxuICAgICAgICAsIHIgPSBmaWx0ZXJlZFJlc3BvbnNlXG4gICAgICB0cnkge1xuICAgICAgICByZXNwLnJlc3BvbnNlVGV4dCA9IHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gY2FuJ3QgYXNzaWduIHRoaXMgaW4gSUU8PTgsIGp1c3QgaWdub3JlXG4gICAgICB9XG4gICAgICBpZiAocikge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3AgPSB3aW4uSlNPTiA/IHdpbi5KU09OLnBhcnNlKHIpIDogZXZhbCgnKCcgKyByICsgJyknKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKHJlc3AsICdDb3VsZCBub3QgcGFyc2UgSlNPTiBpbiByZXNwb25zZScsIGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnanMnOlxuICAgICAgICAgIHJlc3AgPSBldmFsKHIpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgcmVzcCA9IHJcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgIHJlc3AgPSByZXNwLnJlc3BvbnNlWE1MXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvciAvLyBJRSB0cm9sb2xvXG4gICAgICAgICAgICAgICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5lcnJvckNvZGVcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLnJlYXNvblxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fZnVsZmlsbGVkID0gdHJ1ZVxuICAgICAgZm4ocmVzcClcbiAgICAgIHNlbGYuX3N1Y2Nlc3NIYW5kbGVyKHJlc3ApXG4gICAgICB3aGlsZSAoc2VsZi5fZnVsZmlsbG1lbnRIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3AgPSBzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLnNoaWZ0KCkocmVzcClcbiAgICAgIH1cblxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihyZXNwLCBtc2csIHQpIHtcbiAgICAgIHJlc3AgPSBzZWxmLnJlcXVlc3RcbiAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLm1zZyA9IG1zZ1xuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnQgPSB0XG4gICAgICBzZWxmLl9lcnJlZCA9IHRydWVcbiAgICAgIHdoaWxlIChzZWxmLl9lcnJvckhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fZXJyb3JIYW5kbGVycy5zaGlmdCgpKHJlc3AsIG1zZywgdClcbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlKHJlc3ApXG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0ID0gZ2V0UmVxdWVzdC5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9yKVxuICB9XG5cbiAgUmVxd2VzdC5wcm90b3R5cGUgPSB7XG4gICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlXG4gICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKVxuICAgIH1cblxuICAsIHJldHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbml0LmNhbGwodGhpcywgdGhpcy5vLCB0aGlzLmZuKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNtYWxsIGRldmlhdGlvbiBmcm9tIHRoZSBQcm9taXNlcyBBIENvbW1vbkpzIHNwZWNpZmljYXRpb25cbiAgICAgKiBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Qcm9taXNlcy9BXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBgdGhlbmAgd2lsbCBleGVjdXRlIHVwb24gc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICAgICAqL1xuICAsIHRoZW46IGZ1bmN0aW9uIChzdWNjZXNzLCBmYWlsKSB7XG4gICAgICBzdWNjZXNzID0gc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgZmFpbCA9IGZhaWwgfHwgZnVuY3Rpb24gKCkge31cbiAgICAgIGlmICh0aGlzLl9mdWxmaWxsZWQpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AgPSBzdWNjZXNzKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmYWlsKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwLCB0aGlzLl9yZXNwb25zZUFyZ3MubXNnLCB0aGlzLl9yZXNwb25zZUFyZ3MudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcnMucHVzaChzdWNjZXNzKVxuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZmFpbClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGFsd2F5c2Agd2lsbCBleGVjdXRlIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc3VjY2VlZHMgb3IgZmFpbHNcbiAgICAgKi9cbiAgLCBhbHdheXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCB8fCB0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlSGFuZGxlcnMucHVzaChmbilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYGZhaWxgIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZSByZXF1ZXN0IGZhaWxzXG4gICAgICovXG4gICwgZmFpbDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZXJyZWQpIHtcbiAgICAgICAgZm4odGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXF3ZXN0KG8sIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIG5ld2xpbmUgdmFyaWFudHMgYWNjb3JkaW5nIHRvIHNwZWMgLT4gQ1JMRlxuICBmdW5jdGlvbiBub3JtYWxpemUocykge1xuICAgIHJldHVybiBzID8gcy5yZXBsYWNlKC9cXHI/XFxuL2csICdcXHJcXG4nKSA6ICcnXG4gIH1cblxuICBmdW5jdGlvbiBzZXJpYWwoZWwsIGNiKSB7XG4gICAgdmFyIG4gPSBlbC5uYW1lXG4gICAgICAsIHQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICwgb3B0Q2IgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgIC8vIElFIGdpdmVzIHZhbHVlPVwiXCIgZXZlbiB3aGVyZSB0aGVyZSBpcyBubyB2YWx1ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAvLyAnc3BlY2lmaWVkJyByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUNvcmUvY29yZS5odG1sI0lELTg2MjUyOTI3M1xuICAgICAgICAgIGlmIChvICYmICFvWydkaXNhYmxlZCddKVxuICAgICAgICAgICAgY2Iobiwgbm9ybWFsaXplKG9bJ2F0dHJpYnV0ZXMnXVsndmFsdWUnXSAmJiBvWydhdHRyaWJ1dGVzJ11bJ3ZhbHVlJ11bJ3NwZWNpZmllZCddID8gb1sndmFsdWUnXSA6IG9bJ3RleHQnXSkpXG4gICAgICAgIH1cbiAgICAgICwgY2gsIHJhLCB2YWwsIGlcblxuICAgIC8vIGRvbid0IHNlcmlhbGl6ZSBlbGVtZW50cyB0aGF0IGFyZSBkaXNhYmxlZCBvciB3aXRob3V0IGEgbmFtZVxuICAgIGlmIChlbC5kaXNhYmxlZCB8fCAhbikgcmV0dXJuXG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpZiAoIS9yZXNldHxidXR0b258aW1hZ2V8ZmlsZS9pLnRlc3QoZWwudHlwZSkpIHtcbiAgICAgICAgY2ggPSAvY2hlY2tib3gvaS50ZXN0KGVsLnR5cGUpXG4gICAgICAgIHJhID0gL3JhZGlvL2kudGVzdChlbC50eXBlKVxuICAgICAgICB2YWwgPSBlbC52YWx1ZVxuICAgICAgICAvLyBXZWJLaXQgZ2l2ZXMgdXMgXCJcIiBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIGNoZWNrYm94IGhhcyBubyB2YWx1ZSwgc28gY29ycmVjdCBpdCBoZXJlXG4gICAgICAgIDsoIShjaCB8fCByYSkgfHwgZWwuY2hlY2tlZCkgJiYgY2Iobiwgbm9ybWFsaXplKGNoICYmIHZhbCA9PT0gJycgPyAnb24nIDogdmFsKSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgY2Iobiwgbm9ybWFsaXplKGVsLnZhbHVlKSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGlmIChlbC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3Qtb25lJykge1xuICAgICAgICBvcHRDYihlbC5zZWxlY3RlZEluZGV4ID49IDAgPyBlbC5vcHRpb25zW2VsLnNlbGVjdGVkSW5kZXhdIDogbnVsbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGVsLmxlbmd0aCAmJiBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbC5vcHRpb25zW2ldLnNlbGVjdGVkICYmIG9wdENiKGVsLm9wdGlvbnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gY29sbGVjdCB1cCBhbGwgZm9ybSBlbGVtZW50cyBmb3VuZCBmcm9tIHRoZSBwYXNzZWQgYXJndW1lbnQgZWxlbWVudHMgYWxsXG4gIC8vIHRoZSB3YXkgZG93biB0byBjaGlsZCBlbGVtZW50czsgcGFzcyBhICc8Zm9ybT4nIG9yIGZvcm0gZmllbGRzLlxuICAvLyBjYWxsZWQgd2l0aCAndGhpcyc9Y2FsbGJhY2sgdG8gdXNlIGZvciBzZXJpYWwoKSBvbiBlYWNoIGVsZW1lbnRcbiAgZnVuY3Rpb24gZWFjaEZvcm1FbGVtZW50KCkge1xuICAgIHZhciBjYiA9IHRoaXNcbiAgICAgICwgZSwgaVxuICAgICAgLCBzZXJpYWxpemVTdWJ0YWdzID0gZnVuY3Rpb24gKGUsIHRhZ3MpIHtcbiAgICAgICAgICB2YXIgaSwgaiwgZmFcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmEgPSBlW2J5VGFnXSh0YWdzW2ldKVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZhLmxlbmd0aDsgaisrKSBzZXJpYWwoZmFbal0sIGNiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZSA9IGFyZ3VtZW50c1tpXVxuICAgICAgaWYgKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWEvaS50ZXN0KGUudGFnTmFtZSkpIHNlcmlhbChlLCBjYilcbiAgICAgIHNlcmlhbGl6ZVN1YnRhZ3MoZSwgWyAnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJyBdKVxuICAgIH1cbiAgfVxuXG4gIC8vIHN0YW5kYXJkIHF1ZXJ5IHN0cmluZyBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5U3RyaW5nKCkge1xuICAgIHJldHVybiByZXF3ZXN0LnRvUXVlcnlTdHJpbmcocmVxd2VzdC5zZXJpYWxpemVBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKVxuICB9XG5cbiAgLy8geyAnbmFtZSc6ICd2YWx1ZScsIC4uLiB9IHN0eWxlIHNlcmlhbGl6YXRpb25cbiAgZnVuY3Rpb24gc2VyaWFsaXplSGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IHt9XG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgaW4gaGFzaCkge1xuICAgICAgICBoYXNoW25hbWVdICYmICFpc0FycmF5KGhhc2hbbmFtZV0pICYmIChoYXNoW25hbWVdID0gW2hhc2hbbmFtZV1dKVxuICAgICAgICBoYXNoW25hbWVdLnB1c2godmFsdWUpXG4gICAgICB9IGVsc2UgaGFzaFtuYW1lXSA9IHZhbHVlXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvLyBbIHsgbmFtZTogJ25hbWUnLCB2YWx1ZTogJ3ZhbHVlJyB9LCAuLi4gXSBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIHJlcXdlc3Quc2VyaWFsaXplQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyciA9IFtdXG4gICAgZWFjaEZvcm1FbGVtZW50LmFwcGx5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgYXJyLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0pXG4gICAgfSwgYXJndW1lbnRzKVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIHJlcXdlc3Quc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgICB2YXIgb3B0LCBmblxuICAgICAgLCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuXG4gICAgb3B0ID0gYXJncy5wb3AoKVxuICAgIG9wdCAmJiBvcHQubm9kZVR5cGUgJiYgYXJncy5wdXNoKG9wdCkgJiYgKG9wdCA9IG51bGwpXG4gICAgb3B0ICYmIChvcHQgPSBvcHQudHlwZSlcblxuICAgIGlmIChvcHQgPT0gJ21hcCcpIGZuID0gc2VyaWFsaXplSGFzaFxuICAgIGVsc2UgaWYgKG9wdCA9PSAnYXJyYXknKSBmbiA9IHJlcXdlc3Quc2VyaWFsaXplQXJyYXlcbiAgICBlbHNlIGZuID0gc2VyaWFsaXplUXVlcnlTdHJpbmdcblxuICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKVxuICB9XG5cbiAgcmVxd2VzdC50b1F1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKG8sIHRyYWQpIHtcbiAgICB2YXIgcHJlZml4LCBpXG4gICAgICAsIHRyYWRpdGlvbmFsID0gdHJhZCB8fCBmYWxzZVxuICAgICAgLCBzID0gW11cbiAgICAgICwgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAsIGFkZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gICAgICAgICAgdmFsdWUgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlKSA/IHZhbHVlKCkgOiAodmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpXG4gICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmMoa2V5KSArICc9JyArIGVuYyh2YWx1ZSlcbiAgICAgICAgfVxuICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgaWYgKGlzQXJyYXkobykpIHtcbiAgICAgIGZvciAoaSA9IDA7IG8gJiYgaSA8IG8ubGVuZ3RoOyBpKyspIGFkZChvW2ldWyduYW1lJ10sIG9baV1bJ3ZhbHVlJ10pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgIGZvciAocHJlZml4IGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkocHJlZml4KSkgYnVpbGRQYXJhbXMocHJlZml4LCBvW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BhY2VzIHNob3VsZCBiZSArIGFjY29yZGluZyB0byBzcGVjXG4gICAgcmV0dXJuIHMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgIHZhciBuYW1lLCBpLCB2XG4gICAgICAsIHJicmFja2V0ID0gL1xcW1xcXSQvXG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgIGZvciAoaSA9IDA7IG9iaiAmJiBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHYgPSBvYmpbaV1cbiAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xuICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICBhZGQocHJlZml4LCB2KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArICh0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyBpIDogJycpICsgJ10nLCB2LCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArIG5hbWUgKyAnXScsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICBhZGQocHJlZml4LCBvYmopXG4gICAgfVxuICB9XG5cbiAgcmVxd2VzdC5nZXRjYWxsYmFja1ByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2tQcmVmaXhcbiAgfVxuXG4gIC8vIGpRdWVyeSBhbmQgWmVwdG8gY29tcGF0aWJpbGl0eSwgZGlmZmVyZW5jZXMgY2FuIGJlIHJlbWFwcGVkIGhlcmUgc28geW91IGNhbiBjYWxsXG4gIC8vIC5hamF4LmNvbXBhdChvcHRpb25zLCBjYWxsYmFjaylcbiAgcmVxd2VzdC5jb21wYXQgPSBmdW5jdGlvbiAobywgZm4pIHtcbiAgICBpZiAobykge1xuICAgICAgb1sndHlwZSddICYmIChvWydtZXRob2QnXSA9IG9bJ3R5cGUnXSkgJiYgZGVsZXRlIG9bJ3R5cGUnXVxuICAgICAgb1snZGF0YVR5cGUnXSAmJiAob1sndHlwZSddID0gb1snZGF0YVR5cGUnXSlcbiAgICAgIG9bJ2pzb25wQ2FsbGJhY2snXSAmJiAob1snanNvbnBDYWxsYmFja05hbWUnXSA9IG9bJ2pzb25wQ2FsbGJhY2snXSkgJiYgZGVsZXRlIG9bJ2pzb25wQ2FsbGJhY2snXVxuICAgICAgb1snanNvbnAnXSAmJiAob1snanNvbnBDYWxsYmFjayddID0gb1snanNvbnAnXSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXF3ZXN0KG8sIGZuKVxuICB9XG5cbiAgcmVxd2VzdC5hamF4U2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgZm9yICh2YXIgayBpbiBvcHRpb25zKSB7XG4gICAgICBnbG9iYWxTZXR1cE9wdGlvbnNba10gPSBvcHRpb25zW2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXdlc3Rcbn0pO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKFwiLi9ob3N0L2hvc3RcIikoZmFsc2UpO1xuXG4gIChmdW5jdGlvbih3aW5kb3csIHNmKSB7XG4gICAgcmV0dXJuIHdpbmRvd1tcIiRzZlwiXSA9IHNmO1xuICB9KSh3aW5kb3csIHNmKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHNmO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKCcuLi9zaGFyZWQvYmFzZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdywgc2YpIHtcbiAgICB2YXIgQVVUT19CT09UX01BWF9SRVRSSUVTLCBTRl9EQVRBVEFHX0NMQVNTLCBTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MsIFNGX1RBR19UWVBFLCBib290LCBib290X3JldHJpZXMsIGQsIGRvaW5nX2F1dG9fYm9vdCwgZG9tLCBoYXNfYm9vdGVkLCBpbmxpbmVfdGFnc19wcm9jZXNzZWQsIGxhbmcsIGxpYiwgd2luLCBfYXR0ciwgX2F1dG9fYm9vdCwgX2NsZWFuX3VwX2Jvb3RlZF90YWdzLCBfY3JlYXRlX3Bvc19tYXJrdXAsIF9jc3RyLCBfZWx0LCBfZ3VpZCwgX2xvZywgX3BhciwgX3B1cmdlLCBfcmVhZHksIF90YWdzO1xuICAgIHdpbiA9IHdpbmRvdyAhPSBudWxsID8gd2luZG93IDogdGhpcztcbiAgICBfbG9nID0gZnVuY3Rpb24obXNnLCBpc19lcnIpIHtcbiAgICAgIHZhciBlcnJfdGFnLCBoZWFkX2VsLCBsaWI7XG4gICAgICB0cnkge1xuICAgICAgICBsaWIgPSBzZi5saWI7XG4gICAgICAgIGlmIChsaWIgJiYgbGliLmxvZ2dlciAmJiB3aW4gPT09IHRvcCkge1xuICAgICAgICAgIGlmIChpc19lcnIpIHtcbiAgICAgICAgICAgIGxpYi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliLmxvZ2dlci5sb2cobXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZF9lbCA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICAgIGVycl90YWcgPSBkLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgZXJyX3RhZy50eXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgICAgZXJyX3RhZy50ZXh0ID0gXCI8IS0tIFNhZmVGcmFtZSBcIiArIChpc19lcnIgPyBcImVycm9yXCIgOiBcImxvZ1wiKSArIFwiOiBcIiArIChtc2cgfHwgXCJ1bmtub3duXCIpICsgXCIgLS0+XCI7XG4gICAgICAgICAgaGVhZF9lbC5hcHBlbmRDaGlsZChoZWFkX2VsLCBlcnJfdGFnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgIH07XG5cbiAgICAvKlxuICAgIENyZWF0ZSB0aGUgSFRNTCBtYXJrdXAgZm9yIGEgcG9zaXRpb24gaWYgYSBzcmMgcHJvcGVydHkgd2FzIHVzZWRcbiAgICBcbiAgICBAbmFtZSAkc2YuaG9zdC1fY3JlYXRlX3Bvc19tYXJrdXBcbiAgICBAZnVuY3Rpb25cbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgX2NyZWF0ZV9wb3NfbWFya3VwID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgICByZXR1cm4gX2NzdHIoW1wiPHNjclwiLCBcImlwdCB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnLCBzcmM9J1wiLCBzcmMsIFwiJz48L3NjclwiLCBcImlwdD5cIl0pO1xuICAgIH07XG4gICAgX2F1dG9fYm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbmZpZywgZG9fYXV0bywgZG9pbmdfYXV0b19ib290LCBlLCBoZWFkLCBob3N0X2ZpbGUsIHNjcl90YWcsIHNmX2hvc3Q7XG4gICAgICBkb19hdXRvID0gdHJ1ZTtcbiAgICAgIGNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHNmX2hvc3QgPSB2b2lkIDA7XG4gICAgICBob3N0X2ZpbGUgPSB2b2lkIDA7XG4gICAgICBoZWFkID0gdm9pZCAwO1xuICAgICAgc2NyX3RhZyA9IHZvaWQgMDtcbiAgICAgIGlmIChoYXNfYm9vdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNmX2hvc3QgPSBzZiAmJiBzZi5ob3N0O1xuICAgICAgaWYgKHdpbiA9PT0gdG9wKSB7XG4gICAgICAgIGlmIChzZl9ob3N0ICYmICFzZl9ob3N0LmJvb3QpIHtcbiAgICAgICAgICBzZl9ob3N0LmJvb3QgPSBib290O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uZmlnID0gc2ZfaG9zdCAmJiBzZl9ob3N0LkNvbmZpZygpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGNvbmZpZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uZmlnID0gc2ZfaG9zdCAmJiBzZl9ob3N0LmNvbmY7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgY29uZmlnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgIGlmICgoXCJhdXRvXCIgaW4gY29uZmlnKSAmJiBjb25maWcuYXV0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRvX2F1dG8gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZl9ob3N0LnJlbmRlciB8fCAhc2ZfaG9zdC5Db25maWcpIHtcbiAgICAgICAgICAgIGhvc3RfZmlsZSA9IGNvbmZpZy5ob3N0RmlsZTtcbiAgICAgICAgICAgIGlmIChob3N0X2ZpbGUpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IF90YWdzKFwiaGVhZFwiKVswXTtcbiAgICAgICAgICAgICAgc2NyX3RhZyA9IGRvbS5tYWtlKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICBzY3JfdGFnLmlkID0gXCJzZl9ob3N0X2xpYlwiO1xuICAgICAgICAgICAgICBzY3JfdGFnLnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICAgICAgICAgICAgICBzY3JfdGFnLmNsYXNzTmFtZSA9IFwic2ZfbGliXCI7XG4gICAgICAgICAgICAgIHNjcl90YWcuc3JjID0gaG9zdF9maWxlO1xuICAgICAgICAgICAgICBpZiAod2luLkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBzY3JfdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRvaW5nX2F1dG9fYm9vdCwgcnM7XG4gICAgICAgICAgICAgICAgICBycyA9IHNjcl90YWcucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChycyA9PT0gXCJsb2FkZWRcIiB8fCBycyA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9fYXV0bykge1xuICAgICAgICAgICAgICAgICAgICAgIGJvb3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY3JfdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNjcl90YWcgPSBoZWFkID0gc2ZfaG9zdCA9IGNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JfdGFnLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRvaW5nX2F1dG9fYm9vdDtcbiAgICAgICAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGRvX2F1dG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYm9vdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2NyX3RhZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgc2NyX3RhZyA9IGhlYWQgPSBzZl9ob3N0ID0gY29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvaW5nX2F1dG9fYm9vdCA9IHRydWU7XG4gICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyX3RhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvX2F1dG8pIHtcbiAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBkb2luZ19hdXRvX2Jvb3QgPSB0cnVlO1xuICAgICAgICAgICAgYm9vdCgpO1xuICAgICAgICAgICAgZG9pbmdfYXV0b19ib290ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChib290X3JldHJpZXMrKyA8PSBBVVRPX0JPT1RfTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChfYXV0b19ib290LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib290KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgR28gdGhyb3VnaCBhbmQgcmVtb3ZlIGFueSBpbmxpbmUgc2NyaXB0IHRhZ3MgdGhhdCBhcmUgb3VyIGRhdGEtaXNsYW5kcyAsIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGJvb3N0cmFwcGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmhvc3QtX2NsZWFuX3VwX2Jvb3RlZF90YWdzXG4gICAgQHByaXZhdGVcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgICovXG4gICAgX2NsZWFuX3VwX2Jvb3RlZF90YWdzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NyaXB0X3RhZywgc2NyaXB0X3RhZ19pZDtcbiAgICAgIHNjcmlwdF90YWdfaWQgPSB2b2lkIDA7XG4gICAgICBzY3JpcHRfdGFnID0gdm9pZCAwO1xuICAgICAgaWYgKGRvbSkge1xuICAgICAgICBmb3IgKHNjcmlwdF90YWdfaWQgaW4gaW5saW5lX3RhZ3NfcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgc2NyaXB0X3RhZyA9IF9lbHQoc2NyaXB0X3RhZ19pZCk7XG4gICAgICAgICAgaWYgKHNjcmlwdF90YWcpIHtcbiAgICAgICAgICAgIF9wdXJnZShzY3JpcHRfdGFnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbmxpbmVfdGFnc19wcm9jZXNzZWRbc2NyaXB0X3RhZ19pZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VhcmNoIGZvciBTYWZlRnJhbWVzIHRhZ3MgYW5kIHJlbmRlciB0aGVtLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgIGF1dG9tYXRpY2FsbHkgd2hlbmV2ZXIgdGhlIFNhZmVGcmFtZXMgcHVibGlzaGVyIGxpYnJhcnkgaXMgbG9hZGVkLiBIb3dldmVyIGEgY29uZmlndXJhdGlvblxuICAgIGNhbiBiZSBhcHBsaWVkIHRvIG5vdCBoYXZlIFNhZmVGcmFtZXMgdGFncyBhdXRvbWF0aWNhbGx5IGJlIHJlbmRlcmVkLCByZXF1aXJpbmcgYSBjb250cm9sbGVkXG4gICAgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxuICAgIFxuICAgIEBuYW1lICRzZi5ob3N0LmJvb3RcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgICAqL1xuICAgIGJvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBib290X3Bvc2l0aW9ucywgZGF0YSwgZSwgZXJyLCBlcnJNc2csIGhhc19ib290ZWQsIGh0bWwsIGlkeCwgbGliLCBtZXRhX2tleSwgcG9zX2NvbmYsIHBvc19kZXN0X2VsLCBwb3NfbWV0YSwgcG9zX21ldGFfaXRlbSwgcG9zX29iaiwgcHJ2X21ldGEsIHBydl9tZXRhX2tleSwgcmV0LCBzY3JpcHRfdGFnLCBzY3JpcHRfdGFnX2lkLCBzY3JpcHRfdGFnX3Bhciwgc2NyaXB0X3RhZ3MsIHNmX2NvbmYsIHNmX2hvc3QsIHNmX2lubGluZV9jb25mLCBzZl9vY25mLCBzaGFyZWRfbWV0YSwgdHlwO1xuICAgICAgc2NyaXB0X3RhZ3MgPSAoX3RhZ3MgJiYgX3RhZ3MoXCJzY3JpcHRcIikpIHx8IFtdO1xuICAgICAgYm9vdF9wb3NpdGlvbnMgPSBbXTtcbiAgICAgIGlkeCA9IDA7XG4gICAgICByZXQgPSBmYWxzZTtcbiAgICAgIGVyck1zZyA9IHZvaWQgMDtcbiAgICAgIHNmX2hvc3QgPSBzZiAmJiBzZi5ob3N0O1xuICAgICAgc2ZfaW5saW5lX2NvbmYgPSBzZl9ob3N0ICYmIHNmX2hvc3QuY29uZjtcbiAgICAgIHNjcmlwdF90YWcgPSB2b2lkIDA7XG4gICAgICBzY3JpcHRfdGFnX3BhciA9IHZvaWQgMDtcbiAgICAgIHNjcmlwdF90YWdfaWQgPSB2b2lkIDA7XG4gICAgICBkYXRhID0gdm9pZCAwO1xuICAgICAgaHRtbCA9IHZvaWQgMDtcbiAgICAgIHBvc19vYmogPSB2b2lkIDA7XG4gICAgICBwb3NfY29uZiA9IHZvaWQgMDtcbiAgICAgIHBvc19kZXN0X2VsID0gdm9pZCAwO1xuICAgICAgcG9zX21ldGEgPSB2b2lkIDA7XG4gICAgICBwb3NfbWV0YV9pdGVtID0gdm9pZCAwO1xuICAgICAgdHlwID0gdm9pZCAwO1xuICAgICAgc2hhcmVkX21ldGEgPSB2b2lkIDA7XG4gICAgICBwcnZfbWV0YSA9IHZvaWQgMDtcbiAgICAgIHBydl9tZXRhX2tleSA9IHZvaWQgMDtcbiAgICAgIG1ldGFfa2V5ID0gdm9pZCAwO1xuICAgICAgc2Zfb2NuZiA9IHZvaWQgMDtcbiAgICAgIGVyciA9IHZvaWQgMDtcbiAgICAgIGlmICghc2YgfHwgIWxhbmcgfHwgIWRvbSkge1xuICAgICAgICBfbG9nKFwiU2FmZUZyYW1lIGJhc2UgbGlicmFyeSBub3QgZm91bmRcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBpZiAoIWxpYikge1xuICAgICAgICBsaWIgPSBzZiAmJiBzZi5saWI7XG4gICAgICB9XG4gICAgICBpZiAoZG9pbmdfYXV0b19ib290ICYmIGhhc19ib290ZWQpIHtcbiAgICAgICAgX2xvZyhcIkF1dG9tYXRpYyBib290IGFscmVhZHkgaW52b2tlZFwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW4gPT09IHRvcCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNmX2NvbmYgPSBzZl9ob3N0LkNvbmZpZygpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgc2ZfY29uZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNmX2lubGluZV9jb25mICYmICFzZl9jb25mKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNmX2NvbmYgPSBzZl9ob3N0LkNvbmZpZyhzZl9pbmxpbmVfY29uZik7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgc2ZfY29uZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2ZfY29uZikge1xuICAgICAgICAgIF9sb2coXCJObyBjb25maWd1cmF0aW9uIGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzY3JpcHRfdGFnID0gc2NyaXB0X3RhZ3NbaWR4KytdKSB7XG4gICAgICAgIGlmIChzY3JpcHRfdGFnLmNsYXNzTmFtZSA9PT0gU0ZfREFUQVRBR19DTEFTUyB8fCBfYXR0cihzY3JpcHRfdGFnLCBcInR5cGVcIikgPT09IFNGX1RBR19UWVBFKSB7XG4gICAgICAgICAgaGFzX2Jvb3RlZCA9IHRydWU7XG4gICAgICAgICAgc2NyaXB0X3RhZ19pZCA9IF9hdHRyKHNjcmlwdF90YWcsIFwiaWRcIik7XG4gICAgICAgICAgaWYgKCFzY3JpcHRfdGFnX2lkKSB7XG4gICAgICAgICAgICBzY3JpcHRfdGFnX2lkID0gX2d1aWQoXCJzZl9kYXRhX2VsZW1lbnRcIik7XG4gICAgICAgICAgICBfYXR0cihzY3JpcHRfdGFnLCBcImlkXCIsIHNjcmlwdF90YWdfaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5saW5lX3RhZ3NfcHJvY2Vzc2VkW3NjcmlwdF90YWdfaWRdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YSA9IHNjcmlwdF90YWcudGV4dCB8fCBzY3JpcHRfdGFnLmlubmVySFRNTCB8fCBzY3JpcHRfdGFnLmlubmVyVGV4dDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IGxhbmcudHJpbShkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGVyck1zZyA9IFwiRXJyb3IgcGFyc2luZyB0YWcgY29uZmlndXJhdGlvbiBcIiArIChlcnIgJiYgZXJyLm1lc3NhZ2UgfHwgXCJcIik7XG4gICAgICAgICAgICBfbG9nKGVyck1zZywgdHJ1ZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5pZCAmJiAoZGF0YS5odG1sIHx8IGRhdGEuc3JjKSkge1xuICAgICAgICAgICAgaWYgKHdpbiAhPT0gdG9wKSB7XG4gICAgICAgICAgICAgIGh0bWwgPSBkYXRhLmh0bWwgfHwgXCJcIjtcbiAgICAgICAgICAgICAgaHRtbCA9IGh0bWwgfHwgX2NyZWF0ZV9wb3NfbWFya3VwKGRhdGEuc3JjKTtcbiAgICAgICAgICAgICAgaWYgKCFfcmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIGQud3JpdGUoaHRtbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2xvZyhcImNhbm5vdCB3cml0ZSBodG1sIGNvbnRlbnQgaW50byBhbHJlYWR5IGxvYWRlZCBkb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2NyaXB0X3RhZ19wYXIgPSBfcGFyKHNjcmlwdF90YWcpO1xuICAgICAgICAgICAgICBpZiAoIXNjcmlwdF90YWdfcGFyKSB7XG4gICAgICAgICAgICAgICAgX2xvZyhcImNhbid0IGZpbmQgcGFyZW50IGVsZW1lbnQgZm9yIHNjcmlwdCB0YWdcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zX2NvbmYgPSBzZl9jb25mICYmIHNmX2NvbmYucG9zaXRpb25zW2RhdGEuaWRdO1xuICAgICAgICAgICAgICBpZiAoIXBvc19jb25mKSB7XG4gICAgICAgICAgICAgICAgcG9zX2NvbmYgPSBkYXRhLmNvbmY7XG4gICAgICAgICAgICAgICAgcG9zX2NvbmYuaWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgICAgIGlmIChwb3NfY29uZikge1xuICAgICAgICAgICAgICAgICAgcG9zX2NvbmYgPSBuZXcgc2ZfaG9zdC5Qb3NDb25maWcocG9zX2NvbmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBvc19jb25mKSB7XG4gICAgICAgICAgICAgICAgX2xvZyhcIm5vIHBvc2l0aW9uIGNvbmYgZm91bmQgcHJlLWRlZmluZWQgb3IgaW5saW5lIGZvciBwb3NpdGlvbiBcIiArIGRhdGEuaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcG9zX2NvbmYuZGVzdCkge1xuICAgICAgICAgICAgICAgIHBvc19jb25mID0gbmV3IHNmX2hvc3QuUG9zQ29uZmlnKHBvc19jb25mLCBfZ3VpZChTRl9QT1NFTEVNX1dSQVBQRVJfQ0xBU1MpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGF0YS5tZXRhKSB7XG4gICAgICAgICAgICAgICAgcG9zX21ldGEgPSBkYXRhLm1ldGE7XG4gICAgICAgICAgICAgICAgbWV0YV9rZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNoYXJlZF9tZXRhID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChtZXRhX2tleSBpbiBwb3NfbWV0YSkge1xuICAgICAgICAgICAgICAgICAgcG9zX21ldGFfaXRlbSA9IHBvc19tZXRhW21ldGFfa2V5XTtcbiAgICAgICAgICAgICAgICAgIHR5cCA9IHR5cGVvZiBwb3NfbWV0YV9pdGVtO1xuICAgICAgICAgICAgICAgICAgaWYgKCFwcnZfbWV0YSAmJiB0eXAgPT09IFwib2JqZWN0XCIgJiYgcG9zX21ldGFfaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBwcnZfbWV0YSA9IHBvc19tZXRhX2l0ZW07XG4gICAgICAgICAgICAgICAgICAgIHBydl9tZXRhX2tleSA9IG1ldGFfa2V5O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cCAhPT0gXCJvYmplY3RcIiAmJiB0eXAgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBzaGFyZWRfbWV0YVttZXRhX2tleV0gPSBwb3NfbWV0YV9pdGVtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NfbWV0YSA9IG5ldyBzZl9ob3N0LlBvc01ldGEoc2hhcmVkX21ldGEsIHBydl9tZXRhX2tleSB8fCBcIlwiLCAocHJ2X21ldGFfa2V5ICYmIHBydl9tZXRhID8gcHJ2X21ldGEgOiBudWxsKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zX29iaiA9IG5ldyBzZl9ob3N0LlBvc2l0aW9uKGRhdGEsIG51bGwsIHBvc19tZXRhLCBwb3NfY29uZik7XG4gICAgICAgICAgICAgIGlubGluZV90YWdzX3Byb2Nlc3NlZFtzY3JpcHRfdGFnX2lkXSA9IHNjcmlwdF90YWdfaWQ7XG4gICAgICAgICAgICAgIHBvc19kZXN0X2VsID0gX2VsdChwb3NfY29uZi5kZXN0KTtcbiAgICAgICAgICAgICAgaWYgKCFwb3NfZGVzdF9lbCkge1xuICAgICAgICAgICAgICAgIGlmIChfcmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgcG9zX2Rlc3RfZWwgPSBkb20ubWFrZShcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgIF9hdHRyKHBvc19kZXN0X2VsLCBcImlkXCIsIHBvc19jb25mLmRlc3QpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0X3RhZ19wYXIuaW5zZXJ0QmVmb3JlKHBvc19kZXN0X2VsKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9sb2coXCJmYWlsZWQgYXV0by1hZGRpbmcgZGVzdGluYXRpb24gZWxlbWVudCBcIiArIGVyci5tZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGQud3JpdGUoXCI8ZGl2IGlkPSdcIiwgcG9zX2NvbmYuZGVzdCwgXCInPjwvZGl2PlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYm9vdF9wb3NpdGlvbnMucHVzaChwb3Nfb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2xvZyhcIm5vIGNvbnRlbnQgb3IgaWQgcHJvcGVydHkgZm91bmQgaW4gdGhlIGlubGluZSBwb3NpdGlvbiBvYmplY3RcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYm9vdF9wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2ZfaG9zdC5yZW5kZXIoYm9vdF9wb3NpdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIF9sb2coXCJmYWlsZWQgZHVyaW5nIHJlbmRlcmluZyBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2coXCJubyBwb3NpdGlvbnMgdG8gYm9vdFwiKTtcbiAgICAgIH1cbiAgICAgIGRvbS53YWl0KF9jbGVhbl91cF9ib290ZWRfdGFncyk7XG4gICAgfTtcbiAgICBTRl9EQVRBVEFHX0NMQVNTID0gXCJzZl9kYXRhXCI7XG4gICAgU0ZfVEFHX1RZUEUgPSBcInRleHQveC1zYWZlZnJhbWVcIjtcbiAgICBBVVRPX0JPT1RfTUFYX1JFVFJJRVMgPSAxMDA7XG4gICAgU0ZfUE9TRUxFTV9XUkFQUEVSX0NMQVNTID0gXCJzZl9wb3NpdGlvblwiO1xuICAgIGQgPSB3aW4gJiYgd2luLmRvY3VtZW50O1xuICAgIGxpYiA9IHNmLmxpYjtcbiAgICBsYW5nID0gbGliLmxhbmc7XG4gICAgZG9tID0gbGliLmRvbTtcbiAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICBfZ3VpZCA9IGxhbmcuZ3VpZDtcbiAgICBfZWx0ID0gZG9tLmVsdDtcbiAgICBfcGFyID0gZG9tLnBhcjtcbiAgICBfdGFncyA9IGRvbS50YWdzO1xuICAgIF9hdHRyID0gZG9tLmF0dHI7XG4gICAgX3B1cmdlID0gZG9tLnB1cmdlO1xuICAgIF9yZWFkeSA9IGRvbS5yZWFkeTtcbiAgICBpbmxpbmVfdGFnc19wcm9jZXNzZWQgPSB7fTtcbiAgICBib290X3JldHJpZXMgPSAwO1xuICAgIGhhc19ib290ZWQgPSBmYWxzZTtcbiAgICBkb2luZ19hdXRvX2Jvb3QgPSBmYWxzZTtcbiAgICBzZXRUaW1lb3V0KF9hdXRvX2Jvb3QsIDUwKTtcbiAgICByZXR1cm4gc2Y7XG4gIH0pKHdpbmRvdywgc2YpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuXG4vKlxuQG5hbWVzcGFjZSAkc2YuaG9zdCBEZWZpbmVzIHRoZSBQdWJsaXNoZXIgc2lkZSBhcGksIGFuZCBoZWxwZXIgZnVuY3Rpb25zXG5AbmFtZSAkc2YuaG9zdFxuQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOnNzbmlkZXJAeWFob28taW5jLmNvbVwiPlNlYW4gU25pZGVyPC9hPlxuQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmNjb2xlW0FUXWVtaW5hdGlvbi5jb21cIj5DaHJpcyBDb2xlPC9hPlxuQHZlcnNpb24gMS4wLjJcbiAqL1xuXG5cbi8qXG5AaWdub3JlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgc2Y7XG5cbiAgc2YgPSByZXF1aXJlKCcuL2Jvb3QnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFsbG93Tm90VG9wKSB7XG4gICAgaWYgKGFsbG93Tm90VG9wID09IG51bGwpIHtcbiAgICAgIGFsbG93Tm90VG9wID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoZnVuY3Rpb24od2luZG93LCBzZikge1xuICAgICAgdmFyIEFUVEFDSCwgQVVUTywgQVVUT19CT09UX01BWF9SRVRSSUVTLCBCRl9QT1NfTVNHLCBDTElQLCBDT0xMQVBTRV9DT01NQU5ELCBDT01QQVJFX0RPQ19QT1MsIENPTVBBVF9NT0RFLCBDT05UQUlOUywgQ29uZmlnLCBERUZBVUxUX1JFTkRFUl9USU1FT1VULCBERUZBVUxUX1pJTkRFWCwgREVUQUNILCBET0MsIERPQ19FTCwgRUxfRlJPTV9QVCwgRVJST1JfQ09NTUFORCwgRVhQQU5EX0NPTU1BTkQsIEZMQVNIX01JTUUsIEdFT01fVVBEQVRFX0lOVFJWQUwsIEdVSUQsIEhFSUdIVCwgSElEREVOLCBJRV9CT1JERVJfQURKLCBJTlRFUlNFQ1RfRkFDVE9SLCBMRU4sIE0sIE1TRywgTk9ERV9UWVBFLCBOT1RJRllfQ09MTEFQU0UsIE5PVElGWV9FWFBBTkQsIE5PVElGWV9GT0NVU19DSEFOR0UsIE5PVElGWV9HRU9NX1VQREFURSwgT0JKLCBPTlNDUk9MTCwgT1ZFUiwgUE1TRywgUE9TX0lEX0FVVE9fUFJFRklYLCBQT1NfTVNHLCBQT1NfUkVMX0JPWF9JRF9QUkVGSVgsIFBYLCBQYXJhbUhhc2gsIFBvc0NvbmZpZywgUG9zTWV0YSwgUG9zaXRpb24sIFNDUk9MTCwgU0ZfREFUQVRBR19DTEFTUywgU0ZfUE9TRUxFTV9XUkFQUEVSX0NMQVNTLCBTVCwgU1RSLCBTVVBQT1JUU19GRUFUVVJFUywgVEZYRCwgVkVSU0lPTiwgV0lEVEgsIFhDT01fUkVTUF9ERUxBWSwgYXR0YWNoX2lmcmFtZV9tc2dpbmcsIGJvdW5kcywgY2FuVXNlSFRNTDUsIGNvbXBsZXRlX2lmcnMsIGNvbmZpZywgY29udGFpbnMsIGN1cnJlbnRTdHlsZSwgY3VycmVudF9zdGF0dXMsIGRjLCBkZXRhY2hfaWZyYW1lX21zZ2luZywgZG9jUmVjdCwgZG9tLCBlbnYsIGZsYXNoQWN0aXZlWFZlcnNpb25zLCBmbGFzaF92ZXIsIGZvY3VzX3VwZGF0ZV90aW1lciwgZ2Vja1ZlciwgZ2VvbV91cGRhdGVfdGltZXIsIGdldCwgaHRtbDVCb3VuZCwgaWVWZXIsIGlmcl9kZXN0X2lkX21hcCwgaWZyYW1lcywgaW5WaWV3UGVyY2VudGFnZSwgaW5pdElELCBpc0lFLCBsYW5nLCBsaWIsIGxvYywgbG9jSG9zdCwgbWdyX2JvdW5kc19kZXRhaWxzLCBtc2dfcGlwZXMsIG1zZ2hvc3RmYiwgbnVrZSwgb3BlcmFWZXIsIG92ZXJsYXBzLCBwZW5kaW5nX2lmcnMsIHByZXBfaWZyYW1lX21zZ2luZywgcmVuZGVyLCByZW5kZXJlZF9pZnJzLCBzY3JvbGxfcGFyZW50c19hdHRhY2hlZCwgc2VuZF9tc2dfdG9fY2hpbGRfaWZyYW1lLCBzdGF0dXMsIHVhLCB1c2luZ0hUTUw1LCB3YlZlciwgd2luLCB3aW5SZWN0LCB3aW5fZXZlbnRzX2F0dGFjaGVkLCBfYXR0ciwgX2J1aWxkX2dlb20sIF9jYWxjQm9yZGVycywgX2NhbGxfeG1zZ19ob3N0X2ZiLCBfY2FsbGFibGUsIF9jYm9vbCwgX2NoZWNrX2h0bWw1X2luaXQsIF9jbGVhcl9mb2N1c191cGRhdGVfdGltZXIsIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lciwgX2NudW0sIF9jb2xsYXBzZV9zYWZlZnJhbWUsIF9jb29raWVIYXNoLCBfY29va2llc19lbmFibGVkX3Rlc3QsIF9jcmVhdGVfcG9zX21hcmt1cCwgX2NzdHIsIF9kb2MsIF9kb2NOb2RlLCBfZWx0LCBfZXMsIF9leHBhbmRfc2FmZWZyYW1lLCBfZmlyZV9wdWJfY2FsbGJhY2ssIF9nZXRDbGlwLCBfZ2V0R2VvbSwgX2dldFJlY3RJRSwgX2dldFJlY3ROb25JRSwgX2dldF9kb2Nfc2Nyb2xsLCBfZ2V0X2ZsYXNoX3ZlcnNpb24sIF9ndWlkLCBfaGFuZGxlX2ZyYW1lX2xvYWQsIF9oYW5kbGVfbXNnX2V2dCwgX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlLCBfaGFuZGxlX25vZGVfc2Nyb2xsLCBfaGFuZGxlX3JlbmRlcl90aW1lb3V0LCBfaGFuZGxlX3VubG9hZCwgX2hhbmRsZV93aW5fYmx1ciwgX2hhbmRsZV93aW5fZm9jdXMsIF9oYW5kbGVfd2luX2dlb21fcmVzaXplLCBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCwgX2hhc19wZW5kaW5nX3JlbmRlcnMsIF9pZnJfdmlldywgX2lzUFgsIF9tYXgsIF9taW4sIF9taXgsIF9ub29wLCBfcGFyLCBfcHVyZ2UsIF9yZWFkX2Nvb2tpZSwgX3JlYWR5LCBfcmVjb3JkX2Vycm9yLCBfcmVjdCwgX3JvdW5kLCBfc2VuZF9nZW5lcmljX3Jlc3BvbnNlLCBfc2VuZF9yZXNwb25zZSwgX3NldF9mb2N1c191cGRhdGVfdGltZXIsIF9zZXRfZ2VvbV91cGRhdGVfdGltZXIsIF9zaGltX2ZyYW1lLCBfc3RyaXBwZWRFbmNvZGVkTG9jYXRpb24sIF90YWdOYW1lLCBfdGFncywgX3VwZGF0ZV9mb2N1cywgX3VwZGF0ZV9nZW9tLCBfdXBkYXRlX2dlb21fd2luX3Jlc2l6ZSwgX3VwZGF0ZV9nZW9tX3dpbl9zY3JvbGwsIF92aWV3LCBfd3JpdGVfY29va2llO1xuICAgICAgd2luID0gd2luZG93O1xuICAgICAgREVGQVVMVF9SRU5ERVJfVElNRU9VVCA9IDYwMDAwO1xuICAgICAgUE9TX0lEX0FVVE9fUFJFRklYID0gXCJzZl9wb3NcIjtcbiAgICAgIFBPU19SRUxfQk9YX0lEX1BSRUZJWCA9IFwic2ZfcG9zX3JlbF9lbFwiO1xuICAgICAgU0ZfREFUQVRBR19DTEFTUyA9IFwic2ZfZGF0YVwiO1xuICAgICAgU0ZfUE9TRUxFTV9XUkFQUEVSX0NMQVNTID0gXCJzZl9wb3NpdGlvblwiO1xuICAgICAgQVVUT19CT09UX01BWF9SRVRSSUVTID0gMTAwO1xuICAgICAgR0VPTV9VUERBVEVfSU5UUlZBTCA9IDEwMDtcbiAgICAgIFhDT01fUkVTUF9ERUxBWSA9IDE7XG4gICAgICBJRV9CT1JERVJfQURKID0gMjtcbiAgICAgIElOVEVSU0VDVF9GQUNUT1IgPSAxMDtcbiAgICAgIEJGX1BPU19NU0cgPSBcIm9uQmVmb3JlUG9zTXNnXCI7XG4gICAgICBQT1NfTVNHID0gXCJvblBvc01zZ1wiO1xuICAgICAgU1VQUE9SVFNfRkVBVFVSRVMgPSB7XG4gICAgICAgIFwiZXhwLW92clwiOiAxLFxuICAgICAgICBcImV4cC1wdXNoXCI6IDAsXG4gICAgICAgIGJnOiAwLFxuICAgICAgICBwaW46IDAsXG4gICAgICAgIFwicmVhZC1jb29raWVcIjogMCxcbiAgICAgICAgXCJ3cml0ZS1jb29raWVcIjogMFxuICAgICAgfTtcbiAgICAgIEVYUEFORF9DT01NQU5EID0gXCJleHAtb3ZyXCI7XG4gICAgICBDT0xMQVBTRV9DT01NQU5EID0gXCJjb2xsYXBzZVwiO1xuICAgICAgRVJST1JfQ09NTUFORCA9IFwiZXJyb3JcIjtcbiAgICAgIE5PVElGWV9FWFBBTkQgPSBcImV4cGFuZFwiO1xuICAgICAgTk9USUZZX0dFT01fVVBEQVRFID0gXCJnZW9tLXVwZGF0ZVwiO1xuICAgICAgTk9USUZZX0NPTExBUFNFID0gQ09MTEFQU0VfQ09NTUFORDtcbiAgICAgIE5PVElGWV9GT0NVU19DSEFOR0UgPSBcImZvY3VzLWNoYW5nZVwiO1xuICAgICAgREVGQVVMVF9aSU5ERVggPSAzMDAwO1xuICAgICAgT0JKID0gXCJvYmplY3RcIjtcbiAgICAgIFNUUiA9IFwic3RyaW5nXCI7XG4gICAgICBTVCA9IFwic3R5bGVcIjtcbiAgICAgIExFTiA9IFwibGVuZ3RoXCI7XG4gICAgICBXSURUSCA9IFwid2lkdGhcIjtcbiAgICAgIEhFSUdIVCA9IFwiaGVpZ2h0XCI7XG4gICAgICBQWCA9IFwiUFhcIjtcbiAgICAgIENMSVAgPSBcImNsaXBcIjtcbiAgICAgIFNDUk9MTCA9IFwic2Nyb2xsXCI7XG4gICAgICBPTlNDUk9MTCA9IFwib25zY3JvbGxcIjtcbiAgICAgIENPTVBBVF9NT0RFID0gXCJjb21wYXRNb2RlXCI7XG4gICAgICBET0NfRUwgPSBcImRvY3VtZW50RWxlbWVudFwiO1xuICAgICAgRE9DID0gXCJkb2N1bWVudFwiO1xuICAgICAgTk9ERV9UWVBFID0gXCJub2RlVHlwZVwiO1xuICAgICAgQ09OVEFJTlMgPSBcImNvbnRhaW5zXCI7XG4gICAgICBDT01QQVJFX0RPQ19QT1MgPSBcImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXCI7XG4gICAgICBFTF9GUk9NX1BUID0gXCJlbGVtZW50RnJvbVBvaW50XCI7XG4gICAgICBBVVRPID0gXCJhdXRvXCI7XG4gICAgICBISURERU4gPSBcImhpZGRlblwiO1xuICAgICAgT1ZFUiA9IFwib3ZlcmZsb3dcIjtcbiAgICAgIFRGWEQgPSBcInRvRml4ZWRcIjtcbiAgICAgIEFUVEFDSCA9IFwiYXR0YWNoXCI7XG4gICAgICBERVRBQ0ggPSBcImRldGFjaFwiO1xuICAgICAgTVNHID0gXCJtZXNzYWdlXCI7XG4gICAgICBQTVNHID0gXCJwb3N0TWVzc2FnZVwiO1xuICAgICAgR1VJRCA9IFwiZ3VpZFwiO1xuICAgICAgRkxBU0hfTUlNRSA9IFwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIjtcbiAgICAgIFZFUlNJT04gPSBzZi52ZXI7XG4gICAgICBlbnYgPSBzZi5lbnY7XG4gICAgICB1YSA9IGVudi51YTtcbiAgICAgIGxpYiA9IHNmLmxpYjtcbiAgICAgIGxhbmcgPSBsaWIubGFuZztcbiAgICAgIGRvbSA9IGxpYi5kb207XG4gICAgICBpZnJhbWVzID0gZG9tLmlmcmFtZXM7XG4gICAgICBfY2Jvb2wgPSBsYW5nLmNib29sO1xuICAgICAgX2NudW0gPSBsYW5nLmNudW07XG4gICAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICAgIF9jYWxsYWJsZSA9IGxhbmcuY2FsbGFibGU7XG4gICAgICBfbm9vcCA9IGxhbmcubm9vcDtcbiAgICAgIF9ndWlkID0gbGFuZ1tHVUlEXTtcbiAgICAgIF9taXggPSBsYW5nLm1peDtcbiAgICAgIF9lbHQgPSBkb20uZWx0O1xuICAgICAgX3BhciA9IGRvbS5wYXI7XG4gICAgICBfdGFncyA9IGRvbS50YWdzO1xuICAgICAgX2F0dHIgPSBkb20uYXR0cjtcbiAgICAgIF9kb2MgPSBkb20uZG9jO1xuICAgICAgX3RhZ05hbWUgPSBkb20udGFnTmFtZTtcbiAgICAgIF92aWV3ID0gZG9tLnZpZXc7XG4gICAgICBfaWZyX3ZpZXcgPSBpZnJhbWVzLnZpZXc7XG4gICAgICBfcHVyZ2UgPSBkb20ucHVyZ2U7XG4gICAgICBfcmVhZHkgPSBkb20ucmVhZHk7XG4gICAgICBfZXMgPSB3aW4gJiYgd2luLmVzY2FwZTtcbiAgICAgIE0gPSB3aW4gJiYgd2luLk1hdGg7XG4gICAgICBfbWF4ID0gTS5tYXg7XG4gICAgICBfbWluID0gTS5taW47XG4gICAgICBfcm91bmQgPSBNLnJvdW5kO1xuICAgICAgX3JlY3QgPSBudWxsO1xuICAgICAgUGFyYW1IYXNoID0gbGFuZyAmJiBsYW5nLlBhcmFtSGFzaDtcbiAgICAgIGRjID0gd2luICYmIHdpbltET0NdO1xuICAgICAgaXNJRSA9IGVudiAmJiBlbnYuaXNJRTtcbiAgICAgIGllVmVyID0gKHVhICYmIHVhLmllKSB8fCAwO1xuICAgICAgd2JWZXIgPSAodWEgJiYgdWEud2Via2l0KSB8fCAwO1xuICAgICAgZ2Vja1ZlciA9ICh1YSAmJiB1YS5nZWNrbykgfHwgMDtcbiAgICAgIG9wZXJhVmVyID0gKHVhICYmIHVhLm9wZXJhKSB8fCAwO1xuICAgICAgbG9jID0gd2luLmxvY2F0aW9uO1xuICAgICAgbG9jSG9zdCA9IGxvYyAmJiAoKGxvYy5wcm90b2NvbCArIFwiLy9cIiArIChsb2MuaG9zdCB8fCBsb2MuaG9zdG5hbWUpKSB8fCBcIlwiKTtcbiAgICAgIHJlbmRlcmVkX2lmcnMgPSB7fTtcbiAgICAgIG1zZ19waXBlcyA9IHt9O1xuICAgICAgaWZyX2Rlc3RfaWRfbWFwID0ge307XG4gICAgICBwZW5kaW5nX2lmcnMgPSB7fTtcbiAgICAgIGNvbXBsZXRlX2lmcnMgPSB7fTtcbiAgICAgIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkID0ge307XG4gICAgICBtZ3JfYm91bmRzX2RldGFpbHMgPSBmYWxzZTtcbiAgICAgIGNhblVzZUhUTUw1ID0gZmFsc2U7XG4gICAgICBodG1sNUJvdW5kID0gZmFsc2U7XG4gICAgICB3aW5fZXZlbnRzX2F0dGFjaGVkID0gZmFsc2U7XG4gICAgICBnZW9tX3VwZGF0ZV90aW1lciA9IDA7XG4gICAgICBmb2N1c191cGRhdGVfdGltZXIgPSAwO1xuICAgICAgY3VycmVudF9zdGF0dXMgPSBudWxsO1xuICAgICAgbXNnaG9zdGZiID0gbnVsbDtcbiAgICAgIGZsYXNoX3ZlciA9IG51bGw7XG4gICAgICBjb25maWcgPSBudWxsO1xuICAgICAgZmxhc2hBY3RpdmVYVmVyc2lvbnMgPSBbXCJTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaC4xMVwiLCBcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoLjhcIiwgXCJTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaC43XCIsIFwiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2guNlwiLCBcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoXCJdO1xuICAgICAgaW5pdElEID0gdm9pZCAwO1xuXG4gICAgICAvKlxuICAgICAgQ29uZmlndXJlIHRoZSBiYXNlLWxldmVsIHNldHRpbmdzIGZvciB0aGUgU2FmZUZyYW1lcyBsaWJyYXJ5XG4gICAgICBOb3RlIHRoYXQgb25seSBvbmUgY29uZmlndXJhdGlvbiBjYW4gYmUgYWN0aXZlIGF0IGEgZ2l2ZW4gdGltZS5cbiAgICAgIFRoZXJlZm9yZSB5b3UgY2Fubm90IGNoYW5nZSB0aGUgY29uZmlndXJhdGlvbiBieSBjcmVhdGluZyBhIG5ldyAkc2YuaG9zdC5Db25maWcgd2hpbGVcbiAgICAgIHRoZSBTYWZlRnJhbWVzIGxpYnJhcnkgaXMgYnVzeSAoaG93ZXZlciB5b3UgY2FuIGFkZCBuZXcgcG9zaXRpb24gY29uZmlndXJhdGlvbnMpLlxuICAgICAgSW5zdGF0aWF0aW5nIGEgbmV3IGNvbmZpZywgd2hlbiB0aGUgbGlicmFyeSBpcyBub3QgYnVzeSB3aWxsIGRlc3Ryb3kgLyByZW1vdmUgYWxsIGN1cnJlbnRseVxuICAgICAgbWFuYWdlZCBwb3NpdGlvbnMgYW5kIHRoZXJlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC5Db25maWdcbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICAgQHB1YmxpY1xuICAgICAgQHBhcmFtIHtPYmplY3R9IGNvbmYgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBmb3IgY29uZmlndXJhdGlvblxuICAgICAgQHBhcmFtIHtCb29sZWFufSBbY29uZi5hdXRvXSBXaGV0aGVyIG9yIG5vdCB0byBoYXZlIFNhZmVGcmFtZXMgYXV0b21hdGljYWxseSBib29zdHJhcCBhbiByZW5kZXIgYW55IFNhZmVGcmFtZXMgdGFncyB3aXRoaW4gdGhlIHBhZ2VcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBjb25mLmNkbiBUaGUgcHJvdG9jb2wsaG9zdCBuYW1lLCBhbmQgcG9ydCBwYXJ0cyBvZiBhIFVSSSwgdGhhdCBpcyBhIDJuZGFyeSBvcmlnaW4sIHVzZWQgd2l0aCBTYWZlRnJhbWVzIHRvIHJlbmRlciBjb250ZW50LiBGb3IgZXhhbXBsZSBKUyBmaWxlcyB3b3VsZCBiZSBsb2FkZWQgZnJvbSBjb25mLmNkbitcIi9cIitjb25mLnJvb3QrXCIvXCIrY29uZi52ZXJzaW9uK1wiL1tmaWxlbmFtZV1cIlxuICAgICAgQHBhcmFtIHtCb29sZWFufSBbY29uZi5kZWJ1Z10gV2hldGhlciBvciBub3QgZGVidWcgbW9kZSBpcyBvbiBvciBvZmZcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBjb25mLnJvb3QgVGhlIHJvb3QgcGF0aCBwYXJ0IG9mIHRoZSBVUkkgdGhhdCBpcyBhIDJuZGFyeSBvcmlnaW4sIHVzZWQgd2l0aCBTYWZlRnJhbWVzIHRvIHJlbmRlciBjb250ZW50LiBGb3IgZXhhbXBsZSB0aGUgSFRNTCBmaWxlIGZvciByZW5kZXJpbmcgY29udGVudCBpbnRvIHdvdWxkIGJlbG9hZGVkIGZyb20gY29uZi5jZG4rXCIvXCIrY29uZi5yb290K1wiL1wiK2NvbmYudmVyc2lvbitcIi9cIitjb25mLnJlbmRlckZpbGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBjb25mLnJlbmRlckZpbGUgVGhlIGZpbGVuYW1lIChtYXkgYWxzbyBpbmNsdWRlIHBhdGggaW5mbyksIGZvciB3aGljaCB0byByZW5kZXIgY29udGVudCBpbnRvIHZpYSBhIFNhZmVGcmFtZS5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbY29uZi5tc2dGaWxlXSBUaGUgZmlsZW5hbWUgKG1heSBhbHNvIGluY2x1ZGUgcGF0aCBpbmZvKSwgZm9yIHdoaWNoIHRvIHVzZSBhcyBhIHByb3h5IGZvciB4LWRvbWFpbiBtZXNzYWdpbmcgd2hlbmV2ZXIgSFRNTDUgbWVzc2FnaW5nIGlzIG5vdCBhdmFpbGFibGUuIE9ubHkgcmVxdWlyZWQgaWYgc3VwcG9ydGluZyBvbGRlciBicm93c2Vycy5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbY29uZi50b10gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgU2FmZUZyYW1lIHRvIGZpbmlzaCByZW5kZXJpbmcsIGRlZmF1bHRzIHRvIDYwIHNlY29uZHMuXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZi5vbkJlZm9yZVBvc01zZ10gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgZmlyZWQgYmVmb3JlIGFueSBjYW5jZWxsYWJsZSBhY3Rpb24gaXMgcmVxdWVzdGVkIHRvIGJlIHBlZm9ybWVkIGZyb20gYSBhIFNhZmVGcmFtZSwgc3VjaCBhcyBleHBhbnNpb24sIGV0Yy4gIFJldHVybiB0cnVlIG91dCBvZiB0aGlzIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbmNlbC9kaXNhbGxvdyB0aGUgYWN0aW9uIGluIHF1ZXN0aW9uLlxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmYub25Qb3NNc2ddIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGZpcmVkIHdoZW4gYW4gYWN0aW9uIHJlcXVlc3RlZCBieSBhIFNhZmVGcmFtZSBpcyBwZXJmb3JtZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjb25mLm9uU3RhcnRQb3NSZW5kZXJdIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGZpcmVkIHdoZW4gYSBTYWZlRnJhbWUgc3RhcnRzIHRvIHJlbmRlciAzcmQgcGFydHkgY29udGVudC5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjb25mLm9uRW5kUG9zUmVuZGVyXSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBmaXJlZCB3aGVuIGEgU2FmZUZyYW1lIGZpbmlzaGVzIHJlbmRlcmluZyAzcmQgcGFydHkgY29udGVudC5cbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBbY29uZi5wb3NpdGlvbnNdIEEgbWFwIG9mIHBvc2l0aW9ucyB0byBhdXRvbWF0aWNhbGx5IGNvbmZpZ3VyZSwgd2hlcmUgZWFjaCBrZXkgZXF1YWxzIHRoZSBpZCBvZiB0aGUgJHNmLmhvc3QuUG9zQ29uZmlnIG9iamVjdCwgYW5kIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgY29udGFpbmluZyBzYWlkIG9iamVjdCdzIHNldHRpbmdzLlxuICAgICAgICovXG4gICAgICBDb25maWcgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgICAgIHZhciBib290X3VwLCBjb25mX3Bvc19tYXAsIG1lLCBwb3NJRCwgcG9zX2NvbmYsIHBvc19pZCwgcG9zX21hcDtcbiAgICAgICAgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gKGNvbmZpZyA/IF9taXgoe30sIGNvbmZpZykgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShtZSBpbnN0YW5jZW9mIENvbmZpZykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbmZpZyhjb25mKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICBjb25maWcgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJvb3RfdXAgPSAhIWNvbmZpZztcbiAgICAgICAgbWUuYXV0byA9IChcImF1dG9cIiBpbiBjb25mID8gX2Nib29sKGNvbmYuYXV0bykgOiB0cnVlKTtcbiAgICAgICAgbWUuY2RuID0gX2NzdHIoY29uZi5jZG4pO1xuICAgICAgICBtZS5kZWJ1ZyA9IF9jYm9vbChjb25mLmRlYnVnKTtcbiAgICAgICAgbWUucm9vdCA9IF9jc3RyKGNvbmYucm9vdCk7XG4gICAgICAgIG1lLnJlbmRlckZpbGUgPSBfY3N0cihjb25mLnJlbmRlckZpbGUpO1xuICAgICAgICBtZS5tc2dGaWxlID0gX2NzdHIoY29uZi5tc2dGaWxlKTtcbiAgICAgICAgbWUudG8gPSBfY251bShjb25mLnRvLCBERUZBVUxUX1JFTkRFUl9USU1FT1VUKTtcbiAgICAgICAgbWUudmVyID0gX2NzdHIoY29uZi52ZXIpIHx8IFZFUlNJT047XG4gICAgICAgIG1lLm9uQmVmb3JlUG9zTXNnID0gKF9jYWxsYWJsZShjb25mLm9uQmVmb3JlUG9zTXNnKSA/IGNvbmYub25CZWZvcmVQb3NNc2cgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uUG9zTXNnID0gKF9jYWxsYWJsZShjb25mLm9uUG9zTXNnKSA/IGNvbmYub25Qb3NNc2cgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uU3RhcnRQb3NSZW5kZXIgPSAoX2NhbGxhYmxlKGNvbmYub25TdGFydFBvc1JlbmRlcikgPyBjb25mLm9uU3RhcnRQb3NSZW5kZXIgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uRW5kUG9zUmVuZGVyID0gKF9jYWxsYWJsZShjb25mLm9uRW5kUG9zUmVuZGVyKSA/IGNvbmYub25FbmRQb3NSZW5kZXIgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uRmFpbHVyZSA9IChfY2FsbGFibGUoY29uZi5vbkZhaWx1cmUpID8gY29uZi5vbkZhaWx1cmUgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uQWRMb2FkID0gKF9jYWxsYWJsZShjb25mLm9uQWRMb2FkKSA/IGNvbmYub25BZExvYWQgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uUmVhZENvb2tpZSA9IChfY2FsbGFibGUoY29uZi5vblJlYWRDb29raWUpID8gY29uZi5vblJlYWRDb29raWUgOiBfbm9vcCk7XG4gICAgICAgIG1lLm9uV3JpdGVDb29raWUgPSAoX2NhbGxhYmxlKGNvbmYub25Xcml0ZUNvb2tpZSkgPyBjb25mLm9uV3JpdGVDb29raWUgOiBfbm9vcCk7XG4gICAgICAgIGNvbmZfcG9zX21hcCA9IGNvbmYucG9zaXRpb25zO1xuICAgICAgICBtZS5wb3NpdGlvbnMgPSBwb3NfbWFwID0ge307XG4gICAgICAgIGlmIChjb25mX3Bvc19tYXApIHtcbiAgICAgICAgICBmb3IgKHBvc0lEIGluIGNvbmZfcG9zX21hcCkge1xuICAgICAgICAgICAgcG9zX2NvbmYgPSBjb25mX3Bvc19tYXBbcG9zSURdO1xuICAgICAgICAgICAgaWYgKHBvc19jb25mICYmIHR5cGVvZiBwb3NfY29uZiA9PT0gT0JKKSB7XG4gICAgICAgICAgICAgIHBvc19pZCA9IHBvc0lEIHx8IHBvc19jb25mLmlkIHx8IF9ndWlkKFBPU19JRF9BVVRPX1BSRUZJWCk7XG4gICAgICAgICAgICAgIHBvc19tYXBbcG9zX2lkXSA9IG5ldyBQb3NDb25maWcocG9zX2NvbmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25maWcgPSBtZTtcbiAgICAgICAgYm9vdF91cCA9ICEhKGJvb3RfdXAgJiYgbWUuYXV0byAmJiAoc2YuaG9zdC5ib290ICE9IG51bGwpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYm9vdF91cCkge1xuICAgICAgICAgICAgc2YuaG9zdC5ib290KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHJldHVybiBfbWl4KHt9LCBjb25maWcpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENvbmZpZ3VyZSBhIHBhcnRpY3VhbGFyIHBvc2l0aW9uIGZvciByZW5kZXJpbmcgYSBTYWZlRnJhbWVcbiAgICAgIEVhY2ggJHNmLmhvc3QuUG9zQ29uZmlnIG9iamVjdCBoYXMgYW4gaWQgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdW5pcXVlLiAgQ3JlYXRpbmcgYSBuZXcgJHNmLmhvc3QuUG9zQ29uZmlnIHdpdGggYW4gaWQsIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICAgICAgdXNlZCByZXN1bHRzIGluIGNoYW5naW5nIHRoZSBvbGQgJHNmLmhvc3QuUG9zQ29uZmlnIHNldHRpbmdzLCBhbmQgY2FuIG9ubHkgYmUgZG9uZSBpZiB0aGUgU2FmZUZyYW1lcyBsaWJyYXJ5IGlzIG5vdCBidXN5LlxuICAgICAgQXV0b21hdGljYWxseSBhZHMgdG8gdGhlIHBvc2l0aW9uIG1hcCBvZiB0aGUgJHNmLmhvc3QuQ29uZmlnIG9iamVjdCBpZiBzYWlkIGNvbmZpZyBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LlBvc0NvbmZpZ1xuICAgICAgQHB1YmxpY1xuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHBvc0lEb3JPYmogVGhlIGlkIG9mIHRoZSAkc2YuaG9zdC5Qb3NDb25maWcgaW5zdGFuY2UsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBzZXR0aW5ncyB0aGF0IGFyZSB0byBiZSB1c2VkIGZvciB0aGUgaW5zdGFuY2UuXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouaWRdIFRoZSBpZCBvZiB0aGUgJHNmLmhvc3QuUG9zQ29uZmlnIGluc3RhbmNlLCBpZiBub3Qgc3BlY2lmaWVkIG9uZSB3aWxsIGJlIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLmRlc3RdIFRoZSBIVE1MIGVsZW1lbnQgaWQgYXR0cmlidXRlIG9mIHRoZSBIVE1MIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50IHdoZXJlIGEgU2FmZUZyYW1lIHdpbGwgYmUgcmVuZGVyZWQuIFNhaWQgZWxlbWVudCBNVVNUIGV4aXN0IHdpdGhpbiB0aGUgcGFnZSBwcmlvciB0byBhIHJlbmRlci5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5iZ10gVGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIHRvIGJlIHVzZWQgaW5zaWRlIHRoZSBTYWZlRnJhbWUuIERlZmF1bHQgZXF1YWxzIFwidHJhbnNwYXJlbnRcIi5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai50Z3RdIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgd2luZG93IHdoZXJlIGh5cGVybGlua3MgaW5zaWRlIGEgU2FmZUZyYW1lIHdpbGwgbmF2aWdhdGUgdG9vLi4uTm90ZSB0aGF0IFwiX3NlbGZcIiBpcyBub3QgYWxsb3dlZCBhbmQgYWx3YXlzIGNvbnZlcnRlZCB0byBcIl90b3BcIi4gQWxsb3dlZCB2YWx1ZXMgYXJlIGFueSBzdHJpbmcgdmFsdWUgbm90IHByZWZpeGVkIHdpdGggXCJfXCIsIG9yIFwiX3RvcFwiIG9yIFwiX2JsYW5rXCIuXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouY3NzXSBBIHN0cmluZyBvZiBDU1MgcnVsZXMsIG9yIGEgVVJMIHRoYXQgcG9pbnRzIHRvIGEgQ1NTIHN0eWxlIHNoZWV0IHRvIGJlIHVzZWQgaW5zaWRlIHRoZSBTYWZlRnJhbWVcbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbcG9zSURvck9iai53XSBUaGUgd2lkdGggb2YgdGhlIFNhZmVGcmFtZSwgc3BlY2lmaWVkIGluIHBpeGVscy4gQ2Fubm90IGJlIHNwZWNpZmllZCBpbiBlbSwgJSBvciBhbm90aGVyIHZhbHVlcy5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbcG9zSURvck9iai5oXSBUaGUgaGVpZ2h0IG9mIHRoZSBTYWZlRnJhbWUsIHNwZWNpZmllZCBpbiBwaXhlbHMuIENhbm5vdCBiZSBzcGVjaWZpZWQgaW4gZW0sICUgb3IgYW5vdGhlciB2YWx1ZXMuXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouc2l6ZV0gQSBzdHJpbmcgZm9ybWF0ZWQgYXMgXCJ3aWR0aFhoZWlnaHRcIiwgdGhhdCBkZWZpbmVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBTYWZlRnJhbWUuIFRoZSBkZWxpbWl0ZXIgY2hhcmFjdGVyIFwiWFwiIGlzIGNhbiBiZSBzcGVjaWZpZWQgYXMgbG93ZXIgb3IgdXBwZXIgY2FzZS5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai56XSBUaGUgei1pbmRleCBvZiB0aGUgU2FmZUZyYW1lLlxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtwb3NJRG9yT2JqLnN1cHBvcnRzXSBBbiBvYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgZm9yIHdoYXQgZmVhdHVyZXMvYWN0aW9ucyBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBTYWZlRnJhbWUsIGFuZCBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZSByZXByZXNlbnRzIGEgYm9vbGVhbiBkZXRlcmVtaW5nIHdoZXRoZXIgdGhhdCBmZWF0dXJlIGNhbiBiZSB1c2VkLiAgQ3VycmVudGx5IHN1cHBvcnRlZCBrZXlzIGFyZSBcImV4cC1vdnJcIiA9PSBTYWZlRnJhbWUgY2FuIGV4cGFuZCBpbiBvdmVybGF5IG1vZGUsIFwiZXhwLXB1c2hcIiA9PSBTYWZlRnJhbWUgY2FuIGV4cGFuZCBpbiBwdXNoIG1vZGUsIGFuZCBcImJnXCIgPT0gU2FmZUZyYW1lIGNhbiBjaGFuZ2UgdGhlIGJhY2tncm91bmQgb2YgdGhlIHB1Ymxpc2hlciAvIGhvc3QuXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2Rlc3RJRF0gVGhlIEhUTUwgZWxlbWVudCBpZCBhdHRyaWJ1dGUgb2YgdGhlIEhUTUwgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQgd2hlcmUgYSBTYWZlRnJhbWUgd2lsbCBiZSByZW5kZXJlZC4gU2FpZCBlbGVtZW50IE1VU1QgZXhpc3Qgd2l0aGluIHRoZSBwYWdlIHByaW9yIHRvIGEgcmVuZGVyLlxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtiYXNlQ29uZl0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhICRzZi5ob3N0LkNvbmZpZyBvYmplY3QgdG8gYXV0b21hdGljYWxseSB1c2UgLyBjcmVhdGUgZm9yIHRoZSBTYWZlRnJhbWVzIGxpYnJhcnkuIE5vdGUgdGhhdCBiYXNlQ29uZiBjYW4gb25seSBiZSB1c2VkIG9uZSB0aW1lLCBvdGhlcndpc2UgeW91IGhhdmUgdG8gdXNlIHRoZSAkc2YuaG9zdC5Db25maWcgb2JqZWN0IGRpcmVjdGx5LlxuICAgICAgICovXG4gICAgICBQb3NDb25maWcgPSBmdW5jdGlvbihwb3NJRG9yT2JqLCBkZXN0SUQsIGJhc2VDb25mKSB7XG4gICAgICAgIHZhciBtZSwgc3osIHN6X3NwbGl0LCB0eXA7XG4gICAgICAgIG1lID0gdGhpcztcbiAgICAgICAgdHlwID0gKHBvc0lEb3JPYmogJiYgdHlwZW9mIHBvc0lEb3JPYmopIHx8IFwiXCI7XG4gICAgICAgIGlmICghKG1lIGluc3RhbmNlb2YgUG9zQ29uZmlnKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUG9zQ29uZmlnKHBvc0lEb3JPYmosIGRlc3RJRCwgYmFzZUNvbmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXAgPT09IE9CSikge1xuICAgICAgICAgIG1lLmlkID0gX2NzdHIocG9zSURvck9iai5pZCk7XG4gICAgICAgICAgbWUuZGVzdCA9IF9jc3RyKHBvc0lEb3JPYmouZGVzdCB8fCBkZXN0SUQpO1xuICAgICAgICAgIG1lLmJnID0gX2NzdHIocG9zSURvck9iai5iZykgfHwgXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgIG1lLnRndCA9IF9jc3RyKHBvc0lEb3JPYmoudGd0KSB8fCBcIl90b3BcIjtcbiAgICAgICAgICBtZS5jc3MgPSBfY3N0cihwb3NJRG9yT2JqLmNzcyk7XG4gICAgICAgICAgbWUudyA9IF9jbnVtKHBvc0lEb3JPYmoudywgMCk7XG4gICAgICAgICAgbWUuaCA9IF9jbnVtKHBvc0lEb3JPYmouaCwgMCk7XG4gICAgICAgICAgbWUueiA9IF9jbnVtKHBvc0lEb3JPYmoueiwgMCk7XG4gICAgICAgICAgbWUucmVuZGVyRmlsZSA9IF9jc3RyKHBvc0lEb3JPYmoucmVuZGVyRmlsZSkgfHwgbnVsbDtcbiAgICAgICAgICBtZS5zdXBwb3J0cyA9IF9taXgoe30sIHBvc0lEb3JPYmouc3VwcG9ydHMgfHwgU1VQUE9SVFNfRkVBVFVSRVMsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGlmICghbWUudyB8fCAhbWUuaCkge1xuICAgICAgICAgICAgc3ogPSBfY3N0cihwb3NJRG9yT2JqLnNpemUpO1xuICAgICAgICAgICAgaWYgKHN6KSB7XG4gICAgICAgICAgICAgIHN6X3NwbGl0ID0gc3ouc3BsaXQoL3gvZyk7XG4gICAgICAgICAgICAgIG1lLncgPSBfY251bShzel9zcGxpdFswXSwgMCk7XG4gICAgICAgICAgICAgIG1lLmggPSBfY251bShzel9zcGxpdFsxXSwgMCk7XG4gICAgICAgICAgICAgIG1lLnNpemUgPSBzejtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lLnNpemUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zaXplID0gbWUudyArIFwieFwiICsgbWUuaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbWUuaWQgPSBfY3N0cihwb3NJRG9yT2JqKTtcbiAgICAgICAgICBtZS5kZXN0ID0gX2NzdHIoZGVzdElEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZS5kZXN0ID0gXCJcIjtcbiAgICAgICAgICBtZS5iZyA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICBtZS50Z3QgPSBcIl90b3BcIjtcbiAgICAgICAgICBtZS5jc3MgPSBcIlwiO1xuICAgICAgICAgIG1lLncgPSAwO1xuICAgICAgICAgIG1lLmggPSAwO1xuICAgICAgICAgIG1lLnNpemUgPSBcIlwiO1xuICAgICAgICAgIG1lLnogPSAwO1xuICAgICAgICAgIG1lLnN1cHBvcnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbWUuaWQgPSBtZS5pZCB8fCBfZ3VpZChQT1NfSURfQVVUT19QUkVGSVgpO1xuICAgICAgICBpZiAoIWNvbmZpZyAmJiBiYXNlQ29uZikge1xuICAgICAgICAgIENvbmZpZyhiYXNlQ29uZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgIGNvbmZpZy5wb3NpdGlvbnNbbWUuaWRdID0gbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9taXgoe30sIG1lKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDb25zdHJ1Y3QgYSBzZXQgb2YgZHluYW1pYyBrZXkvdmFsdWUgcGFpcnMgdGhhdCBjYW4gYmUgc2hhcmVkIGFzIG1ldGEtZGF0YSB3aXRoIHRoZSAzcmQgcGFydHkgY29udGVudCBpbnNpZGUgYSBTYWZlRnJhbWUuXG4gICAgICBBbGwgZGF0YSBpcyB0cmVhdGVkIGFzIHByb3RlY3RlZCwgYW5kIGNhbiBvbmx5IGJlIHNwZWNmaWVkIGR1cmluZyBjb25zdHJ1Y3Rpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICBcbiAgICAgIEBleHBvcnRzIFBvc01ldGEgYXMgJHNmLmhvc3QuUG9zTWV0YSNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICAgQGNsYXNzXG4gICAgICBAcGFyYW0ge09iamVjdH0gc2hhcmVkX29iamVjdCBBbiBvYmplY3QgY29udGFpbmluZyBrZXlzIGFuZCB2YWx1ZXMgdG8gYmUgc2hhcmVkIGFzIG1ldGEtZGF0YSBpbnNpZGUgdGhlIFNhZmVGcmFtZVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtvd25lcl9rZXldIEEga2V5IG5hbWUgdG8gYmUgdXNlZCB0byBob2xkIHBzZXVkbyBwcml2YXRlIGtleXMgLyB2YWx1ZXMgb2YgbWV0YSBkYXRhLlxuICAgICAgQHBhcmFtIHtPYmplY3R9IFtvd25lZF9vYmpdIEFuIG9iamVjdCBjb250YWluaW5nIHBzdWVkbyBwcml2YXRlIGtleXMgYW5kIHZhbHVlcyB0byBiZSBzaGFyZWQgYXMgbWV0YS1kYXRhIGluc2lkZSB0aGUgU2FmZUZyYW1lLlxuICAgICAgQGV4YW1wbGVcbiAgICAgIHZhciBzaGFyZWRfZGF0YSBcdFx0ID0ge2NvbnRlbnRfaWQ6ODk3ODA5OCxwYXJ0bmVyX2lkOjk5fSxcbiAgICAgIHByaXZhdGVfZGF0YV9rZXlcdCA9IFwicm14XCIsXG4gICAgICBwcml2YXRlX2RhdGEgICAgICA9IHtzZWN0aW9uX2lkOjIzNDIsc2l0ZV9pZDoyMzkwNH0sXG4gICAgICBtZXRhX2RhdGFcdFx0ID0gbmV3ICRzZi5ob3N0LlBvc01ldGEoc2hhcmVkX2RhdGEsIHByaXZhdGVfZGF0YV9rZXksIHByaXZhdGVfZGF0YSk7XG4gICAgICBcbiAgICAgIC8vc2hvdyBzZWN0aW9uIGlkIG9uIGhvc3Qgc2lkZVxuICAgICAgYWxlcnQobWV0YV9kYXRhLnZhbHVlKFwicm14XCIsIFwic2l0ZV9pZFwiKSk7IC8vPT0gMjM5MDRcbiAgICAgIFxuICAgICAgQGV4YW1wbGVcbiAgICAgIC8vbm93IHJldHJpZXZlIHRoaXMgaW5mb3JtYXRpb24gaW5zaWRlIHRoZSBzYWZlIGZyYW1lXG4gICAgICBcbiAgICAgIHZhciBjb250ZW50X2lkID0gJHNmLnZlbmQubWV0YShcImNvbnRlbnRfaWRcIik7IC8vPT0gODk3ODA5OFxuICAgICAgXG4gICAgICB2YXIgcm14X3NlY3Rpb25faWQgPSAkc2YudmVuZC5tZXRhKFwicm14XCIsIFwic2VjdGlvbl9pZFwiKSAvLz09IDIzNDIsIGJ1dCBub3RlIHRoYXQgdmVuZG9yIHNpZGUgY29kZSBtdXN0IGtub3cgdGhlIFwib3duZXJfa2V5XCIgdXBmcm9udC5cbiAgICAgICAqL1xuICAgICAgUG9zTWV0YSA9IGZ1bmN0aW9uKHNoYXJlZF9vYmosIG93bmVyX2tleSwgb3duZWRfb2JqKSB7XG5cbiAgICAgICAgLypcbiAgICAgICAgQSBtZXRob2QgcmV0cmlldmVzIGEgbWV0YSBkYXRhIHZhbHVlIGZyb20gdGhpcyBvYmplY3QuXG4gICAgICAgIFxuICAgICAgICBAZXhwb3J0cyBnZXRfdmFsdWUgYXMgJHNmLmhvc3QuUG9zTWV0YSN2YWx1ZVxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gcHJvcEtleSBUaGUgbmFtZSBvZiB0aGUgdmFsdWUgdG8gcmV0cmlldmVcbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IFtvd25lcl9rZXldIFRoZSBuYW1lIG9mIHRoZSBvd25lciBrZXkgb2YgdGhlIG1ldGEgZGF0YSB2YWx1ZS4gQnkgZGVmYXVsdCwgaXQgaXMgYXNzdW1lZCB0byBiZSBzaGFyZWQsIHNvIG5vdGhpbmcgbmVlZHMgdG8gYmUgcGFzc2VkIGluIHVubGVzcyBsb29raW5nIGZvciBhIHNwZWNpZmljIHByb3ByaWV0YXJ5IHZhbHVlXG4gICAgICAgIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ8Qm9vbGVhbn1cbiAgICAgICAgQGRlZmF1bHQge1N0cmluZ30gXCJcIlxuICAgICAgICBAcHVibGljXG4gICAgICAgIEBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGdldF92YWx1ZSwgbWUsIG5vbl9zaGFyZWQsIG9sZCwgcG9zQ29uZiwgc2VyaWFsaXplLCBzZXRfdmFsdWUsIHNoYXJlZDtcbiAgICAgICAgZ2V0X3ZhbHVlID0gZnVuY3Rpb24ocHJvcEtleSwgb3duZXJfa2V5KSB7XG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICByZXQgPSBcIlwiO1xuICAgICAgICAgIGlmICghcHJvcEtleSB8fCB0eXBlb2YgcHJvcEtleSAhPT0gU1RSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW93bmVyX2tleSB8fCB0eXBlb2Ygb3duZXJfa2V5ICE9PSBTVFIpIHtcbiAgICAgICAgICAgIG93bmVyX2tleSA9IFwic2hhcmVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvd25lcl9rZXkgPT09IFwic2hhcmVkXCIpIHtcbiAgICAgICAgICAgIHJldCA9IHNoYXJlZFtwcm9wS2V5XSB8fCBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSAocHJvcEtleSBpbiBub25fc2hhcmVkID8gbm9uX3NoYXJlZFtwcm9wX2tleV0gfHwgXCJcIiA6IFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgIFJldHVybiBhIHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIChpbiB1cmwgcXVlcnkgc3RyaW5nIGZvcm1hdCkgb2YgdGhlIG1ldGEgZGF0YSBvYmplY3RcbiAgICAgICAgXG4gICAgICAgIEBleHBvcnRzIHNlcmlhbGl6ZSBhcyAkc2YuaG9zdC5Qb3NNZXRhI3RvU3RyaW5nXG4gICAgICAgIEBmdW5jdGlvblxuICAgICAgICBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBzZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgb2JqO1xuICAgICAgICAgIG9iaiA9IG5ldyBQYXJhbUhhc2goKTtcbiAgICAgICAgICBvYmouc2hhcmVkID0gc2hhcmVkO1xuICAgICAgICAgIG9iai5ub25fc2hhcmVkID0gbm9uX3NoYXJlZDtcbiAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHNldF92YWx1ZSA9IGZ1bmN0aW9uKHByb3BLZXksIG93bmVyS2V5LCB2YWx1ZSkge1xuICAgICAgICAgIG5vbl9zaGFyZWRbb3duZXJLZXldIHx8IChub25fc2hhcmVkW293bmVyS2V5XSA9IHt9KTtcbiAgICAgICAgICByZXR1cm4gbm9uX3NoYXJlZFtvd25lcktleV1bcHJvcEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgbWUgPSB0aGlzO1xuICAgICAgICBzaGFyZWQgPSB2b2lkIDA7XG4gICAgICAgIG5vbl9zaGFyZWQgPSB2b2lkIDA7XG4gICAgICAgIG9sZCA9IHZvaWQgMDtcbiAgICAgICAgcG9zQ29uZiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQb3NNZXRhKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUG9zTWV0YShrZXksIG93bmVkX29iaiwgcG9zLCBzaGFyZWRfb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFyZWQgPSB7fTtcbiAgICAgICAgbm9uX3NoYXJlZCA9IHt9O1xuICAgICAgICBpZiAoIW93bmVyX2tleSB8fCB0eXBlb2Ygb3duZXJfa2V5ICE9PSBTVFIpIHtcbiAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlZF9vYmogJiYgdHlwZW9mIHNoYXJlZF9vYmogPT09IE9CSikge1xuICAgICAgICAgIHNoYXJlZCA9IF9taXgoc2hhcmVkLCBzaGFyZWRfb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3duZWRfb2JqICYmIHR5cGVvZiBvd25lZF9vYmogPT09IE9CSikge1xuICAgICAgICAgIG5vbl9zaGFyZWRbb3duZXJfa2V5XSA9IG93bmVkX29iajtcbiAgICAgICAgfVxuICAgICAgICBtZS50b1N0cmluZyA9IHNlcmlhbGl6ZTtcbiAgICAgICAgbWUudmFsdWUgPSBnZXRfdmFsdWU7XG4gICAgICAgIG1lLnNldFZhbHVlID0gc2V0X3ZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENyZWF0ZSB0aGUgSFRNTCBtYXJrdXAgZm9yIGEgcG9zaXRpb24gaWYgYSBzcmMgcHJvcGVydHkgd2FzIHVzZWRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2NyZWF0ZV9wb3NfbWFya3VwXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIF9jcmVhdGVfcG9zX21hcmt1cCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB2YXIgY2tWYWwsIGZWZXI7XG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoXCIke3NmX3Zlcn1cIikgPiAtMSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcJHtzZl92ZXJ9L2csICRzZi52ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoXCIke2NrX29ufVwiKSA+IC0xKSB7XG4gICAgICAgICAgICBja1ZhbCA9IChfY29va2llc19lbmFibGVkX3Rlc3QoKSA/IFwiMVwiIDogXCIwXCIpO1xuICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcJHtja19vbn0vZywgY2tWYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoXCIke2ZsYXNoX3Zlcn1cIikgPiAtMSkge1xuICAgICAgICAgICAgZlZlciA9IF9nZXRfZmxhc2hfdmVyc2lvbigpO1xuICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcJHtmbGFzaF92ZXJ9L2csIGZWZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2NzdHIoW1wiPHNjclwiLCBcImlwdCB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnLCBzcmM9J1wiLCBzcmMsIFwiJz48L3NjclwiLCBcImlwdD5cIl0pO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEdldCB0aGUgZmFsc2ggdmVyc2lvbiBudW1iZXJcbiAgICAgICAqL1xuICAgICAgX2dldF9mbGFzaF92ZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlcnIsIGdldEFjdGl2ZVhWZXJzaW9uLCBpLCBtaW1lVHlwZXMsIG9iaiwgcCwgdG1wVmVyO1xuICAgICAgICBpZiAoZmxhc2hfdmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZsYXNoX3ZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF2aWdhdG9yLnBsdWdpbnMgJiYgbmF2aWdhdG9yLnBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG1pbWVUeXBlcyA9IG5hdmlnYXRvci5taW1lVHlwZXM7XG4gICAgICAgICAgaWYgKG1pbWVUeXBlcyAmJiBtaW1lVHlwZXNbRkxBU0hfTUlNRV0gJiYgbWltZVR5cGVzW0ZMQVNIX01JTUVdLmVuYWJsZWRQbHVnaW4gJiYgbWltZVR5cGVzW0ZMQVNIX01JTUVdLmVuYWJsZWRQbHVnaW4uZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZsYXNoX3ZlciA9IG1pbWVUeXBlc1tGTEFTSF9NSU1FXS5lbmFibGVkUGx1Z2luLnZlcnNpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNmLmVudi5pc0lFKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCBmbGFzaEFjdGl2ZVhWZXJzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG9iaiA9IG5ldyBBY3RpdmVYT2JqZWN0KGZsYXNoQWN0aXZlWFZlcnNpb25zW2ldKTtcbiAgICAgICAgICAgICAgdG1wVmVyID0gb2JqLkdldFZhcmlhYmxlKFwiJHZlcnNpb25cIik7XG4gICAgICAgICAgICAgIHAgPSB0bXBWZXIuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICAgIGlmIChwID4gLTEpIHtcbiAgICAgICAgICAgICAgICBmbGFzaF92ZXIgPSB0bXBWZXIuc3Vic3RyKHAgKyAxKS5yZXBsYWNlKC8sL2csIFwiLlwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFzaF92ZXIgPSB0bXBWZXIucmVwbGFjZSgvLC9nLCBcIi5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICAgICAgICBmbGFzaF92ZXIgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhc2hfdmVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhc2hfdmVyO1xuICAgICAgICBnZXRBY3RpdmVYVmVyc2lvbiA9IGZ1bmN0aW9uKGFjdGl2ZVhPYmopIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbjtcbiAgICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBhY3RpdmVYT2JqLkdldFZhcmlhYmxlKFwiJHZlcnNpb25cIik7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFRlc3QgdG8gc2VlIGlmIGNvb2tpZXMgYXJlIGVuYWJsZWRcbiAgICAgICAqL1xuICAgICAgX2Nvb2tpZXNfZW5hYmxlZF90ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb29raWVFbmFibGVkO1xuICAgICAgICBjb29raWVFbmFibGVkID0gKG5hdmlnYXRvci5jb29raWVFbmFibGVkID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IuY29va2llRW5hYmxlZCA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhY29va2llRW5hYmxlZCkge1xuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IFwidGVzdGNvb2tpZVwiO1xuICAgICAgICAgIGNvb2tpZUVuYWJsZWQgPSAoZG9jdW1lbnQuY29va2llLmluZGV4T2YoXCJ0ZXN0Y29va2llXCIpICE9PSAtMSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICAgICAgbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQgPSBjb29raWVFbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llRW5hYmxlZDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDb25zdHJ1Y3Rpb24gYSBwb3N0aW9uIGNvbnRlbnQgb2JqZWN0IHRoYXQgY29udGFpbnMgSFRNTCwgb3B0aW9uYWxseSBtZXRhLWRhdGEsIGFuZCBvcHRpb25hbGx5IGEgcG9zaXRpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAgICBUaGUgaWQgc3BlY2lmaWVkIG11c3QgbWF0Y2ggYW4gaWQgZm9yIGEgJHNmLmhvc3QuUG9zQ29uZmlnIChhbHRob3VnaCBzYWlkIGNvbmZpZyBjb3VsZCBiZSBzcGVjZmllZCBkaXJlY3RseSBoZXJlIHZpYSBhcmd1bWVudHMpLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC5Qb3NpdGlvblxuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICBAcHVibGljXG4gICAgICBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHBvc0lEb3JPYmogVGhlIGlkIG9mIHRoZSBwb3NpdGlvbiB3aGljaCBtYXBzIHRvIGl0cyBjb25maWd1cmF0aW9uLCBvciBhbiBvYmplY3QgcmVwcmVzZXRpbmcgdGhlIHZhcmlvdXMgdmFsdWVzIG9mIGFuICRzZi5ob3N0LlBvc2l0aW9uIGluc3RhbmNlLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtwb3NJRG9yT2JqLmlkXSBUaGUgaWQgb2YgdGhlIHBvc2l0aW9uIHdoaWNoIG1hcHMgdG8gaXRzIGNvbmZpZ3VyYXRpb24uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW3Bvc0lEb3JPYmouaHRtbF0gVGhlIEhUTUwgY29udGVudCB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIFNhZmVGcmFtZS4gTm90ZSB0aGF0IEhUTUwgc3RyaW5ncyB3aGljaCBoYXZlIFNDUklQVCB0YWdzIG9yIG90aGVyIHNwZWNpYWwgY2hhcmFjdGVycyBtYXkgbmVlZCB0byBiZSBwcm9wZXJseSBlc2NhcGVkIGluIG9yZGVyIHRvIGF2b2lkIEphdmFTY3JpcHQgc3ludGF4IGVycm9ycy5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbcG9zSURvck9iai5zcmNdIEFuIG9wdGlvbmFsIFVSTCB0byBiZSB1c2VkIGZvciByZWRlcmluZyBpbnNpZGUgdGhlIFNhZmVGcmFtZSB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSBTQ1JJUFQgdGFnIHdpdGggdGhlIHNwZWNpZmllZCBVUkwuXG4gICAgICBAcGFyYW0geyRzZi5ob3N0LlBvc01ldGF9IFtwb3NJRG9yT2JqLm1ldGFdIEFuIG9wdGlvbmFsIGluc3RhbmNlIG9mIHRoZSAkc2YuaG9zdC5Qb3NNZXRhIG9iamVjdCB0byBiZSBwYXNzZWQgYWxvbmcgaW50byB0aGUgU2FmZUZyYW1lXG4gICAgICBAcGFyYW0ge09iamVjdH0gW3Bvc0lEb3JPYmouY29uZl0gQW4gb3B0aW9uYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gJHNmLmhvc3QuUG9zQ29uZmlnIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgU2FmZUZyYW1lIHBvc2l0aW9uLlxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtodG1sXSBUaGUgSFRNTCBjb250ZW50IHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgU2FmZUZyYW1lLiBOb3RlIHRoYXQgSFRNTCBzdHJpbmdzIHdoaWNoIGhhdmUgU0NSSVBUIHRhZ3Mgb3Igb3RoZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIG1heSBuZWVkIHRvIGJlIHByb3Blcmx5IGVzY2FwZWQgaW4gb3JkZXIgdG8gYXZvaWQgSmF2YVNjcmlwdCBzeW50YXggZXJyb3JzLlxuICAgICAgQHBhcmFtIHskc2YuaG9zdC5Qb3NNZXRhfSBbbWV0YV0gQW4gb3B0aW9uYWwgaW5zdGFuY2Ugb2YgdGhlICRzZi5ob3N0LlBvc01ldGEgb2JqZWN0IHRvIGJlIHBhc3NlZCBhbG9uZyBpbnRvIHRoZSBTYWZlRnJhbWVcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBbY29uZl0gQW4gb3B0aW9uYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gJHNmLmhvc3QuUG9zQ29uZmlnIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgU2FmZUZyYW1lIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc0lEb3JPYmosIGh0bWwsIG1ldGEsIGNvbmYpIHtcbiAgICAgICAgdmFyIGlkLCBtZSwgbXNnLCBvcmlnSHRtbCwgdHlwO1xuICAgICAgICBtZSA9IHRoaXM7XG4gICAgICAgIHR5cCA9IHBvc0lEb3JPYmogJiYgdHlwZW9mIHBvc0lEb3JPYmo7XG4gICAgICAgIG9yaWdIdG1sID0gaHRtbDtcbiAgICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQb3NpdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc0lEb3JPYmosIGh0bWwsIG1ldGEsIGNvbmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCkge1xuICAgICAgICAgIG1zZyA9IFwiUHVibGlzaGVyIENvbmZpZyBub3QgaW5pdGlhbGl6ZWQgLSBhYm9ydFwiO1xuICAgICAgICAgIHNmLmxpYi5sb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICBzZi5pbmZvLmVycnMucHVzaChtc2cpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwID09PSBPQkopIHtcbiAgICAgICAgICBfbWl4KG1lLCBwb3NJRG9yT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IG1lLmlkID0gX2NzdHIocG9zSURvck9iaikgfHwgX2d1aWQoUE9TX0lEX0FVVE9fUFJFRklYKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWh0bWwpIHtcbiAgICAgICAgICBpZiAobWUuc3JjKSB7XG4gICAgICAgICAgICBtZS5odG1sID0gX2NyZWF0ZV9wb3NfbWFya3VwKG1lLnNyYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmh0bWwgPSBtZS5odG1sIHx8IFwiXCI7XG4gICAgICAgICAgICBtZS5zcmMgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZS5odG1sID0gaHRtbDtcbiAgICAgICAgICBtZS5zcmMgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWUuaHRtbCkge1xuICAgICAgICAgIG1lLmh0bWwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIG1lLm1ldGEgPSBtZXRhIHx8IG1lLm1ldGEgfHwge307XG4gICAgICAgIG1lLmNvbmYgPSBjb25mIHx8IG1lLmNvbmYgfHwge307XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLnBvc2l0aW9uc1tpZF0pIHtcbiAgICAgICAgICAgIG1lLmNvbmYgPSBjb25maWcucG9zaXRpb25zW2lkXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgY29uZi5pZCA9IGlkO1xuICAgICAgICAgICAgICBtZS5jb25mID0gbmV3IFBvc0NvbmZpZyhjb25mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBAbmFtZXNwYWNlICRzZi5saWIuZG9tLm1zZ2hvc3QgQ29udGFpbnMgZnVuY3Rpb25hbGl0eSB0byByZXNpZGUgaW4gdGhlIHRvcCBsZXZlbCBwYWdlIGZvciBzZW5kaW5nIGFuZCByZWNlaXZpbmcgeC1kb21haW4gbWVzc2FnZXMgdG8gU2FmZUZyYW1lIGNvbnRhaW5lcnNcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3RcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJucyB0aGUgcm9vdCBkb2N1bWVudCBIVE1MRWxlbWVudCAvIG5vZGVcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLV9kb2NOb2RlXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIEFuIEhUTUxFbGVtZW50IHRvIHVzZSBhcyBhIHJlZmVyZW5jZSBmb3IgZmluZGluZyB0aGUgcm9vdCBkb2N1bWVudCBlbGVtZW50LlxuICAgICAgQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICBfZG9jTm9kZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBjb21wYXRNb2RlLCBkLCByb290O1xuICAgICAgICBkID0gKGVsICYmIF9kb2MoZWwpKSB8fCBkYztcbiAgICAgICAgY29tcGF0TW9kZSA9IGRbQ09NUEFUX01PREVdO1xuICAgICAgICByb290ID0gZFtET0NfRUxdO1xuICAgICAgICBpZiAoY29tcGF0TW9kZSAmJiAhb3BlcmFWZXIgJiYgY29tcGF0TW9kZSAhPT0gXCJDU1MxQ29tcGF0XCIpIHtcbiAgICAgICAgICByb290ID0gZC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybnMgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgaW4gcGl4ZWxzXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS1faXNQWFxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHZhbCBBIGNzcyB2YWx1ZSBvZiBzaXplXG4gICAgICBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX2lzUFggPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gX2NzdHIodmFsKTtcbiAgICAgICAgaWYgKHZhbCAmJiB2YWwuc2VhcmNoKC9cXEQrL2cpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgJiYgdmFsLnNlYXJjaCgvcHgvZykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm4gYW4gYXJyYXkgb2YgdmFsdWVzIG9mIGNsaXBwaW5nIHJlZ2lvbiBpbmZvcm1hdGlvbi4gQXJyYXkgcmVwcmVzZW50cyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgdmFsdWVzIHJlc3BlY3RpdmVseS5cbiAgICAgIElmIHZhbHVlcyBhcmUgbm90IHNwZWNpZmllZCBpbiBwaXhlbHMsIG9yIG5vIGNsaXAgcmVnaW9uIGlzIGRlZmluZWQgZm9yIHRoYXQgZWxlbWVudCwgLTEgaXMgcmV0dXJuZWQgZm9yIGVhY2ggdmFsdWUuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLV9nZXRDbGlwXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAc3RhdGljXG4gICAgICBAcGFyYW0ge0hUTUxTdHlsZU9iamVjdH0gY3VyU3QgVGhlIGN1cnJlbnQgc3R5bGUgb2JqZWN0IG9mIGFuIEhUTUxFbGVtZW50XG4gICAgICBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgX2dldENsaXAgPSBmdW5jdGlvbihjdXJTdCkge1xuICAgICAgICB2YXIgY2xpcFZhbCwgaWR4LCBsZW4sIHByb3AsIHByb3BzLCByZXQsIHZhbDtcbiAgICAgICAgcmV0ID0gWy0xLCAtMSwgLTEsIC0xXTtcbiAgICAgICAgcHJvcHMgPSBbQ0xJUCArIFwiVG9wXCIsIENMSVAgKyBcIlJpZ2h0XCIsIENMSVAgKyBcIkJvdHRvbVwiLCBDTElQICsgXCJMZWZ0XCJdO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBjbGlwVmFsID0gdm9pZCAwO1xuICAgICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgICB2YWwgPSB2b2lkIDA7XG4gICAgICAgIGxlbiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKCFjdXJTdCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGllVmVyKSB7XG4gICAgICAgICAgd2hpbGUgKHByb3AgPSBwcm9wc1tpZHhdKSB7XG4gICAgICAgICAgICBjbGlwVmFsID0gY3VyU3RbcHJvcF07XG4gICAgICAgICAgICBpZiAoX2lzUFgoY2xpcFZhbCkpIHtcbiAgICAgICAgICAgICAgY2xpcFZhbCA9IF9jbnVtKGNsaXBWYWwsIC0xKTtcbiAgICAgICAgICAgICAgaWYgKGNsaXBWYWwgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldFtpZHhdID0gY2xpcFZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaXBWYWwgPSBjdXJTdFtDTElQXTtcbiAgICAgICAgICBpZiAoY2xpcFZhbCAmJiBjbGlwVmFsLnNlYXJjaCgvXFxkKy9nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNsaXBWYWwgPSBjbGlwVmFsLnJlcGxhY2UoL1xcdytcXCgoW15cXCldKj8pXFwpL2csIFwiJDFcIik7XG4gICAgICAgICAgICByZXQgPSBjbGlwVmFsLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgIHJldCA9IChyZXRbTEVOXSA8PSAxID8gcmV0LnNwbGl0KFwiLFwiKSA6IHJldCk7XG4gICAgICAgICAgICBsZW4gPSByZXRbTEVOXTtcbiAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgdmFsID0gcmV0W2lkeF07XG4gICAgICAgICAgICAgIGlmICghX2lzUFgodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldFtpZHhdID0gLTE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0W2lkeF0gPSBfY251bSh2YWwsIC0xKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm5zIGJvcmRlciB2YWx1ZXMgaW4gcGl4ZWxzIGlmIHBvc3NpYmxlIHRvIGhlbHAgY2FsY3VsYXRlIGdlb21ldHJ5IG9mIGFuIGVsZW1lbnRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20tX2NhbGNCb3JkZXJzXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTEVsZW1lbnQgZm9yIHdoaWNoIHRvIGxvb2sgYXQuIC4gLlxuICAgICAgQHBhcmFtIHtPYmplY3R9IHJlY3QgVGhlIHJlY3Qgb2JqZWN0IGdlbmVyYXRlZCBmb3IgdGhlIEhUTUxFbGVtZW50IGluIHF1ZXN0aW9uIHRvIGJlIGFkanVzdGVkXG4gICAgICBAcmV0dXJucyB7T2JqZWN0fSByZWN0XG4gICAgICAgKi9cbiAgICAgIF9jYWxjQm9yZGVycyA9IGZ1bmN0aW9uKGVsLCByZWN0KSB7XG4gICAgICAgIHZhciBsLCByZSwgc3QsIHQ7XG4gICAgICAgIHQgPSAwO1xuICAgICAgICBsID0gMDtcbiAgICAgICAgc3QgPSB2b2lkIDA7XG4gICAgICAgIHJlID0gL150KD86YWJsZXxkfGh8cnxoZWFkfGZvb3QpJC9pO1xuICAgICAgICBzdCA9IGN1cnJlbnRTdHlsZShlbCk7XG4gICAgICAgIGlmIChzdCkge1xuICAgICAgICAgIHQgPSBzdFtcImJvcmRlclRvcFdpZHRoXCJdO1xuICAgICAgICAgIGwgPSBzdFtcImJvcmRlckxlZnRXaWR0aFwiXTtcbiAgICAgICAgICB0ID0gKF9pc1BYKHQpID8gX2NudW0odCwgMCkgOiAwKTtcbiAgICAgICAgICBsID0gKF9pc1BYKGwpID8gX2NudW0obCwgMCkgOiAwKTtcbiAgICAgICAgICBpZiAoZ2Vja1ZlciAmJiByZS50ZXN0KF90YWdOYW1lKGVsKSkpIHtcbiAgICAgICAgICAgIHQgPSBsID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IHJlY3QgfHwge1xuICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgbDogMFxuICAgICAgICB9O1xuICAgICAgICByZWN0LnQgKz0gdDtcbiAgICAgICAgcmVjdC5sICs9IGw7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHJpZXZlIHNjcm9sbCB2YWx1ZXMgb2YgYSBkb2N1bWVudFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS1fZ2V0X2RvY19zY3JvbGxcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQW4gSFRNTEVsZW1lbnQgdG8gdXNlIGFzIGEgcmVmZXJlbmNlIGRvY3VtZW50IHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IG1haW4gZG9jdW1lbnRcbiAgICAgIEByZXR1cm4ge09iamVjdH0gQ29udGFpbnMgeCwgeSwgdywgaCBwcm9wZXJ0aWVzIGZvciBzY3JvbGxpbmdcbiAgICAgICAqL1xuICAgICAgX2dldF9kb2Nfc2Nyb2xsID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGQsIGRiLCBkZSwgZGVmLCBkdiwgb2Zmc2V0WCwgb2Zmc2V0WSwgcG9zO1xuICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgaDogMFxuICAgICAgICB9O1xuICAgICAgICBkZWYgPSB7XG4gICAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgICAgc2Nyb2xsV2lkdGg6IDAsXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGQgPSB2b2lkIDA7XG4gICAgICAgIGRlID0gdm9pZCAwO1xuICAgICAgICBkdiA9IHZvaWQgMDtcbiAgICAgICAgZGIgPSB2b2lkIDA7XG4gICAgICAgIG9mZnNldFggPSAwO1xuICAgICAgICBvZmZzZXRZID0gMDtcbiAgICAgICAgZCA9IF9kb2MoZWwpIHx8IGRjO1xuICAgICAgICBkZSA9IGRbRE9DX0VMXSB8fCBkZWY7XG4gICAgICAgIGRiID0gZC5ib2R5IHx8IGRlZjtcbiAgICAgICAgZHYgPSBkLmRlZmF1bHRWaWV3O1xuICAgICAgICBpZiAoZHYpIHtcbiAgICAgICAgICBvZmZzZXRYID0gX2NudW0oZHYucGFnZVhPZmZzZXQsIDApO1xuICAgICAgICAgIG9mZnNldFkgPSBfY251bShkdi5wYWdlWU9mZnNldCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zLnggPSBfbWF4KGRlLnNjcm9sbExlZnQsIGRiLnNjcm9sbExlZnQsIG9mZnNldFgpO1xuICAgICAgICBwb3MueSA9IF9tYXgoZGUuc2Nyb2xsVG9wLCBkYi5zY3JvbGxUb3AsIG9mZnNldFkpO1xuICAgICAgICBwb3MudyA9IF9tYXgoZGUuc2Nyb2xsV2lkdGgsIGRiLnNjcm9sbFdpZHRoLCAwKTtcbiAgICAgICAgcG9zLmggPSBfbWF4KGRlLnNjcm9sbEhlaWdodCwgZGIuc2Nyb2xsSGVpZ2h0LCAwKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDYWxjdWxhdGUgYSBnZW9tZXRyaWMgcmVjdGFuZ2xlIGZvciBhIGdpdmVuIGVsZW1lbnQuIE5vdGUgdGhhdCBmb3IgSUUgYnJvd3NlcnNcbiAgICAgIHdlIGNhbiB1c2UgdGhlIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgZnVuY3Rpb24gd2hpY2ggc2F2ZXMgdXMgc29tZSB0aW1lIC8gaW5jcmVhc2VzXG4gICAgICBwZWZvcm1hbmNlLiAuIGhvd2V2ZXIgaXQgcmVhbGx5IGNhbiBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgRE9NIGlzIGNvbXBsZXRlbHkgbG9hZGVkLFxuICAgICAgYW5kIGlmIHRoYXQgaXMgdGhlIGNhc2Ugd2UgZmFsbGJhY2sgdG8gdGhlIGJydXRlLWZvcmNlIC8gbm9uLUlFIG1ldGhvZC5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20tX2dldFJlY3RJRVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgIFRoZSBlbGVtZW50IGZvciB3aGljaCB0byBkZXJpdmUgYSByZWN0YW5nbGUgb2JqZWN0XG4gICAgICBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZWN0YW5nbGUgZm9yIHRoZSBnaXZlbiBIVE1MRWxlbWVudFxuICAgICAgICovXG4gICAgICBfZ2V0UmVjdElFID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGFkanVzdFgsIGFkanVzdFksIGJMZWZ0LCBiVG9wLCBib3gsIGNvbXBhdE1vZGUsIGQsIGRlLCBlLCByZWN0LCBzY3JvbGwsIHN0LCBfYmFjaztcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICB0OiAwLFxuICAgICAgICAgIGw6IDAsXG4gICAgICAgICAgcjogMCxcbiAgICAgICAgICBiOiAwLFxuICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgaDogMCxcbiAgICAgICAgICB6OiAwXG4gICAgICAgIH07XG4gICAgICAgIF9iYWNrID0gXCJCYWNrQ29tcGF0XCI7XG4gICAgICAgIHNjcm9sbCA9IHZvaWQgMDtcbiAgICAgICAgYm94ID0gdm9pZCAwO1xuICAgICAgICBkID0gdm9pZCAwO1xuICAgICAgICBkZSA9IHZvaWQgMDtcbiAgICAgICAgY29tcGF0TW9kZSA9IHZvaWQgMDtcbiAgICAgICAgc3QgPSB2b2lkIDA7XG4gICAgICAgIGFkanVzdFggPSB2b2lkIDA7XG4gICAgICAgIGFkanVzdFkgPSB2b2lkIDA7XG4gICAgICAgIGJMZWZ0ID0gdm9pZCAwO1xuICAgICAgICBiVG9wID0gdm9pZCAwO1xuICAgICAgICBpZiAoZWwgJiYgZWxbTk9ERV9UWVBFXSA9PT0gMSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkID0gX2RvYyhlbCkgfHwgZGM7XG4gICAgICAgICAgICBpZiAoIWRvbS5yZWFkeSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0UmVjdE5vbklFKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcm9sbCA9IF9nZXRfZG9jX3Njcm9sbChlbCk7XG4gICAgICAgICAgICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJlY3QudCA9IGJveC50b3A7XG4gICAgICAgICAgICByZWN0LmwgPSBib3gubGVmdDtcbiAgICAgICAgICAgIGFkanVzdFggPSBhZGp1c3RZID0gSUVfQk9SREVSX0FESjtcbiAgICAgICAgICAgIGNvbXBhdE1vZGUgPSBkW0NPTVBBVF9NT0RFXTtcbiAgICAgICAgICAgIGRlID0gZFtET0NfRUxdO1xuICAgICAgICAgICAgc3QgPSBjdXJyZW50U3R5bGUoZGUpO1xuICAgICAgICAgICAgYkxlZnQgPSBzdFtcImJvcmRlckxlZnRXaWR0aFwiXTtcbiAgICAgICAgICAgIGJUb3AgPSBzdFtcImJvcmRlclRvcFdpZHRoXCJdO1xuICAgICAgICAgICAgaWYgKGllVmVyID09PSA2KSB7XG4gICAgICAgICAgICAgIGlmIChjb21wYXRNb2RlICE9PSBfYmFjaykge1xuICAgICAgICAgICAgICAgIGFkanVzdFggPSBhZGp1c3RZID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhdE1vZGUgPT09IF9iYWNrKSB7XG4gICAgICAgICAgICAgIGJMZWZ0ID0gKF9pc1BYKGJMZWZ0KSA/IF9jbnVtKGJMZWZ0LCAwKSA6IDApO1xuICAgICAgICAgICAgICBhZGp1c3RYID0gYkxlZnQ7XG4gICAgICAgICAgICAgIGJUb3AgPSAoX2lzUFgoYlRvcCkgPyBfY251bShiVG9wLCAwKSA6IDApO1xuICAgICAgICAgICAgICBhZGp1c3RZID0gYlRvcDtcbiAgICAgICAgICAgICAgcmVjdC50IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgIHJlY3QubCAtPSBhZGp1c3RZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdC50ICs9IHNjcm9sbC55O1xuICAgICAgICAgICAgcmVjdC5sICs9IHNjcm9sbC54O1xuICAgICAgICAgICAgcmVjdC5iID0gcmVjdC50ICsgZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgcmVjdC5yID0gcmVjdC5sICsgZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICByZWN0LncgPSBfbWF4KHJlY3QuciAtIHJlY3QubCwgMCk7XG4gICAgICAgICAgICByZWN0LmggPSBfbWF4KHJlY3QuYiAtIHJlY3QudCwgMCk7XG4gICAgICAgICAgICByZWN0LnogPSBjdXJyZW50U3R5bGUoZWwsIFwiekluZGV4XCIpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgICAgIGw6IDAsXG4gICAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgICAgIGg6IDAsXG4gICAgICAgICAgICAgIHo6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENhbGN1bGF0ZSBhIGdlb21ldHJpYyByZWN0YW5nbGUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gRm9yIG5vbi1JRSBicm93c2Vycywgd2UgbXVzdCB1c2VcbiAgICAgIGJydXRlLWZvcmNlIGFuZCB3YWxrIHVwIHRoZSBvZmZzZXRQYXJlbnQgdHJlZS4gQWxzbyB0YWtlcyBpbiBjb25zaWRlcmF0aW9uIGZvciBzb21lXG4gICAgICBvdGhlciBzbGlnaHQgdmFyaWF0aW9ucyBpbiBicm93c2Vycy5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20tX2dldFJlY3ROb25JRVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgIFRoZSBlbGVtZW50IGZvciB3aGljaCB0byBkZXJpdmUgYSByZWN0YW5nbGUgb2JqZWN0XG4gICAgICBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZWN0YW5nbGUgZm9yIHRoZSBnaXZlbiBIVE1MRWxlbWVudFxuICAgICAgICovXG4gICAgICBfZ2V0UmVjdE5vbklFID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGJDaGVjaywgZSwgaCwgcGFyZW50Tm9kZSwgcmVjdCwgcm9vdCwgc2Nyb2xsLCBzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHc7XG4gICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgdDogMCxcbiAgICAgICAgICBsOiAwLFxuICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgYjogMCxcbiAgICAgICAgICB3OiAwLFxuICAgICAgICAgIGg6IDAsXG4gICAgICAgICAgejogMFxuICAgICAgICB9O1xuICAgICAgICBzY3JvbGxUb3AgPSAwO1xuICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgYkNoZWNrID0gZmFsc2U7XG4gICAgICAgIHJvb3QgPSBfZG9jTm9kZShlbCk7XG4gICAgICAgIHNjcm9sbCA9IF9nZXRfZG9jX3Njcm9sbChlbCk7XG4gICAgICAgIHBhcmVudE5vZGUgPSB2b2lkIDA7XG4gICAgICAgIHcgPSB2b2lkIDA7XG4gICAgICAgIGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChlbCAmJiBlbFtOT0RFX1RZUEVdID09PSAxKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlY3QubCA9IGVsLm9mZnNldExlZnQgfHwgMDtcbiAgICAgICAgICAgIHJlY3QudCA9IGVsLm9mZnNldFRvcCB8fCAwO1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IGVsO1xuICAgICAgICAgICAgYkNoZWNrID0gZ2Vja1ZlciB8fCB3YlZlciA+IDUxOTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmVjdC50ICs9IHBhcmVudE5vZGUub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgICAgICAgIHJlY3QubCArPSBwYXJlbnROb2RlLm9mZnNldExlZnQgfHwgMDtcbiAgICAgICAgICAgICAgaWYgKGJDaGVjaykge1xuICAgICAgICAgICAgICAgIF9jYWxjQm9yZGVycyhwYXJlbnROb2RlLCByZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gZWw7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlKHBhcmVudE5vZGUsIFwicG9zaXRpb25cIikgIT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgICBwYXJlbnROb2RlID0gZWw7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnROb2RlID0gX3BhcihwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlW05PREVfVFlQRV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHBhcmVudE5vZGUuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gcGFyZW50Tm9kZS5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgICAgICAgICAgICBpZiAoZ2Vja1ZlciAmJiBjdXJyZW50U3R5bGUocGFyZW50Tm9kZSwgT1ZFUikgIT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxjQm9yZGVycyhwYXJlbnROb2RlLCByZWN0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlY3QubCAtPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgcmVjdC50IC09IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWN0LnQgKz0gc2Nyb2xsLnk7XG4gICAgICAgICAgICAgIHJlY3QubCArPSBzY3JvbGwueDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY3QudCArPSBzY3JvbGwueTtcbiAgICAgICAgICAgICAgcmVjdC5sICs9IHNjcm9sbC54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpZVZlciAmJiBlbCA9PT0gX2RvY05vZGUoZWwpKSB7XG4gICAgICAgICAgICAgIGggPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgIHcgPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGggPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgIHcgPSBlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3QuYiA9IHJlY3QudCArIGg7XG4gICAgICAgICAgICByZWN0LnIgPSByZWN0LmwgKyB3O1xuICAgICAgICAgICAgcmVjdC53ID0gX21heChyZWN0LnIgLSByZWN0LmwsIDApO1xuICAgICAgICAgICAgcmVjdC5oID0gX21heChyZWN0LmIgLSByZWN0LnQsIDApO1xuICAgICAgICAgICAgcmVjdC56ID0gY3VycmVudFN0eWxlKGVsLCBcInpJbmRleFwiKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgICB0OiAwLFxuICAgICAgICAgICAgICBsOiAwLFxuICAgICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgICB3OiAwLFxuICAgICAgICAgICAgICBoOiAwLFxuICAgICAgICAgICAgICB6OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSByZWN0YW5nbGUgd2l0aCB0aGUgZ2VvbWV0cmljIGluZm9ybWF0aW9uIG9mIGFuIEhUTUxEb2N1bWVudFxuICAgICAgKGluY2x1ZGVzIHNjcm9sbCB3aWR0aCAvIGhlaWdodClcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20uZG9jUmVjdFxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIEFuIEhUTUxFbGVtZW50IHRvIHVzZSBhcyB0aGUgcmVmZXJlbmNlIGZvciBhbiBIVE1MRG9jdW1lbnRcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGRvY1JlY3QgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgaCwgcm9vdCwgdztcbiAgICAgICAgcm9vdCA9IF9kb2NOb2RlKGVsKTtcbiAgICAgICAgdyA9IDA7XG4gICAgICAgIGggPSAwO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIHcgPSByb290LnNjcm9sbFdpZHRoIHx8IDA7XG4gICAgICAgICAgaCA9IHJvb3Quc2Nyb2xsSGVpZ2h0IHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0OiAwLFxuICAgICAgICAgIGw6IDAsXG4gICAgICAgICAgYjogaCxcbiAgICAgICAgICByOiB3LFxuICAgICAgICAgIHc6IHcsXG4gICAgICAgICAgaDogaFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHJlY3RhbmdsZSB3aXRoIHRoZSBnZW9tZXRyaWMgaW5mb3JtYXRpb24gb2YgYW4gSFRNTFdpbmRvd1xuICAgICAgKGRvZXMgbm90IGluY2x1ZGUgc2Nyb2xsIHdpZHRoIC8gaGVpZ2h0KVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS53aW5SZWN0XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtlbF0gQW4gSFRNTEVsZW1lbnQgdG8gdXNlIGFzIHRoZSByZWZlcmVuY2VzIGZvciBhbiBIVE1MV2luZG93XG4gICAgICBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICB3aW5SZWN0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGIsIGgsIGwsIHIsIHJvb3QsIHQsIHcsIHdpO1xuICAgICAgICB3aSA9IChlbCAmJiBfdmlldyhlbCkpIHx8IHdpbjtcbiAgICAgICAgaCA9IHdpLmlubmVySGVpZ2h0IHx8IDA7XG4gICAgICAgIHcgPSB3aS5pbm5lcldpZHRoIHx8IDA7XG4gICAgICAgIHQgPSB3aS5zY3JlZW5ZIHx8IHdpLnNjcmVlblRvcCB8fCAwO1xuICAgICAgICBiID0gaCArIHQ7XG4gICAgICAgIGwgPSB3aS5zY3JlZW5YIHx8IHdpLnNjcmVlbkxlZnQgfHwgMDtcbiAgICAgICAgciA9IHcgKyBsO1xuICAgICAgICByb290ID0gX2RvY05vZGUoZWwpO1xuICAgICAgICBpZiAoIWggJiYgIXcgJiYgcm9vdCkge1xuICAgICAgICAgIGggPSByb290LmNsaWVudEhlaWdodCB8fCAwO1xuICAgICAgICAgIHcgPSByb290LmNsaWVudFdpZHRoIHx8IDA7XG4gICAgICAgICAgciA9IGwgKyB3O1xuICAgICAgICAgIGIgPSB0ICsgaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHQ6IHQsXG4gICAgICAgICAgbDogbCxcbiAgICAgICAgICBiOiBiLFxuICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgdzogdyxcbiAgICAgICAgICBoOiBoXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBIVE1MRWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGFub3RoZXIgSFRNTEVsZW1lbnRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20uY29udGFpbnNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgcmVmZXJlbmNlIHRvIHNlYXJjaCB3aXRoaW5cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5lZWRsZSBUaGUgSFRNTEVsZW1lbnQgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoZWNrIGlmIGl0cyBjb250YWluZWQgYnkgdGhlIDFzdCBwYXJhbWV0ZXJcbiAgICAgIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBjb250YWlucyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG5lZWRsZSkge1xuICAgICAgICB2YXIgZWxfbm9kZV90eXBlLCBuZWVkbGVfbm9kZV90eXBlLCByZXQ7XG4gICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICBlbF9ub2RlX3R5cGUgPSAoZWxlbWVudCAmJiBlbGVtZW50W05PREVfVFlQRV0pIHx8IC0xO1xuICAgICAgICBuZWVkbGVfbm9kZV90eXBlID0gKG5lZWRsZSAmJiBuZWVkbGVbTk9ERV9UWVBFXSkgfHwgLTE7XG4gICAgICAgIGlmIChlbF9ub2RlX3R5cGUgPT09IDEgJiYgbmVlZGxlX25vZGVfdHlwZSAhPT0gLTEpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudFtDT05UQUlOU10pIHtcbiAgICAgICAgICAgIGlmIChvcGVyYVZlciB8fCBuZWVkbGVfbm9kZV90eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIHJldCA9IGVsZW1lbnRbQ09OVEFJTlNdKG5lZWRsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAobmVlZGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IG5lZWRsZSkge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWVkbGUgPSBuZWVkbGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFtDT01QQVJFX0RPQ19QT1NdKSB7XG4gICAgICAgICAgICAgIHJldCA9IGVsZW1lbnQgPT09IG5lZWRsZSB8fCAhIShlbGVtZW50W0NPTVBBUkVfRE9DX1BPU10obmVlZGxlKSAmIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgc3R5bGUgYXR0cmlidXRlLCBvciB0aGUgY3VycmVudCBzdHlsZSBvYmplY3QgaW4gaXRzIGVudGlyZXR5IGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIGF0dHJpYnV0ZSBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLmN1cnJlbnRTdHlsZVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIGluZm9ybWF0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gW2F0dHJdIFRoZSBzdHlsZSBhdHRyaWJ1dGUgKGluIEphdmFTY3JpcHQgbm90YXRpb24sIGUuZy4gJ2JhY2tncm91bmRDb2xvcicgcmF0aGVyIHRoYW4gJ2JhY2tncm91bmQtY29sb3InKSB0byBmZXRjaC5cbiAgICAgIEByZXR1cm4ge0hUTUxTdHlsZU9iamVjdH0gQW4gSFRNTFN0eWxlT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnQgc3R5bGUgYXR0cmlidXRlIHZhbHVlc1xuICAgICAgQHJldHVybiB7U3RyaW5nfSBUaGUgdmFsdWUgb2YgYW4gc3R5bGUgYXR0cmlidXRlIChvbmx5IGlmIGF0dHIgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCkuXG4gICAgICAgKi9cbiAgICAgIGN1cnJlbnRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG4gICAgICAgIHZhciBjb21wLCBlLCBoYXNBdHRyLCB2YWw7XG4gICAgICAgIHZhbCA9IFwiXCI7XG4gICAgICAgIGhhc0F0dHIgPSAhIShhcmd1bWVudHMubGVuZ3RoICYmIGF0dHIpO1xuICAgICAgICBjb21wID0gXCJnZXRDb21wdXRlZFN0eWxlXCI7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChoYXNBdHRyKSB7XG4gICAgICAgICAgaWYgKGllVmVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWwgPSBlbC5jdXJyZW50U3R5bGVbYXR0cl07XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsID0gX3ZpZXcoZWwpW2NvbXBdKGVsLCBudWxsKVthdHRyXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaWVWZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWwgPSBfdmlldyhlbClbY29tcF0oZWwsIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ2FsY3VsYXRlIHRoZSBzdXJyb3VuZGluZyBib3VuZGFyaWVzIG9mIGFuIEhUTUxFbGVtZW50LCBhbmQgd2hldGhlciBvciBub3QgdGhlIEhUTUxFbGVtZW50IGlzIFwiaW4tdmlld1wiIG9mIHRoZSB1c2VyXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLmJvdW5kc1xuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgZWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIGluZm9ybWF0aW9uXG4gICAgICBAcGFyYW0ge09iamVjdH0gW2RldGFpbHNdIEFuIG9iamVjdCByZWZlcmVuY2UgdXNlZCBhcyBhbiBvdXRwdXQgcGFyYW1ldGVyIGluIHdoaWNoIGZ1cnRoZXIgZGV0YWlscyBhYm91dCB0aGUgYm91bmRhcmllcyBvZiB0aGUgZWxlbWVudCBhcmUgc3BlY2lmaWVkXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IFtjaGVja18zRF0gQ2hlY2sgdGhlIGVsZW1lbnQgd2l0aGluIDMgZGltZW5zaW9uYWwgc3BhY2Ugc3VjaCB0aGF0IGFueSBlbGVtZW50cyBjb3ZlcmluZyBzYWlkIGVsZW1lbnQgYXJlIGFsc28gdGFrZSBpbnRvIGNvbnNpZGVyYXRpb25cbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IGluZm8gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVsZW1lbnQgYm91bmRhcmllc1xuICAgICAgICovXG4gICAgICBib3VuZHMgPSBmdW5jdGlvbihlbCwgZGV0YWlscywgY2hlY2tfM0QpIHtcbiAgICAgICAgdmFyIGIsIGNsaWVudF9oZWlnaHQsIGNsaWVudF93aWR0aCwgY2xpcCwgY2xpcF9yZWN0LCBjdXJfc3QsIGRvY19yZWN0LCBlbF9yZWN0LCBleHBfcmVjdCwgaCwgaXNfc2Nyb2xsX25vZGUsIGlzX3VzaW5nX2RvY19yb290X2IsIGlzX3VzaW5nX2RvY19yb290X3IsIGwsIG9mZnNldF9oZWlnaHQsIG9mZnNldF93aWR0aCwgb3Zlcl94X3ZhbCwgb3Zlcl95X3ZhbCwgcGFyLCByLCByZWZfbm9kZSwgcm9vdCwgcm9vdF9yZWN0LCByb290X3Njcm9sbCwgc2Nyb2xsX2hlaWdodCwgc2Nyb2xsX2xlZnQsIHNjcm9sbF90b3AsIHNjcm9sbF93aWR0aCwgdCwgdGVtcF9yZWN0LCB3LCB4X2hpZGRlbiwgeHNiX2gsIHlfaGlkZGVuLCB5c2JfdztcbiAgICAgICAgcGFyID0gZWwgJiYgX3BhcihlbCk7XG4gICAgICAgIHJvb3QgPSBfZG9jTm9kZShlbCk7XG4gICAgICAgIGVsX3JlY3QgPSBfcmVjdChlbCk7XG4gICAgICAgIHJvb3RfcmVjdCA9IF9yZWN0KHJvb3QpO1xuICAgICAgICByb290X3Njcm9sbCA9IF9nZXRfZG9jX3Njcm9sbChyb290KTtcbiAgICAgICAgZG9jX3JlY3QgPSBkb2NSZWN0KGVsKTtcbiAgICAgICAgY2xpcF9yZWN0ID0ge1xuICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgbDogMCxcbiAgICAgICAgICByOiAwLFxuICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgdzogMCxcbiAgICAgICAgICBoOiAwXG4gICAgICAgIH07XG4gICAgICAgIGV4cF9yZWN0ID0ge1xuICAgICAgICAgIHQ6IDAsXG4gICAgICAgICAgbDogMCxcbiAgICAgICAgICByOiAwLFxuICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgeHM6IDAsXG4gICAgICAgICAgeXM6IDAsXG4gICAgICAgICAgeGl2OiAwLFxuICAgICAgICAgIHlpdjogMCxcbiAgICAgICAgICBpdjogMCxcbiAgICAgICAgICB3OiAwLFxuICAgICAgICAgIGg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgeHNiX2ggPSAwO1xuICAgICAgICB5c2JfdyA9IDA7XG4gICAgICAgIGlzX3Njcm9sbF9ub2RlID0gZmFsc2U7XG4gICAgICAgIGlzX3VzaW5nX2RvY19yb290X3IgPSBmYWxzZTtcbiAgICAgICAgaXNfdXNpbmdfZG9jX3Jvb3RfYiA9IGZhbHNlO1xuICAgICAgICBjdXJfc3QgPSB2b2lkIDA7XG4gICAgICAgIHcgPSB2b2lkIDA7XG4gICAgICAgIGggPSB2b2lkIDA7XG4gICAgICAgIHQgPSB2b2lkIDA7XG4gICAgICAgIGwgPSB2b2lkIDA7XG4gICAgICAgIHIgPSB2b2lkIDA7XG4gICAgICAgIGIgPSB2b2lkIDA7XG4gICAgICAgIHNjcm9sbF93aWR0aCA9IHZvaWQgMDtcbiAgICAgICAgb2Zmc2V0X3dpZHRoID0gdm9pZCAwO1xuICAgICAgICBjbGllbnRfd2lkdGggPSB2b2lkIDA7XG4gICAgICAgIHNjcm9sbF9oZWlnaHQgPSB2b2lkIDA7XG4gICAgICAgIG9mZnNldF9oZWlnaHQgPSB2b2lkIDA7XG4gICAgICAgIGNsaWVudF9oZWlnaHQgPSB2b2lkIDA7XG4gICAgICAgIG92ZXJfeF92YWwgPSB2b2lkIDA7XG4gICAgICAgIHNjcm9sbF9sZWZ0ID0gdm9pZCAwO1xuICAgICAgICBzY3JvbGxfdG9wID0gdm9pZCAwO1xuICAgICAgICBvdmVyX3lfdmFsID0gdm9pZCAwO1xuICAgICAgICBjbGlwID0gdm9pZCAwO1xuICAgICAgICB4X2hpZGRlbiA9IHZvaWQgMDtcbiAgICAgICAgeV9oaWRkZW4gPSB2b2lkIDA7XG4gICAgICAgIHJlZl9ub2RlID0gdm9pZCAwO1xuICAgICAgICB0ZW1wX3JlY3QgPSB2b2lkIDA7XG4gICAgICAgIGlzX3Njcm9sbF9ub2RlID0gZmFsc2U7XG4gICAgICAgIGRldGFpbHMgPSAoZGV0YWlscyAmJiB0eXBlb2YgZGV0YWlscyA9PT0gT0JKID8gZGV0YWlscyA6IHt9KTtcbiAgICAgICAgaWYgKHBhcikge1xuICAgICAgICAgIHdoaWxlIChjdXJfc3QgPSBjdXJyZW50U3R5bGUocGFyKSkge1xuICAgICAgICAgICAgaWYgKGN1cl9zdFtcImRpc3BsYXlcIl0gPT09IFwiYmxvY2tcIiB8fCBjdXJfc3RbXCJwb3NpdGlvblwiXSA9PT0gXCJhYnNvbHV0ZVwiIHx8IGN1cl9zdFtcImZsb2F0XCJdICE9PSBcIm5vbmVcIiB8fCBjdXJfc3RbXCJjbGVhclwiXSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgb3Zlcl94X3ZhbCA9IGN1cl9zdFtPVkVSICsgXCJYXCJdO1xuICAgICAgICAgICAgICBvdmVyX3lfdmFsID0gY3VyX3N0W09WRVIgKyBcIllcIl07XG4gICAgICAgICAgICAgIGNsaXAgPSBfZ2V0Q2xpcChjdXJfc3QpO1xuICAgICAgICAgICAgICBpZiAocGFyID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsX3dpZHRoID0gcm9vdF9zY3JvbGwudztcbiAgICAgICAgICAgICAgICBzY3JvbGxfaGVpZ2h0ID0gcm9vdF9zY3JvbGwuaDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxfd2lkdGggPSBwYXIuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICAgICAgc2Nyb2xsX2hlaWdodCA9IHBhci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2Zmc2V0X3dpZHRoID0gcGFyLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICBvZmZzZXRfaGVpZ2h0ID0gcGFyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgY2xpZW50X3dpZHRoID0gcGFyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICBjbGllbnRfaGVpZ2h0ID0gcGFyLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgaWYgKG92ZXJfeF92YWwgPT09IEhJRERFTiB8fCBjbGlwWzFdID4gMCB8fCBjbGlwWzNdID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHhfaGlkZGVuID0gMTtcbiAgICAgICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Zlcl95X3ZhbCA9PT0gSElEREVOIHx8IGNsaXBbMF0gPiAwIHx8IGNsaXBbMl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgeV9oaWRkZW4gPSAxO1xuICAgICAgICAgICAgICAgICAgcmVmX25vZGUgPSBwYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvdmVyX3hfdmFsID09PSBTQ1JPTEwpIHtcbiAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgICB4c2JfaCA9IG9mZnNldF9oZWlnaHQgLSBjbGllbnRfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlzX3Njcm9sbF9ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Zlcl95X3ZhbCA9PT0gU0NST0xMKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgICAgcmVmX25vZGUgPSBwYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlzYl93ID0gb2Zmc2V0X3dpZHRoIC0gY2xpZW50X3dpZHRoO1xuICAgICAgICAgICAgICAgIGlzX3Njcm9sbF9ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3Zlcl94X3ZhbCA9PT0gQVVUTykge1xuICAgICAgICAgICAgICAgIGlmICghcmVmX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlZl9ub2RlID0gcGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsX3dpZHRoID4gY2xpZW50X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICB4c2JfaCA9IG9mZnNldF9oZWlnaHQgLSBjbGllbnRfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc19zY3JvbGxfbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG92ZXJfeV92YWwgPT09IEFVVE8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICByZWZfbm9kZSA9IHBhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbF9oZWlnaHQgPiBjbGllbnRfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICB5c2JfdyA9IG9mZnNldF93aWR0aCAtIGNsaWVudF93aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNfc2Nyb2xsX25vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWZfbm9kZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyID09PSByb290KSB7XG4gICAgICAgICAgICAgIGlmIChzY3JvbGxfd2lkdGggPiBjbGllbnRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBoID0gKHdpbi5pbm5lckhlaWdodCB8fCAwKSB8fCBvZmZzZXRfaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHhzYl9oID0gaCAtIGNsaWVudF9oZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNjcm9sbF9oZWlnaHQgPiBjbGllbnRfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdyA9ICh3aW4uaW5uZXJXaWR0aCB8fCAwKSB8fCBvZmZzZXRfd2lkdGg7XG4gICAgICAgICAgICAgICAgeXNiX3cgPSB3IC0gY2xpZW50X3dpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzX3Njcm9sbF9ub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhciA9IF9wYXIocGFyKTtcbiAgICAgICAgICAgIGlmICghcGFyIHx8IHBhcltOT0RFX1RZUEVdICE9PSAxKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxfcmVjdC53ICYmIGVsX3JlY3QuaCkge1xuICAgICAgICAgIGlmICghcmVmX25vZGUgfHwgcmVmX25vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgICAgIGV4cF9yZWN0LnQgPSBfbWF4KGVsX3JlY3QudCwgMCk7XG4gICAgICAgICAgICBleHBfcmVjdC5sID0gX21heChlbF9yZWN0LmwsIDApO1xuICAgICAgICAgICAgaWYgKGllVmVyICYmIGRjW0NPTVBBVF9NT0RFXSA9PT0gXCJCYWNrQ29tcGF0XCIgJiYgX2F0dHIocm9vdCwgU0NST0xMKSA9PT0gXCJub1wiKSB7XG4gICAgICAgICAgICAgIHlfaGlkZGVuID0geF9oaWRkZW4gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyX3N0ID0gY3VycmVudFN0eWxlKHJvb3QpO1xuICAgICAgICAgICAgICBpZiAoY3VyX3N0KSB7XG4gICAgICAgICAgICAgICAgeF9oaWRkZW4gPSBjdXJfc3RbT1ZFUiArIFwiWFwiXSA9PT0gSElEREVOO1xuICAgICAgICAgICAgICAgIHlfaGlkZGVuID0gY3VyX3N0W09WRVIgKyBcIllcIl0gPT09IEhJRERFTjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3Rfc2Nyb2xsLmggPiByb290LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICBpZiAoeV9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBleHBfcmVjdC5iID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc191c2luZ19kb2Nfcm9vdF9iID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHBfcmVjdC5iID0gX21heCgoKGRvY19yZWN0LmggLSBlbF9yZWN0LmgpIC0geHNiX2gpIC0gZWxfcmVjdC50LCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuYiA9IF9tYXgoKChyb290X3JlY3QuaCAtIGVsX3JlY3QuaCkgLSB4c2JfaCkgLSBlbF9yZWN0LnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3Rfc2Nyb2xsLncgPiByb290LmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgIGlmICh4X2hpZGRlbikge1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LnIgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzX3VzaW5nX2RvY19yb290X3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LnIgPSBfbWF4KCgoZG9jX3JlY3QudyAtIGVsX3JlY3QudykgLSB5c2JfdykgLSBlbF9yZWN0LmwsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHBfcmVjdC5yID0gX21heCgoKHJvb3RfcmVjdC5yIC0gZWxfcmVjdC53KSAtIHlzYl93KSAtIGVsX3JlY3QubCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cl9zdCA9IGN1cnJlbnRTdHlsZShyZWZfbm9kZSk7XG4gICAgICAgICAgICBpZiAoX3RhZ05hbWUocmVmX25vZGUpID09PSBcImJvZHlcIikge1xuICAgICAgICAgICAgICByZWZfbm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICAgIHQgPSBlbF9yZWN0LnQ7XG4gICAgICAgICAgICAgIGwgPSBlbF9yZWN0Lmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ID0gbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwX3JlY3QgPSBfcmVjdChyZWZfbm9kZSk7XG4gICAgICAgICAgICBpZiAoY2xpcFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgY2xpcF9yZWN0LncgPSBjbGlwWzFdO1xuICAgICAgICAgICAgICBjbGlwX3JlY3QuciA9IGNsaXBfcmVjdC5sICsgY2xpcF9yZWN0Lnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpcFszXSA+IDApIHtcbiAgICAgICAgICAgICAgY2xpcF9yZWN0LmwgPSBjbGlwX3JlY3QubCArIGNsaXBbM107XG4gICAgICAgICAgICAgIGNsaXBfcmVjdC53ID0gY2xpcF9yZWN0LncgLSBjbGlwWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaXBbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIGNsaXBfcmVjdC5oID0gY2xpcFsyXTtcbiAgICAgICAgICAgICAgY2xpcF9yZWN0LmIgPSBjbGlwX3JlY3QudCArIGNsaXBfcmVjdC5oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaXBbMF0gPiAwKSB7XG4gICAgICAgICAgICAgIGNsaXBfcmVjdC50ID0gY2xpcF9yZWN0LnQgKyBjbGlwWzBdO1xuICAgICAgICAgICAgICBjbGlwX3JlY3QuaCA9IGNsaXBfcmVjdC5oIC0gY2xpcFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbF9yZWN0LnQgPiBjbGlwX3JlY3QudCAmJiBjbGlwX3JlY3QudCA+IDApIHtcbiAgICAgICAgICAgICAgdCA9IGVsX3JlY3QudCAtIGNsaXBfcmVjdC50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsX3JlY3QubCA+IGNsaXBfcmVjdC5sICYmIGNsaXBfcmVjdC5sID4gMCkge1xuICAgICAgICAgICAgICBsID0gZWxfcmVjdC5sIC0gY2xpcF9yZWN0Lmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JvbGxfdG9wID0gcmVmX25vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgc2Nyb2xsX2xlZnQgPSByZWZfbm9kZS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgc2Nyb2xsX2hlaWdodCA9IHJlZl9ub2RlLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIHNjcm9sbF93aWR0aCA9IHJlZl9ub2RlLnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgZXhwX3JlY3QudCA9IF9tYXgodCwgMCk7XG4gICAgICAgICAgICBleHBfcmVjdC5sID0gX21heChsLCAwKTtcbiAgICAgICAgICAgIGlmIChjdXJfc3QpIHtcbiAgICAgICAgICAgICAgeF9oaWRkZW4gPSBjdXJfc3RbT1ZFUiArIFwiWFwiXSA9PT0gSElEREVOIHx8IGNsaXBbMV0gPiAwIHx8IGNsaXBbM10gPiAwO1xuICAgICAgICAgICAgICB5X2hpZGRlbiA9IGN1cl9zdFtPVkVSICsgXCJZXCJdID09PSBISURERU4gfHwgY2xpcFswXSA+IDAgfHwgY2xpcFsyXSA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxfcmVjdC50ID49IGNsaXBfcmVjdC5iKSB7XG4gICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF5X2hpZGRlbiAmJiBlbF9yZWN0LnQgPj0gY2xpcF9yZWN0LmIpIHtcbiAgICAgICAgICAgICAgICB5X2hpZGRlbiA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNjcm9sbF9oZWlnaHQgPiByZWZfbm9kZS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoeV9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHBfcmVjdC5iID0gX21heCgoKHNjcm9sbF9oZWlnaHQgLSBlbF9yZWN0LmgpIC0geHNiX2gpIC0gdCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cF9yZWN0LmIgPSBfbWF4KCgoY2xpcF9yZWN0LmggLSBlbF9yZWN0LmgpIC0geHNiX2gpIC0gdCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbF9yZWN0LmwgPj0gY2xpcF9yZWN0LnIpIHtcbiAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXhfaGlkZGVuICYmIGVsX3JlY3QubCA+PSBjbGlwX3JlY3Qucikge1xuICAgICAgICAgICAgICAgIHhfaGlkZGVuID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2Nyb2xsX3dpZHRoID4gcmVmX25vZGUuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeF9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgIGV4cF9yZWN0LnIgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHBfcmVjdC5yID0gX21heCgoKHNjcm9sbF93aWR0aCAtIGVsX3JlY3QudykgLSB5c2JfdykgLSBsLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwX3JlY3QuciA9IF9tYXgoKChjbGlwX3JlY3QudyAtIGVsX3JlY3QudykgLSB5c2JfdykgLSBsLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBleHBfcmVjdC54cyA9ICh4c2JfaCA/IDEgOiAwKTtcbiAgICAgICAgICBleHBfcmVjdC55cyA9ICh5c2JfdyA/IDEgOiAwKTtcbiAgICAgICAgICBleHBfcmVjdC53ID0gZXhwX3JlY3QuciArIGV4cF9yZWN0Lmw7XG4gICAgICAgICAgZXhwX3JlY3QuaCA9IGV4cF9yZWN0LnQgKyBleHBfcmVjdC5iO1xuICAgICAgICAgIGlmICghcmVmX25vZGUgfHwgcmVmX25vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgICAgIHRlbXBfcmVjdCA9IHJvb3RfcmVjdDtcbiAgICAgICAgICAgIHJlZl9ub2RlID0gcm9vdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcF9yZWN0ID0gY2xpcF9yZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsID0gX21heChlbF9yZWN0LmwsIHRlbXBfcmVjdC5sKTtcbiAgICAgICAgICByID0gX21pbihlbF9yZWN0LnIsIChpc191c2luZ19kb2Nfcm9vdF9yID8gX21pbihkb2NfcmVjdC5yLCB0ZW1wX3JlY3QucikgOiB0ZW1wX3JlY3QucikpO1xuICAgICAgICAgIHcgPSBfbWF4KHIgLSBsLCAwKTtcbiAgICAgICAgICB0ID0gX21heChlbF9yZWN0LnQsIHRlbXBfcmVjdC50KTtcbiAgICAgICAgICBiID0gX21pbihlbF9yZWN0LmIsIChpc191c2luZ19kb2Nfcm9vdF9iID8gX21pbihkb2NfcmVjdC5iLCB0ZW1wX3JlY3QuYikgOiB0ZW1wX3JlY3QuYikpO1xuICAgICAgICAgIGggPSBfbWF4KGIgLSB0LCAwKTtcbiAgICAgICAgICBleHBfcmVjdC54aXYgPSBfY251bSgodyAvIGVsX3JlY3QudylbVEZYRF0oMikpO1xuICAgICAgICAgIGV4cF9yZWN0LnlpdiA9IF9jbnVtKChoIC8gZWxfcmVjdC5oKVtURlhEXSgyKSk7XG4gICAgICAgICAgZXhwX3JlY3QuaXYgPSBfY251bSgoKHcgKiBoKSAvIChlbF9yZWN0LncgKiBlbF9yZWN0LmgpKVtURlhEXSgyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5yZWZOb2RlID0gcmVmX25vZGUgfHwgcm9vdDtcbiAgICAgICAgZGV0YWlscy5pc1Jvb3QgPSByZWZfbm9kZSA9PT0gcm9vdDtcbiAgICAgICAgZGV0YWlscy5jYW5TY3JvbGwgPSBpc19zY3JvbGxfbm9kZTtcbiAgICAgICAgZGV0YWlscy5yZWZSZWN0ID0gKCFyZWZfbm9kZSB8fCByZWZfbm9kZSA9PT0gcm9vdCA/IHJvb3RfcmVjdCA6IGNsaXBfcmVjdCk7XG4gICAgICAgIGRldGFpbHMuZXhwUmVjdCA9IGV4cF9yZWN0O1xuICAgICAgICBkZXRhaWxzLnJlY3QgPSBlbF9yZWN0O1xuICAgICAgICBpZiAoY2hlY2tfM0QpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJPdnJsYXBzLCBlbF9hcmVhLCBlbF9oLCBlbF93LCBpZHgsIGxlbiwgbmV3X2l2LCBuZXdfeGl2LCBuZXdfeWl2LCBvdnJfYXJlYSwgb3ZyX25vZGUsIG92cl9ub2RlX3JlY3Q7XG4gICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGFyT3ZybGFwcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGVsX3cgPSB2b2lkIDA7XG4gICAgICAgICAgICBlbF9oID0gdm9pZCAwO1xuICAgICAgICAgICAgZWxfYXJlYSA9IHZvaWQgMDtcbiAgICAgICAgICAgIG92cl9ub2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgb3ZyX25vZGVfcmVjdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBiID0gdm9pZCAwO1xuICAgICAgICAgICAgbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHIgPSB2b2lkIDA7XG4gICAgICAgICAgICBoID0gdm9pZCAwO1xuICAgICAgICAgICAgdyA9IHZvaWQgMDtcbiAgICAgICAgICAgIG92cl9hcmVhID0gdm9pZCAwO1xuICAgICAgICAgICAgbmV3X2l2ID0gdm9pZCAwO1xuICAgICAgICAgICAgbmV3X3hpdiA9IHZvaWQgMDtcbiAgICAgICAgICAgIG5ld195aXYgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZXhwX3JlY3QuaXYgPiAuNSkge1xuICAgICAgICAgICAgICBtZ3JfYm91bmRzX2RldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICAgICAgICBhck92cmxhcHMgPSBvdmVybGFwcyhlbCwgX2NudW0oY2hlY2tfM0QsIDEsIDEpKTtcbiAgICAgICAgICAgICAgbWdyX2JvdW5kc19kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgICAgICAgbGVuID0gYXJPdnJsYXBzW0xFTl07XG4gICAgICAgICAgICAgIGVsX3cgPSBlbF9yZWN0Lnc7XG4gICAgICAgICAgICAgIGVsX2ggPSBlbF9yZWN0Lmg7XG4gICAgICAgICAgICAgIGVsX2FyZWEgPSBlbF93ICogZWxfaDtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHdoaWxlIChvdnJfbm9kZSA9IGFyT3ZybGFwc1tpZHgrK10pIHtcbiAgICAgICAgICAgICAgICAgIG92cl9ub2RlX3JlY3QgPSBfcmVjdChvdnJfbm9kZSk7XG4gICAgICAgICAgICAgICAgICBsID0gX21heChlbF9yZWN0LmwsIG92cl9ub2RlX3JlY3QubCk7XG4gICAgICAgICAgICAgICAgICByID0gX21pbihlbF9yZWN0LnIsIG92cl9ub2RlX3JlY3Qucik7XG4gICAgICAgICAgICAgICAgICB0ID0gX21heChlbF9yZWN0LnQsIG92cl9ub2RlX3JlY3QudCk7XG4gICAgICAgICAgICAgICAgICBiID0gX21pbihlbF9yZWN0LmIsIG92cl9ub2RlX3JlY3QuYik7XG4gICAgICAgICAgICAgICAgICB3ID0gciAtIGw7XG4gICAgICAgICAgICAgICAgICBoID0gYiAtIHQ7XG4gICAgICAgICAgICAgICAgICBvdnJfYXJlYSA9IHcgKiBoO1xuICAgICAgICAgICAgICAgICAgbmV3X3hpdiA9ICgxIC0gKHcgLyBlbF93KSlbVEZYRF0oMik7XG4gICAgICAgICAgICAgICAgICBuZXdfeWl2ID0gKDEgLSAoaCAvIGVsX2gpKVtURlhEXSgyKTtcbiAgICAgICAgICAgICAgICAgIG5ld19pdiA9ICgxIC0gKG92cl9hcmVhIC8gZWxfYXJlYSkpW1RGWERdKDIpO1xuICAgICAgICAgICAgICAgICAgaWYgKChuZXdfeGl2ID4gMCAmJiBuZXdfeGl2IDwgZXhwX3JlY3QueGl2KSB8fCAobmV3X3lpdiA+IDAgJiYgbmV3X3lpdiA8IGV4cF9yZWN0LnlpdikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwX3JlY3QueGl2ID0gbmV3X3hpdjtcbiAgICAgICAgICAgICAgICAgICAgZXhwX3JlY3QueWl2ID0gbmV3X3lpdjtcbiAgICAgICAgICAgICAgICAgICAgZXhwX3JlY3QuaXYgPSBuZXdfaXY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwX3JlY3Q7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgRmluZCBhbnkgSFRNTEVsZW1lbnRzIHRoYXQgYXJlIGNvdmVyaW5nIGEgZ2l2ZW4gSFRNTEVsZW1lbnQuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm92ZXJsYXBzXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBIVE1MRWxlbWVudCBmb3Igd2hpY2ggdG8gZmluZCBhbnkgb3RoZXIgZWxlbWVudHMgdGhhdCBtYXkgYmUgY292ZXJpbmcgaXQuXG4gICAgICBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBUaGUgbWF4aW11bSBudW1iZXIgb2YgY292ZXJpbmcgZWxlbWVudHMgdG8gcmV0dXJuXG4gICAgICBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGNvdmVyaW5nIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIG92ZXJsYXBzID0gZnVuY3Rpb24oZWwsIGxpbWl0KSB7XG4gICAgICAgIHZhciBiYXNlSCwgYmFzZVcsIGNoZWNrRWwsIGN1ckgsIGN1clcsIGRvYywgZmFjdG9yLCBoLCBpZCwgaWR4LCBsLCBtYXhYLCBtYXhZLCBwYXJfZGV0YWlscywgcG9pbnRzLCBwdCwgcmVjdCwgcmVmX3Bhcl9ub2RlLCByZWZfcGFyX3JlY3QsIHJldCwgcm9vdCwgc2VlbiwgdCwgdywgeCwgeTtcbiAgICAgICAgcmVjdCA9IF9yZWN0KGVsKTtcbiAgICAgICAgZG9jID0gX2RvYyhlbCk7XG4gICAgICAgIHJvb3QgPSBfZG9jTm9kZShkb2MpO1xuICAgICAgICB0ID0gcmVjdC50O1xuICAgICAgICBsID0gcmVjdC5sO1xuICAgICAgICB3ID0gcmVjdC5yIC0gcmVjdC5sO1xuICAgICAgICBoID0gcmVjdC5iIC0gcmVjdC50O1xuICAgICAgICBmYWN0b3IgPSBJTlRFUlNFQ1RfRkFDVE9SO1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgYmFzZVcgPSBfcm91bmQodyAvIGZhY3Rvcik7XG4gICAgICAgIGJhc2VIID0gX3JvdW5kKGggLyBmYWN0b3IpO1xuICAgICAgICBjdXJXID0gYmFzZVc7XG4gICAgICAgIGN1ckggPSBiYXNlSDtcbiAgICAgICAgc2VlbiA9IHt9O1xuICAgICAgICBwYXJfZGV0YWlscyA9IHt9O1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgeCA9IHZvaWQgMDtcbiAgICAgICAgeSA9IHZvaWQgMDtcbiAgICAgICAgcHQgPSB2b2lkIDA7XG4gICAgICAgIGlkID0gdm9pZCAwO1xuICAgICAgICBjaGVja0VsID0gdm9pZCAwO1xuICAgICAgICByZWZfcGFyX25vZGUgPSB2b2lkIDA7XG4gICAgICAgIHJlZl9wYXJfcmVjdCA9IHZvaWQgMDtcbiAgICAgICAgbWF4WCA9IHZvaWQgMDtcbiAgICAgICAgbWF4WSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKG1ncl9ib3VuZHNfZGV0YWlscykge1xuICAgICAgICAgIHBhcl9kZXRhaWxzID0gbWdyX2JvdW5kc19kZXRhaWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvdW5kcyhlbCwgcGFyX2RldGFpbHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJlZl9wYXJfbm9kZSA9IHBhcl9kZXRhaWxzLnJlZk5vZGU7XG4gICAgICAgIHJlZl9wYXJfcmVjdCA9IHBhcl9kZXRhaWxzLnJlZlJlY3Q7XG4gICAgICAgIGlmIChyZWZfcGFyX3JlY3QgJiYgcmVmX3Bhcl9ub2RlICYmIHJlZl9wYXJfbm9kZSAhPT0gcm9vdCkge1xuICAgICAgICAgIG1heFggPSByZWZfcGFyX3JlY3QucjtcbiAgICAgICAgICBtYXhZID0gcmVmX3Bhcl9yZWN0LmI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4WCA9IGwgKyB3O1xuICAgICAgICAgIG1heFkgPSB0ICsgaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jICYmIHJvb3QgJiYgZG9jW0VMX0ZST01fUFRdKSB7XG4gICAgICAgICAgd2hpbGUgKGN1clcgPCB3KSB7XG4gICAgICAgICAgICBjdXJIID0gYmFzZUg7XG4gICAgICAgICAgICB3aGlsZSAoY3VySCA8IGgpIHtcbiAgICAgICAgICAgICAgeCA9IGwgKyBjdXJXO1xuICAgICAgICAgICAgICB5ID0gdCArIGN1ckg7XG4gICAgICAgICAgICAgIGlmICh4IDwgbWF4WCAmJiB5IDwgbWF4WSkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VySCArPSBiYXNlSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clcgKz0gYmFzZVc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbWl0ID0gX2NudW0obGltaXQsIHBvaW50c1tMRU5dKTtcbiAgICAgICAgICB3aGlsZSAocHQgPSBwb2ludHNbaWR4KytdKSB7XG4gICAgICAgICAgICBjaGVja0VsID0gZG9jW0VMX0ZST01fUFRdKHB0WzBdLCBwdFsxXSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY2hlY2tFbCAmJiBjaGVja0VsLm5vZGVUeXBlID09PSAxICYmIGNoZWNrRWwgIT09IHJvb3QgJiYgY2hlY2tFbCAhPT0gZWwgJiYgIWNvbnRhaW5zKGVsLCBjaGVja0VsKSkge1xuICAgICAgICAgICAgICAgIGlkID0gX2F0dHIoY2hlY2tFbCwgXCJpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgICBpZCA9IGxhbmcuZ3VpZChcImdlb21faW50ZXJcIik7XG4gICAgICAgICAgICAgICAgICBfYXR0cihjaGVja0VsLCBcImlkXCIsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuW2lkXSAmJiByZXRbTEVOXSA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICBzZWVuW2lkXSA9IDE7XG4gICAgICAgICAgICAgICAgICByZXQucHVzaChjaGVja0VsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSBcIlwiO1xuICAgICAgICBmb3IgKGlkIGluIHNlZW4pIHtcbiAgICAgICAgICBpZiAoaWQuaW5kZXhPZihcImdlb21faW50ZXJcIikgPT09IDApIHtcbiAgICAgICAgICAgIGNoZWNrRWwgPSBfZWx0KGlkKTtcbiAgICAgICAgICAgIGlmIChjaGVja0VsKSB7XG4gICAgICAgICAgICAgIF9hdHRyKGNoZWNrRWwsIFwiaWRcIiwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQSBwcm94eSB3cmFwcGVyIGZvciBjYWxsaW5nIGludG8gdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgaG9zdCBmYWxsIGJhY2sgbGlicmFyeVxuICAgICAgTG9va3MgZm9yIG5hbWVzcGFjZSB3aWxsIGJlICRzZi5saWIuZG9tLm1zZ2hvc3RfZmJcbiAgICAgIFNhaWQgbGlicmFyeSBpcyB1c2VkIGluIGNhc2VzIHdoZXJlIHRoZXJlIGlzIG5vdCBIVE1MNSBzdHlsZSBtZXNzYWdpbmcgKGkuZS4gbm8gcG9zdE1lc3NhZ2UgbWV0aG9kIGF2YWlsYWJsZSkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QtX2NhbGxfeG1zZ19ob3N0X2ZiXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1N0cmluZ30gbWV0aE5hbWUgVGhlIG1ldGhvZCBuYW1lIGluIHRoZSBtc2cgaG9zdCBsaWJyYXJ5IHRvIGNhbGxcbiAgICAgIEBwYXJhbSB7Kn0gYXJnMSBBbiBhcmJpdHJhcnkgYXJndW1lbnQgdG8gcGFzcyB0byBzYWlkIG1ldGhvZCBhcyB0aGUgMXN0IGFyZ1xuICAgICAgQHBhcmFtIHsqfSBhcmcyIEFuIGFyYml0cmFyeSBhcmd1bWVudCB0byBwYXNzIHRvIHNhaWQgbWV0aG9kIGFzIHRoZSAybmQgYXJnXG4gICAgICBAcGFyYW0geyp9IGFyZzMgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDNyZCBhcmdcbiAgICAgIEByZXR1cm5zIHsqfSB3aGF0ZXZlciBjb21lcyBiYWNrIGZyb20gdGhlIG1ldGhvZFxuICAgICAgICovXG4gICAgICBfY2FsbF94bXNnX2hvc3RfZmIgPSBmdW5jdGlvbihtZXRoTmFtZSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBpZiAoIW1zZ2hvc3RmYikge1xuICAgICAgICAgIG1zZ2hvc3RmYiA9IGRvbS5tc2dob3N0X2ZiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRoTmFtZSAmJiBtc2dob3N0ZmIgJiYgbXNnaG9zdGZiW21ldGhOYW1lXSAmJiBtc2dob3N0ZmJbbWV0aE5hbWVdKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIExpc3RlbiBmb3IgYW4gaW5pdGlhbCBIVE1MNSBwb3N0TWVzc2FnZSBldmVudCwgdG8gdmFsaWRhdGUgdGhhdCBIVE1MNSBzdHlsZVxuICAgICAgbWVzc2FnaW5nIGNhbiBiZSB1c2VkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QtX2NoZWNrX2h0bWw1X2luaXRcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBIVE1MIGV2ZW50IG9iamVjdCByZWNlaXZlZCBmcm9tIHRoZSBwb3N0TWVzc2FnZSBjYWxsXG4gICAgICAgKi9cbiAgICAgIF9jaGVja19odG1sNV9pbml0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghY2FuVXNlSFRNTDUgJiYgZXZ0ICYmIGV2dC5kYXRhID09PSBpbml0SUQpIHtcbiAgICAgICAgICBjYW5Vc2VIVE1MNSA9IHRydWU7XG4gICAgICAgICAgZG9tLmV2dENuY2woZXZ0KTtcbiAgICAgICAgICBkb21bREVUQUNIXSh3aW4sIE1TRywgX2NoZWNrX2h0bWw1X2luaXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTGlzdGVuIGZvciBvbm1lc3NhZ2UgZXZlbnRzIGluIHRoZSBtYWluIHdpbmRvdy4gVmFsaWRhdGUgdGhhdCBtZXNzYWdlIGlzIGZvciB1cywgYW5kIGlmIHNvXG4gICAgICBwYXNzIGl0IHRocm91Z2ggdG8gdGhlIHJlc3Qgb2YgdGhlIGNvZGUgYW5kIGNhbmNlbCBmdXJ0aGVyIGhhbmRsaW5nLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS5tc2dob3N0LV9oYW5kbGVfbXNnX2Zyb21fb3V0c2lkZVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRXZlbnR9IGV2dCBUaGUgcmF3IEhUTUwgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gdGhlIHBvc3RNZXNzYWdlIGNhbGxcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBjYiwgZGF0YSwgZGF0YUdVSUQsIGUsIGZyX3dpbiwgaWZyLCBtc2dfd2luLCBwYXJhbXMsIHBpcGUsIHBpcGVHVUlELCByZXQsIHRndElEO1xuICAgICAgICBkYXRhID0gZXZ0ICYmIGV2dC5kYXRhO1xuICAgICAgICBtc2dfd2luID0gZXZ0ICYmIGV2dC5zb3VyY2U7XG4gICAgICAgIHBhcmFtcyA9IGRhdGEgJiYgKGRhdGEuaW5kZXhPZihHVUlEKSAhPT0gLTEpICYmIFBhcmFtSGFzaChkYXRhKTtcbiAgICAgICAgdGd0SUQgPSBwYXJhbXMgJiYgcGFyYW1zLmlkO1xuICAgICAgICBpZnIgPSB0Z3RJRCAmJiBfZWx0KHRndElEKTtcbiAgICAgICAgZnJfd2luID0gaWZyICYmIF9pZnJfdmlldyhpZnIpO1xuICAgICAgICBwaXBlID0gdGd0SUQgJiYgbXNnX3BpcGVzW3RndElEXTtcbiAgICAgICAgZGF0YUdVSUQgPSBwYXJhbXMgJiYgcGFyYW1zW0dVSURdO1xuICAgICAgICBwaXBlR1VJRCA9IHBpcGUgJiYgcGlwZVtHVUlEXTtcbiAgICAgICAgY2IgPSBwaXBlICYmIHBpcGUuX3htc2djYjtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIGlmIChwaXBlR1VJRCAmJiBkYXRhR1VJRCAmJiBkYXRhR1VJRCA9PT0gcGlwZUdVSUQgJiYgbXNnX3dpbiAmJiBmcl93aW4gJiYgZnJfd2luID09PSBtc2dfd2luKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldCA9IGNiKHBhcmFtcy5tc2cpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgZG9tLmV2dENuY2woZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFNlbmQgYSBtZXNzYWdlIHRvIGEgY2hpbGQgaWZyYW1lLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YubGliLmRvbS5tc2dob3N0LnNlbmRcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IHRndElEIFRoZSBIVE1MIGlkIGF0dHJpYnV0ZSBvZiB0aGUgaWZyYW1lIGVsZW1lbnQgZm9yIHdoaWNoIHRvIHNlbmQgYSBtZXNzYWdlXG4gICAgICBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgc3RyaW5nIG9mIGRhdGEgdG8gc2VuZCB0byB0aGUgZ2l2ZW4gaWZyYW1lXG4gICAgICBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgbWVzc2FnZSB3YXMgc2VuZCBzdWNjZXNmdWxseSAobm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgbWVhbiBtZXNzYWdlIHdhcyBoYW5kbGVkIC8gcmVjZXZpZWQsIG9ubHkgdGhhdCBzZW5kaW5nIHdhcyBvaykuXG4gICAgICAgKi9cbiAgICAgIHNlbmRfbXNnX3RvX2NoaWxkX2lmcmFtZSA9IGZ1bmN0aW9uKHRndElELCBkYXRhKSB7XG4gICAgICAgIHZhciBlLCBlbCwgbXNnT2JqLCBwaXBlLCBzdWNjZXNzLCB3O1xuICAgICAgICBwaXBlID0gdGd0SUQgJiYgbXNnX3BpcGVzW3RndElEXTtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBtc2dPYmogPSB2b2lkIDA7XG4gICAgICAgIHcgPSB2b2lkIDA7XG4gICAgICAgIGVsID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBpZiAoIXBpcGUpIHtcbiAgICAgICAgICBzdWNjZXNzID0gX2NhbGxfeG1zZ19ob3N0X2ZiKFwic2VuZFwiLCB0Z3RJRCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBpcGUpIHtcbiAgICAgICAgICAgIG1zZ09iaiA9IFBhcmFtSGFzaCgpO1xuICAgICAgICAgICAgbXNnT2JqLm1zZyA9IGRhdGE7XG4gICAgICAgICAgICBtc2dPYmouZ3VpZCA9IHBpcGUuZ3VpZDtcbiAgICAgICAgICAgIGlmICh1c2luZ0hUTUw1KCkpIHtcbiAgICAgICAgICAgICAgZWwgPSBfZWx0KHRndElEKTtcbiAgICAgICAgICAgICAgdyA9IF9pZnJfdmlldyhlbCk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd1tQTVNHXShfY3N0cihtc2dPYmopLCBwaXBlLnNyY0hvc3QgfHwgXCIqXCIpO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VjY2VzcyA9IF9jYWxsX3htc2dfaG9zdF9mYihcInNlbmRcIiwgdGd0SUQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtc2dPYmogPSB3ID0gZWwgPSBudWxsO1xuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBHZXQgd2hldGhlciBvciBub3QgSFRNTDUgc3R5bGUgbWVzc2FnaW5nIGNhbiBiZSB1c2VkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QudXNpbmdIVE1MNVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgdXNpbmdIVE1MNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FuVXNlSFRNTDU7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgR2V0cyBhIGxvY2F0aW9uIG9mIHRoZSBob3N0aW5nIHBhZ2UsIHN0cmlwcGVkIG9mIHRoZSBzZWFyY2ggaGFzaCxcbiAgICAgIGJ1dCBsZWF2aW5nIHF1ZXJ5IHBhcmFtZXRlcnMsIHBvcnQsIGhvc3QsIHBhdGgsIGV0Yy5cbiAgICAgICAqL1xuICAgICAgX3N0cmlwcGVkRW5jb2RlZExvY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbGVhbmVkLCBwb3M7XG4gICAgICAgIGNsZWFuZWQgPSB2b2lkIDA7XG4gICAgICAgIHBvcyA9IGxvYy5ocmVmLmluZGV4T2YoXCIjXCIpO1xuICAgICAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgICAgICBjbGVhbmVkID0gbG9jLmhyZWYuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW5lZCA9IGxvYy5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGNsZWFuZWQuaW5kZXhPZihcIj9cIik7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnN1YnN0cigwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlc2NhcGUoY2xlYW5lZCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUHJlcGFyZSBhbiBpZnJhbWUgaW4gdGhlIHRvcCBsZXZlbCB3aW5kb3cgdG8gYmUgYWJsZSB0byBzZW5kIC8gcmVjZWl2ZSBjcm9zcy1kb21haW4gbWVzc2FnZXNcbiAgICAgIEdlbmVyYWxseSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSAkc2YubGliLmlmcmFtZXMuICBUaGUgYXR0cnMgb2JqZWN0IGluIHF1ZXN0aW9uIHNob3VsZFxuICAgICAgcmVwcmVzZW50IGtleS92YWx1ZSBwYWlycyBvZiBIVE1MIGF0dHJpYnV0ZXMgZm9yIHRoZSBpZnJhbWUuIE5vdGUgdGhhdCB0aGUgYXR0cnMgb2JqZWN0IHBhc3NlZFxuICAgICAgaW4gd2lsbCBiZSBtb2RpZmllZCB3aXRoIGEgbmV3IFwibmFtZVwiIHByb3BlcnR5LCB0byBzZW5kIGluZm9ybWF0aW9uIGludG8gdGhlIGlmcmFtZSBhbmQgc2V0dXBcbiAgICAgIG1lc3NhZ2luZy5cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC5wcmVwXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBJbmZvcm1hdGlvbiByZXF1aXJlZCB0byBzZXQgdXAgdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgY2hhbm5lbFxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGF0dHJzLmlkIFRoZSBJRlJBTUUgSFRNTCBpZCBhdHRyaWJ1dGVcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBhdHRycy5zcmMgVGhlIFVSTCAvIHNyYyBhdHRyaWJ1dGUgb2YgdGhlIElGUkFNRVxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFthdHRycy5ndWlkXSBUaGUgZ3VpZCAvIHNpZ25hdHVyZSB0byB1c2UgdG8gdmFsaWRhdGUgdGhhdCBtZXNzYWdlcyBzZW50LyByZWNlaXZlZCBjYW4gYmUgYWNjZXB0ZWQuIElmIG5vdCBzcGVjaWZpZWQsIG9uZSB3aWxsIGJlIGNyZWF0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbYXR0cnMubmFtZV0gVGhlIElGUkFNRSBIVE1MIG5hbWUgYXR0cmlidXRlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzZW5kIGFuIGludGlhbCBtZXNzYWdlIHRvIHRoZSBIVE1MIGRvY3VtZW50IGluc2lkZSB0aGUgSUZSQU1FLlxuICAgICAgQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdmFyaW91cyBwcm9wZXJ0aWVzIGRldGFpbGluZyB0aGUgbWVzc2FnaW5nIHBpcGUtbGluZS5cbiAgICAgICAqL1xuICAgICAgcHJlcF9pZnJhbWVfbXNnaW5nID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgdmFyIGlmcmFtZU5hbWUsIGxvY1N0cmlwcGVkLCBuYW1lUGFyYW1zLCBuZXdQaXBlLCBwaXBlLCBzcmMsIHNyY0hvc3Q7XG4gICAgICAgIHBpcGUgPSBudWxsO1xuICAgICAgICBpZnJhbWVOYW1lID0gdm9pZCAwO1xuICAgICAgICBuYW1lUGFyYW1zID0gdm9pZCAwO1xuICAgICAgICBzcmMgPSB2b2lkIDA7XG4gICAgICAgIHNyY0hvc3QgPSB2b2lkIDA7XG4gICAgICAgIG5ld1BpcGUgPSB2b2lkIDA7XG4gICAgICAgIGxvY1N0cmlwcGVkID0gX3N0cmlwcGVkRW5jb2RlZExvY2F0aW9uKCk7XG4gICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgIGlmcmFtZU5hbWUgPSBhdHRycy5uYW1lO1xuICAgICAgICAgIG5hbWVQYXJhbXMgPSBQYXJhbUhhc2goaWZyYW1lTmFtZSk7XG4gICAgICAgICAgc3JjID0gX2NzdHIoYXR0cnMuc3JjKTtcbiAgICAgICAgICBzcmNIb3N0ID0gc3JjICYmIHNyYy5zdWJzdHJpbmcoMCwgc3JjLmluZGV4T2YoXCIvXCIsIDkpKTtcbiAgICAgICAgICBzcmNIb3N0ID0gKHNyY0hvc3Quc2VhcmNoKC9odHRwL2cpICE9PSAwID8gXCJcIiA6IHNyY0hvc3QpO1xuICAgICAgICAgIHBpcGUgPSBQYXJhbUhhc2gobmFtZVBhcmFtcyk7XG4gICAgICAgICAgcGlwZS5pZCA9IGF0dHJzLmlkIHx8IChcImlmcmFtZV9cIiArIF9ndWlkKCkpO1xuICAgICAgICAgIHBpcGUuc3JjID0gc3JjO1xuICAgICAgICAgIHBpcGUuc3JjSG9zdCA9IHNyY0hvc3Q7XG4gICAgICAgICAgcGlwZVtHVUlEXSA9IHBpcGVbR1VJRF0gfHwgX2d1aWQoKTtcbiAgICAgICAgICBwaXBlLmhvc3QgPSBsb2NIb3N0O1xuICAgICAgICAgIHBpcGUubG9jID0gbG9jU3RyaXBwZWQ7XG4gICAgICAgICAgcGlwZS5wcm94eUlEID0gXCJcIjtcbiAgICAgICAgICBpZiAodXNpbmdIVE1MNSgpKSB7XG4gICAgICAgICAgICBwaXBlLmh0bWw1ID0gMTtcbiAgICAgICAgICAgIHBpcGUucHJveHlQYXRoID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3UGlwZSA9IF9jYWxsX3htc2dfaG9zdF9mYihcInByZXBcIiwgcGlwZSk7XG4gICAgICAgICAgICBpZiAobmV3UGlwZSkge1xuICAgICAgICAgICAgICBwaXBlID0gbmV3UGlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cnMubmFtZSA9IHBpcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGU7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgTGlzdGVuIGZvciBtZXNzYWdlcyBmcm9tIGFuIElGUkFNRS4gTm90ZSB0aGF0IG9uIHRoZSBob3N0IC8gcHVibGlzaGVyIHNpZGVcbiAgICAgIHRoaXMgbGlicmFyeSBvbmx5IGFsbG93cyBmb3Igb25lIG1lc3NhZ2UgaGFuZGxlciB0byBiZSBhdHRhY2hlZCB0byBhIGdpdmVuXG4gICAgICBJRlJBTUUuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5saWIuZG9tLm1zZ2hvc3QuYXR0YWNoXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBJRlJBTUUgcmVmZXJlbmNlIHRvIGF0dGFjaCBhIGxpc3RlbmVyIGNhbGxiYWNrIHRvby4gLlxuICAgICAgQHBhcmFtIHtPYmplY3R9IHBpcGUgVGhlIG1lc3NhZ2UgcGlwZSBvYmplY3QgY3JlYXRlZCBmcm9tICRzZi5saWIuZG9tLm1zZ2hvc3QucHJlcFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgICAqL1xuICAgICAgYXR0YWNoX2lmcmFtZV9tc2dpbmcgPSBmdW5jdGlvbihlbCwgcGlwZSwgY2IpIHtcbiAgICAgICAgdmFyIHRndElEO1xuICAgICAgICB0Z3RJRCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKF90YWdOYW1lKGVsKSA9PT0gXCJpZnJhbWVcIikge1xuICAgICAgICAgIHRndElEID0gX2F0dHIoZWwsIFwiaWRcIik7XG4gICAgICAgICAgaWYgKHRndElEICYmIHBpcGUgJiYgKHBpcGUgaW5zdGFuY2VvZiBQYXJhbUhhc2gpICYmIHRndElEID09PSBwaXBlLmlkKSB7XG4gICAgICAgICAgICBpZiAodXNpbmdIVE1MNSgpKSB7XG4gICAgICAgICAgICAgIG1zZ19waXBlc1t0Z3RJRF0gPSBwaXBlO1xuICAgICAgICAgICAgICBwaXBlLl94bXNnY2IgPSBjYjtcbiAgICAgICAgICAgICAgaWYgKCFodG1sNUJvdW5kKSB7XG4gICAgICAgICAgICAgICAgZG9tW0FUVEFDSF0od2luLCBNU0csIF9oYW5kbGVfbXNnX2Zyb21fb3V0c2lkZSk7XG4gICAgICAgICAgICAgICAgaHRtbDVCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9jYWxsX3htc2dfaG9zdF9mYihBVFRBQ0gsIGVsLCBwaXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgRGV0YWNoIGxpc3RlbmluZyBmb3IgbWVzc2FnZXMgZnJvbSBhbiBJRlJBTUVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmxpYi5kb20ubXNnaG9zdC5kZXRhY2hcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIElGUkFNRSByZWZlcmVuY2UgdG8gZGV0YWNoIGEgbGlzdGVuZXJcbiAgICAgICAqL1xuICAgICAgZGV0YWNoX2lmcmFtZV9tc2dpbmcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICB2YXIgZW1wdHksIGlkLCBwaXBlLCB3O1xuICAgICAgICBpZCA9IF9hdHRyKGVsLCBcImlkXCIpO1xuICAgICAgICBwaXBlID0gaWQgJiYgbXNnX3BpcGVzW2lkXTtcbiAgICAgICAgdyA9IG51bGw7XG4gICAgICAgIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwaXBlKSB7XG4gICAgICAgICAgX2NhbGxfeG1zZ19ob3N0X2ZiKERFVEFDSCwgZWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGlwZSkge1xuICAgICAgICAgIHBpcGUuX3htc2djYiA9IG1zZ19waXBlc1tpZF0gPSBudWxsO1xuICAgICAgICAgIHBpcGUgPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZSBtc2dfcGlwZXNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlkID0gXCJcIjtcbiAgICAgICAgZm9yIChpZCBpbiBtc2dfcGlwZXMpIHtcbiAgICAgICAgICBwaXBlID0gbXNnX3BpcGVzW2lkXTtcbiAgICAgICAgICBpZiAocGlwZSAmJiBwaXBlW0dVSURdKSB7XG4gICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eSAmJiB1c2luZ0hUTUw1KCkgJiYgaHRtbDVCb3VuZCkge1xuICAgICAgICAgIGh0bWw1Qm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBkb21bREVUQUNIXSh3aW4sIE1TRywgX2hhbmRsZV9tc2dfZnJvbV9vdXRzaWRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IHcgPSBwaXBlID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBGaXJlIHRoZSBzcGVjaWZlZCBjYWxsYmFjayBvdXQgdG8gdGhlIHB1Ymxpc2hlci4gTm90ZSB0aGF0IG90aGVyIGFyZ3VtZW50cyBiZXlvbmQgdGhlIDFzdCBhcmd1bWVudCBhcmUgcGFzc2VkIHRocm91ZyB0byB0aGUgY2FsbGJhY2suXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9maXJlX3B1Yl9jYWxsYmFja1xuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGNiX25hbWUgVGhlIGNhbGxiYWNrIG5hbWUgdG8gZmlyZVxuICAgICAgICovXG4gICAgICBfZmlyZV9wdWJfY2FsbGJhY2sgPSBmdW5jdGlvbihjYl9uYW1lKSB7XG4gICAgICAgIHZhciBhLCBhcmdzLCBjYl9hcmdzLCBlLCBmLCBpZHgsIGxlbiwgcmV0O1xuICAgICAgICBjYl9hcmdzID0gW107XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxlbiA9IGFyZ3NbTEVOXTtcbiAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgZiA9IHZvaWQgMDtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIGEgPSB2b2lkIDA7XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICBmID0gY29uZmlnW2NiX25hbWVdO1xuICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgICAgYSA9IGFyZ3NbaWR4KytdO1xuICAgICAgICAgICAgICBpZiAoYSAhPT0gY2JfbmFtZSkge1xuICAgICAgICAgICAgICAgIGNiX2FyZ3MucHVzaChhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0ID0gZi5hcHBseShudWxsLCBjYl9hcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBOdWtlIHRoZSBwb3NpdGlvbiBhbiByZXBvcnQgdGhhdCBzYWlkIHBvc2l0aW9uIHRvb2sgdG9vIGxvbmcgdG8gcmVuZGVyXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfcmVuZGVyX3RpbWVvdXRcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBwb3NfaWQgVGhlIHBvc2l0aW9uIGlkIHRoYXQgaGFzIHRha2VuIHRvbyBsb25nXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfcmVuZGVyX3RpbWVvdXQgPSBmdW5jdGlvbihwb3NfaWQpIHtcbiAgICAgICAgdmFyIHBlbmQ7XG4gICAgICAgIHBlbmQgPSBwb3NfaWQgJiYgcGVuZGluZ19pZnJzW3Bvc19pZF07XG4gICAgICAgIGlmIChwZW5kKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmQpO1xuICAgICAgICAgIG51a2UocG9zX2lkKTtcbiAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgXCJyZW5kZXItdGltZW91dFwiLCBwb3NfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2hhc19wZW5kaW5nX3JlbmRlcnMoKSkge1xuICAgICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIENsZWFyIHRoZSB0aW1lciB0aGF0IGZpcmVzIGV2ZXJ5IHNvIG9mdGVuIHRvIHVwZGF0ZSB0aGUgZ2VvbWV0cnkgaW4gc2lkZVxuICAgICAgb2YgU2FmZUZyYW1lc1xuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fY2xlYXJfZ2VvbV91cGRhdGVfdGltZXJcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChnZW9tX3VwZGF0ZV90aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChnZW9tX3VwZGF0ZV90aW1lcik7XG4gICAgICAgICAgZ2VvbV91cGRhdGVfdGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgK1x0ICogQ2xlYXIgdGhlIHRpbWVyIHRoYXQgZmlyZXMgZXZlcnkgc28gb2Z0ZW4gdG8gdXBkYXRlIHRoZSBnZW9tZXRyeSBpbiBzaWRlXG4gICAgICArXHQgKiBvZiBTYWZlRnJhbWVzXG4gICAgICArXHQgKlxuICAgICAgK1x0ICogQG5hbWUgJHNmLmhvc3QtX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyXG4gICAgICArXHQgKiBAc3RhdGljXG4gICAgICArXHQgKiBAcHJpdmF0ZVxuICAgICAgK1x0ICogQGZ1bmN0aW9uXG4gICAgICArXHQgKlxuICAgICAgK1xuICAgICAgICovXG4gICAgICBfY2xlYXJfZm9jdXNfdXBkYXRlX3RpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChmb2N1c191cGRhdGVfdGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZm9jdXNfdXBkYXRlX3RpbWVyKTtcbiAgICAgICAgICBmb2N1c191cGRhdGVfdGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3NldF9mb2N1c191cGRhdGVfdGltZXIgPSBmdW5jdGlvbihpbl9mb2N1cykge1xuICAgICAgICBfY2xlYXJfZm9jdXNfdXBkYXRlX3RpbWVyKCk7XG4gICAgICAgIGZvY3VzX3VwZGF0ZV90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3VwZGF0ZV9mb2N1cyhpbl9mb2N1cyk7XG4gICAgICAgIH0sIDIpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFNldCB1cCB0aGUgdGltZXIgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIGVhY2ggU2FmZUZyYW1lIHdpdGggdXAgdG8gZGF0ZSBnZW9tZXRyaWMgaW5mb3JtYXRpb25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3NldF9nZW9tX3VwZGF0ZV90aW1lclxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBfc2V0X2dlb21fdXBkYXRlX3RpbWVyID0gZnVuY3Rpb24oaXNfd2luX3Njcm9sbCkge1xuICAgICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICAgICAgaWYgKGlzX3dpbl9zY3JvbGwpIHtcbiAgICAgICAgICBnZW9tX3VwZGF0ZV90aW1lciA9IHNldFRpbWVvdXQoX3VwZGF0ZV9nZW9tX3dpbl9zY3JvbGwsIEdFT01fVVBEQVRFX0lOVFJWQUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlb21fdXBkYXRlX3RpbWVyID0gc2V0VGltZW91dChfdXBkYXRlX2dlb21fd2luX3Jlc2l6ZSwgR0VPTV9VUERBVEVfSU5UUlZBTCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBVcGRhdGUgYWxsIFNhZmVGcmFtZXMgd2l0aCB1cGRhdGVkIGdlb21ldHJpYyBpbmZvcm1hdGlvblxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fdXBkYXRlX2dlb21cbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gaXNfd2luX3Njcm9sbCBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgdXBkYXRpbmcgZHVlIHRvIHRoZSBtYWluIHdpbmRvdyBiZWluZyBzY3JvbGxlZFxuICAgICAgICovXG4gICAgICBfdXBkYXRlX2dlb20gPSBmdW5jdGlvbihpc193aW5fc2Nyb2xsKSB7XG4gICAgICAgIHZhciBnLCBpZCwgaWZyLCBtc2dPYmosIHBhcmFtcywgcG9zSUQ7XG4gICAgICAgIHBvc0lEID0gdm9pZCAwO1xuICAgICAgICBwYXJhbXMgPSB2b2lkIDA7XG4gICAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICAgIGlmciA9IHZvaWQgMDtcbiAgICAgICAgZyA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChwb3NJRCBpbiByZW5kZXJlZF9pZnJzKSB7XG4gICAgICAgICAgaWYgKGlzX3dpbl9zY3JvbGwgJiYgKHBvc0lEIGluIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtcyA9IHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgICAgIGlkID0gcGFyYW1zICYmIHBhcmFtcy5kZXN0O1xuICAgICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICAgIGlmIChpZnIgJiYgcGFyYW1zKSB7XG4gICAgICAgICAgICBnID0gX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSk7XG4gICAgICAgICAgICBtc2dPYmogPSBQYXJhbUhhc2goKTtcbiAgICAgICAgICAgIG1zZ09iai5wb3MgPSBwb3NJRDtcbiAgICAgICAgICAgIG1zZ09iai5jbWQgPSBOT1RJRllfR0VPTV9VUERBVEU7XG4gICAgICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhnKTtcbiAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBwb3NJRCwgTk9USUZZX0dFT01fVVBEQVRFLCBnKTtcbiAgICAgICAgICAgIF9zZW5kX3Jlc3BvbnNlKHBhcmFtcywgbXNnT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2NsZWFyX2dlb21fdXBkYXRlX3RpbWVyKCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgVXBkYXRlIGFsbCBTYWZlRnJhbWVzIHdpdGggdXBkYXRlZCBnZW9tZXRyaWMgaW5mb3JtYXRpb24gZHVlIHRvIGEgd2luZG93IHJlc2l6ZVxuICAgICAgZXZlbnQuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV91cGRhdGVfZ2VvbV93aW5fcmVzaXplXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF91cGRhdGVfZ2VvbV93aW5fcmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF91cGRhdGVfZ2VvbSgpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFVwZGF0ZSBhbGwgU2FmZUZyYW1lcyB3aXRoIHVwZGF0ZWQgZ2VvbWV0cmljIGluZm9ybWF0aW9uIGR1ZSB0byBhIHdpbmRvdyBzY3JvbGwgZXZlbnRcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3VwZGF0ZV9nZW9tX3dpbl9zY3JvbGxcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX3VwZGF0ZV9nZW9tX3dpbl9zY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3VwZGF0ZV9nZW9tKHRydWUpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFVwZGF0ZSBhIFNhZmVGcmFtZSB0aGF0IGhhcyBuZXcgZ2VvbWV0cmljIGluZm9ybWF0aW9uIGR1ZSB0byBpdHMgcGFyZW50IEhUTUwgZWxlbWVudFxuICAgICAgc2Nyb2xsaW5nLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1faGFuZGxlX25vZGVfc2Nyb2xsXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfbm9kZV9zY3JvbGwgPSBmdW5jdGlvbihldnQsIHBvc0lELCBub2RlKSB7XG4gICAgICAgIHZhciBnLCBzY3JfaGFuZGxlO1xuICAgICAgICBzY3JfaGFuZGxlID0gc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcG9zSURdO1xuICAgICAgICBnID0gdm9pZCAwO1xuICAgICAgICBpZiAoc2NyX2hhbmRsZSkge1xuICAgICAgICAgIGlmIChzY3JfaGFuZGxlLnRJRCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcl9oYW5kbGUudElEKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzY3JfaGFuZGxlLnRJRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NyX2hhbmRsZS50SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlkLCBpZnIsIG1zZ09iaiwgcGFyYW1zO1xuICAgICAgICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgICAgICBpZCA9IHBhcmFtcyAmJiBwYXJhbXMuZGVzdDtcbiAgICAgICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICAgICAgZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpZnIgJiYgcGFyYW1zKSB7XG4gICAgICAgICAgICAgIGcgPSBfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKTtcbiAgICAgICAgICAgICAgbXNnT2JqID0gUGFyYW1IYXNoKCk7XG4gICAgICAgICAgICAgIG1zZ09iai5wb3MgPSBwb3NJRDtcbiAgICAgICAgICAgICAgbXNnT2JqLmNtZCA9IE5PVElGWV9HRU9NX1VQREFURTtcbiAgICAgICAgICAgICAgbXNnT2JqLmdlb20gPSBfZXMoZyk7XG4gICAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBwb3NJRCwgTk9USUZZX0dFT01fVVBEQVRFLCBnKTtcbiAgICAgICAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHNjcl9oYW5kbGUudElEO1xuICAgICAgICAgIH0sIEdFT01fVVBEQVRFX0lOVFJWQUwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIHRoZSB3aW5kb3cgb25zY3JvbGwgZXZlbnQsIGV2ZW50dWFsbHkgbGVhZGluZyB0byBhIGdlb21ldHJpYyB1cGRhdGVcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV93aW5fZ2VvbV9zY3JvbGxcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBldmVudCBvYmplY3RcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV93aW5fZ2VvbV9zY3JvbGwgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3NldF9nZW9tX3VwZGF0ZV90aW1lcigxKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIHdpbmRvdyBvbnJlc2l6ZSBldmVudCwgZXZlbnR1YWxseSBsZWFkaW5nIHRvIGEgZ2VvbWV0cmljIHVwZGF0ZVxuICAgICAgb25jZSB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2xvd2VkIGRvd25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2hhbmRsZV93aW5fZ2VvbV9yZXNpemVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgVGhlIHJhdyBldmVudCBvYmplY3RcbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV93aW5fZ2VvbV9yZXNpemUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3NldF9nZW9tX3VwZGF0ZV90aW1lcigpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFVwZGF0ZSBhbGwgU2FmZUZyYW1lcyB3aXRoIHVwZGF0ZWQgZm9jdXMgaW5mb3JtYXRpb25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3VwZGF0ZV9mb2N1c1xuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtCb29sZWFufSBpbl9mb2N1cyBUcnVlIHdoZW4gdGhlIHdpbmRvdyBoYXMgZ2FpbmVkIGZvY3VzXG4gICAgICAgKi9cbiAgICAgIF91cGRhdGVfZm9jdXMgPSBmdW5jdGlvbihpbl9mb2N1cykge1xuICAgICAgICB2YXIgZGF0YSwgaWQsIGlmciwgbXNnT2JqLCBwYXJhbXMsIHBvc0lEO1xuICAgICAgICBwb3NJRCA9IHZvaWQgMDtcbiAgICAgICAgcGFyYW1zID0gdm9pZCAwO1xuICAgICAgICBtc2dPYmogPSB2b2lkIDA7XG4gICAgICAgIGlkID0gdm9pZCAwO1xuICAgICAgICBpZnIgPSB2b2lkIDA7XG4gICAgICAgIGZvciAocG9zSUQgaW4gcmVuZGVyZWRfaWZycykge1xuICAgICAgICAgIHBhcmFtcyA9IHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgICAgIGlkID0gcGFyYW1zICYmIHBhcmFtcy5kZXN0O1xuICAgICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICAgIGlmIChpZnIgJiYgcGFyYW1zKSB7XG4gICAgICAgICAgICBtc2dPYmogPSBQYXJhbUhhc2goKTtcbiAgICAgICAgICAgIGRhdGEgPSBQYXJhbUhhc2goKTtcbiAgICAgICAgICAgIG1zZ09iai5wb3MgPSBwb3NJRDtcbiAgICAgICAgICAgIG1zZ09iai5jbWQgPSBkYXRhLmNtZCA9IE5PVElGWV9GT0NVU19DSEFOR0U7XG4gICAgICAgICAgICBtc2dPYmoudmFsdWUgPSBpbl9mb2N1cztcbiAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBwb3NJRCwgTk9USUZZX0ZPQ1VTX0NIQU5HRSwgaW5fZm9jdXMpO1xuICAgICAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfY2xlYXJfZm9jdXNfdXBkYXRlX3RpbWVyKCk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgSGFuZGxlIHRoZSB3aW5kb3cgZm9jdXMgZXZlbnQsIHdoaWNoIG5vdGlmaWVzIGFkcyBvZiB0aGUgY2hhbmdlXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfd2luX2ZvY3VzID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF9zZXRfZm9jdXNfdXBkYXRlX3RpbWVyKHRydWUpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSB0aGUgd2luZG93IGJsdXIgZXZlbnQsIHdoaWNoIG5vdGlmaWVzIGFkcyBvZiB0aGUgY2hhbmdlXG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfd2luX2JsdXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3NldF9mb2N1c191cGRhdGVfdGltZXIoZmFsc2UpO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEhhbmRsZSB0aGUgd2luZG93IHVubG9hZCBldmVudCwgY2xlYXJpbmcgdXAgb3VyIHN0YXRlXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfdW5sb2FkXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgZXZlbnQgb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIF9oYW5kbGVfdW5sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBlLCBwcm9wLCBzY3JfaGFuZGxlO1xuICAgICAgICBwcm9wID0gdm9pZCAwO1xuICAgICAgICBzY3JfaGFuZGxlID0gdm9pZCAwO1xuICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb20uZGV0YWNoKHdpbiwgU0NST0xMLCBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCk7XG4gICAgICAgICAgZG9tLmRldGFjaCh3aW4sIFwicmVzaXplXCIsIF9oYW5kbGVfd2luX2dlb21fcmVzaXplKTtcbiAgICAgICAgICBkb20uZGV0YWNoKHdpbiwgXCJ1bmxvYWRcIiwgX2hhbmRsZV91bmxvYWQpO1xuICAgICAgICAgIGRvbS5kZXRhY2god2luLCBcImZvY3VzXCIsIF9oYW5kbGVfd2luX2ZvY3VzKTtcbiAgICAgICAgICBkb20uZGV0YWNoKHdpbiwgXCJibHVyXCIsIF9oYW5kbGVfd2luX2JsdXIpO1xuICAgICAgICAgIGZvciAocHJvcCBpbiBzY3JvbGxfcGFyZW50c19hdHRhY2hlZCkge1xuICAgICAgICAgICAgc2NyX2hhbmRsZSA9IHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHNjcl9oYW5kbGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNjcl9oYW5kbGUudElEKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcl9oYW5kbGUudElEKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb20uZGV0YWNoKHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Byb3BdLCBTQ1JPTEwsIHNjcl9oYW5kbGVbT05TQ1JPTExdKTtcbiAgICAgICAgICAgICAgc2NyX2hhbmRsZVtPTlNDUk9MTF0gPSBzY3JfaGFuZGxlLm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcHJvcF0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aW5fZXZlbnRzX2F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIHdpbmRvdyBtZXNzYWdlIGV2ZW50LCBwYXNzZWQgZnJvbSByYXcgZXZlbnQgaGFuZGxpbmcgb2YgdGhlIG1zZ2hvc3QgY29kZS5cbiAgICAgIFBhc3MgdGhyb3VnaCB0aGUgZGF0YSB0byBvdXIgZm9ybWF0IGhhbmRsaW5nIGZ1bmN0aW9ucyBmb3IgZXhwYW5kLCBldGMuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9oYW5kbGVfbXNnX2V2dFxuICAgICAgQHN0YXRpY1xuICAgICAgQHByaXZhdGVcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhIHRoZSBtZXNzYWdlIHRvIGJlIGhhbmRsZWRcbiAgICAgIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgbWVzc2FnZSB3YXMgaGFuZGxlZFxuICAgICAgICovXG4gICAgICBfaGFuZGxlX21zZ19ldnQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjYW5SZWFkLCBjYW5Xcml0ZSwgaW5mbywgbXNnT2JqLCByZXQ7XG4gICAgICAgIG1zZ09iaiA9IHZvaWQgMDtcbiAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIGluZm8gPSB2b2lkIDA7XG4gICAgICAgIG1zZ09iaiA9IFBhcmFtSGFzaChkYXRhLCBudWxsLCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYgKG1zZ09iaiAmJiBtc2dPYmoucG9zKSB7XG4gICAgICAgICAgaW5mbyA9IHJlbmRlcmVkX2lmcnNbbXNnT2JqLnBvc107XG4gICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIHJldCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChtc2dPYmouY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV4cC1wdXNoXCI6XG4gICAgICAgICAgICAgICAgICBfZXhwYW5kX3NhZmVmcmFtZShtc2dPYmosIHRydWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV4cC1vdnJcIjpcbiAgICAgICAgICAgICAgICAgIF9leHBhbmRfc2FmZWZyYW1lKG1zZ09iaik7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29sbGFwc2VcIjpcbiAgICAgICAgICAgICAgICAgIF9jb2xsYXBzZV9zYWZlZnJhbWUobXNnT2JqKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtc2dcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xpY2tlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2aWV3ZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWVzdGVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVudmlld2VkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlbG9hZFwiOlxuICAgICAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIG1zZ09iai5wb3MsIG1zZ09iai5jbWQsIG1zZ09iai5tc2cpO1xuICAgICAgICAgICAgICAgICAgX3NlbmRfZ2VuZXJpY19yZXNwb25zZShtc2dPYmoucG9zLCBtc2dPYmouY21kKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsb2FkZWRcIjpcbiAgICAgICAgICAgICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhcIm9uQWRMb2FkXCIsIG1zZ09iai5wb3MsIG1zZ09iaik7XG4gICAgICAgICAgICAgICAgICBfc2VuZF9nZW5lcmljX3Jlc3BvbnNlKG1zZ09iai5wb3MsIG1zZ09iai5jbWQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBFUlJPUl9DT01NQU5EOlxuICAgICAgICAgICAgICAgICAgX3JlY29yZF9lcnJvcihtc2dPYmopO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBOT1RJRllfR0VPTV9VUERBVEU6XG4gICAgICAgICAgICAgICAgICBzZi5saWIubG9nZ2VyLmxvZyhcIkdlb20gdXBkYXRlIGNvbXBsZXRlOiBcIiArIG1zZ09iai5wb3MpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYWQtY29va2llXCI6XG4gICAgICAgICAgICAgICAgICBjYW5SZWFkID0gaW5mby5jb25mICYmIGluZm8uY29uZi5zdXBwb3J0cyAmJiBpbmZvLmNvbmYuc3VwcG9ydHNbbXNnT2JqLmNtZF0gJiYgaW5mby5jb25mLnN1cHBvcnRzW21zZ09iai5jbWRdICE9PSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgIGlmIChjYW5SZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZWFkX2Nvb2tpZShtc2dPYmopO1xuICAgICAgICAgICAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soXCJvbkNvb2tpZVJlYWRcIiwgbXNnT2JqLnBvcywgbXNnT2JqLmNvb2tpZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIndyaXRlLWNvb2tpZVwiOlxuICAgICAgICAgICAgICAgICAgY2FuV3JpdGUgPSBpbmZvLmNvbmYgJiYgaW5mby5jb25mLnN1cHBvcnRzICYmIGluZm8uY29uZi5zdXBwb3J0c1ttc2dPYmouY21kXSAmJiBpbmZvLmNvbmYuc3VwcG9ydHNbbXNnT2JqLmNtZF0gIT09IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIF93cml0ZV9jb29raWUobXNnT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFwib25Db29raWVXcml0ZVwiLCBtc2dPYmoucG9zLCBtc2dPYmouY29va2llKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgQ2hlY2sgd2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBTYWZlRnJhbWVzIGJlaW5nIHJlbmRlcmVkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9oYXNfcGVuZGluZ19yZW5kZXJzXG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9oYXNfcGVuZGluZ19yZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGxfcmVuZGVyc19kb25lLCBwb3NfaWQ7XG4gICAgICAgIGFsbF9yZW5kZXJzX2RvbmUgPSB0cnVlO1xuICAgICAgICBwb3NfaWQgPSB2b2lkIDA7XG4gICAgICAgIGZvciAocG9zX2lkIGluIHBlbmRpbmdfaWZycykge1xuICAgICAgICAgIGFsbF9yZW5kZXJzX2RvbmUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsX3JlbmRlcnNfZG9uZTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBTZW5kIGEgcmVzcG9uc2UgYmFjayBkb3duIHRvIHRoZSBTYWZlRnJhbWUgYWZ0ZXIgYSBtZXNzYWdlIHdhcyBoYW5kbGVkXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9zZW5kX3Jlc3BvbnNlXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IHBhcmFtcyBUaGUgcGFyYW1ldGVycyBvYmplY3Qgc3RvcmVkIGZvciBhIHJlbmRlcmVkIFNhZmVGcmFtZSBob2xkaW5nIHN0YXRlIGluZm9ybWF0aW9uXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBUaGUgbWVzc2FnZSB0byBzZW5kIGJhY2sgZG93biBpbnRvIHRoZSBTYWZlRnJhbWVcbiAgICAgICAqL1xuICAgICAgX3NlbmRfcmVzcG9uc2UgPSBmdW5jdGlvbihwYXJhbXMsIG1zZ09iaikge1xuXG4gICAgICAgIC8qXG4gICAgICAgIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRfc3RhdHVzID0gXCJzZW5kaW5nLW1zZy1kb3duLVwiICsgbXNnT2JqLmNtZDtcbiAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgIGlkID0gcGFyYW1zICYmIHBhcmFtcy5kZXN0O1xuICAgICAgICAgIGlmIChpZCAmJiBtc2dPYmopIHtcbiAgICAgICAgICAgIHNlbmRfbXNnX3RvX2NoaWxkX2lmcmFtZShpZCwgbXNnT2JqLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50X3N0YXR1cyA9IFwiXCI7XG4gICAgICAgICAgbXNnT2JqID0gaWQgPSBwYXJhbXMgPSBudWxsO1xuICAgICAgICB9KSwgWENPTV9SRVNQX0RFTEFZKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBIYW5kbGUgdGhlIG9ubG9hZCBldmVudCBmcm9tIHRoZSBJRlJBTUUgdGFnIGNyZWF0ZWQgZm9yIGEgU2FmZUZyYW1lLlxuICAgICAgTm90ZSB0aGF0IGIvYyB3ZSB1c2VkIG91ciBvd24gbGlicmFyeSB0byBjcmVhdGUgdGhlIElGUkFNRSAoJHNmLmxpYi5kb20uaWZyYW1lcyksXG4gICAgICB0aGUgXCJ0aGlzXCIga2V5d29yZCB3aWxsIG5vdyBwcm9wZXJseSBwb2ludCB0byB0aGUgSUZSQU1FIGluIHF1ZXN0aW9uLlxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1faGFuZGxlX2ZyYW1lX2xvYWRcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgX2hhbmRsZV9mcmFtZV9sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGxfcmVuZGVyc19kb25lLCBlbCwgcG9zX2lkO1xuICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIHBvc19pZCA9IGRvbS5hdHRyKGVsLCBcIl9wb3NfaWRcIik7XG4gICAgICAgIGFsbF9yZW5kZXJzX2RvbmUgPSB0cnVlO1xuICAgICAgICBpZiAocGVuZGluZ19pZnJzW3Bvc19pZF0pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocGVuZGluZ19pZnJzW3Bvc19pZF0pO1xuICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICBjb21wbGV0ZV9pZnJzW3Bvc19pZF0gPSBwb3NfaWQ7XG4gICAgICAgICAgZG9tLmF0dHIoZWwsIFwiX3Bvc19pZFwiLCBudWxsKTtcbiAgICAgICAgICBkb20uYXR0cihlbCwgXCJuYW1lXCIsIG51bGwpO1xuICAgICAgICAgIGVsW1NUXS52aXNpYmlsaXR5ID0gXCJpbmhlcml0XCI7XG4gICAgICAgICAgZWxbU1RdLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFwib25FbmRQb3NSZW5kZXJcIiwgcG9zX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9oYXNfcGVuZGluZ19yZW5kZXJzKCkpIHtcbiAgICAgICAgICBjdXJyZW50X3N0YXR1cyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBCdWlsZCBhbiBleHRyYSBJRlJBTUUgdG8gcHV0IGJlaGluZCBhbnkgaWZyYW1lIHRoYXQgaXMgZXhwYW5kaW5nLCB0byBwcm90ZWN0XG4gICAgICBhZ2FpbnN0IHBhaW50aW5nIGlzc3VlcyBpbiBJRSB3aXRoIHdpbmRvdydkIG1vZGUgZmxhc2guXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9zaGltX2ZyYW1lXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIF9zaGltX2ZyYW1lID0gZnVuY3Rpb24oaWQsIHNob3dJdCwgdywgaCwgeikge1xuICAgICAgICB2YXIgaWZyLCBzaG1Gcm0sIHNobUlEO1xuICAgICAgICBpZiAoIWlzSUUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWZyID0gX2VsdChpZCk7XG4gICAgICAgIHNobUlEID0gXCJzaG1fXCIgKyBpZDtcbiAgICAgICAgc2htRnJtID0gX2VsdChzaG1JRCk7XG4gICAgICAgIGlmIChzaG93SXQpIHtcbiAgICAgICAgICBpZiAoc2htRnJtKSB7XG4gICAgICAgICAgICBzaG1Gcm1bU1RdLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2htRnJtID0gaWZyYW1lcy5jbG9uZShpZnIsIHtcbiAgICAgICAgICAgIGlkOiBzaG1JRCxcbiAgICAgICAgICAgIHNyYzogXCJcIixcbiAgICAgICAgICAgIG5hbWU6IHNobUlEXG4gICAgICAgICAgfSwgW1dJRFRILCBcIjpcIiwgdywgUFgsIFwiO3Bvc2l0aW9uOmFic29sdXRlO1wiLCBIRUlHSFQsIFwiOlwiLCBoLCBQWCwgXCI7ei1pbmRleDpcIiwgeiAtIDEsIFwiO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEob3BhY2l0eT0wKVwiXSk7XG4gICAgICAgICAgZG9tLmFwcGVuZChfcGFyKGlmciksIHNobUZybSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzaG93SXQgJiYgc2htRnJtKSB7XG4gICAgICAgICAgICBzaG1Gcm1bU1RdLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEJ1aWxkIGEgZ2VvbWV0cnkgaW5mbyBvYmplY3QgZm9yIGEgcGFydGljdWxhciBTYWZlRnJhbWUgcG9zaXRpb24sIGFuZCBhbHNvXG4gICAgICBtYXkgYXR0YWNoIGFuIG9uc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRvIGEgcGFyZW50IEhUTUwgZWxlbWVudCBpZiBzYWlkIHBhcmVudCBlbGVtZW50XG4gICAgICBpcyBzY3JvbGxhYmxlIGJ1dCBub3QgdGhlIHJvb3QgZG9jdW1lbnQgbm9kZSAvIGJvZHlcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX2J1aWxkX2dlb21cbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEByZXR1cm4ge09iamVjdH0gV2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gU2FmZUZyYW1lXG4gICAgICAgKi9cbiAgICAgIF9idWlsZF9nZW9tID0gZnVuY3Rpb24ocG9zSUQsIGRlc3QsIGRvbnRfYXR0YWNoX3Njcm9sbF9ldnQpIHtcbiAgICAgICAgdmFyIGRldGFpbHMsIGUsIGV4LCBpbmZvLCBuZXdfcmVmX25vZGUsIG5vZGUsIHMsIHNjcl9oYW5kbGU7XG4gICAgICAgIGJvdW5kcyA9IHZvaWQgMDtcbiAgICAgICAgaW5mbyA9IFBhcmFtSGFzaCgpO1xuICAgICAgICBkZXRhaWxzID0ge307XG4gICAgICAgIHNjcl9oYW5kbGUgPSB2b2lkIDA7XG4gICAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgIG5ld19yZWZfbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgZXggPSB2b2lkIDA7XG4gICAgICAgIHMgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm91bmRzID0gZG9tLmJvdW5kcyhkZXN0LCBkZXRhaWxzLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIWRvbnRfYXR0YWNoX3Njcm9sbF9ldnQgJiYgIWRldGFpbHMuaXNSb290ICYmIGRldGFpbHMuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgICBleCA9IGRldGFpbHMuZXhwUmVjdDtcbiAgICAgICAgICAgIGlmIChleC54cyB8fCBleC55cykge1xuICAgICAgICAgICAgICBzY3JfaGFuZGxlID0gc2Nyb2xsX3BhcmVudHNfYXR0YWNoZWRbcG9zSURdO1xuICAgICAgICAgICAgICBuZXdfcmVmX25vZGUgPSBkZXRhaWxzLnJlZk5vZGU7XG4gICAgICAgICAgICAgIGlmIChzY3JfaGFuZGxlICYmIHNjcl9oYW5kbGUubm9kZSAhPT0gbmV3X3JlZl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcl9oYW5kbGUudElEKSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb20uZGV0YWNoKG5vZGUsIFNDUk9MTCwgc2NyX2hhbmRsZVtPTlNDUk9MTF0pO1xuICAgICAgICAgICAgICAgIHNjcl9oYW5kbGUubm9kZSA9IHNjcl9oYW5kbGVbT05TQ1JPTExdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF0pIHtcbiAgICAgICAgICAgICAgICBzY3JfaGFuZGxlID0ge307XG4gICAgICAgICAgICAgICAgc2NyX2hhbmRsZS5ub2RlID0gbmV3X3JlZl9ub2RlO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBAaWdub3JlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2NyX2hhbmRsZVtPTlNDUk9MTF0gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgIF9oYW5kbGVfbm9kZV9zY3JvbGwoZXZ0LCBwb3NJRCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF0gPSBzY3JfaGFuZGxlO1xuICAgICAgICAgICAgICAgIGRvbS5hdHRhY2gobmV3X3JlZl9ub2RlLCBTQ1JPTEwsIHNjcl9oYW5kbGVbT05TQ1JPTExdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBpbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpbmZvLndpbiA9IFBhcmFtSGFzaChkb20ud2luUmVjdCgpKTtcbiAgICAgICAgICAgIGluZm8ucGFyID0gUGFyYW1IYXNoKGRldGFpbHMucmVmUmVjdCk7XG4gICAgICAgICAgICBleCA9IFBhcmFtSGFzaChkZXRhaWxzLmV4cFJlY3QpO1xuICAgICAgICAgICAgcyA9IFBhcmFtSGFzaChkZXRhaWxzLnJlY3QpO1xuICAgICAgICAgICAgcy5pdiA9IGV4Lml2O1xuICAgICAgICAgICAgcy54aXYgPSBleC54aXY7XG4gICAgICAgICAgICBzLnlpdiA9IGV4LnlpdjtcbiAgICAgICAgICAgIGRlbGV0ZSBleC5pdjtcbiAgICAgICAgICAgIGRlbGV0ZSBleC54aXY7XG4gICAgICAgICAgICBkZWxldGUgZXgueWl2O1xuICAgICAgICAgICAgaW5mby5leHAgPSBleDtcbiAgICAgICAgICAgIGluZm8uc2VsZiA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIGluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEV4cGFuZHMgYSBnaXZlbiBTYWZlRnJhbWUgYmFzZWQgb24gYSBjb21tYW5kIGZyb20gdGhlIDNyZCBwYXJ0eSBjb250ZW50XG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9leHBhbmRfc2FmZWZyYW1lXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBEZXRhaWxzIGFib3V0IGhvdyB0byBkbyB0aGUgZXhwYW5zaW9uXG4gICAgICBcbiAgICAgIFRPRE8sIGhhbmRsZSBvbW5pLWRpcmVjdGlvbmFsIGFuZCBwdXNoXG4gICAgICAgKi9cbiAgICAgIF9leHBhbmRfc2FmZWZyYW1lID0gZnVuY3Rpb24obXNnT2JqLCBwdXNoKSB7XG4gICAgICAgIHZhciBiLCBkZWx0YSwgZHgsIGR5LCBleHAsIGlkLCBpZnIsIGlmclN0LCBsLCBuSHQsIG5XZCwgb3JIdCwgb3JXZCwgcGFyLCBwYXJTdCwgcGFyYW1zLCBwYXJhbXNfY29uZiwgcG9zSUQsIHIsIHNjcl9oYW5kbGUsIHQsIHhuLCB5biwgejtcbiAgICAgICAgeG4gPSBmYWxzZTtcbiAgICAgICAgeW4gPSBmYWxzZTtcbiAgICAgICAgcG9zSUQgPSBtc2dPYmogJiYgbXNnT2JqLnBvcztcbiAgICAgICAgcGFyYW1zID0gdm9pZCAwO1xuICAgICAgICBwYXJhbXNfY29uZiA9IHZvaWQgMDtcbiAgICAgICAgaWZyID0gdm9pZCAwO1xuICAgICAgICBwYXIgPSB2b2lkIDA7XG4gICAgICAgIGlmclN0ID0gdm9pZCAwO1xuICAgICAgICBwYXJTdCA9IHZvaWQgMDtcbiAgICAgICAgb3JXZCA9IHZvaWQgMDtcbiAgICAgICAgb3JIdCA9IHZvaWQgMDtcbiAgICAgICAgZHggPSB2b2lkIDA7XG4gICAgICAgIGR5ID0gdm9pZCAwO1xuICAgICAgICBuV2QgPSB2b2lkIDA7XG4gICAgICAgIG5IdCA9IHZvaWQgMDtcbiAgICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICAgIHQgPSB2b2lkIDA7XG4gICAgICAgIGwgPSB2b2lkIDA7XG4gICAgICAgIHIgPSB2b2lkIDA7XG4gICAgICAgIGIgPSB2b2lkIDA7XG4gICAgICAgIGV4cCA9IHZvaWQgMDtcbiAgICAgICAgeiA9IHZvaWQgMDtcbiAgICAgICAgZGVsdGEgPSB2b2lkIDA7XG4gICAgICAgIHNjcl9oYW5kbGUgPSB2b2lkIDA7XG4gICAgICAgIGlmICghcG9zSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgICBpZiAoIXBhcmFtcyB8fCAhcGFyYW1zX2NvbmYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSBwYXJhbXMuZGVzdDtcbiAgICAgICAgaWZyID0gX2VsdChpZCk7XG4gICAgICAgIHBhciA9IF9lbHQoUE9TX1JFTF9CT1hfSURfUFJFRklYICsgXCJfXCIgKyBwb3NJRCk7XG4gICAgICAgIGlmICghaWZyIHx8ICFwYXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWZyU3QgPSBpZnJbU1RdO1xuICAgICAgICBwYXJTdCA9IHBhcltTVF07XG4gICAgICAgIGlmICghaWZyU3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NyX2hhbmRsZSA9IHNjcm9sbF9wYXJlbnRzX2F0dGFjaGVkW3Bvc0lEXTtcbiAgICAgICAgaWYgKHNjcl9oYW5kbGUgJiYgc2NyX2hhbmRsZS50SUQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2NyX2hhbmRsZS50SUQpO1xuICAgICAgICB9XG4gICAgICAgIF9jbGVhcl9nZW9tX3VwZGF0ZV90aW1lcigpO1xuICAgICAgICBleHAgPSBtc2dPYmouZXhwX29iajtcbiAgICAgICAgb3JXZCA9IHBhcmFtc19jb25mLnc7XG4gICAgICAgIG9ySHQgPSBwYXJhbXNfY29uZi5oO1xuICAgICAgICBpZiAoIWV4cCkge1xuICAgICAgICAgIGR4ID0gcGFyYW1zLmR4ID0gX2NudW0obXNnT2JqLmR4KTtcbiAgICAgICAgICBkeSA9IHBhcmFtcy5keSA9IF9jbnVtKG1zZ09iai5keSk7XG4gICAgICAgICAgeG4gPSBkeCA8IDA7XG4gICAgICAgICAgeW4gPSBkeSA8IDA7XG4gICAgICAgICAgbldkID0gKHhuID8gb3JXZCArIChkeCAqIC0xKSA6IG9yV2QgKyBkeCk7XG4gICAgICAgICAgbkh0ID0gKHluID8gb3JIdCArIChkeSAqIC0xKSA6IG9ySHQgKyBkeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IF9jbnVtKGV4cC50LCAwLCAwKTtcbiAgICAgICAgICBsID0gX2NudW0oZXhwLmwsIDAsIDApO1xuICAgICAgICAgIHIgPSBfY251bShleHAuciwgMCwgMCk7XG4gICAgICAgICAgYiA9IF9jbnVtKGV4cC5iLCAwLCAwKTtcbiAgICAgICAgICBuV2QgPSBfY251bShvcldkICsgbCArIHIsIDAsIDApO1xuICAgICAgICAgIG5IdCA9IF9jbnVtKG9ySHQgKyB0ICsgYiwgMCwgMCk7XG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIGR5ID0gdCAqIC0xO1xuICAgICAgICAgICAgeW4gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICBkeCA9IGwgKiAtMTtcbiAgICAgICAgICAgIHhuID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobldkIDw9IG9yV2QgJiYgbkh0IDw9IG9ySHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9maXJlX3B1Yl9jYWxsYmFjayhCRl9QT1NfTVNHLCBwb3NJRCwgRVhQQU5EX0NPTU1BTkQsIGR4LCBkeSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWZyU3RbV0lEVEhdID0gbldkICsgUFg7XG4gICAgICAgIGlmclN0W0hFSUdIVF0gPSBuSHQgKyBQWDtcbiAgICAgICAgaWYgKHhuKSB7XG4gICAgICAgICAgaWZyU3QubGVmdCA9IGR4ICsgUFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHluKSB7XG4gICAgICAgICAgaWZyU3QudG9wID0gZHkgKyBQWDtcbiAgICAgICAgfVxuICAgICAgICB6ID0gX2NudW0ocGFyYW1zLnosIDApO1xuICAgICAgICBpZiAoIXopIHtcbiAgICAgICAgICB6ID0gREVGQVVMVF9aSU5ERVg7XG4gICAgICAgIH1cbiAgICAgICAgaWZyU3QuekluZGV4ID0gejtcbiAgICAgICAgX3NoaW1fZnJhbWUoaWQsIHRydWUsIG5XZCwgbkh0LCB6IC0gMSk7XG4gICAgICAgIGlmIChwdXNoKSB7XG4gICAgICAgICAgcGFyU3RbV0lEVEhdID0gbldkICsgUFg7XG4gICAgICAgICAgcGFyU3RbSEVJR0hUXSA9IG5IdCArIFBYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhclN0W1dJRFRIXSA9IG9yV2QgKyBQWDtcbiAgICAgICAgICBwYXJTdFtIRUlHSFRdID0gb3JIdCArIFBYO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgIG1zZ09iai5keCA9IGR4O1xuICAgICAgICBtc2dPYmouZHkgPSBkeTtcbiAgICAgICAgbXNnT2JqLncgPSBuV2Q7XG4gICAgICAgIG1zZ09iai5oID0gbkh0O1xuICAgICAgICBtc2dPYmouY21kID0gXCJleHBhbmRcIjtcbiAgICAgICAgbXNnT2JqLmdlb20gPSBfZXMoX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSkpO1xuICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgcG9zSUQsIEVYUEFORF9DT01NQU5ELCBkeCwgZHkpO1xuICAgICAgICBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICAgIGlmclN0ID0gcGFyID0gaWZyID0gcGFyYW1zID0gbXNnT2JqID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBDb2xsYXBzZSBhIFNhZmVGcmFtZSBhZnRlciBpdCBoYXMgYmVlbiBleHBhbmRlZFxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC1fY29sbGFwc2Vfc2FmZWZyYW1lXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQHN0YXRpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyRzZi5saWIubGFuZy5QYXJhbUhhc2h9IG1zZ09iaiBUaGUgZGV0YWlscyBhYm91dCB0aGUgbWVzc2FnZSBzZW5kIGZyb20gdGhlIFNhZmVGcmFtZSB0byBjb2xsYXBzZVxuICAgICAgQHBhcmFtIHtCb29sZWFufSBbaXNPdXRzaWRlXSBXaGV0aGVyIG9yIG5vdCB0aGUgY29sbGFwc2UgY29tbWFuZCBjYW1lIGZyb20gdGhlIHB1Ymxpc2hlclxuICAgICAgQHBhcmFtIHtCb29sZWFufSBbbm9Nc2dpbmddIFdoZXRoZXIgb3Igbm90IHRvIHNlbmQgYSBtZXNzYWdlIG9mIHJlc3BvbnNlIGJhY2sgdG8gdGhlIFNhZmVGcmFtZSBiZWluZyBjb2xsYXBzZWRcbiAgICAgICAqL1xuICAgICAgX2NvbGxhcHNlX3NhZmVmcmFtZSA9IGZ1bmN0aW9uKG1zZ09iaiwgaXNPdXRzaWRlLCBub01zZ2luZykge1xuICAgICAgICB2YXIgaWQsIGlmciwgaWZyU3QsIHBhciwgcGFyU3QsIHBhcmFtcywgcGFyYW1zX2NvbmYsIHBvc0lELCBzY3JfaGFuZGxlO1xuICAgICAgICBwb3NJRCA9IG1zZ09iaiAmJiBtc2dPYmoucG9zO1xuICAgICAgICBwYXJhbXMgPSBwb3NJRCAmJiByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgcGFyYW1zX2NvbmYgPSBwYXJhbXMgJiYgcGFyYW1zLmNvbmY7XG4gICAgICAgIGlkID0gcGFyYW1zX2NvbmYgJiYgcGFyYW1zX2NvbmYuZGVzdDtcbiAgICAgICAgaWZyID0gaWQgJiYgX2VsdChpZCk7XG4gICAgICAgIHBhciA9IGlmciAmJiBfZWx0KFBPU19SRUxfQk9YX0lEX1BSRUZJWCArIFwiX1wiICsgcG9zSUQpO1xuICAgICAgICBpZnJTdCA9IGlmciAmJiBpZnJbU1RdO1xuICAgICAgICBwYXJTdCA9IHBhciAmJiBwYXJbU1RdO1xuICAgICAgICBzY3JfaGFuZGxlID0gdm9pZCAwO1xuICAgICAgICBpZiAoIXBvc0lEIHx8ICFwYXJhbXMgfHwgIWlmciB8fCAhcGFyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLmV4cGFuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNjcl9oYW5kbGUgPSBzY3JvbGxfcGFyZW50c19hdHRhY2hlZFtwb3NJRF07XG4gICAgICAgIGlmIChzY3JfaGFuZGxlICYmIHNjcl9oYW5kbGUudElEKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcl9oYW5kbGUudElEKTtcbiAgICAgICAgfVxuICAgICAgICBfY2xlYXJfZ2VvbV91cGRhdGVfdGltZXIoKTtcbiAgICAgICAgaWYgKCFub01zZ2luZykge1xuICAgICAgICAgIGlmIChfZmlyZV9wdWJfY2FsbGJhY2soQkZfUE9TX01TRywgcG9zSUQsIENPTExBUFNFX0NPTU1BTkQsIDAsIDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmclN0LmxlZnQgPSBpZnJTdC50b3AgPSBcIjBweFwiO1xuICAgICAgICBwYXJTdFtXSURUSF0gPSBpZnJTdFtXSURUSF0gPSBwYXJhbXNfY29uZi53ICsgUFg7XG4gICAgICAgIHBhclN0W0hFSUdIVF0gPSBpZnJTdFtIRUlHSFRdID0gcGFyYW1zX2NvbmYuaCArIFBYO1xuICAgICAgICBpZnJTdC56SW5kZXggPSBwYXJhbXMuZHggPSBwYXJhbXMuZHkgPSAwO1xuICAgICAgICBfc2hpbV9mcmFtZShpZCk7XG4gICAgICAgIGlmICghbm9Nc2dpbmcpIHtcbiAgICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgcG9zSUQsIENPTExBUFNFX0NPTU1BTkQsIDAsIDApO1xuICAgICAgICAgIG1zZ09iai5jbWQgPSAoaXNPdXRzaWRlID8gXCJjb2xsYXBzZWRcIiA6IFwiY29sbGFwc2VcIik7XG4gICAgICAgICAgbXNnT2JqLmdlb20gPSBfZXMoX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSkpO1xuICAgICAgICAgIF9zZW5kX3Jlc3BvbnNlKHBhcmFtcywgbXNnT2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZnIgPSBpZnJTdCA9IHBhciA9IHBhclN0ID0gcGFyYW1zID0gbXNnT2JqID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZWNvcmRzIGEgcmVwb3J0ZWQgZXJyb3IgbWVzc2FnZSB0byAkc2YuaW5mby5lcnJvcnMgYW5kIGZpcmVzIGFueSBsaXN0ZW5lcnNcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QtX3JlY29yZF9lcnJvclxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHskc2YubGliLmxhbmcuUGFyYW1IYXNofSBtc2dPYmogVGhlIGRldGFpbHMgYWJvdXQgdGhlIG1lc3NhZ2Ugc2VuZCBmcm9tIHRoZSBTYWZlRnJhbWUgaGF2aW5nIGFuIGVycm9yXG4gICAgICAgKi9cbiAgICAgIF9yZWNvcmRfZXJyb3IgPSBmdW5jdGlvbihtc2dPYmopIHtcbiAgICAgICAgdmFyIGlkLCBpZnIsIGlmclN0LCBwYXIsIHBhclN0LCBwYXJhbXMsIHBhcmFtc19jb25mLCBwb3NJRCwgc2NyX2hhbmRsZTtcbiAgICAgICAgcG9zSUQgPSBtc2dPYmogJiYgbXNnT2JqLnBvcztcbiAgICAgICAgcGFyYW1zID0gcG9zSUQgJiYgcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIHBhcmFtc19jb25mID0gcGFyYW1zICYmIHBhcmFtcy5jb25mO1xuICAgICAgICBpZCA9IHBhcmFtc19jb25mICYmIHBhcmFtc19jb25mLmRlc3Q7XG4gICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICBwYXIgPSBpZnIgJiYgX2VsdChQT1NfUkVMX0JPWF9JRF9QUkVGSVggKyBcIl9cIiArIHBvc0lEKTtcbiAgICAgICAgaWZyU3QgPSBpZnIgJiYgaWZyW1NUXTtcbiAgICAgICAgcGFyU3QgPSBwYXIgJiYgcGFyW1NUXTtcbiAgICAgICAgc2NyX2hhbmRsZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHNmICYmIHNmLmluZm8gJiYgc2YuaW5mby5lcnJzKSB7XG4gICAgICAgICAgc2YuaW5mby5lcnJzLnB1c2gobXNnT2JqKTtcbiAgICAgICAgfVxuICAgICAgICBfZmlyZV9wdWJfY2FsbGJhY2soUE9TX01TRywgcG9zSUQsIEVSUk9SX0NPTU1BTkQsIG1zZ09iaik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudCBjb29raWVzIGFzIGEgaGFzaFxuICAgICAgQG5hbWUgJHNmLmxpYi5fY29va2llSGFzaFxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHJldHVybnMge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgX2Nvb2tpZUhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMsIGNvb2tpZXMsIGNvb2tzLCBpLCBrZXk7XG4gICAgICAgIGNvb2tzID0gdm9pZCAwO1xuICAgICAgICBrZXkgPSB2b2lkIDA7XG4gICAgICAgIGkgPSB2b2lkIDA7XG4gICAgICAgIGNvb2tpZXMgPSB7fTtcbiAgICAgICAgYyA9IHZvaWQgMDtcbiAgICAgICAgY29va3MgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7IFwiKTtcbiAgICAgICAgaSA9IGNvb2tzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICBjID0gY29va3NbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgIGNvb2tpZXNbY1swXV0gPSBjWzFdO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llcztcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBSZWFkIGEgaG9zdCBkb21haW4gY29va2llXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV9yZWFkX2Nvb2tpZVxuICAgICAgQHByaXZhdGVcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHskc2YubGliLmxhbmcuUGFyYW1IYXNofSBtc2dPYmogVGhlIGRldGFpbHMgYWJvdXQgdGhlIG1lc3NhZ2Ugc2VuZCBmcm9tIHRoZSBTYWZlRnJhbWVcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2lzT3V0c2lkZV0gV2hldGhlciBvciBub3QgdGhlIHJlYWQtY29va2llIGNvbW1hbmQgY2FtZSBmcm9tIHRoZSBwdWJsaXNoZXJcbiAgICAgICAqL1xuICAgICAgX3JlYWRfY29va2llID0gZnVuY3Rpb24obXNnT2JqLCBpc091dHNpZGUpIHtcbiAgICAgICAgdmFyIGNhblJlYWQsIGNvbW1hbmQsIGNvb2tpZXMsIGlkLCBpZnIsIGtleSwgcGFyYW1zLCBwYXJhbXNfY29uZiwgcG9zSUQ7XG4gICAgICAgIHBvc0lEID0gbXNnT2JqICYmIG1zZ09iai5wb3M7XG4gICAgICAgIHBhcmFtcyA9IHBvc0lEICYmIHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgICBwYXJhbXNfY29uZiA9IHBhcmFtcyAmJiBwYXJhbXMuY29uZjtcbiAgICAgICAgaWQgPSBwYXJhbXNfY29uZiAmJiBwYXJhbXNfY29uZi5kZXN0O1xuICAgICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgICAga2V5ID0gdm9pZCAwO1xuICAgICAgICBjb29raWVzID0gdm9pZCAwO1xuICAgICAgICBjb21tYW5kID0gXCJyZWFkLWNvb2tpZVwiO1xuICAgICAgICBjYW5SZWFkID0gcGFyYW1zX2NvbmYuc3VwcG9ydHMgJiYgcGFyYW1zX2NvbmYuc3VwcG9ydHNbY29tbWFuZF0gJiYgcGFyYW1zX2NvbmYuc3VwcG9ydHNbY29tbWFuZF0gIT09IFwiMFwiO1xuICAgICAgICBpZiAoIWNhblJlYWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwb3NJRCB8fCAhcGFyYW1zIHx8ICFpZnIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gbXNnT2JqLmNvb2tpZTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29va2llcyA9IF9jb29raWVIYXNoKCk7XG4gICAgICAgIF9maXJlX3B1Yl9jYWxsYmFjayhQT1NfTVNHLCBjb21tYW5kLCBwb3NJRCwgMCwgMCk7XG4gICAgICAgIG1zZ09iai5jbWQgPSBjb21tYW5kO1xuICAgICAgICBtc2dPYmouZ2VvbSA9IF9lcyhfYnVpbGRfZ2VvbShwb3NJRCwgaWZyLCB0cnVlKSk7XG4gICAgICAgIG1zZ09iai52YWx1ZSA9IGNvb2tpZXNba2V5XTtcbiAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICBpZnIgPSBwYXJhbXMgPSBtc2dPYmogPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFdyaXRlIGEgaG9zdCBkb21haW4gY29va2llXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5ob3N0LV93cml0ZV9jb29raWVcbiAgICAgIEBwcml2YXRlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7JHNmLmxpYi5sYW5nLlBhcmFtSGFzaH0gbXNnT2JqIFRoZSBkZXRhaWxzIGFib3V0IHRoZSBtZXNzYWdlIHNlbmQgZnJvbSB0aGUgU2FmZUZyYW1lXG4gICAgICBAcGFyYW0ge0Jvb2xlYW59IFtpc091dHNpZGVdIFdoZXRoZXIgb3Igbm90IHRoZSB3cml0ZS1jb29raWUgY29tbWFuZCBjYW1lIGZyb20gdGhlIHB1Ymxpc2hlclxuICAgICAgICovXG4gICAgICBfd3JpdGVfY29va2llID0gZnVuY3Rpb24obXNnT2JqLCBpc091dHNpZGUpIHtcbiAgICAgICAgdmFyIGNfdmFsdWUsIGNhblJlYWQsIGNvbW1hbmQsIGNvb2tpZXMsIGV4ZGF0ZSwgaWQsIGlmciwga2V5LCBuZXdDb29raWVzLCBuZXdWYWx1ZSwgcGFyYW1zLCBwYXJhbXNfY29uZiwgcG9zSUQ7XG4gICAgICAgIHBvc0lEID0gbXNnT2JqICYmIG1zZ09iai5wb3M7XG4gICAgICAgIHBhcmFtcyA9IHBvc0lEICYmIHJlbmRlcmVkX2lmcnNbcG9zSURdO1xuICAgICAgICBwYXJhbXNfY29uZiA9IHBhcmFtcyAmJiBwYXJhbXMuY29uZjtcbiAgICAgICAgaWQgPSBwYXJhbXNfY29uZiAmJiBwYXJhbXNfY29uZi5kZXN0O1xuICAgICAgICBpZnIgPSBpZCAmJiBfZWx0KGlkKTtcbiAgICAgICAga2V5ID0gdm9pZCAwO1xuICAgICAgICBuZXdWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgY29va2llcyA9IHZvaWQgMDtcbiAgICAgICAgbmV3Q29va2llcyA9IHZvaWQgMDtcbiAgICAgICAgY29tbWFuZCA9IFwid3JpdGUtY29va2llXCI7XG4gICAgICAgIGNhblJlYWQgPSBwYXJhbXNfY29uZi5zdXBwb3J0cyAmJiBwYXJhbXNfY29uZi5zdXBwb3J0c1tjb21tYW5kXSAmJiBwYXJhbXNfY29uZi5zdXBwb3J0c1tjb21tYW5kXSAhPT0gXCIwXCI7XG4gICAgICAgIGlmICghY2FuUmVhZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBvc0lEIHx8ICFwYXJhbXMgfHwgIWlmcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBtc2dPYmouY29va2llO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdWYWx1ZSA9IGVzY2FwZShtc2dPYmoudmFsdWUpO1xuICAgICAgICBleGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBleGRhdGUuc2V0RGF0ZShleGRhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgIGNfdmFsdWUgPSBuZXdWYWx1ZSArIFwiOyBleHBpcmVzPVwiICsgZXhkYXRlLnRvVVRDU3RyaW5nKCk7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGtleSArIFwiPVwiICsgY192YWx1ZTtcbiAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFBPU19NU0csIGNvbW1hbmQsIHBvc0lELCAwLCAwKTtcbiAgICAgICAgbXNnT2JqLmNtZCA9IGNvbW1hbmQ7XG4gICAgICAgIG1zZ09iai5nZW9tID0gX2VzKF9idWlsZF9nZW9tKHBvc0lELCBpZnIsIHRydWUpKTtcbiAgICAgICAgbXNnT2JqLmluZm8gPSBuZXdWYWx1ZTtcbiAgICAgICAgbXNnT2JqLnZhbHVlID0gXCJcIjtcbiAgICAgICAgX3NlbmRfcmVzcG9uc2UocGFyYW1zLCBtc2dPYmopO1xuICAgICAgICBpZnIgPSBwYXJhbXMgPSBtc2dPYmogPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlbW92ZSAvIGRlc3Ryb3kgb25lIG9yIG1vcmUgU2FmZUZyYW1lcyBmcm9tIHRoZSBwdWJsaXNoZXIgcGFnZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC5udWtlXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBwb3NfaWQqIE9uZSBvciBtb3JlIHBvc2l0aW9uIGlkcyB0byByZW1vdmUgZnJvbSB0aGUgcGFnZS4gSWYgbm8gYXJndW1lbnRzIGFyZSBzcGVjaWZlZCwgYWxsIHBvc2l0aW9ucyBjdXJyZW50bHkgcmVuZGVyZWQgYXJlIHJlbW92ZWQuXG4gICAgICAgKi9cbiAgICAgIG51a2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MsIGVsLCBlbF9pZCwgZW1wdHksIGlkeCwgcGFyLCBwb3MsIHBvc19pZCwgc2JfcmVsO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBlbXB0eSA9IHRydWU7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHBvc19pZCA9IHZvaWQgMDtcbiAgICAgICAgcG9zID0gdm9pZCAwO1xuICAgICAgICBlbF9pZCA9IHZvaWQgMDtcbiAgICAgICAgZWwgPSB2b2lkIDA7XG4gICAgICAgIHNiX3JlbCA9IHZvaWQgMDtcbiAgICAgICAgcGFyID0gdm9pZCAwO1xuICAgICAgICBpZiAoIWFyZ3NbTEVOXSB8fCBhcmdzW2lkeF0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgIGZvciAocG9zX2lkIGluIHJlbmRlcmVkX2lmcnMpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChwb3NfaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocG9zX2lkID0gYXJnc1tpZHgrK10pIHtcbiAgICAgICAgICBwb3MgPSByZW5kZXJlZF9pZnJzW3Bvc19pZF07XG4gICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgaWYgKHBvc19pZCBpbiBwZW5kaW5nX2lmcnMpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmdfaWZyc1twb3NfaWRdKTtcbiAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdfaWZyc1twb3NfaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc19pZCBpbiBjb21wbGV0ZV9pZnJzKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBjb21wbGV0ZV9pZnJzW3Bvc19pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbF9pZCA9IHBvcy5kZXN0O1xuICAgICAgICAgICAgZWwgPSBlbF9pZCAmJiBfZWx0KGVsX2lkKTtcbiAgICAgICAgICAgIHBhciA9IGVsICYmIF9wYXIoZWwpO1xuICAgICAgICAgICAgaWYgKGRvbS5hdHRyKHBhciwgXCJpZFwiKS5pbmRleE9mKFBPU19SRUxfQk9YX0lEX1BSRUZJWCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHNiX3JlbCA9IHBhcjtcbiAgICAgICAgICAgICAgcGFyID0gX3BhcihzYl9yZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLnB1cmdlKGVsKTtcbiAgICAgICAgICAgIGlmIChzYl9yZWwpIHtcbiAgICAgICAgICAgICAgZG9tLnB1cmdlKHNiX3JlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlZF9pZnJzW3Bvc19pZF0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIHJlbmRlcmVkX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgIGVsID0gZG9tLm1ha2UoXCJkaXZcIik7XG4gICAgICAgICAgICBkb20uYXR0cihlbCwgXCJpZFwiLCBlbF9pZCk7XG4gICAgICAgICAgICBkb20uYXBwZW5kKHBhciwgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NfaWQgPSBcIlwiO1xuICAgICAgICBmb3IgKHBvc19pZCBpbiByZW5kZXJlZF9pZnJzKSB7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICBjdXJyZW50X3N0YXR1cyA9IFwiXCI7XG4gICAgICAgICAgX2hhbmRsZV91bmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFJlbmRlciBvbmUgb3IgbW9yZSAkc2YuaG9zdC5Qb3NpdGlvbiBvYmplY3RzIGludG8gdGhlIHBhZ2VcbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmhvc3QucmVuZGVyXG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7JHNmLmhvc3QuUG9zaXRpb259IHBvcyogQW4gaW5zdGFuY2Ugb2YgYW4gJHNmLmhvc3QuUG9zaXRpb24gb2JqZWN0IHRvIHJlbmRlci4gTm90ZSB0aGF0IHNhaWQgb2JqZWN0IG11c3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgJHNmLmhvc3QuUG9zQ29uZmlnLCBhcyB3ZWxsIGFzICRzZi5ob3N0LkNvbmZpZyBtdXN0IGhhdmUgYmVlbiBzZXRcbiAgICAgICAqL1xuICAgICAgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzLCBjc3NfdHh0LCBkZXN0X2VsLCBkZXN0X2lkLCBkZXN0X3JlbF9pZCwgZSwgZmluYWxDU1NFbmQsIGZpbmFsQ1NTUG9zLCBmaXJzdENTU1BvcywgaCwgaWR4LCBuYW1lX3BhcmFtcywgbmV3X2Rlc3RfZWwsIHBhcl9lbCwgcGVuZCwgcG9zLCBwb3NfY29uZiwgcG9zX2lkLCByZWxfZWwsIHN0LCB3O1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBmaXJzdENTU1BvcyA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgZmluYWxDU1NQb3MgPSBcImFic29sdXRlXCI7XG4gICAgICAgIGZpbmFsQ1NTRW5kID0gXCJ0b3A6MHB4O2xlZnQ6MHB4O3Zpc2liaWxpdHk6aGlkZGVuO2Rpc3BsYXk6bm9uZTtcIjtcbiAgICAgICAgcG9zID0gdm9pZCAwO1xuICAgICAgICBwb3NfaWQgPSB2b2lkIDA7XG4gICAgICAgIHBvc19jb25mID0gdm9pZCAwO1xuICAgICAgICBkZXN0X2VsID0gdm9pZCAwO1xuICAgICAgICBuZXdfZGVzdF9lbCA9IHZvaWQgMDtcbiAgICAgICAgcmVsX2VsID0gdm9pZCAwO1xuICAgICAgICBwYXJfZWwgPSB2b2lkIDA7XG4gICAgICAgIG5hbWVfcGFyYW1zID0gdm9pZCAwO1xuICAgICAgICBkZXN0X2lkID0gdm9pZCAwO1xuICAgICAgICBkZXN0X3JlbF9pZCA9IHZvaWQgMDtcbiAgICAgICAgY3NzX3R4dCA9IHZvaWQgMDtcbiAgICAgICAgdyA9IHZvaWQgMDtcbiAgICAgICAgaCA9IHZvaWQgMDtcbiAgICAgICAgc3QgPSB2b2lkIDA7XG4gICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgIHBlbmQgPSB2b2lkIDA7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tLnJlYWR5KCkpIHtcbiAgICAgICAgICBkb20ud2FpdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbmRlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGFyZ3MgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoYXJnc1swXSBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmdzW0xFTl0gPT09IDEpIHtcbiAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocG9zID0gYXJnc1tpZHgrK10pIHtcbiAgICAgICAgICBwb3NfaWQgPSBwb3MuaWQ7XG4gICAgICAgICAgcG9zX2NvbmYgPSAocG9zX2lkID8gY29uZmlnLnBvc2l0aW9uc1twb3NfaWRdIDogbnVsbCk7XG4gICAgICAgICAgaWYgKHBvc19jb25mKSB7XG4gICAgICAgICAgICBkZXN0X2lkID0gcG9zX2NvbmYuZGVzdDtcbiAgICAgICAgICAgIGRlc3RfZWwgPSBkZXN0X2lkICYmIF9lbHQoZGVzdF9pZCk7XG4gICAgICAgICAgICBpZiAoZGVzdF9lbCkge1xuICAgICAgICAgICAgICB3ID0gcG9zX2NvbmYudztcbiAgICAgICAgICAgICAgaCA9IHBvc19jb25mLmg7XG4gICAgICAgICAgICAgIGlmICghdykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB3ID0gZGVzdF9lbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICAgIHBvc19jb25mLncgPSB3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaCA9IGRlc3RfZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgICAgIGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgICAgICAgcG9zX2NvbmYuaCA9IGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcyA9IG5ldyBQYXJhbUhhc2goKTtcbiAgICAgICAgICAgICAgICBkZXN0X3JlbF9pZCA9IFBPU19SRUxfQk9YX0lEX1BSRUZJWCArIFwiX1wiICsgcG9zX2lkO1xuICAgICAgICAgICAgICAgIHJlbF9lbCA9IF9lbHQoZGVzdF9yZWxfaWQpO1xuICAgICAgICAgICAgICAgIHBhcl9lbCA9IF9wYXIoZGVzdF9lbCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbF9lbCAmJiBwYXJfZWwgPT09IHJlbF9lbCkge1xuICAgICAgICAgICAgICAgICAgcGFyX2VsID0gX3BhcihyZWxfZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfc2hpbV9mcmFtZShkZXN0X2lkKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgQGlnbm9yZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHBlbmQgPSBwZW5kaW5nX2lmcnNbcG9zX2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZW5kID0gY29tcGxldGVfaWZyc1twb3NfaWRdO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgY29tcGxldGVfaWZyc1twb3NfaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZW5kaW5nX2lmcnNbcG9zX2lkXSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBfaGFuZGxlX3JlbmRlcl90aW1lb3V0KHBvc19pZCk7XG4gICAgICAgICAgICAgICAgfSwgY29uZmlnLnRvKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3N0YXR1cyA9IFwicmVuZGVyaW5nXCI7XG4gICAgICAgICAgICAgICAgX2ZpcmVfcHViX2NhbGxiYWNrKFwib25TdGFydFBvc1JlbmRlclwiLCBwb3NfaWQsIHBvc19jb25mLCBwb3MpO1xuICAgICAgICAgICAgICAgIGNzc190eHQgPSBbXCJwb3NpdGlvbjpcIiwgXCJcIiwgXCI7ei1pbmRleDowO1wiLCBXSURUSCwgXCI6XCIsIHcsIFBYLCBcIjtcIiwgSEVJR0hULCBcIjpcIiwgaCwgUFgsIFwiO1wiLCBcInZpc2liaWxpdHk6aW5oZXJpdDtcIl07XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxfZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNzc190eHRbMV0gPSBmaXJzdENTU1BvcztcbiAgICAgICAgICAgICAgICAgIHJlbF9lbCA9IGRvbS5tYWtlKFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgcmVsX2VsLmlkID0gZGVzdF9yZWxfaWQ7XG4gICAgICAgICAgICAgICAgICByZWxfZWwuY2xhc3NOYW1lID0gXCJpYWJfc2ZcIjtcbiAgICAgICAgICAgICAgICAgIG5ld19kZXN0X2VsID0gZGVzdF9lbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgZG9tLmNzcyhuZXdfZGVzdF9lbCwgY3NzX3R4dCk7XG4gICAgICAgICAgICAgICAgICByZWxfZWwuYXBwZW5kQ2hpbGQobmV3X2Rlc3RfZWwpO1xuICAgICAgICAgICAgICAgICAgZG9tLmNzcyhyZWxfZWwsIGNzc190eHQpO1xuICAgICAgICAgICAgICAgICAgcGFyX2VsLnJlcGxhY2VDaGlsZChyZWxfZWwsIGRlc3RfZWwpO1xuICAgICAgICAgICAgICAgICAgZGVzdF9lbCA9IF9lbHQoZGVzdF9pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ID0gcmVsX2VsW1NUXTtcbiAgICAgICAgICAgICAgICAgIHN0LndpZHRoID0gdyArIFBYO1xuICAgICAgICAgICAgICAgICAgc3QuaGVpZ2h0ID0gaCArIFBYO1xuICAgICAgICAgICAgICAgICAgc3QgPSBkZXN0X2VsICYmIGRlc3RfZWxbU1RdO1xuICAgICAgICAgICAgICAgICAgc3Qud2lkdGggPSB3ICsgUFg7XG4gICAgICAgICAgICAgICAgICBzdC5oZWlnaHQgPSBoICsgUFg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmlkID0gcG9zX2lkO1xuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmRlc3QgPSBkZXN0X2lkO1xuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmNvbmYgPSBQYXJhbUhhc2gocG9zX2NvbmYpO1xuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLm1ldGEgPSBwb3MubWV0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmh0bWwgPSBfZXMocG9zLmh0bWwpO1xuICAgICAgICAgICAgICAgIG5hbWVfcGFyYW1zLmdlb20gPSBfZXMoX2J1aWxkX2dlb20ocG9zX2lkLCBkZXN0X2VsKSk7XG4gICAgICAgICAgICAgICAgbmFtZV9wYXJhbXMuc3JjID0gcG9zX2NvbmYucmVuZGVyRmlsZSB8fCBjb25maWcucmVuZGVyRmlsZTtcbiAgICAgICAgICAgICAgICBuYW1lX3BhcmFtcy5oYXNfZm9jdXMgPSBsYW5nLmNzdHIoZG9jdW1lbnQuaGFzRm9jdXMoKSk7XG4gICAgICAgICAgICAgICAgY3NzX3R4dFsxXSA9IGZpbmFsQ1NTUG9zO1xuICAgICAgICAgICAgICAgIGNzc190eHRbMTNdID0gZmluYWxDU1NFbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5fZXZlbnRzX2F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgU0NST0xMLCBfaGFuZGxlX3dpbl9nZW9tX3Njcm9sbCk7XG4gICAgICAgICAgICAgICAgICBkb20uYXR0YWNoKHdpbiwgXCJyZXNpemVcIiwgX2hhbmRsZV93aW5fZ2VvbV9yZXNpemUpO1xuICAgICAgICAgICAgICAgICAgZG9tLmF0dGFjaCh3aW4sIFwidW5sb2FkXCIsIF9oYW5kbGVfdW5sb2FkKTtcbiAgICAgICAgICAgICAgICAgIGRvbS5hdHRhY2god2luLCBcImZvY3VzXCIsIF9oYW5kbGVfd2luX2ZvY3VzKTtcbiAgICAgICAgICAgICAgICAgIGRvbS5hdHRhY2god2luLCBcImJsdXJcIiwgX2hhbmRsZV93aW5fYmx1cik7XG4gICAgICAgICAgICAgICAgICB3aW5fZXZlbnRzX2F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWZyYW1lcy5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgIGlkOiBkZXN0X2lkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZV9wYXJhbXMsXG4gICAgICAgICAgICAgICAgICBzcmM6IHBvc19jb25mLnJlbmRlckZpbGUgfHwgY29uZmlnLnJlbmRlckZpbGUsXG4gICAgICAgICAgICAgICAgICBfcG9zX2lkOiBwb3NfaWRcbiAgICAgICAgICAgICAgICB9LCBjc3NfdHh0LCByZWxfZWwsIF9oYW5kbGVfZnJhbWVfbG9hZCwgX2hhbmRsZV9tc2dfZXZ0KTtcbiAgICAgICAgICAgICAgICByZW5kZXJlZF9pZnJzW3Bvc19pZF0gPSBuYW1lX3BhcmFtcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIEdldHMgYSBjb3B5IG9mIHRoZSBQb3NpdGlvbiBjb25maWd1cmF0aW9uLCBjb250ZW50LCBhbmQgbWV0YSBkYXRhIGZvciBhIGdpdmVuIFNhZmVGcmFtZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC5nZXRcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHJldHVybiB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBnZXQgPSBmdW5jdGlvbihwb3NpdGlvbklkKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIG9iaiA9IHJlbmRlcmVkX2lmcnNbcG9zaXRpb25JZF07XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9taXgoe30sIG9iaik7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgUmV0dXJucyBhIHN0cmluZyBhcyB0byB3aGV0aGVyIG9yIG5vdCB0aGUgbGlicmFyeSBpcyBidXN5LCBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgb24gaWRsZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuaG9zdC5zdGF0dXNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHN0YXRpY1xuICAgICAgQHJldHVybiB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBzdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfc3RhdHVzO1xuICAgICAgfTtcbiAgICAgIF9zZW5kX2dlbmVyaWNfcmVzcG9uc2UgPSBmdW5jdGlvbihwb3NJRCwgY29tbWFuZCkge1xuICAgICAgICB2YXIgbXNnT2JqLCBwYXJhbXM7XG4gICAgICAgIG1zZ09iaiA9IG5ldyBQYXJhbUhhc2goKTtcbiAgICAgICAgcGFyYW1zID0gcG9zSUQgJiYgcmVuZGVyZWRfaWZyc1twb3NJRF07XG4gICAgICAgIG1zZ09iai5jbWQgPSBjb21tYW5kO1xuICAgICAgICBtc2dPYmoucG9zID0gcG9zSUQ7XG4gICAgICAgIHJldHVybiBfc2VuZF9yZXNwb25zZShwYXJhbXMsIG1zZ09iaik7XG4gICAgICB9O1xuICAgICAgX2dldEdlb20gPSBmdW5jdGlvbihwb3NJRCkge1xuICAgICAgICB2YXIgZywgaWQsIGlmciwgcGFyYW1zO1xuICAgICAgICBwYXJhbXMgPSByZW5kZXJlZF9pZnJzW3Bvc0lEXTtcbiAgICAgICAgaWQgPSBwYXJhbXMgJiYgcGFyYW1zLmRlc3Q7XG4gICAgICAgIGlmciA9IGlkICYmIF9lbHQoaWQpO1xuICAgICAgICBnID0gX2J1aWxkX2dlb20ocG9zSUQsIGlmciwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfTtcbiAgICAgIGluVmlld1BlcmNlbnRhZ2UgPSBmdW5jdGlvbihwb3NJRCkge1xuICAgICAgICB2YXIgZ2VvbV9pbmZvLCBpdiwgdHYsIF9yZWY7XG4gICAgICAgIGdlb21faW5mbyA9IF9nZXRHZW9tKHBvc0lEKTtcbiAgICAgICAgaXYgPSBfY251bShnZW9tX2luZm8gIT0gbnVsbCA/IChfcmVmID0gZ2VvbV9pbmZvLnNlbGYpICE9IG51bGwgPyBfcmVmLml2IDogdm9pZCAwIDogdm9pZCAwLCAtMSwgMCk7XG4gICAgICAgIGlmIChpdiA+PSAwKSB7XG4gICAgICAgICAgdHYgPSBNYXRoLmZsb29yKGl2ICogMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHY7XG4gICAgICB9O1xuICAgICAgaWYgKGxhbmcpIHtcbiAgICAgICAgaWYgKHdpbiA9PT0gdG9wIHx8IGFsbG93Tm90VG9wKSB7XG4gICAgICAgICAgX3JlY3QgPSAoaWVWZXIgPyBfZ2V0UmVjdElFIDogX2dldFJlY3ROb25JRSk7XG4gICAgICAgICAgX21peChkb20sIHtcbiAgICAgICAgICAgIHJlY3Q6IF9yZWN0LFxuICAgICAgICAgICAgY3VycmVudFN0eWxlOiBjdXJyZW50U3R5bGUsXG4gICAgICAgICAgICBjb250YWluczogY29udGFpbnMsXG4gICAgICAgICAgICBkb2NSZWN0OiBkb2NSZWN0LFxuICAgICAgICAgICAgd2luUmVjdDogd2luUmVjdCxcbiAgICAgICAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgICAgICAgb3ZlcmxhcHM6IG92ZXJsYXBzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgIEBpZ25vcmVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICAgIGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBkb20ubXNnaG9zdCA9IHtcbiAgICAgICAgICAgICAgcHJlcDogcHJlcF9pZnJhbWVfbXNnaW5nLFxuICAgICAgICAgICAgICBhdHRhY2g6IGF0dGFjaF9pZnJhbWVfbXNnaW5nLFxuICAgICAgICAgICAgICBkZXRhY2g6IGRldGFjaF9pZnJhbWVfbXNnaW5nLFxuICAgICAgICAgICAgICB1c2luZ0hUTUw1OiB1c2luZ0hUTUw1LFxuICAgICAgICAgICAgICBzZW5kOiBzZW5kX21zZ190b19jaGlsZF9pZnJhbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb21bQVRUQUNIXSh3aW4sIE1TRywgX2NoZWNrX2h0bWw1X2luaXQpO1xuICAgICAgICAgICAgaW5pdElEID0gXCJ4ZG0taHRtbDUtaW5pdC1cIiArIF9ndWlkKCk7XG4gICAgICAgICAgICBsb2NIb3N0ID0gKGxvY0hvc3QuaW5kZXhPZihcImZpbGVcIikgPT09IDAgPyBsb2NIb3N0ID0gXCJmaWxlXCIgOiBsb2NIb3N0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbltQTVNHXShpbml0SUQsIChsb2NIb3N0ID09PSBcImZpbGVcIiA/IFwiKlwiIDogbG9jSG9zdCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIGRvbVtERVRBQ0hdKHdpbiwgTVNHLCBfY2hlY2tfaHRtbDVfaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBfbWl4KHNmLmhvc3QsIHtcbiAgICAgICAgICAgIENvbmZpZzogQ29uZmlnLFxuICAgICAgICAgICAgUG9zQ29uZmlnOiBQb3NDb25maWcsXG4gICAgICAgICAgICBQb3NNZXRhOiBQb3NNZXRhLFxuICAgICAgICAgICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgICAgICAgICAgbnVrZTogbnVrZSxcbiAgICAgICAgICAgIGdldDogZ2V0LFxuICAgICAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIGluVmlld1BlcmNlbnRhZ2U6IGluVmlld1BlcmNlbnRhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsbG93Tm90VG9wKSB7XG4gICAgICAgIHdpbmRvd1tcIiRzZlwiXSA9IHNmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNmO1xuICAgIH0pKHdpbmRvdywgc2YpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tLCBlbnYsIGxhbmcsIGxvZ2dlcjtcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICBkb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG4gIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24obGFuZywgZW52LCBkb20sIGxvZ2dlcikge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXI6IFwiMS0xLTBcIixcbiAgICAgIHNwZWNWZXJzaW9uOiBcIjEuMVwiLFxuICAgICAgbGliOiB7XG4gICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgIGRvbTogZG9tLFxuICAgICAgICBsb2dnZXI6IGxvZ2dlclxuICAgICAgfSxcbiAgICAgIGVudjogZW52LFxuICAgICAgaG9zdDoge30sXG4gICAgICBleHQ6IHt9LFxuICAgICAgaW5mbzoge1xuICAgICAgICBlcnJzOiBbXSxcbiAgICAgICAgbGlzdDogW11cbiAgICAgIH1cbiAgICB9O1xuICB9KShsYW5nLCBlbnYsIGRvbSwgbG9nZ2VyKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS43LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIGVudiwgbGFuZztcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgZW52ID0gcmVxdWlyZSgnLi9lbnYnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3csIGxhbmcsIGVudikge1xuICAgIHZhciBCTEFOS19VUkwsIEVWVF9DTkNMX01FVEhPRFMsIEdDLCBJRV9HQ19JTlRFUlZBTCwgSUZSQU1FLCBhcHBlbmQsIGF0dGFjaCwgYXR0ciwgY2xvbmVfaWZyYW1lLCBjc3MsIGRldGFjaCwgZG9jLCBkb20sIGRvbV9pc19yZWFkeSwgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSwgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50LCBkb21fcmVhZHlfY2hrX21heF90cmllcywgZG9tX3JlYWR5X2Noa190aW1lcl9pZCwgZG9tX3JlYWR5X2Noa190cmllcywgZG9tX3JlYWR5X2Noa190cnlfaW50ZXJ2YWwsIGVsdCwgZXZ0Q25jbCwgZXZ0VGd0LCBldnRfdGd0X3Byb3BfYSwgZXZ0X3RndF9wcm9wX2IsIGdjLCBnY190aW1lcl9pZCwgaWVfYXR0YWNoLCBpZV9kZXRhY2gsIGlmcmFtZV9jYnNfYXR0YWNoZWQsIGlmcmFtZV9tc2dfaG9zdF9saWIsIGlmcmFtZV9uZXh0X2lkLCBpZnJhbWVfdmlldywgaXNJRSwgbWFrZV9lbGVtZW50LCBtYWtlX2lmcmFtZSwgcGFyLCBwdXJnZSwgcmVhZHksIHJlcGxhY2VfaWZyYW1lLCB0YWdOYW1lLCB0YWdzLCB0aGVEb2N1bWVudCwgdXNlT2xkU3R5bGVBdHRyTWV0aG9kcywgdXNlX2F0dGFjaCwgdXNlX2RldGFjaCwgdXNlX2llX29sZF9hdHRhY2gsIHZpZXcsIHczY19hdHRhY2gsIHczY19kZXRhY2gsIHdhaXQsIHdpbiwgX2JpbmRfaWZyYW1lX29ubG9hZCwgX2J5SUQsIF9jYWxsX3htc2dfaG9zdCwgX2NhbGxhYmxlLCBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2ssIF9jbG9uZV9pZnJhbWUsIF9jc3RyLCBfZW52LCBfaGFuZGxlX2RvbV9sb2FkX2V2dCwgX2xhbmcsIF9yZWFkeV9zdGF0ZV9jaGVjaywgX3VuYmluZF9pZnJhbWVfb25sb2FkO1xuICAgIGRvbSA9IHt9O1xuICAgIF9sYW5nID0gbGFuZztcbiAgICBfZW52ID0gZW52O1xuICAgIHdpbiA9IHdpbmRvdztcbiAgICBJRlJBTUUgPSBcImlmcmFtZVwiO1xuICAgIEdDID0gXCJDb2xsZWN0R2FyYmFnZVwiO1xuICAgIGllX2F0dGFjaCA9IFwiYXR0YWNoRXZlbnRcIjtcbiAgICB3M2NfYXR0YWNoID0gXCJhZGRFdmVudExpc3RlbmVyXCI7XG4gICAgaWVfZGV0YWNoID0gXCJkZXRhY2hFdmVudFwiO1xuICAgIHczY19kZXRhY2ggPSBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjtcbiAgICB1c2VfYXR0YWNoID0gXCJcIjtcbiAgICB1c2VfZGV0YWNoID0gXCJcIjtcbiAgICB1c2VfaWVfb2xkX2F0dGFjaCA9IGZhbHNlO1xuICAgIElFX0dDX0lOVEVSVkFMID0gMzAwMDtcbiAgICBFVlRfQ05DTF9NRVRIT0RTID0ge1xuICAgICAgXCJwcmV2ZW50RGVmYXVsdFwiOiAwLFxuICAgICAgXCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIjogMCxcbiAgICAgIFwic3RvcFByb3BhZ2F0aW9uXCI6IDAsXG4gICAgICBcInByZXZlbnRCdWJibGVcIjogMFxuICAgIH07XG4gICAgaXNJRSA9IGVudi5pc0lFO1xuICAgIHVzZU9sZFN0eWxlQXR0ck1ldGhvZHMgPSBmYWxzZTtcbiAgICBnY190aW1lcl9pZCA9IDA7XG4gICAgZG9tX2lzX3JlYWR5ID0gbnVsbDtcbiAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgIGRvbV9yZWFkeV9jaGtfbWF4X3RyaWVzID0gMzAwO1xuICAgIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsID0gNTA7XG4gICAgZG9tX3JlYWR5X2Noa190cmllcyA9IDA7XG4gICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IDA7XG4gICAgaWZyYW1lX25leHRfaWQgPSAwO1xuICAgIGlmcmFtZV9jYnNfYXR0YWNoZWQgPSB7fTtcbiAgICBldnRfdGd0X3Byb3BfYSA9IFwiXCI7XG4gICAgZXZ0X3RndF9wcm9wX2IgPSBcIlwiO1xuICAgIGlmcmFtZV9tc2dfaG9zdF9saWIgPSBudWxsO1xuICAgIHRoZURvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuICAgIEJMQU5LX1VSTCA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgICBfY3N0ciA9IGxhbmcuY3N0cjtcbiAgICBfY2FsbGFibGUgPSBsYW5nLmNhbGxhYmxlO1xuXG4gICAgLypcbiAgICBDbGVhciBvdXQgdGhlIHRpbWVyIGZ1bmN0aW9uIHVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIHJlYWR5IHN0YXRlIG9mIHRoZSBET01cbiAgICBjYW5ub3QgYmUgZGlyZWN0bHkgZGV0ZWN0ZWRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fY2xlYXJfcmVhZHlfdGltZXJfY2hlY2tcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfY2xlYXJfcmVhZHlfdGltZXJfY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb21fcmVhZHlfY2hrX3RpbWVyX2lkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkb21fcmVhZHlfY2hrX3RpbWVyX2lkKTtcbiAgICAgICAgZG9tX3JlYWR5X2Noa190aW1lcl9pZCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBfaGFuZGxlX2RvbV9sb2FkX2V2dCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZGV0YWNoKHdpbiwgXCJsb2FkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIGRldGFjaCh3aW4sIFwiRE9NQ29udGVudExvYWRlZFwiLCBfaGFuZGxlX2RvbV9sb2FkX2V2dCk7XG4gICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyB0byBzZWUgaWYgdGhlIERPTSBpcyByZWFkeSB0byBiZSBtYW5pcHVsYXRlZCwgd2l0aG91dCB0aGUgbmVlZCBmb3IgZXZlbnQgaG9va2luZy5cbiAgICBPZnRlbiB0aW1lcyB5b3UnbGwgc2VlIGZvbGtzIHVzZSB0aGUgb25sb2FkIGV2ZW50IG9yIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQuICBIb3dldmVyXG4gICAgdGhlIHByb2JsZW0gd2l0aCB0aG9zZSwgaXMgdGhhdCB5b3VyIEphdmFTY3JpcHQgY29kZSBtYXkgaGF2ZSBiZWVuIGxvYWRlZCBhc3luY2hyb25vdXNseSxcbiAgICBhZnRlciBlaXRoZXIgb25lIG9mIHRob3NlIGV2ZW50cyBoYXZlIGZpcmVkLCBhbmQgaW4gd2hpY2ggY2FzZSB5b3Ugc3RpbGwgZG9uJ3Qga25vdyBpZiB0aGUgRE9NIGlzIHJlYWxseVxuICAgIHJlYWR5LiAgTW9zdCBtb2Rlcm4gYnJvd3NlcnMgKGluY2x1ZGluZyBJRSksIGltcGxlbWVudCBhIGRvY3VtZW50LnJlYWR5U3RhdGUgcHJvcGVydHkgdGhhdCB3ZSBjYW5cbiAgICBjaGVjaywgYnV0IG5vdCBhbGwuICBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIHByb3BlcnR5IGlzIG5vdCBpbXBsZW1lbnRlZCwgd2UgZG8gYSBzZXJpZXMgb2Ygbm9kZVxuICAgIGNoZWNrcyBhbmQgdGFnIGNvdW50cyB2aWEgdGltZXJzLiAgT2YgY291cnNlIHRoaXMgbWVhbnMgdGhhdCBvbiB0aGUgdmVyeSAxc3QgY2FsbCwgd2Ugd2lsbCBhbHdheXNcbiAgICBhcHBlYXIgdG8gYmUgbm90IHJlYWR5IGV2ZW50aG91Z2ggdGhlIERPTSBpdHNlbGYgbWF5IGJlIGluIGEgcmVhZHkgc3RhdGUsIGJ1dCBvdXIgdGltZW91dCBpbnRlcnZhbFxuICAgIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoaXMgaXMgT0suXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20tX3JlYWR5X3N0YXRlX2NoZWNrXG4gICAgQHByaXZhdGVcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgICovXG4gICAgX3JlYWR5X3N0YXRlX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYiwgZSwga2lkcywgbHN0LCB0YWdfY250O1xuICAgICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrKCk7XG4gICAgICBpZiAoZG9tX3JlYWR5X2Noa190cmllcyA+PSBkb21fcmVhZHlfY2hrX21heF90cmllcykge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgZG9tX2lzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb21faXNfcmVhZHkgPT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiID0gdGhlRG9jdW1lbnQgJiYgdGhlRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICBraWRzID0gYiAmJiB0YWdzKFwiKlwiLCBiKTtcbiAgICAgICAgICB0YWdfY250ID0ga2lkcyAmJiBraWRzW0xFTl07XG4gICAgICAgICAgbHN0ID0gYiAmJiBiLmxhc3RDaGlsZDtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21fbGFzdF9rbm93bl90YWdfY291bnQgJiYgdGFnX2NudCA9PT0gZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ICYmIGxzdCA9PT0gZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSkge1xuICAgICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tX2xhc3Rfa25vd25fdGFnX2NvdW50ID0gdGFnX2NudDtcbiAgICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbHN0O1xuICAgICAgICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgKz0gMTtcbiAgICAgICAgICBkb21fcmVhZHlfY2hrX3RpbWVyX2lkID0gc2V0VGltZW91dChfcmVhZHlfc3RhdGVfY2hlY2ssIGRvbV9yZWFkeV9jaGtfdHJ5X2ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2xhc3Rfa25vd25fY2hpbGRfbm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgRGV0YWNoIG9ubG9hZCBoYW5kbGVycyBvbiBpZnJhbWVzIHRoYXQgd2UgaGF2ZSBjcmVhdGVkXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fdW5iaW5kX2lmcmFtZV9vbmxvYWRcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgaWZyYW1lIGVsZW1lbnQgdG8gdW5iaW5kIGZyb21cbiAgICAgKi9cbiAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGlkLCBvbGRDQjtcbiAgICAgIGlkID0gYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgIG9sZENCID0gdm9pZCAwO1xuICAgICAgb2xkQ0IgPSBpZCAmJiBpZnJhbWVfY2JzX2F0dGFjaGVkW2lkXTtcbiAgICAgIGlmIChvbGRDQikge1xuICAgICAgICBkZXRhY2goZWwsIFwibG9hZFwiLCBvbGRDQik7XG4gICAgICAgIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIGlmcmFtZV9jYnNfYXR0YWNoZWRbaWRdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIEEgZGVmYXVsdCBvbmxvYWQgZXZlbnQgaGFuZGxlciBmb3IgSUZyYW1lcy4gV2UgZG9uJ3RcbiAgICB3YW50IHRvIGF0dGFjaCB0byBvbmxvYWQgZXZlbnRzIGZvciBJRnJhbWVzIHZpYSBhdHRyaWJ1dGVzXG4gICAgYi9jIHdlIGRvbid0IHdhbnQgb3RoZXJzIHRvIHNlZSB3aGF0IGhhbmRsZXJzIGFyZSB0aGVyZS5cbiAgICBJbiB0dXJuIHdlIGFsc28gbWFrZSBzdXJlIHRoZSBcInRoaXNcIiByZWZlcmVuY2UgZm9yIHRoZSBvdXRzaWRlXG4gICAgaGFuZGxlIGdldHMgc2V0IHByb3Blcmx5LCBhbmQgaXQgYWxsb3dzIHVzIHRvIG1ha2Ugc3VyZVxuICAgIHRoYXQgdW5iaW5kaW5nIG9mIHRoZSBldmVudCBoYW5kbGVyIGFsc28gZ2V0cyBoYW5kbGVkIGFsd2F5c1xuICAgIHNvIGFzIG5vdCB0byBjcmVhdGUgbWVtb3J5IGxlYWsgaXNzdWVzLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMtX2JpbmRfaWZyYW1lX29ubG9hZFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBpZnJhbWUgZWxlbWVudCB0byBiaW5kIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBvbmxvYWQgaGFuZGxlciBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICovXG4gICAgX2JpbmRfaWZyYW1lX29ubG9hZCA9IGZ1bmN0aW9uKGVsLCBjYikge1xuICAgICAgdmFyIGlkLCBuZXdDQjtcbiAgICAgIG5ld0NCID0gdm9pZCAwO1xuICAgICAgaWQgPSB2b2lkIDA7XG4gICAgICBpZiAoX2NhbGxhYmxlKGNiKSkge1xuXG4gICAgICAgIC8qXG4gICAgICAgIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIG5ld0NCID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIGUsIHRndDtcbiAgICAgICAgICB0Z3QgPSBldnRUZ3QoZXZ0KTtcbiAgICAgICAgICBlID0gdm9pZCAwO1xuICAgICAgICAgIF91bmJpbmRfaWZyYW1lX29ubG9hZCh0Z3QpO1xuICAgICAgICAgIGlmICh0Z3QgJiYgY2IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNiLmNhbGwodGd0LCBldnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgICB0Z3QgPSBlbCA9IGNiID0gbmV3Q0IgPSBpZCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlkID0gYXR0cihlbCwgXCJpZFwiKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKGVsKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWZyYW1lX2Nic19hdHRhY2hlZFtpZF0gPSBuZXdDQjtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2goZWwsIFwibG9hZFwiLCBuZXdDQik7XG4gICAgICB9XG4gICAgICBuZXdDQiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBlbGVtZW50IHJlZmVyZW5jZSBwYXNzZWQgaW4sIGFuZCBpZiBpdHMgYSBzdHJpbmcgdmFsdWUgcGFzc2VkXG4gICAgaW4gdXNlIHRoYXQgdG8gbG9va3VwIHRoZSBlbGVtZW50IGJ5IGlkIGF0dHJpYnV0ZS5cbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS1fYnlJRFxuICAgIEBwcml2YXRlXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBlbCAgdGhlIGVsZW1lbnQgaWQgLyBlbGVtZW50IHJlZmVyZW5jZVxuICAgIEByZXR1cm4ge0hUTUxFbGVtZW50fGVsfVxuICAgICAqL1xuICAgIF9ieUlEID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGVsdChlbCkgfHwgZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSBwcm94eSB3cmFwcGVyIGZvciBjYWxsaW5nIGludG8gdGhlIGNyb3NzLWRvbWFpbiBtZXNzYWdpbmcgaG9zdCBsaWJyYXJ5XG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy1fY2FsbF94bXNnX2hvc3RcbiAgICBAcHJpdmF0ZVxuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gbWV0aE5hbWUgVGhlIG1ldGhvZCBuYW1lIGluIHRoZSBtc2cgaG9zdCBsaWJyYXJ5IHRvIGNhbGxcbiAgICBAcGFyYW0geyp9IGFyZzEgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDFzdCBhcmdcbiAgICBAcGFyYW0geyp9IGFyZzIgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDJuZCBhcmdcbiAgICBAcGFyYW0geyp9IGFyZzMgQW4gYXJiaXRyYXJ5IGFyZ3VtZW50IHRvIHBhc3MgdG8gc2FpZCBtZXRob2QgYXMgdGhlIDNyZCBhcmdcbiAgICBAcmV0dXJuIHsqfSB3aGF0ZXZlciBjb21lcyBiYWNrIGZyb20gdGhlIG1ldGhvZFxuICAgICAqL1xuICAgIF9jYWxsX3htc2dfaG9zdCA9IGZ1bmN0aW9uKG1ldGhOYW1lLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlmcmFtZV9tc2dfaG9zdF9saWIpIHtcbiAgICAgICAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gZG9tLm1zZ2hvc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICBpZnJhbWVfbXNnX2hvc3RfbGliID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh3aW4gIT09IHRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aE5hbWUgJiYgaWZyYW1lX21zZ19ob3N0X2xpYiAmJiBpZnJhbWVfbXNnX2hvc3RfbGliW21ldGhOYW1lXSAmJiBpZnJhbWVfbXNnX2hvc3RfbGliW21ldGhOYW1lXShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSBhIGRvY3VtZW50IGZvciBhIGdpdmVuIEhUTUwgRWxlbWVudFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIGRvYyBhcyAkc2YubGliLmRvbS5kb2NcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHdoaWNoIHlvdSB3aXNoIHRvIGZpbmQgaXQncyBwYXJlbnQgZG9jdW1lbnRcbiAgICBAcmV0dXJuIHtEb2N1bWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICBkb2MgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGxvY2FsRDtcbiAgICAgIGxvY2FsRCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbEQgPSBlbC5kb2N1bWVudCB8fCBlbC5vd25lckRvY3VtZW50IHx8IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgbG9jYWxEID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NhbEQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cmlldmUgdGhlIGhvc3Qgd2luZG93IG9iamVjdCBmb3IgYSBnaXZlbiBIVE1MIEVsZW1lbnQvZG9jdW1lbnQuIE5vdGUgdGhhdCB0aGlzIGlzIE5PVCB0aGUgc2FtZSBhcyAkc2YubGliLmRvbS5pZnJhbWVzLnZpZXcsIHdoaWNoXG4gICAgcmV0dXJucyB0aGUgd2luZG93IHJlZmVyZW5jZSBJTlNJREUgdGhlIElGUkFNRSBlbGVtZW50LlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmRvbVxuICAgIEBleHBvcnRzIHZpZXcgYXMgJHNmLmxpYi5kb20udmlld1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MRG9jdW1lbnR9IGVsIHRoZSBIVE1MIGVsZW1lbnQvZG9jdW1lbnQgZm9yIHdoaWNoIHlvdSB3aXNoIHRvIGZpbmQgaXQncyBwYXJlbnQgd2luZG93XG4gICAgQHJldHVybiB7RG9jdW1lbnR8bnVsbH0gbnVsbCBpZiBub3RoaW5nIGZvdW5kXG4gICAgICovXG4gICAgdmlldyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgZSwgbG9jYWxELCBwcm9wMSwgcHJvcDIsIHc7XG4gICAgICB3ID0gbnVsbDtcbiAgICAgIGxvY2FsRCA9IHZvaWQgMDtcbiAgICAgIHByb3AxID0gXCJwYXJlbnRXaW5kb3dcIjtcbiAgICAgIHByb3AyID0gXCJkZWZhdWx0Vmlld1wiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdyA9IGVsW3Byb3AxXSB8fCBlbFtwcm9wMl0gfHwgbnVsbDtcbiAgICAgICAgICBpZiAoIXcpIHtcbiAgICAgICAgICAgIGxvY2FsRCA9IGRvYyhlbCk7XG4gICAgICAgICAgICB3ID0gKGxvY2FsRCAmJiAobG9jYWxEW3Byb3AxXSB8fCBsb2NhbERbcHJvcDJdKSkgfHwgbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB3ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHJpZXZlIGFuIGVsZW1lbnQgYnkgaXRzIElELiAuIGJhc2ljYWxseSBhIHNob3J0IGhhbmQgd3JhcHBlciBhcm91bmQgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZWx0IGFzICRzZi5saWIuZG9tLmVsdFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IGlkIChSZXF1aXJlZCkgdGhlIGlkIG9mIHRoZSBIVE1MIGVsZW1lbnQgdG8gZmluZFxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFdpbmRvd3xIVE1MRG9jdW1lbnR9IFtwYXJdIFRoZSBwYXJlbnQgZWxlbWVudCxkb2N1bWVudCx3aW5kb3cgdG8gbG9vayBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSBudWxsIGlmIG5vdGhpbmcgZm91bmRcbiAgICAgKi9cbiAgICBlbHQgPSBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIGFyZ3MsIGRjLCBsZW47XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgICBkYyA9IHZvaWQgMDtcbiAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgIGRjID0gZG9jKGFyZ3NbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGMgPSB0aGVEb2N1bWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZGMgJiYgZGMuZ2V0RWxlbWVudEJ5SWQoaWQpKSB8fCBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgd3JhcHBlciBhcm91bmQgcmV0cmlldmluZyB0aGUgdGFnTmFtZSBvZiBhbiBIVE1MIGVsZW1lbnQgKG5vcm1hbGl6ZXMgdmFsdWVzIHRvIGxvd2VyIGNhc2Ugc3RyaW5ncykuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdGFnTmFtZSBhcyAkc2YubGliLmRvbS50YWdOYW1lXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgSFRNTCBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIHRhZyBuYW1lLlxuICAgIEByZXR1cm4ge1N0cmluZ30gVGhlIHRhZyBuYW1lIGluIGFsbCBsb3dlciBjYXNlIG9mIGFuIEhUTUwgZWxlbWVudCwgaWYgaXQgY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQsIGFsd2FzeXMgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgKHdoaWNoIHdpbGwgZXZhbHVhdGUgdG8gZmFsc2UpLlxuICAgICAqL1xuICAgIHRhZ05hbWUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCI7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIGFyb3VuZCByZXRyaWV2aW5nIGEgbGlzdCBvZiB0YWdzIGJ5IG5hbWUuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgdGFncyBhcyAkc2YubGliLmRvbS50YWdzXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFncyB0aGF0IHlvdSB3aXNoIHRvIGxvb2sgZm9yLCBub3RlIHRoYXQgeW91IGNhbiBwYXNzIGluIFwiKlwiIHRvIGZpbmQgYWxsLlxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9IFtwYXJOb2RlXSB0aGUgcGFyZW50IG5vZGUgdGhhdCB5b3Ugd2lzaCB0byBsb29rIGluXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnRDb2xsZWN0aW9ufSBMaXN0IG9mIHRhZ3MgZm91bmQuIE5vdGUgdGhhdCBpcyBOT1QgYSByZWFsIEphdmFTY3JpcHQgQXJyYXlcbiAgICAgKi9cbiAgICB0YWdzID0gZnVuY3Rpb24obmFtZSwgcGFyTm9kZSkge1xuICAgICAgdmFyIGUsIHJldDtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJOb2RlICYmIHBhck5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICByZXQgPSBwYXJOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpIHx8IHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSB0aGVEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKSB8fCByZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0cml2ZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgYW4gSFRNTCBlbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcGFyIGFzICRzZi5saWIuZG9tLnBhclxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBjaGVja1xuICAgIHJldHVybiB7SFRNTEVsZW1lbnR9IHRoZSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBvciBudWxsXG4gICAgICovXG4gICAgcGFyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbCAmJiAoZWwucGFyZW50Tm9kZSB8fCBlbC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZS9TZXQvRGVsZXRlIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUuIE5vdGUgdGhhdCB0aGlzIGhhbmRsZSdzXG4gICAgc2xpZ2h0IGRpZmZlcmVuY2VzIGluIHRoZSB3YXkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBoYW5kbGVkIGFjcm9zcyBicm93c2Vyc1xuICAgIGFzIHdlbGwgYXMgYmVpbmcgc2hvcnRoYW5kXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXR0ciBhcyAkc2YubGliLmRvbS5hdHRyXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgdGhlIGF0dHJpYnV0ZSB0byBzZXQvZ2V0XG4gICAgQHBhcmFtIHtTdHJpbmd9IFthdHRyVmFsXSwgaWYgc3BlY2lmaWVkIHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGZvciB0aGlzIGVsZW1lbnQuICBQYXNzaW5nIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBjb21wbGV0ZWx5XG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBub3JtYWxpemVkIHRvIGEgc3RyaW5nIChtYXkgYmUgZW1wdHkpXG4gICAgICovXG4gICAgYXR0ciA9IGZ1bmN0aW9uKGVsLCBhdHRyTmFtZSwgYXR0clZhbCkge1xuICAgICAgdmFyIGU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgaWYgKGF0dHJWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1c2VPbGRTdHlsZUF0dHJNZXRob2RzKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoYXR0clZhbCk7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJWYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCwgMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodXNlT2xkU3R5bGVBdHRyTWV0aG9kcykge1xuICAgICAgICAgICAgYXR0clZhbCA9IF9jc3RyKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSwgMCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gX2NzdHIoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgYXR0clZhbCA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0clZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZXQvR2V0IHRoZSBDU1MgdGV4dCBvZiBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBjc3MgYXMgJHNmLmxpYi5kb20uY3NzXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgSFRNTCBlbGVtZW50IHRvIG1hbmlwdWxhdGVcbiAgICBAcGFyYW0ge1N0cmluZ30gW3ZhbF0gdGhlIENTUyBzdHJpbmcgdG8gc2V0IGlmIHNwZWNpZmllZCAoZS5nLiBcImJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjBweDtsZWZ0OjBweFwiKS5cbiAgICBAcmV0dXJuIHtTdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIG5vcm1hbGl6ZWQgdG8gYSBzdHJpbmcgKG1heSBiZSBlbXB0eSlcbiAgICAgKi9cbiAgICBjc3MgPSBmdW5jdGlvbihlbCwgdmFsKSB7XG4gICAgICB2YXIgZSwgc3Q7XG4gICAgICBzdCA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ID0gZWwuc3R5bGU7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN0LmNzc1RleHQgPSBfY3N0cih2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHN0LmNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNYWtlIGEgbmV3IGVsZW1lbnRcbiAgICBcbiAgICBAbmFtZSAkc2YubGliLmRvbS5tYWtlXG4gICAgQGV4cG9ydHMgbWFrZV9lbGVtZW50IGFzICRzZi5saWIuZG9tLm1ha2VcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lXG4gICAgQHBhcmFtIHtEb2N1bWVudHxIVE1MRWxlbWVudHxXaW5kb3d9IFtwYXJlbnRdIGVsZW1lbnQsIGRvY3VtZW50LCBvciB3aW5kb3cgdG8gbWFrZSB0aGUgdGFnIGluLCBvcHRpb25hbC5cbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBtYWtlX2VsZW1lbnQgPSBmdW5jdGlvbih0YWdOYW1lLCBwYXIpIHtcbiAgICAgIHJldHVybiAoKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGRvYyhwYXIpKSB8fCB0aGVEb2N1bWVudCkuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBBcHBlbmQgYW5kIEhUTUxFbGVtZW50IHRvIGFub3RoZXIgSFRNTEVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBhcHBlbmQgYXMgJHNmLmxpYi5kb20uYXBwZW5kXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJOb2RlIHRoZSBIVE1MIGVsZW1lbnQgdG8gbWFuaXB1bGF0ZVxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNoaWxkIChSZXF1aXJlZCkgdGhlIG5ldyBIVE1MIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBwYXJlbnRcbiAgICByZXR1cm4ge0hUTUxFbGVtZW50fEJvb2xlYW59IHRoZSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBlbGVtZW50IHRoYXQgd2FzIGFwcGVuZGVkLCBvciBmYWxzZSBpZiBmYWlsdXJlXG4gICAgICovXG4gICAgYXBwZW5kID0gZnVuY3Rpb24ocGFyTm9kZSwgY2hpbGQpIHtcbiAgICAgIHZhciBlLCBzdWNjZXNzO1xuICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYXJOb2RlKSB7XG4gICAgICAgICAgc3VjY2VzcyA9IHBhck5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQSB3cmFwcGVyIG1ldGhvZCBmb3IgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSBhIGRvY3VtZW50IHJhdGhlciB0aGFuIGNhbGxpbmcgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCByYXcuXG4gICAgSGFzIHNwZWNpYWwgcHJvY2Vzc2luZyB0byBlbnN1cmUgdGhhdCBjb250ZW50cyBvZiBJRlJBTUUgdGFncyBnZXRzIHJlbGVhc2VkIGZyb20gbWVtb3J5IGFzIHdlbGxcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBwdXJnZSBhcyAkc2YubGliLmRvbS5wdXJnZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgSFRNTCBlbGVtZW50IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkXG4gICAgICovXG4gICAgcHVyZ2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZSwgaXNJRnJhbWUsIHBhck5vZGUsIHN1Y2Nlc3M7XG4gICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICBwYXJOb2RlID0gdm9pZCAwO1xuICAgICAgaXNJRnJhbWUgPSB0YWdOYW1lKG5vZGUpID09PSBJRlJBTUU7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgaWYgKGlzSUZyYW1lKSB7XG4gICAgICAgIF9jYWxsX3htc2dfaG9zdChcImRldGFjaFwiLCBub2RlKTtcbiAgICAgICAgX3VuYmluZF9pZnJhbWVfb25sb2FkKG5vZGUpO1xuICAgICAgICBpZiAoIWlzSUUpIHtcbiAgICAgICAgICBhdHRyKG5vZGUsIFwic3JjXCIsIEJMQU5LX1VSTCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHBhck5vZGUgPSBwYXIobm9kZSk7XG4gICAgICAgIGlmIChwYXJOb2RlKSB7XG4gICAgICAgICAgcGFyTm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNJRSAmJiBpc0lGcmFtZSkge1xuICAgICAgICAgICAgZ2MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIG5vZGUgPSBwYXJOb2RlID0gbnVsbDtcbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEF0dGFjaCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIEhUTUxFbGVtZW50LiAgTm90ZSBub3JtYWxpemUgZXZlbnQgbmFtZXMgdG8gbG93ZXIgY2FzZSAvIHczYyBzdGFuZGFyZHMuXG4gICAgU2VlIGV4YW1wbGUuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgYXR0YWNoIGFzICRzZi5saWIuZG9tLmF0dGFjaFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBhdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0b29cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvb1xuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBmdW5jdGlvbiB1c2VkIHRvIGhhbmRsZSB0aGUgcGFydGljdWxhciBldmVudFxuICAgIFxuICAgIEBleGFtcGxlXG4gICAgdmFyIGVsID0gJHNmLmxpYi5kb20uZWx0KFwibXlfZWxlbWVudFwiKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVfY2xpY2soZXZ0KVxuICAgIHtcbiAgICBhbGVydCgnaSB3YXMgY2xpY2tlZCcpO1xuICAgIH1cbiAgICBcbiAgICAkc2YubGliLmRvbS5hdHRhY2goZWwsXCJjbGlja1wiLGhhbmRsZV9jbGljayk7XG4gICAgICovXG4gICAgYXR0YWNoID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVzZV9pZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgb2JqW3VzZV9hdHRhY2hdKFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpbdXNlX2F0dGFjaF0obmFtZSwgY2IsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgb2JqID0gY2IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERldGFjaCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgZGV0YWNoIGFzICRzZi5saWIuZG9tLmRldGFjaFxuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGhlIEhUTUwgZWxlbWVudCB0byBhdHRhY2ggYW4gZXZlbnQgaGFuZGxlciB0b29cbiAgICBAcGFyYW0ge1N0cmluZ30gbmFtZXRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9vXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoZSBwYXJ0aWN1bGFyIGV2ZW50XG4gICAgICovXG4gICAgZGV0YWNoID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVzZV9pZV9vbGRfYXR0YWNoKSB7XG4gICAgICAgICAgb2JqLmRldGFjaEV2ZW50KFwib25cIiArIG5hbWUsIGNiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICBvYmogPSBjYiA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgRE9NIGlzIHJlYWR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgcmVhZHkgYXMgJHNmLmxpYi5kb20ucmVhZHlcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgcmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBycztcbiAgICAgIHJzID0gdm9pZCAwO1xuICAgICAgX2NsZWFyX3JlYWR5X3RpbWVyX2NoZWNrKCk7XG4gICAgICBpZiAoZG9tX2lzX3JlYWR5KSB7XG4gICAgICAgIGRvbV9sYXN0X2tub3duX2NoaWxkX25vZGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJzID0gdGhlRG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgIGlmIChycykge1xuICAgICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHJzID09PSBcImxvYWRlZFwiIHx8IHJzID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICBkb21faXNfcmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbV9pc19yZWFkeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb21fbGFzdF9rbm93bl9jaGlsZF9ub2RlID0gbnVsbDtcbiAgICAgIGRvbV9yZWFkeV9jaGtfdHJpZXMgPSBkb21fbGFzdF9rbm93bl90YWdfY291bnQgPSAwO1xuICAgICAgX3JlYWR5X3N0YXRlX2NoZWNrKCk7XG4gICAgICByZXR1cm4gISFkb21faXNfcmVhZHk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRmlyZSBvZmYgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIHdoZW4gaXQgaXMgZGV0ZWN0ZWQgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG4gICAgVXNlZnVsIHdoZW4geW91IGRvbid0IGtub3cgZm9yIHN1cmUgaWYgdGhlIERPTSBvZiB0aGUgYnJvd3NlciBpcyByZWFkeSBvciBub3QsIHNvIHRoaXMgd2lsbCBkZXRlY3QgYW5kIGZpcmVcbiAgICB5b3VyIGZ1bmN0aW9uIGZvciB5b3UuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIuZG9tXG4gICAgQGV4cG9ydHMgd2FpdCBhcyAkc2YubGliLmRvbS53YWl0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBBIGZ1bmN0aW9uIHJlZmVyZW5jZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICovXG4gICAgd2FpdCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgZSwgcmR5O1xuICAgICAgcmR5ID0gcmVhZHkoKTtcbiAgICAgIGUgPSB2b2lkIDA7XG4gICAgICBpZiAocmR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGxhbmcuY2FsbGFibGUoY2IpKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgd2FpdChjYik7XG4gICAgICAgIGNiID0gbnVsbDtcbiAgICAgIH0pLCBkb21fcmVhZHlfY2hrX3RyeV9pbnRlcnZhbCArIDEpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENhbmNlbCB0aGUgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIGEgcGFydGljdWxhciBET00gZXZlbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBldnRDbmNsIGFzICRzZi5saWIuZG9tLmV2dENuY2xcbiAgICBAcHVibGljXG4gICAgQHN0YXRpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEV2ZW50fSBldnQgIFRoZSByYXcgSFRNTCBldmVudFxuICAgICAqL1xuICAgIGV2dENuY2wgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBlLCBwcm9wO1xuICAgICAgcHJvcCA9IFwiXCI7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgZXZ0ID0gZXZ0IHx8IHdpbi5ldmVudDtcbiAgICAgIGlmIChldnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2dC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXZ0LnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgICAgIGZvciAocHJvcCBpbiBFVlRfQ05DTF9NRVRIT0RTKSB7XG4gICAgICAgICAgaWYgKEVWVF9DTkNMX01FVEhPRFNbcHJvcF0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGV2dFtwcm9wXSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgdGFyZ2V0L3NyY0VsZW1lbnQgb2YgYW4gZXZlbnQgZnJvbSBhbiBIVE1MIGVsZW1lbnRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5kb21cbiAgICBAZXhwb3J0cyBldnRUZ3QgYXMgJHNmLmxpYi5kb20uZXZ0VGd0XG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge0hUTUxFdmVudH0gZXZ0IFRoZSByYXcgSFRNTCBldmVudFxuICAgICAqL1xuICAgIGV2dFRndCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGUsIHRndDtcbiAgICAgIHRndCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBldnQgPSBldnQgfHwgd2luLmV2ZW50O1xuICAgICAgICB0Z3QgPSAoZXZ0ID8gZXZ0W2V2dF90Z3RfcHJvcF9hXSB8fCBldnRbZXZ0X3RndF9wcm9wX2JdIDogbnVsbCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGd0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0Z3Q7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQG5hbWVzcGFjZSAkc2YubGliLmRvbS5pZnJhbWVzIERlZmluZXMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZGVhbGluZyBzcGVjaWZpY2FsbHkgd2l0aCBJRlJBTUUgdGFncywgd2hpY2ggaXMga2V5IHRvIFNhZmVGcmFtZXMgdGVjaCBpbiBhIGJyb3dzZXIuXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lc1xuICAgIEByZXF1aXJlcyAkc2YubGliLmxhbmdcbiAgICAgKi9cblxuICAgIC8qXG4gICAgQ2xvbmVzIGFuIGlmcmFtZS4gLiAuXG4gICAgVGhpcyBjb2RlIGNyZWF0ZXMgLyBjbG9uZXMgaWZyYW1lIHRhZ3MgaW4gYSB2ZXJ5IHNwZWNpZmljIHdheSB0byBlbnN1cmUgYm90aCBvcHRpbWFsIHBlcmZvcm1hbmNlIGFuZCBzdGFiaWxpdHkuXG4gICAgV2UgdXNlIHN0cmluZyBidWZmZXJzIHRvIGJ1aWxkIG1hcmt1cCBpbnRlcm5hbGx5LCB3aGljaCBpcyB0eXBpY2FsbHkgZmFzdGVyIHRoYW4gdXNpbmcgYWxsIERPTSBBUElzLiAgQWxzb1xuICAgIHdlIGFsbG93IHRoZSB1c2FnZSBvZiB0aGUgXCJuYW1lXCIgYXR0cmlidXRlIGFzIGEgZGF0YSBwaXBlbGluZSwgd2hpY2ggaW4gdHVybiBhbGxvd3MgZm9yIHN5bmNocm9ub3VzIGRvd253YXJkXG4gICAgeC1kb21haW4gbWVzc2FnaW5nLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMuY2xvbmVcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7SFRNTEVsZW1lbnQvU3RyaW5nfSBlbCAgQW4gaWZyYW1lIGVsZW1lbnQgb3IgaWQgb2YgYW4gaWZyYW1lIGVsZW1lbnQgdG8gY2xvbmVcbiAgICBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSAgQSBoYXNoIG1hcCBvZiBvdGhlciBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgaWZyYW1lLiAgRG8gbm90IHNldCBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZnJhbWUgaGVyZSwgc2VlIHRoZSBuZXh0IGFyZ3VtZW50IGZvciB0aGF0LlxuICAgIEBwYXJhbSB7U3RyaW5nfSBbY3NzVGV4dF0gIFRoZSBzdHlsZSBzdHJpbmcgKGFzIGluIHdoYXQgeW91IHdvdWxkIHVzZSBpbiBIVE1MIG1hcmt1cCwgZS5nLiBcImJhY2tncm91bmQtY29sb3I6cmVkO2JvcmRlcjpzb2xpZCAzcHggYmx1ZTtcIiksIHRvIHVzZSBmb3IgdGhpcyBpZnJhbWVcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBzcGVjaWZ5IGZvciB3aGVuIHRoZSBpZnJhbWUgbG9hZHMuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gW3htc2dDQl0gQW4gb3B0aW9uYWwgY2FsbCBiYWNrIGZvciByZWNlaXZpbmcgbWVzc2FnZXMgZnJvbSB0aGUgaWZyYW1lXG4gICAgQHJldHVybiB7SFRNTEVsZW1lbnR9ICB0aGUgaWZyYW1lIG5vZGUgaWYgc3VjY2VzZnVsbHkgY3JlYXRlZCBvciBudWxsLiAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgaW5zZXJ0IHRoZSBpZnJhbWUgaW50byB0aGUgZG9jdW1lbnQgZm9yIHlvdS4gLiAuXG4gICAgICovXG4gICAgY2xvbmVfaWZyYW1lID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKSB7XG4gICAgICByZXR1cm4gX2Nsb25lX2lmcmFtZShlbCwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBfY2xvbmVfaWZyYW1lID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCLCBpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgdmFyIGF0dHJTdHIsIGJ1ZmZlckhUTUwsIGNsLCBodG1sLCBuZXdDbCwgcHJvcCwgdGVtcCwgeG1zZ1BpcGU7XG4gICAgICBidWZmZXJIVE1MID0gW1wiPFwiLCBJRlJBTUUsIFwiIFwiXTtcbiAgICAgIHhtc2dQaXBlID0gXCJcIjtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICB0ZW1wID0gdm9pZCAwO1xuICAgICAgY2wgPSB2b2lkIDA7XG4gICAgICBuZXdDbCA9IHZvaWQgMDtcbiAgICAgIGh0bWwgPSB2b2lkIDA7XG4gICAgICBhdHRyU3RyID0gdm9pZCAwO1xuICAgICAgaWYgKCFpZnJhbWVfc2tpcF9jbG9uZSkge1xuICAgICAgICBlbCA9IF9ieUlEKGVsKTtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBJRlJBTUUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjbCA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbCA9IGVsO1xuICAgICAgfVxuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIGlmIChcInNyY1wiIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIoY2wsIFwic3JjXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuc3JjID0gYXR0cihlbCwgXCJzcmNcIikgfHwgQkxBTktfVVJMO1xuICAgICAgfVxuICAgICAgaWYgKFwibmFtZVwiIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIoY2wsIFwibmFtZVwiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLm5hbWUgPSBhdHRyKGVsLCBcIm5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzLnNyYykge1xuICAgICAgICBhdHRycy5zcmMgPSBCTEFOS19VUkw7XG4gICAgICB9XG4gICAgICB4bXNnUGlwZSA9IHhtc2dDQiAmJiBfY2FsbF94bXNnX2hvc3QoXCJwcmVwXCIsIGF0dHJzKTtcbiAgICAgIGlmICghaWZyYW1lX3NraXBfY2xvbmUpIHtcbiAgICAgICAgYXR0cihjbCwgXCJ3aWR0aFwiLCBudWxsKTtcbiAgICAgICAgYXR0cihjbCwgXCJoZWlnaHRcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICB0ZW1wID0gY3NzKGNsKTtcbiAgICAgICAgaWYgKHRlbXAgJiYgdGVtcC5jaGFyQXQodGVtcC5sZW5ndGggLSAxKSAhPT0gXCI7XCIpIHtcbiAgICAgICAgICB0ZW1wICs9IFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIGNzcyhjbCwgW3RlbXAsIF9jc3RyKGNzc1RleHQpXSk7XG4gICAgICB9XG4gICAgICB0ZW1wID0gbWFrZV9lbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYXBwZW5kKHRlbXAsIGNsKTtcbiAgICAgIGh0bWwgPSB0ZW1wLmlubmVySFRNTDtcbiAgICAgIGF0dHJTdHIgPSBodG1sLnJlcGxhY2UoLzxpZnJhbWUoLio/KT4oLio/KTxcXC9pZnJhbWU+L2csIFwiJDFcIik7XG4gICAgICBidWZmZXJIVE1MLnB1c2goXCJuYW1lPVxcXCJcIiwgYXR0cnMubmFtZSwgXCJcXFwiIFwiLCBhdHRyU3RyLCBcIj48L1wiLCBJRlJBTUUsIFwiPlwiKTtcbiAgICAgIGRlbGV0ZSBhdHRycy5uYW1lO1xuICAgICAgdGVtcC5pbm5lckhUTUwgPSBfY3N0cihidWZmZXJIVE1MKTtcbiAgICAgIG5ld0NsID0gdGVtcC5maXJzdENoaWxkO1xuICAgICAgZm9yIChwcm9wIGluIGF0dHJzKSB7XG4gICAgICAgIGF0dHIobmV3Q2wsIHByb3AsIGF0dHJzW3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cihuZXdDbCwgXCJpZFwiKSkge1xuICAgICAgICBhdHRyKG5ld0NsLCBcImlkXCIsIFwic2ZfXCIgKyBJRlJBTUUgKyBcIl9cIiArIGlmcmFtZV9uZXh0X2lkKTtcbiAgICAgICAgaWZyYW1lX25leHRfaWQrKztcbiAgICAgIH1cbiAgICAgIGF0dHIobmV3Q2wsIFwiRlJBTUVCT1JERVJcIiwgXCJub1wiKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiU0NST0xMSU5HXCIsIFwibm9cIik7XG4gICAgICBhdHRyKG5ld0NsLCBcIkFMTE9XVFJBTlNQQVJFTkNZXCIsIHRydWUpO1xuICAgICAgYXR0cihuZXdDbCwgXCJISURFRk9DVVNcIiwgdHJ1ZSk7XG4gICAgICBhdHRyKG5ld0NsLCBcIlRBQklOREVYXCIsIC0xKTtcbiAgICAgIGF0dHIobmV3Q2wsIFwiTUFSR0lOV0lEVEhcIiwgMCk7XG4gICAgICBhdHRyKG5ld0NsLCBcIk1BUkdJTkhFSUdIVFwiLCAwKTtcbiAgICAgIF9iaW5kX2lmcmFtZV9vbmxvYWQobmV3Q2wsIGNiKTtcbiAgICAgIGlmICh4bXNnUGlwZSkge1xuICAgICAgICBfY2FsbF94bXNnX2hvc3QoXCJhdHRhY2hcIiwgbmV3Q2wsIHhtc2dQaXBlLCB4bXNnQ0IpO1xuICAgICAgfVxuICAgICAgeG1zZ1BpcGUgPSB4bXNnQ0IgPSBjbCA9IGNiID0gZWwgPSB0ZW1wID0gbnVsbDtcbiAgICAgIHJldHVybiBuZXdDbDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBNYWtlIGEgbmV3IGlmcmFtZVxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMubWFrZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtPYmplY3R9IGF0dHJzICBBIGhhc2ggbWFwIG9mIG90aGVyIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBpZnJhbWUuICBEbyBub3Qgc2V0IHN0eWxlIHByb3BlcnRpZXMgZm9yIHRoZSBmcmFtZSBoZXJlLCBzZWUgdGhlIG5leHQgYXJndW1lbnQgZm9yIHRoYXQuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtjc3NUZXh0XSAgVGhlIHN0eWxlIHN0cmluZyAoYXMgaW4gd2hhdCB5b3Ugd291bGQgdXNlIGluIEhUTUwgbWFya3VwLCBlLmcuIFwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7Ym9yZGVyOnNvbGlkIDNweCBibHVlO1wiKSwgdG8gdXNlIGZvciB0aGlzIGlmcmFtZVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gIHRoZSBpZnJhbWUgbm9kZSBpZiBzdWNjZXNmdWxseSBjcmVhdGVkIG9yIG51bGwuICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBpbnNlcnQgdGhlIGlmcmFtZSBpbnRvIHRoZSBkb2N1bWVudCBmb3IgeW91LiAuIC5cbiAgICAgKi9cbiAgICBtYWtlX2lmcmFtZSA9IGZ1bmN0aW9uKGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKSB7XG4gICAgICByZXR1cm4gX2Nsb25lX2lmcmFtZShtYWtlX2VsZW1lbnQoSUZSQU1FKSwgYXR0cnMsIGNzc1RleHQsIGNiLCB4bXNnQ0IsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgbWV0aG9kIHRvIGluc2VydCBvciByZXBsYWNlIGFuIEhUTUwgdGFnIHdpdGggYW4gSUZSQU1FIHRhZywgd2l0aCBhIG5ldyBVUkwgYW5kIGF0dHJpYnV0ZXMuXG4gICAgXG4gICAgVXNlZCBmb3IgMyByZWFzb25zOlxuICAgIDxvbD5cbiAgICA8bGk+SXQgYXZvaWRzIGNsaWNrIHNvdW5kcyBvbiBJRS48L2xpPlxuICAgIDxsaT5JdCBhbGxvd3MgYWx3YXlzIHJlc2V0dGluZyB0aGUgd2luZG93Lm5hbWUgcHJvcGVydHkgb2YgdGhlIGlmcmFtZXMgdW5kZXJseWluZyBIVE1MV2luZG93IG9iamVjdCwgdW5mb3J1bmF0ZWx5IElFIHdpbGwgbm90IGxldCB5b3Ugc2V0IHRoaXMgYXR0cmlidXRlIG9uIGEgY2xvbmUuPC9saT5cbiAgICA8bGk+SXQgZW5zdXJlcyB0aGF0IGV2ZW50IGhhbmRsZXJzIGluIHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50IGZvciB1bmxvYWRpbmcgYXJlIGV4ZWN1dGVkLjwvbGk+XG4gICAgPGxpPkNoYW5naW5nIHRoZSBzcmMgYXR0cmlidXRlIGRpcmVjdGx5IHdpbGwgcmVzdWx0IGluIGEgYnJvd3NlciBoaXN0b3J5IHVwZGF0ZSwgd2hpY2ggd2UgZG8gbm90IHdhbnQuPC9saT5cbiAgICA8L29sPlxuICAgIFxuICAgIFdlIGNvdWxkIGp1c3QgY2hhbmdlIGxvY2F0aW9uLmhyZWYgcHJvcGVydHkgb3IgY2FsbCBsb2NhdGlvbi5yZXBsYWNlLCBob3dldmVyIHRoYXQgaXMgbm90IGFsd2F5cyAgcG9zc2libGUgc2luY2VcbiAgICB0aGUgZnJhbWUgY291bGQgYmUgeC1kb21haW4uXG4gICAgXG4gICAgQG5hbWUgJHNmLmxpYi5kb20uaWZyYW1lcy5yZXBsYWNlXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICBAcGFyYW0ge09iamVjdH0gYXR0cnMgIEEgaGFzaCBtYXAgb2Ygb3RoZXIgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIGlmcmFtZS4gIERvIG5vdCBzZXQgc3R5bGUgcHJvcGVydGllcyBmb3IgdGhlIGZyYW1lIGhlcmUsIHNlZSB0aGUgbmV4dCBhcmd1bWVudCBmb3IgdGhhdC5cbiAgICBAcGFyYW0ge1N0cmluZ30gW2Nzc1RleHRdICBUaGUgc3R5bGUgc3RyaW5nIChhcyBpbiB3aGF0IHlvdSB3b3VsZCB1c2UgaW4gSFRNTCBtYXJrdXAsIGUuZy4gXCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtib3JkZXI6c29saWQgM3B4IGJsdWU7XCIpLCB0byB1c2UgZm9yIHRoaXMgaWZyYW1lXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IFtwYXJSZWZdICBBbiBwYXJlbnQgZWxlbWVudCBvciBwYXJlbnQgZWxlbWVudCBpZCwgdG8gYmUgdXNlZCBvbmx5IGlmIGEgbmV3IGlmcmFtZSBpcyBjcmVhdGVkLCB0aGUgaWZyYW1lIHdpbGwgYmUgYXBwZW5kIHRvIHRoYXQgcGFyZW50LCBpZiBub3Qgc3BlY2lmaWVkIGRvY3VtZW50IGJvZHkgaXMgdXNlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gIEFuIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHNwZWNpZnkgZm9yIHdoZW4gdGhlIGlmcmFtZSBsb2Fkcy5cbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBbeG1zZ0NCXSBBbiBjYWxsIGJhY2sgZm9yIHJlY2VpdmluZyBtZXNzYWdlcyBmcm9tIHRoZSBpZnJhbWVcbiAgICBcbiAgICBAcmV0dXJuIHtIVE1MRWxlbWVudH0gYSByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgaWZyYW1lIGVsZW1lbnQgaWYgc3VjY2Vzc2Z1bGx5IGluc2VydGVkLCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKi9cbiAgICByZXBsYWNlX2lmcmFtZSA9IGZ1bmN0aW9uKGF0dHJzLCBjc3NUZXh0LCBwYXJSZWYsIGNiLCB4bXNnQ0IpIHtcbiAgICAgIHZhciBjbCwgZSwgZWwsIGVsSUQsIGZyYW1lRWwsIHBhck5vZGUsIHRnbjtcbiAgICAgIGNsID0gdm9pZCAwO1xuICAgICAgZWwgPSB2b2lkIDA7XG4gICAgICBmcmFtZUVsID0gdm9pZCAwO1xuICAgICAgZWxJRCA9IHZvaWQgMDtcbiAgICAgIHRnbiA9IHZvaWQgMDtcbiAgICAgIHBhck5vZGUgPSB2b2lkIDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIGVsSUQgPSBhdHRycy5pZDtcbiAgICAgIGVsID0gZWxJRCAmJiBfYnlJRChlbElEKTtcbiAgICAgIHRnbiA9IHRhZ05hbWUoZWwpO1xuICAgICAgZWwgPSAodGduID8gZWwgOiBudWxsKTtcbiAgICAgIGZyYW1lRWwgPSAodGduID09PSBJRlJBTUUgPyBlbCA6IG51bGwpO1xuICAgICAgaWYgKGZyYW1lRWwpIHtcbiAgICAgICAgX2NhbGxfeG1zZ19ob3N0KFwiZGV0YWNoXCIsIGZyYW1lRWwpO1xuICAgICAgICBfdW5iaW5kX2lmcmFtZV9vbmxvYWQoZnJhbWVFbCk7XG4gICAgICAgIHBhck5vZGUgPSBwYXIoZnJhbWVFbCk7XG4gICAgICAgIGNsID0gY2xvbmVfaWZyYW1lKGZyYW1lRWwsIGF0dHJzLCBjc3NUZXh0LCBjYiwgeG1zZ0NCKTtcbiAgICAgICAgYXR0cihjbCwgXCJvbmxvYWRcIiwgbnVsbCk7XG4gICAgICAgIGF0dHIoY2wsIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhclJlZikge1xuICAgICAgICAgIHBhclJlZiA9IF9ieUlEKHBhclJlZik7XG4gICAgICAgICAgaWYgKHRhZ05hbWUocGFyUmVmKSkge1xuICAgICAgICAgICAgcGFyTm9kZSA9IHBhclJlZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJOb2RlICYmIGVsKSB7XG4gICAgICAgICAgcGFyTm9kZSA9IHBhcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IF9jc3RyKGNzc1RleHQpIHx8IGNzcyhlbCkgfHwgXCJcIjtcbiAgICAgICAgY2wgPSBtYWtlX2lmcmFtZShhdHRycywgY3NzVGV4dCwgY2IsIHhtc2dDQik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXBhck5vZGUpIHtcbiAgICAgICAgICBhcHBlbmQodGhlRG9jdW1lbnQuYm9keSwgY2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmcmFtZUVsKSB7XG4gICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChjbCwgZnJhbWVFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChjbCwgZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXBwZW5kKHBhck5vZGUsIGNsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgIGNsID0gZWwgPSBhdHRycyA9IGZyYW1lRWwgPSBwYXJOb2RlID0gY2IgPSBudWxsO1xuICAgICAgcmV0dXJuIGVsdChlbElEKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZXRyaWV2ZSB0aGUgd2luZG93IHJlZmVyZW5jZSBpbnNpZGUgb2YgYW4gSUZSQU1FLiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCAkc2YubGliLmRvbS52aWV3IHdoaWNoXG4gICAgcmV0dXJucyB0aGUgcGFyZW50IHdpbmRvdyByZWZlcmVuY2Ugb2YgYW4gZWxlbWVudC5cbiAgICBcbiAgICBOb3RlIHRoYXQgZXZlbiBpbiBjcm9zcy1kb21haW4gc2NlbmFyaW9zLCB5b3UgYXJlIHN1cHBvc2VkIHRvIGFibGUgdG8gZ2V0IGFjY2VzcyB0byB0aGUgd2luZG93IHJlZmVyZW5jZS5cbiAgICBJbiBhIGNyb3NzLWRvbWFpbiBzY2VuYXJpbywgeW91IHdvdWxkIG5vdCBiZSBhYmxlIHRvIHRoZW4gYWNlc3NzIG1vc3QgcHJvcGVydGllcyAvIG1ldGhvZHMgLyBvYmplY3RzIG9mIHRoYXRcbiAgICB3aW5kb3csIGJ1dCB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBhbGxvd2VkLlxuICAgIFxuICAgIEBuYW1lICRzZi5saWIuZG9tLmlmcmFtZXMudmlld1xuICAgIEBwdWJsaWNcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGlmcmFtZSBlbGVtZW50IHRvIHNhZmVseSBnZXQgYmFjayB0aGUgd2luZG93XG4gICAgQHJldHVybiB7SFRNTFdpbmRvd30gdGhlIHdpbmRvdyByZWZlcmVuY2UgaW5zaWRlIHRoZSBpZnJhbWUuXG4gICAgICovXG4gICAgaWZyYW1lX3ZpZXcgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGUsIGVsRG9jLCBlbFdpbiwgZXJyLCBmZSwgZnJhbWUsIGZyYW1lX2xpc3QsIGlkeCwgbG9jYWxXaW47XG4gICAgICBsb2NhbFdpbiA9IHZvaWQgMDtcbiAgICAgIGVsV2luID0gdm9pZCAwO1xuICAgICAgZWxEb2MgPSB2b2lkIDA7XG4gICAgICBmcmFtZV9saXN0ID0gdm9pZCAwO1xuICAgICAgZnJhbWUgPSB2b2lkIDA7XG4gICAgICBmZSA9IHZvaWQgMDtcbiAgICAgIGlkeCA9IDA7XG4gICAgICBlID0gdm9pZCAwO1xuICAgICAgZXJyID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxXaW4gPSBlbC5jb250ZW50V2luZG93IHx8IG51bGw7XG4gICAgICAgIGlmICghd2luKSB7XG4gICAgICAgICAgZWxEb2MgPSBkb2MoZWwpO1xuICAgICAgICAgIGVsV2luID0gZWxEb2MgJiYgdmlldyhlbERvYyk7XG4gICAgICAgICAgZnJhbWVfbGlzdCA9IChlbFdpbiAmJiBlbFdpbi5mcmFtZXMpIHx8IFtdO1xuICAgICAgICAgIHdoaWxlIChmcmFtZSA9IGZyYW1lX2xpc3RbaWR4KytdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmZSA9IGZyYW1lLmZyYW1lRWxlbWVudDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIGZlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmZSAmJiBmZSA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgbG9jYWxXaW4gPSBmcmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgbG9jYWxXaW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2FsV2luO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBnYyA9IF9sYW5nLm5vb3A7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEFUVFJfTkFNRSwgQ1JFQVRFX0VWRU5ULCBFVlRfVFlQRSwgZXJyLCBvYmosIHByb3A7XG4gICAgICBvYmogPSB2b2lkIDA7XG4gICAgICBBVFRSX05BTUUgPSBcIlNDUk9MTElOR1wiO1xuICAgICAgQ1JFQVRFX0VWRU5UID0gXCJjcmVhdGVFdmVudFwiO1xuICAgICAgRVZUX1RZUEUgPSBcIlVJRXZlbnRcIjtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICBlcnIgPSB2b2lkIDA7XG4gICAgICBpZiAoaXNJRSkge1xuICAgICAgICBldnRfdGd0X3Byb3BfYSA9IFwic3JjRWxlbWVudFwiO1xuICAgICAgICBldnRfdGd0X3Byb3BfYiA9IFwidGFyZ2V0XCI7XG4gICAgICAgIG9iaiA9IG1ha2VfZWxlbWVudChJRlJBTUUpO1xuICAgICAgICBhdHRyKG9iaiwgQVRUUl9OQU1FLCBcIm5vXCIpO1xuICAgICAgICB1c2VPbGRTdHlsZUF0dHJNZXRob2RzID0gYXR0cihvYmosIEFUVFJfTkFNRSkgIT09IFwibm9cIjtcbiAgICAgICAgaWYgKEdDIGluIHdpbikge1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICBAaWdub3JlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZ2MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChnY190aW1lcl9pZCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZ2NfdGltZXJfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2NfdGltZXJfaWcoc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5bR0NdKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge31cbiAgICAgICAgICAgIH0sIElFX0dDX0lOVEVSVkFMKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYyA9IF9sYW5nLm5vb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2dF90Z3RfcHJvcF9hID0gXCJ0YXJnZXRcIjtcbiAgICAgICAgZXZ0X3RndF9wcm9wX2IgPSBcImN1cnJlbnRUYXJnZXRcIjtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5bdzNjX2F0dGFjaF0gJiYgIWlzSUUpIHtcbiAgICAgICAgdXNlX2F0dGFjaCA9IHczY19hdHRhY2g7XG4gICAgICAgIHVzZV9kZXRhY2ggPSB3M2NfZGV0YWNoO1xuICAgICAgfSBlbHNlIGlmIChpc0lFKSB7XG4gICAgICAgIHVzZV9pZV9vbGRfYXR0YWNoID0gdHJ1ZTtcbiAgICAgICAgdXNlX2F0dGFjaCA9IGllX2F0dGFjaDtcbiAgICAgICAgdXNlX2RldGFjaCA9IGllX2RldGFjaDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBvYmogPSB0aGVEb2N1bWVudFtDUkVBVEVfRVZFTlRdKEVWVF9UWVBFKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgIG9iaiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9iaiA9IHRoZURvY3VtZW50W0NSRUFURV9FVkVOVF0oRVZUX1RZUEUgKyBcInNcIik7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICBvYmogPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBFVlRfQ05DTF9NRVRIT0RTKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSkge1xuICAgICAgICAgICAgRVZUX0NOQ0xfTUVUSE9EU1twcm9wXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmogPSBudWxsO1xuICAgICAgYXR0YWNoKHdpbiwgXCJsb2FkXCIsIF9oYW5kbGVfZG9tX2xvYWRfZXZ0KTtcbiAgICAgIHJldHVybiBhdHRhY2god2luLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX2hhbmRsZV9kb21fbG9hZF9ldnQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGRvbSA9IHtcbiAgICAgIGRvYzogZG9jLFxuICAgICAgdmlldzogdmlldyxcbiAgICAgIGVsdDogZWx0LFxuICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICBwYXI6IHBhcixcbiAgICAgIG1ha2U6IG1ha2VfZWxlbWVudCxcbiAgICAgIGNzczogY3NzLFxuICAgICAgYXR0cjogYXR0cixcbiAgICAgIGdjOiBnYyxcbiAgICAgIGFwcGVuZDogYXBwZW5kLFxuICAgICAgcHVyZ2U6IHB1cmdlLFxuICAgICAgYXR0YWNoOiBhdHRhY2gsXG4gICAgICBkZXRhY2g6IGRldGFjaCxcbiAgICAgIHJlYWR5OiByZWFkeSxcbiAgICAgIHdhaXQ6IHdhaXQsXG4gICAgICBldnRDbmNsOiBldnRDbmNsLFxuICAgICAgZXZ0VGd0OiBldnRUZ3QsXG4gICAgICBpZnJhbWVzOiB7XG4gICAgICAgIG1ha2U6IG1ha2VfaWZyYW1lLFxuICAgICAgICBjbG9uZTogY2xvbmVfaWZyYW1lLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlX2lmcmFtZSxcbiAgICAgICAgdmlldzogaWZyYW1lX3ZpZXdcbiAgICAgIH1cbiAgICB9O1xuICB9KSh3aW5kb3csIGxhbmcsIGVudik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgbGFuZyxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBsYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgdmFyIGNhY2hlZF91YSwgaXNJRSwgaXNJRTExLCBuYXZpZ2F0b3IsIHRoZURvY3VtZW50LCB1YSwgdXNlckFnZW50LCB3aW47XG4gICAgd2luID0gd2luZG93O1xuICAgIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgdGhlRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgdXNlckFnZW50ID0gKG5hdmlnYXRvciAhPSBudWxsID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6IHZvaWQgMCkgfHwgXCJcIjtcbiAgICBpc0lFMTEgPSAhd2luZG93LkFjdGl2ZVhPYmplY3QgJiYgX19pbmRleE9mLmNhbGwod2luZG93LCBcIkFjdGl2ZVhPYmplY3RcIikgPj0gMDtcbiAgICBpc0lFID0gIWlzSUUxMSAmJiAod2luICYmIChfX2luZGV4T2YuY2FsbCh3aW4sIFwiQWN0aXZlWE9iamVjdFwiKSA+PSAwKSk7XG4gICAgY2FjaGVkX3VhID0gbnVsbDtcbiAgICB1YSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgLypcbiAgICAgIENvbnZlcnQgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGEgbnVtZXJpYyB2YWx1ZVxuICAgICAgXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLV9udW1iZXJpZnlcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzIFRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdmVyc2lvbiBudW1iZXIgKGUuZy4gJ21ham9yLm1pbm9yLnJldmlzaW9uJylcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBwYXJzZV91YSwgX21hdGNoSXQsIF9udW1iZXJpZnksIF90ZXN0SXQ7XG4gICAgICBfbnVtYmVyaWZ5ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgYyA9IDA7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHMucmVwbGFjZSgvXFwuL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjKysgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICAvKlxuICAgICAgV3JhcHBlciBtZXRob2QgZm9yIHJldHVybmluZyB2YWx1ZXMgZnJvbSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaCBzYWZlbHkuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEtX21hdGNoSXRcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwcml2YXRlXG4gICAgICBAZnVuY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICBAcGFyYW0ge1JlZ0V4cH0gcmVnRXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgZm9yIG1hdGNoaW5nXG4gICAgICBAcGFyYW0ge051bWJlcn0gW2lkeF0gVGhlIGluZGV4IG51bWJlciBvZiBhIG1hdGNoIHRvIHB1bGwgZnJvbVxuICAgICAgQHJldHVybnMge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgX21hdGNoSXQgPSBmdW5jdGlvbihzdHIsIHJlZ0V4LCBpZHgpIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIG0gPSBzdHIgJiYgc3RyLm1hdGNoKHJlZ0V4KTtcbiAgICAgICAgaWYgKCEoaWR4ICE9IG51bGwpKSB7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChtICYmIG1baWR4XSkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgIFdyYXBwZXIgbWV0aG9kIGZvciB0ZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgIFxuICAgICAgQG5hbWUgJHNmLmVudi51YS1fdGVzdEl0XG4gICAgICBAc3RhdGljXG4gICAgICBAcHJpdmF0ZVxuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0ge1JlZ0V4cH0gcmVnRXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IHdpdGhcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAgICAgIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgX3Rlc3RJdCA9IGZ1bmN0aW9uKHJlZ0V4LCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ0V4LnRlc3Qoc3RyKTtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBQYXJzZSBhIHVzZXItYWdlbnQgc3RyaW5nIGZyb20gdGhlIGJyb3dzZXIgYW5kIGdhdGhlciBwZXJ0aW5lbnQgYnJvd3NlciwgYW5kIE9TIGluZm9ybWF0aW9uXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEucGFyc2VcbiAgICAgIEBzdGF0aWNcbiAgICAgIEBwdWJsaWNcbiAgICAgIEBmdW5jdGlvblxuICAgICAgQHBhcmFtIHtTdHJpbmd9IFtzdWJVQV0gQW4gYWx0ZXJuYXRlIHVzZXItYWdlbnQgc3RyaW5nIHRvIHBhcnNlLiBJZiBubyB2YWxpZCBzdHJpbmcgaXMgcGFzc2VkIGluLCBmdW5jdGlvbiB3aWxsIHJldHVybiBhbiBvYmplY3QgYmFzZWQgb24gdGhlIGtub3duIHVzZXItYWdlbnRcbiAgICAgIEByZXR1cm5zIHtPYmplY3R9IDxiPnBhcnNlZDwvYj4gQnJvd3NlciBhbmQgT1MgaW5mb3JtYXRpb248YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaWUgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ub3BlcmEgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBPcGVyYSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5nZWNrbyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEdlY2tvIChGaXJlZm94KSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi53ZWJraXQgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJLaXQgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uc2FmYXJpIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2FmYXJpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmNocm9tZSBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENocm9tZSBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5haXIgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBBSVIgU0RLIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pcG9kIFdoZXRoZXIgb3Igbm90IGFuIGlQb2QgZGV2aWNlIGlzIGJlaW5nIHVzZWQgMSBmb3IgdHJ1ZSwgMCBmb3IgZmFsc2UuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LmlwYWQgV2hldGhlciBvciBub3QgYW4gaVBhZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uaXBob25lIFdoZXRoZXIgb3Igbm90IGFuIGlQaG9uZSBkZXZpY2UgaXMgYmVpbmcgdXNlZCAxIGZvciB0cnVlLCAwIGZvciBmYWxzZS48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4uYW5kcm9pZCBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFuZHJvaWQgT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LndlYm9zIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgV2ViT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+LnNpbGsgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBTaWxrIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7TnVtYmVyfSA8Yj5wYXJzZWQ8L2I+Lm5vZGVqcyBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE5vZGVKUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEByZXR1cm5zIHtOdW1iZXJ9IDxiPnBhcnNlZDwvYj4ucGhhbnRvbWpzIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgUGhhbnRvbUpTIGVudmlyb25tZW50IGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge1N0cmluZ30gPGI+cGFyc2VkPC9iPi5tb2JpbGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIC8gb3MgaXMgYSBtb2JpbGUgZGV2aWNlICBhbmQgaXQncyB0eXBlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd3aW5kb3dzJywgJ2FuZHJvaWQnLCAnc3ltYm9zJywgJ2xpbnV4JywgJ21hY2ludG9zaCcsICdyaGlubycsICdnZWNrbycsICdBcHBsZScsICdjaHJvbWUnLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5pb3MgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBpT1MgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuPGJyIC8+Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7XG4gICAgICBAcmV0dXJucyB7Qm9vbGVhbn0gPGI+cGFyc2VkPC9iPi5hY2NlbCBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIGVudmlyb25tZW50IGluIHF1ZXN0aW9uIGlzIGhhcmR3YXJlIGFjY2VsZXJhdGVkLjxiciAvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xuICAgICAgQHJldHVybnMge051bWJlcn0gPGI+cGFyc2VkPC9iPi5jYWphVmVyc2lvbiBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIENBSkEgZW52aXJvbm1lbnQgb3IgMCBpZiBub3QuXG4gICAgICAgKi9cbiAgICAgIHBhcnNlX3VhID0gZnVuY3Rpb24oc3ViVUEpIHtcbiAgICAgICAgdmFyIGRhdGUsIGUsIG1hdGNoLCByZXQ7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKCFzdWJVQSAmJiBjYWNoZWRfdWEpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkX3VhO1xuICAgICAgICB9XG4gICAgICAgIHJldC5pZSA9IHJldC5vcGVyYSA9IHJldC5nZWNrbyA9IHJldC53ZWJraXQgPSByZXQuc2FmYXJpID0gcmV0LmNocm9tZSA9IHJldC5haXIgPSByZXQuaXBvZCA9IHJldC5pcGFkID0gcmV0LmlwaG9uZSA9IHJldC5hbmRyb2lkID0gcmV0LndlYm9zID0gcmV0LnNpbGsgPSByZXQubm9kZWpzID0gcmV0LnBoYW50b21qcyA9IDA7XG4gICAgICAgIHJldC5tb2JpbGUgPSByZXQuaW9zID0gcmV0Lm9zID0gbnVsbDtcbiAgICAgICAgcmV0LmFjY2VsID0gZmFsc2U7XG4gICAgICAgIHJldC5jYWphID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5jYWphVmVyc2lvbjtcbiAgICAgICAgcmV0LmNrcyA9IGZhbHNlO1xuICAgICAgICBzdWJVQSA9IHN1YlVBIHx8IHVzZXJBZ2VudCB8fCBcIlwiO1xuICAgICAgICBpZiAoc3ViVUEpIHtcbiAgICAgICAgICBpZiAoX3Rlc3RJdCgvd2luZG93c3x3aW4zMi9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwid2luZG93c1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3Rlc3RJdCgvbWFjaW50b3NofG1hY19wb3dlcnBjL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm9zID0gXCJtYWNpbnRvc2hcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL2FuZHJvaWQvaSwgc3ViVUEpKSB7XG4gICAgICAgICAgICByZXQub3MgPSBcImFuZHJvaWRcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90ZXN0SXQoL3N5bWJvcy9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwic3ltYm9zXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGVzdEl0KC9saW51eC9pLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5vcyA9IFwibGludXhcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF90ZXN0SXQoL3JoaW5vL2ksIHN1YlVBKSkge1xuICAgICAgICAgICAgICByZXQub3MgPSBcInJoaW5vXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9LSFRNTC8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0LndlYmtpdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGVzdEl0KC9JRU1vYmlsZXxYQkxXUDcvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgIHJldC5tb2JpbGUgPSBcIndpbmRvd3NcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90ZXN0SXQoL0Zlbm5lYy8sIHN1YlVBKSkge1xuICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiZ2Vja29cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL0FwcGxlV2ViS2l0XFwvKFteXFxzXSopLywgMSk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXQud2Via2l0ID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICByZXQuc2FmYXJpID0gcmV0LndlYmtpdDtcbiAgICAgICAgICAgIGlmIChfdGVzdEl0KC9QaGFudG9tSlMvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL1BoYW50b21KU1xcLyhbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQucGhhbnRvbWpzID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGVzdEl0KFJlZ0V4cChcIiBNb2JpbGVcXFxcL1wiKSwgc3ViVUEpIHx8IF90ZXN0SXQoL2lQYWR8aVBvZHxpUGhvbmUvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiQXBwbGVcIjtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL09TIChbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoICYmIF9udW1iZXJpZnkobWF0Y2gucmVwbGFjZShcIl9cIiwgXCIuXCIpKTtcbiAgICAgICAgICAgICAgcmV0LmlvcyA9IG1hdGNoO1xuICAgICAgICAgICAgICByZXQuaXBhZCA9IHJldC5pcG9kID0gcmV0LmlwaG9uZSA9IDA7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9pUGFkfGlQb2R8aVBob25lLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldFttYXRjaC50b0xvd2VyQ2FzZSgpXSA9IHJldC5pb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9Ob2tpYU5bXlxcL10qfEFuZHJvaWQgXFxkXFwuXFxkfHdlYk9TXFwvXFxkXFwuXFxkLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvd2ViT1MvLCBzdWJVQSkpIHtcbiAgICAgICAgICAgICAgICByZXQubW9iaWxlID0gXCJXZWJPU1wiO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC93ZWJPU1xcLyhbXlxcc10qKTsvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC53ZWJvcyA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Rlc3RJdChSZWdFeHAoXCIgQW5kcm9pZFwiKSwgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiQW5kcm9pZFwiO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BbmRyb2lkIChbXlxcc10qKTsvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hbmRyb2lkID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGVzdEl0KC9TaWxrLywgc3ViVUEpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL1NpbGtcXC8oW15cXHNdKilcXCkvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5zaWxrID0gX251bWJlcmlmeShtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmV0LmFuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldC5hbmRyb2lkID0gMi4zNDtcbiAgICAgICAgICAgICAgICAgIHJldC5vcyA9IFwiQW5kcm9pZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3Rlc3RJdCgvQWNjZWxlcmF0ZWQ9dHJ1ZS8sIHN1YlVBKSkge1xuICAgICAgICAgICAgICAgICAgcmV0LmFjY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoID0gc3ViVUEubWF0Y2goLyhDaHJvbWV8Q3JNbylcXC8oW15cXHNdKikvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICByZXQuY2hyb21lID0gX251bWJlcmlmeShtYXRjaFsyXSk7XG4gICAgICAgICAgICAgIHJldC5zYWZhcmkgPSAwO1xuICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwiQ3JNb1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0Lm1vYmlsZSA9IFwiY2hyb21lXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9BZG9iZUFJUlxcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXQuYWlyID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXQud2Via2l0KSB7XG4gICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT3BlcmFbXFxzXFwvXShbXlxcc10qKS8sIDEpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHJldC5vcGVyYSA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICBtYXRjaCA9IF9tYXRjaEl0KHN1YlVBLCAvT3BlcmEgTWluaVteO10qLywgMCk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5tb2JpbGUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfbWF0Y2hJdChzdWJVQSwgL01TSUVcXHMoW147XSopLywgMSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldC5pZSA9IF9udW1iZXJpZnkobWF0Y2gpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9HZWNrb1xcLyhbXlxcc10qKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgcmV0LmdlY2tvID0gMTtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gX21hdGNoSXQoc3ViVUEsIC9ydjooW15cXHNcXCldKikvLCAxKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXQuZ2Vja28gPSBfbnVtYmVyaWZ5KG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgICAgICB0aGVEb2N1bWVudC5jb29raWUgPSBsYW5nLmNzdHIoW1wic2ZfY2tfdHN0PXRlc3Q7IGV4cGlyZXM9XCIsIGRhdGUudG9HTVRTdHJpbmcoKSwgXCI7IHBhdGg9L1wiXSk7XG4gICAgICAgICAgaWYgKHRoZURvY3VtZW50LmNvb2tpZS5pbmRleE9mKFwic2ZfY2tfdHN0XCIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0LmNrcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICAgIHJldC5ja3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgICAgICAgICAgIHJldC5vcyA9IHByb2Nlc3MucGxhdGZvcm07XG4gICAgICAgICAgICAgIHJldC5ub2RlanMgPSBudW1iZXJpZnkocHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgcmV0Lm5vZGVqcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaWVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgT3BlcmEgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC48YnIgLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcbiAgICAgIEBuYW1lICRzZi5lbnYudWEub3BlcmFcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgR2Vja28gKEZpcmVmb3gpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmdlY2tvXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFdlYktpdCBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS53ZWJraXRcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2FmYXJpIGJyb3dzZXIgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLnNhZmFyaVxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBDaHJvbWUgYnJvd3NlciBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuY2hyb21lXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIEFJUiBTREsgYmVpbmcgdXNlZCwgb3IgMCBpZiBub3QuXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmFpclxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgV2hldGhlciBvciBub3QgYW4gaVBvZCBkZXZpY2UgaXMgYmVpbmcgdXNlZCwgMCBmb3IgZmFsc2UsICZndDsgMCA9PSB0cnVlXG4gICAgICBAbmFtZSAkc2YuZW52LnVhLmlwb2RcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFdoZXRoZXIgb3Igbm90IGFuIGlQYWQgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcGFkXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCBhbiBpUGhvbmUgZGV2aWNlIGlzIGJlaW5nIHVzZWQsIDAgZm9yIGZhbHNlLCAmZ3Q7IDAgPT0gdHJ1ZVxuICAgICAgQG5hbWUgJHNmLmVudi51YS5pcGhvbmVcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQW5kcm9pZCBPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuYW5kcm9pZFxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgVGhlIG1ham9yIHZlcnNpb24gbnVtYmVyIG9mIHRoZSBXZWJPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEud2Vib3NcbiAgICAgIEB0eXBlIHtOdW1iZXJ9XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgU2lsayBicm93c2VyIGJlaW5nIHVzZWQsIG9yIDAgaWYgbm90LlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5zaWxrXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIE5vZGVKUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEubm9kZWpzXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIFBoYW50b21KUyBlbnZpcm9ubWVudCBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEucGhhbnRvbWpzXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgLyBvcyBpcyBhIG1vYmlsZSBkZXZpY2UgIGFuZCBpdCdzIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3dpbmRvd3MnLCAnYW5kcm9pZCcsICdzeW1ib3MnLCAnbGludXgnLCAnbWFjaW50b3NoJywgJ3JoaW5vJywgJ2dlY2tvJywgJ0FwcGxlJywgJ2Nocm9tZScuXG4gICAgICBcbiAgICAgIEBuYW1lICRzZi5lbnYudWEubW9iaWxlXG4gICAgICBAdHlwZSB7U3RyaW5nfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBUaGUgbWFqb3IgdmVyc2lvbiBudW1iZXIgb2YgdGhlIGlPUyBiZWluZyB1c2VkLCBvciAwIGlmIG5vdC5cbiAgICAgIEBuYW1lICRzZi5lbnYudWEuaW9zXG4gICAgICBAdHlwZSB7TnVtYmVyfVxuICAgICAgQHB1YmxpY1xuICAgICAgQHN0YXRpY1xuICAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciAvIGVudmlyb25tZW50IGluIHF1ZXN0aW9uIGlzIGhhcmR3YXJlIGFjY2VsZXJhdGVkLlxuICAgICAgQG5hbWUgJHNmLmVudi51YS5hY2NlbFxuICAgICAgQHR5cGUge0Jvb2xlYW59XG4gICAgICBAcHVibGljXG4gICAgICBAc3RhdGljXG4gICAgICAgKi9cblxuICAgICAgLypcbiAgICAgIFRoZSBtYWpvciB2ZXJzaW9uIG51bWJlciBvZiB0aGUgQ0FKQSBlbnZpcm9ubWVudCBvciAwIGlmIG5vdFxuICAgICAgQG5hbWUgJHNmLmVudi51YS5jYWphVmVyc2lvblxuICAgICAgQHR5cGUge051bWJlcn1cbiAgICAgIEBwdWJsaWNcbiAgICAgIEBzdGF0aWNcbiAgICAgICAqL1xuICAgICAgY2FjaGVkX3VhID0gcGFyc2VfdWEoKTtcbiAgICAgIGNhY2hlZF91YS5wYXJzZSA9IHBhcnNlX3VhO1xuICAgICAgcmV0dXJuIGNhY2hlZF91YTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICB1YTogdWEsXG4gICAgICBpc0lFOiBpc0lFXG4gICAgfTtcbiAgfSkod2luZG93KTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI4RHdvaFJcIikpIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbih3aW5kb3cpIHtcbiAgICB2YXIgUGFyYW1IYXNoLCBiYWNrU2xhc2gsIGNhbGxhYmxlLCBjYm9vbCwgY251bSwgY3N0ciwgZGVmLCBlbnRpdHlNYXAsIGVudGl0eVJlZ2V4ZXMsIGd1aWQsIGlzQXJyYXksIGpzc2FmZV9odG1sLCBrZXlzLCBsYW5nLCBtaXgsIG5leHRfaWQsIG5vb3AsIG5zLCBwcm90bywgcmFuZCwgc2NyaXBfc3RyLCB0aW1lLCB0b1N0cmluZywgdHJpbSwgd2luLCB3cmFwLCBfZXMsIF91ZTtcbiAgICBuZXh0X2lkID0gMDtcbiAgICB3aW4gPSB3aW5kb3c7XG4gICAgYmFja1NsYXNoID0gU3RyaW5nLmZyb21DaGFyQ29kZSg5Mik7XG4gICAgc2NyaXBfc3RyID0gJ3NjclwiK1wiaXB0JztcbiAgICBfZXMgPSB3aW4uZXNjYXBlO1xuICAgIF91ZSA9IHdpbi51bmVzY2FwZTtcblxuICAgIC8qXG4gICAgQSBmdW5jdGlvbiByZWZlcmVuY2UgdGhhdCBkb2VzIG5vdGhpbmcuXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG5vb3AgYXMgJHNmLmxpYi5sYW5nLm5vb3BcbiAgICBAc3RhdGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHB1YmxpY1xuICAgIEByZXR1cm4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgbm9vcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAvKlxuICAgICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIHN0cmluZyB2YWx1ZS5cbiAgICAgIE5vdGUgdGhhdCBcImZhbHN5XCIgdmFsdWVzIG9yIHZhbHVlcyB0aGF0IGNhbm5vdCBiZSBjb252ZXJ0ZWQgd2lsbCBiZSByZXR1cm5lZFxuICAgICAgYXMgYW4gZW1wdHkgc3RyaW5nIChcIlwiKS5cbiAgICAgIFxuICAgICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgICAgQGV4cG9ydHMgY3N0ciBhcyAkc2YubGliLmxhbmcuY3N0clxuICAgICAgQHN0YXRpY1xuICAgICAgQHB1YmxpY1xuICAgICAgQGZ1bmN0aW9uXG4gICAgICBAcGFyYW0geyp9IHN0ciAgQW55IG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZyB2YWx1ZS5cbiAgICAgIEByZXR1cm4ge1N0cmluZ30gIFRoZSBub3JtYWxpemVkIHN0cmluZyB2YWx1ZS5cbiAgICAgICAqL1xuICAgIH07XG4gICAgY3N0ciA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHR5cDtcbiAgICAgIHR5cCA9IHR5cGVvZiBzdHI7XG4gICAgICBpZiAodHlwID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBpZiAodHlwID09PSBcIm51bWJlclwiICYmICFzdHIpIHtcbiAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJvYmplY3RcIiAmJiBzdHIgJiYgc3RyLmpvaW4pIHtcbiAgICAgICAgcmV0dXJuIHN0ci5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBGb3JjZXMgdHlwZSBjb252ZXJzaW9uIG9mIGFueSBKYXZhU2NyaXB0IHZhcmlhYmxlIHRvIGEgYm9vbGVhbi5cbiAgICBcIkZhbHN5XCIgdmFsdWVzIHN1Y2ggYXMgXCJcIiwgMCwgbnVsbCwgYW5kIHVuZGVmaW5lZCBhbGwgcmV0dXJuIGZhbHNlXG4gICAgU3RyaW5nIHZhbHVlcyBvZiAgXCIwXCIsIFwiZmFsc2VcIiwgXCJub1wiLCBcInVuZGVmaW5lZFwiLCBcIm51bGxcIiBhbHNvIHJldHVybiBmYWxzZVxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBjYm9vbCBhcyAkc2YubGliLmxhbmcuY2Jvb2xcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7Kn0gdmFsIEFueSBKYXZhU2NyaXB0IHJlZmVyZW5jZSAvIHZhbHVlXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vcm1hbGl6ZWQgYm9vbGVhbiB2YWx1ZVxuICAgICAqL1xuICAgIGNib29sID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAoIXZhbCB8fCB2YWwgPT09IFwiMFwiIHx8IHZhbCA9PT0gXCJmYWxzZVwiIHx8IHZhbCA9PT0gXCJub1wiIHx8IHZhbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWwgPT09IFwibnVsbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAga2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGssIF92O1xuICAgICAgcmV0dXJuICh0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5rZXlzKG9iaikgOiB2b2lkIDApIHx8ICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgIF92ID0gb2JqW2tdO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRm9yY2VzIHR5cGUgY29udmVyc2lvbiBvZiBhbnkgSmF2YVNjcmlwdCB2YXJpYWJsZSB0byBhIG51bWJlci5cbiAgICBWYWx1ZXMgLyBvYmplY3RzIHRoYXQgY2Fubm90IGJlIGNvbnZlcnRlZCwgd2lsbCBiZSByZXR1cm5lZCBhcyBOYU4sIHVubGVzc1xuICAgIGEgZGVmYXVsdCB2YWx1ZSBpcyBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgdXNlZC5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgY251bSBhcyAkc2YubGliLmxhbmcuY251bVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHsqfSB2YWwgQW55IEphdmFTY3JpcHQgcmVmZXJlbmNlIC8gdmFsdWVcbiAgICBAcGFyYW0geyp9IFtkZWZWYWxdIHVzZSB0aGlzIHZhbHVlIGlmIG9yaWdpbmFsIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIsIG9yIGlmIHZhbHVlIGlzIGxlc3MgdGhhbiBtaW4gdmFsdWUsIG9yIGlmIHZhbHVlIGlzIGxlc3MgdGhhbiBtYXggdmFsdWUuXG4gICAgQHBhcmFtIHtOdW1iZXJ9IFttaW5WYWxdIHNwZWNpZmllcyB0aGUgbG93ZXN0IG51bWVyaWNhbCB2YWx1ZSwgaWYgb3JpZ2luYWwgdmFsdWUgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUsIHRoZSBkZWZWYWwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICBAcGFyYW0ge051bWJlcn0gW21heFZhbF0gc3BlY2lmaWVzIHRoZSBncmVhdGVzdCBudW1lcmljYWwgdmFsdWUsIGlmIG9yaWdpbmFsIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIHZhbHVlLCB0aGUgZGVmVmFsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgQHJldHVybiB7TnVtYmVyfE5hTnwqfSB0aGUgY29udmVydGVkIHZhbHVlLCBvdGhlcndpc2UgTmFOIG9yIGRlZmF1bHQgdmFsdWVcbiAgICAgKi9cbiAgICBjbnVtID0gZnVuY3Rpb24odmFsLCBkZWZWYWwsIG1pblZhbCwgbWF4VmFsKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IE51bWJlci5OYU47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgdmFsID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1heFZhbCA9PSBudWxsKSB7XG4gICAgICAgIG1heFZhbCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB9XG4gICAgICBpZiAobWluVmFsID09IG51bGwpIHtcbiAgICAgICAgbWluVmFsID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICB9XG4gICAgICBpZiAoKGlzTmFOKHZhbCkgfHwgdmFsIDwgbWluVmFsIHx8IHZhbCA+IG1heFZhbCkgJiYgKGRlZlZhbCAhPSBudWxsKSkge1xuICAgICAgICByZXR1cm4gZGVmVmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVja3MgdGhhdCBhIGZ1bmN0aW9uIHJlZmVyZW5jZSBjYW4gYmUgY2FsbGVkIHNhZmVseS4gIFNvbWV0aW1lcyBmdW5jdGlvbiByZWZlcmVuY2VzIGFyZSBwYXJ0XG4gICAgb2Ygb2JqZWN0cyB0aGF0IG1heSBoYXZlIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWQgKHN1Y2ggYXMgYSBmdW5jdGlvbiByZWZlcmVuY2UgZnJvbSBhbm90aGVyIHdpbmRvdyBvciBkb20gZWxlbWVudCkuXG4gICAgVGhpcyBtZXRob2QgY2hlY2tzIHRoZSByZWZlcmVuY2UgYnkgbWFraW5nIHN1cmUgaXQgaGFzIGEgY29uc3RydWN0b3IgYW5kIHRvU3RyaW5nIHByb3BlcnRpZXMuXG4gICAgXG4gICAgTm90ZSB0aGF0IHRoaXMgZG9lc24ndCBtZWFuIHRoYXQgdGhlIGZ1bmN0aW9uIGl0c2VsZiB3aGVuIGNhbGxlZCAob3IgaXRzIHN1YnNxdWVudCBjYWxsIHN0YWNrKSwgY2FuJ3QgdGhyb3cgYW4gZXJyb3IuIC4gLlxuICAgIHNpbXBseSB0aGF0IHlvdSBhcmUgYWJsZSB0byBjYWxsIGl0LiAuIC5cbiAgICBcbiAgICB0aGlzIGNhbiBwcm9ibGVtIGJlIHJlbW92ZWQgaW4gbGlldSBvZiBmdW5jPygpIGluIGNzXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIGNhbGxhYmxlIGFzICRzZi5saWIubGFuZy5jYWxsYWJsZVxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gQSByZWZlcmVuY2UgdG8gYSBKYXZhU2NyaXB0IGZ1bmN0aW9uXG4gICAgQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHNhZmVseSwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGNhbGxhYmxlID0gZnVuY3Rpb24oZikge1xuICAgICAgdmFyIGU7XG4gICAgICB0cnkge1xuICAgICAgICBmID0gKGYgJiYgdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIiAmJiBmLnRvU3RyaW5nKCkgJiYgKG5ldyBmLmNvbnN0cnVjdG9yKCkpID8gZiA6IG51bGwpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIGYgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhZjtcbiAgICB9O1xuXG4gICAgLypcbiAgICBHZW5lcmF0ZSBhIHVuaXF1ZSBpZCBzdHJpbmdcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgZ3VpZCBhcyAkc2YubGliLmxhbmcuZ3VpZFxuICAgIEBzdGF0aWNcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXhdIGEgc3Vic3RyaW5nIHRvIHVzZSBhIHByZWZpeFxuICAgIEByZXR1cm4ge1N0cmluZ30gdW5pcXVlIGlkIHN0cmluZ1xuICAgICAqL1xuICAgIGd1aWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICAgIHJldHVybiBjc3RyKFtwcmVmaXggfHwgXCJcIiwgXCJfXCIsIHRpbWUoKSwgXCJfXCIsIHJhbmQoKSwgXCJfXCIsIG5leHRfaWQrK10pO1xuICAgIH07XG5cbiAgICAvKlxuICAgIE1peGVkIHRoZSBwcm9wZXJ0aWVzIG9mIG9uZSBvYmplY3QgaW50byBhbm90aGVyIG9iamVjdC5cbiAgICBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyByZWN1cnNpdmVcbiAgICBcbiAgICBcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgbWl4IGFzICRzZi5saWIubGFuZy5taXhcbiAgICBAc3RhdGljXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBwYXJhbSB7T2JqZWN0fSAgciAgVGhlIG9iamVjdCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wZXJ0aWVzXG4gICAgQHBhcmFtIHtPYmplY3R9ICBzICBUaGUgb2JqZWN0IHRoYXQgd2lsbCBkZWxpZXZlciBwcm9wZXJ0aWVzXG4gICAgQHBhcmFtIHtCb29sZWFufSBbb3duZWRdIFdoZXRoZXIgb3Igbm90IHRvIHNraXAgb3ZlciBwcm9wZXJ0aWVzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIG9iamVjdCBwcm90b3R5cGVcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtza2lwRnVuY3NdIFdoZXRoZXIgb3Igbm90IHRvIHNraXAgb3ZlciBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgQHBhcmFtIHtCb29sZWFufSBbbm9fb3ZyXSBXaGV0aGVyIG9yIG5vdCB0byBvdmVyd3JpdGUgcHJvcGVydGllcyB0aGF0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBmaWxsZWQgb3V0XG4gICAgQHJldHVybiB7T2JqZWN0fSBUaGUgcmVjZWl2ZXIgb2JqZWN0IHBhc3NlZCBpbiB3aXRoIHBvdGVudGlhbGx5IG5ldyBwcm9wZXJ0aWVzIGFkZGVkXG4gICAgICovXG4gICAgbWl4ID0gZnVuY3Rpb24ociwgcywgb3duZWQsIHNraXBGdW5jcywgbm9fb3ZyKSB7XG4gICAgICB2YXIgaXRlbSwgcCwgdHlwO1xuICAgICAgaWYgKCFzIHx8ICFyKSB7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgZm9yIChwIGluIHMpIHtcbiAgICAgICAgaXRlbSA9IHNbcF07XG4gICAgICAgIHR5cCA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAob3duZWQgJiYgIXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9fb3ZyICYmIChwIGluIHIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBGdW5jcyAmJiB0eXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXAgPT09IFwib2JqZWN0XCIgJiYgaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtLnNsaWNlKSB7XG4gICAgICAgICAgICBpdGVtID0gbWl4KFtdLCBpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IG1peCh7fSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJbcF0gPSBpdGVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLCBmcm9tIHRoZSBlcG9jaFxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyB0aW1lIGFzICRzZi5saWIubGFuZy50aW1lXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgdGltZVxuICAgICAqL1xuICAgIHRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGFueXdoZXJlIGZyb20gMCB0byA5OVxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyByYW5kIGFzICRzZi5saWIubGFuZy5yYW5kXG4gICAgQHB1YmxpY1xuICAgIEBzdGF0aWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcmV0dXJuIHtOdW1iZXJ9IHJhbmRvbSBudW1iZXJcbiAgICAgKi9cbiAgICByYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBUcmltIHRoZSBiZWdpbmluZyBhbmQgZW5kaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cbiAgICBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYW4gYXJndW1lbnQgdG8gYSBzdHJpbmcgZmlyc3RcbiAgICBmb3IgdHlwZSBzYWZldHkgcHVycG9zZXMuIElmIHN0cmluZyBjYW5ub3QgYmUgY29udmVydGVkLCBhbmQgZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIHRyaW0gYXMgJHNmLmxpYi5sYW5nLnRyaW1cbiAgICBAcmV0dXJuIHtTdHJpbmd9IHRyaW1tZWQgc3RyaW5nXG4gICAgQHB1YmxpY1xuICAgIEBmdW5jdGlvblxuICAgIEBzdGF0aWNcbiAgICAgKi9cbiAgICB0cmltID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgcmV0O1xuICAgICAgcmV0ID0gY3N0cihzdHIpO1xuICAgICAgcmV0dXJuIHJldCAmJiByZXQucmVwbGFjZSgvXlxcc1xccyovLCBcIlwiKS5yZXBsYWNlKC9cXHNcXHMqJC8sIFwiXCIpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERlZmluZSBhIEphdmFTY3JpcHQgTmFtZXNwYWNlIHdpdGhpbiBhIGdpdmVuIGNvbnRleHRcbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMgZGVmIGFzICRzZi5saWIubGFuZy5kZWZcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyX25zICBUaGUgbmFtZSBvZiB0aGUgbmFtZXNwYWNlIGluIGRvdCBub3RhdGlvbiBhcyBhIHN0cmluZyAoZS5nLiBcIkZvby5iYXJcIilcbiAgICBAcGFyYW0ge09iamVjdH0gW2F1Z10gZGVmaW5lcyB0aGUgb2JqZWN0IGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVzcGFjZS4gIElmIG5hbWVzcGFjZSBpcyBhbHJlYWR5IHNwZWNpZmllZCwgYW5kIHRoaXMgb2JqZWN0IGlzIHByb3ZpZGVkLCB0aGUgbmFtZXNwYWNlIHdpbGwgYmUgYXVnbWVudGVkIHdpdGggcHJvcGVydGllcyBmcm9tIHRoaXMgb2JqZWN0LiBJZiBub3RoaW5nIGlzIHBhc3NlZCBpbiwgZGVmYXVsdHMgdG8gdXNpbmcgYW4gZW1wdHkgb2JqZWN0LlxuICAgIEBwYXJhbSB7T2JqZWN0fSBbcm9vdF0gdGhlIHJvb3Qgb2JqZWN0IGZyb20gd2hpY2ggdGhlIG5hbWVzcGFjZSBpcyBkZWZpbmVkLiAgSWYgbm90IHBhc3NlZCBpbiBkZWZhdWx0cyB0byB0aGUgZ2xvYmFsL3dpbmRvdyBvYmplY3RcbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtub19vdnJdIGlmIHRydWUsIHByb3BlcnRpZXMgYWxyZWFkeSBkZWZpbmVkIG9uIHJvb3Qgd2l0aCB0aGUgc2FtZSBuYW1lIHdpbGwgYmUgaWdub3JlZFxuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAc3RhdGljXG4gICAgQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVzcGFjZVxuICAgICAqL1xuICAgIGRlZiA9IGZ1bmN0aW9uKHN0cl9ucywgYXVnLCByb290LCBub19vdnIpIHtcbiAgICAgIHZhciBhciwgaWR4LCBpdGVtLCBvYmosIHBlciwgcmV0O1xuICAgICAgb2JqID0gKHJvb3QgJiYgdHlwZW9mIHJvb3QgPT09IFwib2JqZWN0XCIgPyByb290IDogd2luKTtcbiAgICAgIGlkeCA9IDA7XG4gICAgICBwZXIgPSBcIi5cIjtcbiAgICAgIHJldCA9IG51bGw7XG4gICAgICBpZiAoc3RyX25zKSB7XG4gICAgICAgIHN0cl9ucyA9IGNzdHIoc3RyX25zKTtcbiAgICAgICAgYXVnID0gKGF1ZyAmJiB0eXBlb2YgYXVnID09PSBcIm9iamVjdFwiID8gYXVnIDogbnVsbCk7XG4gICAgICAgIGlmIChzdHJfbnMuaW5kZXhPZihwZXIpKSB7XG4gICAgICAgICAgYXIgPSBzdHJfbnMuc3BsaXQocGVyKTtcbiAgICAgICAgICB3aGlsZSAoaXRlbSA9IGFyW2lkeCsrXSkge1xuICAgICAgICAgICAgaXRlbSA9IHRyaW0oaXRlbSk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSBhci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKG9ialtpdGVtXSAmJiBhdWcpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV0gPSBtaXgob2JqW2l0ZW1dLCBhdWcsIGZhbHNlLCBudWxsLCBub19vdnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub19vdnIgJiYgKGl0ZW0gaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXQgPSBvYmpbaXRlbV0gPSBvYmpbaXRlbV0gfHwgYXVnIHx8IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG5vX292ciAmJiAoaXRlbSBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gb2JqW2l0ZW1dO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IG9ialtpdGVtXSA9IG9ialtpdGVtXSB8fCB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2l0ZW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob2JqW3N0cl9uc10gJiYgYXVnKSB7XG4gICAgICAgICAgICByZXQgPSBvYmpbc3RyX25zXSA9IG1peChvYmpbc3RyX25zXSwgYXVnLCBmYWxzZSwgbnVsbCwgbm9fb3ZyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gb2JqW3N0cl9uc10gPSBvYmpbc3RyX25zXSB8fCBhdWcgfHwge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIEphdmFTY3JpcHQgbmFtZXNwYWNlXG4gICAgYXMgb3Bwb3NlZCB0byBkZWYsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZWZpbmUgdGhlIG5hbWVzcGFjZVxuICAgIHdpdGggYSBnaXZlbiBjb250ZXh0LlxuICAgIFxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBucyBhcyAkc2YubGliLmxhbmcubnNcbiAgICBAcGFyYW0ge1N0cmluZ30gc3RyX25zICBBIHN0cmluZyB3aXRoIC4gb3IgW10gbm90YXRpb24gb2YgYSBKYXZhU2NyaXB0IG5hbWVzYWNlIChlLmcuIFwiZm9vLmJhci5zaG93XCIsIG9yIFwiZm9vWydiYXInXVsnc2hvdyddXCIpLlxuICAgIEBwYXJhbSB7T2JqZWN0fSBbcm9vdF0gdGhlIHJvb3Qgb2JqZWN0IHRvIGNoZWNrIHdpdGhpbi4gLmRlZmF1bHRzIHRvIGdsb2JhbCAvIHdpbmRvd1xuICAgIEByZXR1cm4geyp9IFRoZSBlbmRwb2ludCByZWZlcmVuY2Ugb2YgdGhlIG5hbWVzcGFjZSBvciBmYWxzZSBpZiBub3QgZm91bmRcbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgICAqL1xuICAgIG5zID0gZnVuY3Rpb24oc3RyX25zLCByb290KSB7XG4gICAgICB2YXIgZXhpc3RzLCBleHAsIGV4cDIsIGV4cDMsIGV4cDQsIGlkeCwgbWF0Y2hlcywgb2JqLCBwcm9wLCByb290U3RyO1xuICAgICAgZXhwID0gLyhcXFsoLnsxLH0pXFxdKXwoXFwuXFx3KykvZztcbiAgICAgIGV4cDIgPSAvXFxbKCgnfFwiKT8pKChcXHN8LikqPykoKCd8XCIpPylcXF0vZztcbiAgICAgIGV4cDMgPSAvKFxcWy4qKXwoXFwuLiopL2c7XG4gICAgICBleHA0ID0gL1xcLi9nO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHJvb3RTdHIgPSBcIlwiO1xuICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgIG9iaiA9IHJvb3QgPSByb290IHx8IHdpbjtcbiAgICAgIGlmIChzdHJfbnMpIHtcbiAgICAgICAgc3RyX25zID0gY3N0cihzdHJfbnMpO1xuICAgICAgICBpZiAoc3RyX25zKSB7XG4gICAgICAgICAgc3RyX25zID0gdHJpbShzdHJfbnMpO1xuICAgICAgICAgIG1hdGNoZXMgPSBzdHJfbnMubWF0Y2goZXhwKTtcbiAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcm9vdFN0ciA9IHN0cl9ucy5yZXBsYWNlKGV4cDMsIFwiXCIpO1xuICAgICAgICAgICAgbWF0Y2hlcy51bnNoaWZ0KHJvb3RTdHIpO1xuICAgICAgICAgICAgd2hpbGUgKHByb3AgPSBtYXRjaGVzW2lkeCsrXSkge1xuICAgICAgICAgICAgICBwcm9wID0gcHJvcC5yZXBsYWNlKGV4cDIsIFwiJDNcIikucmVwbGFjZShleHA0LCBcIlwiKTtcbiAgICAgICAgICAgICAgaWYgKCFvYmpbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICBleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvYmogPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3AgPSBzdHJfbnM7XG4gICAgICAgICAgICBvYmogPSBvYmpbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZXhpc3RzICYmIG9iaikgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgQGZ1bmN0aW9uXG4gICAgVGVzdHMgdG8gc2VlIGlmIHRoZSBvYmplY3QgcGFzc2VkIGluIGlzIGFuIGFycmF5XG4gICAgICovXG4gICAgaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgob2JqLmxlbmd0aCAhPSBudWxsKSAmJiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrcyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIEphdmFTY3JpcHQgbmFtZXNwYWNlXG4gICAgYXMgb3Bwb3NlZCB0byBkZWYsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZWZpbmUgdGhlIG5hbWVzcGFjZVxuICAgIHdpdGggYSBnaXZlbiBjb250ZXh0LiAgICAgICAgIHZpYSB1bmRlcnNjb3JlLmpzXG4gICAgXG4gICAgQG1lbWJlck9mICRzZi5saWIubGFuZ1xuICAgIEBleHBvcnRzIG5zIGFzICRzZi5saWIubGFuZy53cmFwXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gYmUgd3JhcHBlZFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgZnVuY3Rpb25cbiAgICBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICBAcHVibGljXG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgICAqL1xuICAgIHdyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzO1xuICAgICAgICBhcmdzID0gW2Z1bmNdO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2l2ZW4gYSBzdHJpbmcgb2YgSFRNTCBlc2NhcGUgcXVvdGUgbWFya3MgYW5kIHNlcGVyYXRlIHNjcmlwdCB0YWdzIHNvIHRoYXQgYnJvd3NlcnMgZG9uJ3QgZ2V0IHRyaXBwZWQgdXBcbiAgICBkdXJpbmcgcHJvY2Vzc2luZy5cbiAgICBcbiAgICBAbWVtYmVyT2YgJHNmLmxpYi5sYW5nXG4gICAgQGV4cG9ydHMganNzYWZlX2h0bWwgYXMgJHNmLmxpYi5sYW5nLmpzc2FmZV9odG1sXG4gICAgQHBhcmFtIHtTdHJpbmd9IHN0ciBBIHN0cmluZyBvZiBIVE1MIG1hcmt1cCB0byBiZSBwcm9jZXNzZWRcbiAgICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgQGZ1bmN0aW9uXG4gICAgQHN0YXRpY1xuICAgIEBwdWJsaWNcbiAgICAgKi9cbiAgICBlbnRpdHlNYXAgPSB7XG4gICAgICBlc2NhcGU6IHtcbiAgICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgICBcIidcIjogJyYjeDI3OydcbiAgICAgIH1cbiAgICB9O1xuICAgIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgICBlc2NhcGU6IG5ldyBSZWdFeHAoJ1snICsga2V5cyhlbnRpdHlNYXAuZXNjYXBlKS5qb2luKCcnKSArICddJywgJ2cnKVxuICAgIH07XG4gICAganNzYWZlX2h0bWwgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXMuZXNjYXBlLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW50aXR5TWFwLmVzY2FwZVttYXRjaF07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBAY2xhc3MgSW50YW50aWFibGUgY2xhc3MgdXNlZCB0byBjb252ZXJ0IGEgZGVsaW1pdGVkIHN0cmluZyBpbnRvIGFuIG9iamVjdC48YnIgLz5cbiAgICBGb3IgZXhhbXBsZSBxdWVyeXN0cmluZ3M6IFwibmFtZV8xPXZhbHVlXzEmbmFtZV8yPXZhbHVlXzJcIiA9PT4ge25hbWVfMTp2YWx1ZV8xLG5hbWVfMjp2YWx1ZV8yfTs8YnIvPjxiciAvPlxuICAgIFxuICAgIE5vdGUgdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgY291bGQgYWxzbyBjb250YWluIHRoZSBzYW1lIHNQcm9wRGVsaW0gYW5kIHNWYWx1ZURlbGltIHN0cmluZ3MuICBQcm9wZXIgc3RyaW5nIGVuY29kaW5nIHNob3VsZCBvY2N1clxuICAgIHRvIG5vdCB0cmlwIHVwIHRoZSBwYXJzaW5nIG9mIHRoZSBzdHJpbmcuICBTYWlkIHZhbHVlcyBtYXkgYmUgYXNjaWkgZXNjYXBlZCwgYW5kIGluIHR1cm4sIGFsb25nIHdpdGggdGhlIDxpPjxiPmJSZWN1cnNlPC9iPjwvaT4gY29uc3RydWN0b3IgcGFyYW1ldGVyIHNldCB0byB0cnVlLCB3aWxsIGNhdXNlIG5lc3RlZCBQYXJhbUhhc2ggb2JqZWN0cyB0byBiZSBjcmVhdGVkLlxuICAgIFxuICAgIEBjb25zdHJ1Y3RvclxuICAgIEBtZW1iZXJPZiAkc2YubGliLmxhbmdcbiAgICBAZXhwb3J0cyBQYXJhbUhhc2ggYXMgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1N0cmluZ10gIFRoZSBkZWxpbWl0ZWQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICAgIEBwYXJhbSB7U3RyaW5nfSBbc1Byb3BEZWxpbT1cIiZcIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVyIHVzZWQgdG8gc2VwZXJhdGUgcHJvcGVydGllcy4gRGVmYXVsdCBpcyBcIiZcIi5cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NWYWx1ZURlbGltPVwiPVwiXSAgVGhlIHN1YnN0cmluZyBkZWxpbWl0ZWQgdXNlZCB0byBzZXBlcmF0ZSB2YWx1ZXMuICBEZWZhdWx0IGlzIFwiPVwiLlxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2JOb092ZXJ3cml0ZT1mYWxzZV0gIElmIHRydWUsIHdoZW4gYSBuYW1lIGlzIGVuY291bnRlcmVkIG1vcmUgdGhhbiAxIHRpbWUgaW4gdGhlIHN0cmluZyBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgQHBhcmFtIHtCb29sZWFufSBbYlJlY3Vyc2U9ZmFsc2VdICBJZiB0cnVlLCB3aGVuIGEgdmFsdWUgb2YgYSBwcm9wZXJ0eSB0aGF0IGlzIHBhcnNlZCBhbHNvIGhhcyBib3RoIHRoZSBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSBpbnNpZGUsIGNvbnZlcnQgdGhhdCB2YWx1ZSB0byBhbm90aGVyIFBhcmFtSGFzaCBvYmplY3QgYXV0b21hdGljYWxseVxuICAgIEBleGFtcGxlXG4gICAgdmFyIHBoID0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goXCJ4PTEmeT0xJno9MVwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueik7IC8vID09IDFcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieDoxO3k6Mjt6OjNcIiwgXCI7XCIsIFwiOlwiKTtcbiAgICBhbGVydChwaC54KTsgLy8gPT0gMVxuICAgIGFsZXJ0KHBoLnkpOyAvLyA9PSAyXG4gICAgYWxlcnQocGgueik7IC8vID09IDNcbiAgICBcbiAgICBAZXhhbXBsZVxuICAgIHZhciBwaCA9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKFwieD0xJnk9MSZ6PTEmej0yXCIpO1xuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vIDFcbiAgICBhbGVydChwaC56KTsgLy9Ob3RlIHRoYXQgeiA9PSAyIGIvYyBvZiAyIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICB2YXIgcGggPSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChcIng9MSZ5PTEmej0xJno9MlwiLG51bGwsbnVsbCx0cnVlKTsgLy9udWxsIGZvciBzUHJvcERlbGltIGFuZCBzVmFsdWVEZWxpbSA9PSB1c2UgZGVmYXVsdCB2YWx1ZXMgb2YgXCImXCIgYW5kIFwiPVwiIHJlc3BlY3RpdmVseVxuICAgIGFsZXJ0KHBoLngpOyAvLyA9PSAxXG4gICAgYWxlcnQocGgueSk7IC8vIDFcbiAgICBhbGVydChwaC56KTsgLy9Ob3RlIHRoYXQgeiA9PSAxIGIvYyBiTm9PdmVyd3JpdGUgd2FzIHNldCB0byB0cnVlXG4gICAgXG4gICAgQGV4YW1wbGVcbiAgICAvL1lvdSBjYW4gYWxzbyBkbyByZWN1cnNpdmUgcHJvY2Vzc2luZyBpZiBuZWVkIGJlXG4gICAgdmFyIHBvaW50c1x0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaCgpLFxuICAgIHBvaW50XzFcdD0gbmV3ICRzZi5saWIubGFuZy5QYXJhbUhhc2goKSxcbiAgICBwb2ludF8yXHQ9IG5ldyAkc2YubGliLmxhbmcuUGFyYW1IYXNoKCk7XG4gICAgXG4gICAgcG9pbnRfMS54ID0gMTAwO1xuICAgIHBvaW50XzEueSA9IDc1O1xuICAgIFxuICAgIHBvaW50XzIueCA9IDIwMDtcbiAgICBwb2ludF8yLnkgPSAxNTA7XG4gICAgXG4gICAgcG9pbnRzLnBvaW50XzFcdD0gcG9pbnRfMTtcbiAgICBwb2ludHMucG9pbnRfMlx0PSBwb2ludF8yO1xuICAgIFxuICAgIHZhciBwb2ludF9zdHJcdD0gcG9pbnRzLnRvU3RyaW5nKCk7ICAvLyA9PSBcInBvaW50XzE9eCUzRDEwMCUyNnklM0Q3NSUyNiZwb2ludF8yPXglM0QyMDAlMjZ5JTNEMTUwJTI2JlwiO1xuICAgIHZhciBwb2ludHNfY29weVx0PSBuZXcgJHNmLmxpYi5sYW5nLlBhcmFtSGFzaChwb2ludF9zdHIsIG51bGwsIG51bGwsIHRydWUsIHRydWUpOyAvL25vdGUgcGFzc2luZyB0cnVlLCBiL2Mgd2Ugd2FudCB0byByZWN1cnNlXG4gICAgXG4gICAgYWxlcnQocG9pbnRzX2NvcHkucG9pbnRfMS54KSAvLyA9PSBcIjEwMFwiO1xuICAgICAqL1xuICAgIFBhcmFtSGFzaCA9IGZ1bmN0aW9uKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKSB7XG4gICAgICB2YXIgYWRkZWQsIGNudCwgZG9BZGQsIGlkeCwgaWR4MiwgaWR4MywgaW8sIGxlbiwgbGVuMiwgbWUsIG5tLCBudiwgb2JqLCBwYWlycywgc1RlbXAsIHNUZW1wMiwgc1RlbXAzLCBzcztcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIGlvID0gXCJpbmRleE9mXCI7XG4gICAgICBzcyA9IFwic3Vic3RyaW5nXCI7XG4gICAgICBkb0FkZCA9IGZhbHNlO1xuICAgICAgaWYgKCEobWUgaW5zdGFuY2VvZiBQYXJhbUhhc2gpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1IYXNoKHNTdHJpbmcsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWU7XG4gICAgICB9XG4gICAgICBpZiAoc1N0cmluZyAmJiB0eXBlb2Ygc1N0cmluZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gbWl4KG5ldyBQYXJhbUhhc2goXCJcIiwgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpLCBzU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHNTdHJpbmcgPSBjc3RyKHNTdHJpbmcpO1xuICAgICAgc1Byb3BEZWxpbSA9IGNzdHIoc1Byb3BEZWxpbSkgfHwgXCImXCI7XG4gICAgICBzVmFsdWVEZWxpbSA9IGNzdHIoc1ZhbHVlRGVsaW0pIHx8IFwiPVwiO1xuICAgICAgaWYgKCFzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtZTtcbiAgICAgIH1cbiAgICAgIGlmIChzUHJvcERlbGltICE9PSBcIj9cIiAmJiBzVmFsdWVEZWxpbSAhPT0gXCI/XCIgJiYgc1N0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXSgxKTtcbiAgICAgIH1cbiAgICAgIGlkeCA9IHNTdHJpbmdbaW9dKFwiP1wiKTtcbiAgICAgIGlkeDIgPSBzU3RyaW5nW2lvXShzVmFsdWVEZWxpbSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSAmJiBpZHgyICE9PSAtMSAmJiBpZHggPiBpZHgyKSB7XG4gICAgICAgIHNUZW1wID0gX2VzKHNTdHJpbmdbc3NdKGlkeDIgKyAxKSk7XG4gICAgICAgIHNUZW1wMiA9IHNTdHJpbmcuc3Vic3RyKDAsIGlkeDIgKyAxKTtcbiAgICAgICAgc1N0cmluZyA9IHNUZW1wMiArIHNUZW1wO1xuICAgICAgfSBlbHNlIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHNTdHJpbmcgPSBzU3RyaW5nW3NzXShpZHggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbUhhc2goc1N0cmluZywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc1N0cmluZy5jaGFyQXQoMCkgPT09IHNQcm9wRGVsaW0pIHtcbiAgICAgICAgc1N0cmluZyA9IHNTdHJpbmdbc3NdKDEpO1xuICAgICAgfVxuICAgICAgcGFpcnMgPSBzU3RyaW5nLnNwbGl0KHNQcm9wRGVsaW0pO1xuICAgICAgY250ID0gcGFpcnMubGVuZ3RoO1xuICAgICAgaWR4ID0gMDtcbiAgICAgIHdoaWxlIChjbnQtLSkge1xuICAgICAgICBzVGVtcCA9IHBhaXJzW2lkeCsrXTtcbiAgICAgICAgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgZG9BZGQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNUZW1wKSB7XG4gICAgICAgICAgbnYgPSBzVGVtcC5zcGxpdChzVmFsdWVEZWxpbSk7XG4gICAgICAgICAgbGVuID0gbnYubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgICBubSA9IF91ZShudlswXSk7XG4gICAgICAgICAgICBudi5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGJSZWN1cnNlKSB7XG4gICAgICAgICAgICAgIHNUZW1wMiA9IG5tICsgc1ZhbHVlRGVsaW07XG4gICAgICAgICAgICAgIGlkeDIgPSBzU3RyaW5nW2lvXShzVGVtcDIpO1xuICAgICAgICAgICAgICBsZW4gPSBzVGVtcDJbTEVOXTtcbiAgICAgICAgICAgICAgc1RlbXAzID0gc1N0cmluZ1tzc10oaWR4MiArIGxlbik7XG4gICAgICAgICAgICAgIHNUZW1wMiA9IHNQcm9wRGVsaW0gKyBzUHJvcERlbGltO1xuICAgICAgICAgICAgICBsZW4yID0gc1RlbXAyW0xFTl07XG4gICAgICAgICAgICAgIGlkeDMgPSBzVGVtcDNbaW9dKHNUZW1wMik7XG4gICAgICAgICAgICAgIGlmIChpZHgzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHNUZW1wMyA9IHNTdHJpbmcuc3Vic3RyKGlkeDIgKyBsZW4sIGlkeDMgKyBsZW4yKTtcbiAgICAgICAgICAgICAgICBvYmogPSBuZXcgUGFyYW1IYXNoKHNUZW1wMywgc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGJOb092ZXJ3cml0ZSwgYlJlY3Vyc2UpO1xuICAgICAgICAgICAgICAgIHNUZW1wMyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHNUZW1wMyBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWR4ICs9IGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNUZW1wID0gb2JqO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNUZW1wID0gX3VlKG52LmpvaW4oc1ZhbHVlRGVsaW0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc1RlbXAgPSBfdWUobnYuam9pbihzVmFsdWVEZWxpbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9BZGQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICBubSA9IF91ZShudlswXSk7XG4gICAgICAgICAgICBzVGVtcCA9IF91ZShudlsxXSk7XG4gICAgICAgICAgICBkb0FkZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb0FkZCkge1xuICAgICAgICAgICAgaWYgKGJOb092ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICBpZiAoIShubSBpbiBtZSkpIHtcbiAgICAgICAgICAgICAgICBtZVtubV0gPSBzVGVtcDtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lW25tXSA9IHNUZW1wO1xuICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYlJlY3Vyc2UgJiYgYWRkZWQgJiYgbm0gJiYgc1RlbXAgJiYgdHlwZW9mIHNUZW1wICE9PSBcIm9iamVjdFwiICYmIChzVGVtcFtpb10oc1Byb3BEZWxpbSkgPj0gMCB8fCBzVGVtcFtpb10oc1ZhbHVlRGVsaW0pID49IDApKSB7XG4gICAgICAgICAgICAgIG1lW25tXSA9IG5ldyBQYXJhbUhhc2goc1RlbXAsIHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBiTm9PdmVyd3JpdGUsIGJSZWN1cnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBDb252ZXJ0cyBhIFBhcmFtSGFzaCBvYmplY3QgYmFjayBpbnRvIGEgc3RyaW5nIHVzaW5nIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVsaW1pdGVycyBzcGVjaWZlZCAoZGVmYXVsdHMgdG8gXCImXCIgYW5kIFwiPVwiKS5cbiAgICBBZ2FpbiB0aGlzIG1ldGhvZCB3b3JrcyByZWN1cnNpdmVseS4gIElmIGFuIG9iamVjdCBpcyBmb3VuZCBhcyBhIHByb3BlcnR5LCBpdCB3aWxsIGNvbnZlcnQgdGhhdCBvYmplY3QgaW50byBhIFBhcmFtSGFzaCBzdHJpbmdcbiAgICBhbmQgdGhlbiBlc2NhcGUgaXQuIE5vdGUgYWxzbyB0aGF0IHRoaXMgY2xhc3MncyB2YWx1ZU9mIG1ldGhvZCBpcyBlcXVhbCB0byB0aGlzIG1ldGhvZC5cbiAgICBcbiAgICBAbWV0aG9kT2YgUGFyYW1IYXNoI1xuICAgIEBwdWJsaWNcbiAgICBAZnVuY3Rpb25cbiAgICBAcGFyYW0ge1N0cmluZ30gW3NQcm9wRGVsaW09XCImXCJdICBUaGUgc3Vic3RyaW5nIGRlbGltaXRlciB1c2VkIHRvIHNlcGVyYXRlIHByb3BlcnRpZXMuIERlZmF1bHQgaXMgXCImXCIuXG4gICAgQHBhcmFtIHtTdHJpbmd9IFtzVmFsdWVEZWxpbT1cIj1cIl0gIFRoZSBzdWJzdHJpbmcgZGVsaW1pdGVkIHVzZWQgdG8gc2VwZXJhdGUgdmFsdWVzLiAgRGVmYXVsdCBpcyBcIj1cIi5cbiAgICBAcGFyYW0ge0Jvb2xlYW59IFtlc2NhcGVQcm9wPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBhc2NpaSBlc2NhcGUgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eVxuICAgIEBwYXJhbSB7Qm9vbGVhbn0gW2RvbnRFc2NhcGVWYWx1ZT1mYWxzZV0gRG8gbm90IGVzY2FwZSB2YWx1ZXMgb3IgcHJvcGVydGllcyBhdXRvbWF0aWNhbGx5XG4gICAgQHJldHVybiB7U3RyaW5nfSB0aGUgZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA9IGZ1bmN0aW9uKHNQcm9wRGVsaW0sIHNWYWx1ZURlbGltLCBlc2NhcGVQcm9wLCBkb250RXNjYXBlVmFsdWUpIHtcbiAgICAgIHZhciBidWZmZXIsIGl0ZW0sIGl0ZW1UeXBlLCBtZSwgcHJvcDtcbiAgICAgIHByb3AgPSB2b2lkIDA7XG4gICAgICBidWZmZXIgPSBbXTtcbiAgICAgIG1lID0gdGhpcztcbiAgICAgIGl0ZW1UeXBlID0gdm9pZCAwO1xuICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgIHNQcm9wRGVsaW0gPSBzUHJvcERlbGltIHx8IFwiJlwiO1xuICAgICAgc1ZhbHVlRGVsaW0gPSBzVmFsdWVEZWxpbSB8fCBcIj1cIjtcbiAgICAgIGZvciAocHJvcCBpbiBtZSkge1xuICAgICAgICBpdGVtID0gbWVbcHJvcF07XG4gICAgICAgIGl0ZW1UeXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW1UeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGl0ZW0gPSB0b1N0cmluZy5hcHBseShpdGVtLCBbc1Byb3BEZWxpbSwgc1ZhbHVlRGVsaW0sIGVzY2FwZVByb3AsIGRvbnRFc2NhcGVWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlc2NhcGVQcm9wKSB7XG4gICAgICAgICAgcHJvcCA9IF9lcyhwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRFc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGl0ZW0gPSBfZXMoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2gocHJvcCwgc1ZhbHVlRGVsaW0sIGl0ZW0sIHNQcm9wRGVsaW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzdHIoYnVmZmVyKTtcbiAgICB9O1xuICAgIHByb3RvID0gUGFyYW1IYXNoLnByb3RvdHlwZTtcbiAgICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gdHJpbTtcbiAgICB9XG5cbiAgICAvKlxuICAgIEBpZ25vcmVcbiAgICAgKi9cbiAgICBwcm90by50b1N0cmluZyA9IHByb3RvLnZhbHVlT2YgPSB0b1N0cmluZztcbiAgICBsYW5nID0ge1xuICAgICAgUGFyYW1IYXNoOiBQYXJhbUhhc2gsXG4gICAgICBjc3RyOiBjc3RyLFxuICAgICAgY251bTogY251bSxcbiAgICAgIGNib29sOiBjYm9vbCxcbiAgICAgIG5vb3A6IG5vb3AsXG4gICAgICB0cmltOiB0cmltLFxuICAgICAgY2FsbGFibGU6IGNhbGxhYmxlLFxuICAgICAgZ3VpZDogZ3VpZCxcbiAgICAgIG1peDogbWl4LFxuICAgICAgdGltZTogdGltZSxcbiAgICAgIHJhbmQ6IHJhbmQsXG4gICAgICBkZWY6IGRlZixcbiAgICAgIG5zOiBucyxcbiAgICAgIGpzc2FmZV9odG1sOiBqc3NhZmVfaHRtbCxcbiAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICB3cmFwOiB3cmFwLFxuICAgICAga2V5czoga2V5c1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIGV4cG9ydHMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmxhbmcgPSBsYW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gIH0pKHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNy4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgIHZhciBsb2dFcnJvciwgbG9nSW5mbywgd2luO1xuICAgIHdpbiA9IHdpbmRvdztcblxuICAgIC8qXG4gICAgV3JpdGUgYW4gZW50cnkgdG8gdGhlIGNvbnNvbGUgbG9nIGFuZCBmaXJlIGFueSBsb2cgbGlzdGVuZXJzXG4gICAgXG4gICAgQG1lc3NhZ2UgIFRoZSBsb2cgbWVzc2FnZVxuICAgICAqL1xuICAgIGxvZ0luZm8gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBpZiAod2luLmNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgV3JpdGUgYW4gZW50cnkgdG8gdGhlIGNvbnNvbGUgZXJyb3IgbG9nIGFuZCBmaXJlIGFueSBsb2cgbGlzdGVuZXJzXG4gICAgXG4gICAgQG1lc3NhZ2UgIFRoZSBsb2cgbWVzc2FnZVxuICAgICAqL1xuICAgIGxvZ0Vycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgaWYgKHdpbi5jb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3aW4uY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5mbzogbG9nSW5mbyxcbiAgICAgIGVycm9yOiBsb2dFcnJvclxuICAgIH07XG4gIH0pKHdpbmRvdyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0WywgbGVuZ3RoXSknKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYSkgJiYgQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkKSA/IHNlbGYubGVuZ3RoIDogTnVtYmVyKGVuZClcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IHJlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IHJlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIGludFNpemUgPSA0O1xudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMCk7XG52YXIgY2hyc3ogPSA4O1xuXG5mdW5jdGlvbiB0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgemVyb0J1ZmZlcl0sIGxlbik7XG4gIH1cblxuICB2YXIgYXJyID0gW107XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi5yZWFkSW50MzJCRSA6IGJ1Zi5yZWFkSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUpIHtcbiAgICBhcnIucHVzaChmbi5jYWxsKGJ1ZiwgaSkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGFyciwgc2l6ZSwgYmlnRW5kaWFuKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYud3JpdGVJbnQzMkJFIDogYnVmLndyaXRlSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbi5jYWxsKGJ1ZiwgYXJyW2ldLCBpICogNCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gaGFzaChidWYsIGZuLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmKTtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pLCBidWYubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gdG9CdWZmZXIoYXJyLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGhhc2g6IGhhc2ggfTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbnZhciBzaGEgPSByZXF1aXJlKCcuL3NoYScpXG52YXIgc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIHJuZyA9IHJlcXVpcmUoJy4vcm5nJylcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpXG5cbnZhciBhbGdvcml0aG1zID0ge1xuICBzaGExOiBzaGEsXG4gIHNoYTI1Njogc2hhMjU2LFxuICBtZDU6IG1kNVxufVxuXG52YXIgYmxvY2tzaXplID0gNjRcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMClcbmZ1bmN0aW9uIGhtYWMoZm4sIGtleSwgZGF0YSkge1xuICBpZighQnVmZmVyLmlzQnVmZmVyKGtleSkpIGtleSA9IG5ldyBCdWZmZXIoa2V5KVxuICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuXG4gIGlmKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBmbihrZXkpXG4gIH0gZWxzZSBpZihrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCB6ZXJvQnVmZmVyXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSksIG9wYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdmFyIGhhc2ggPSBmbihCdWZmZXIuY29uY2F0KFtpcGFkLCBkYXRhXSkpXG4gIHJldHVybiBmbihCdWZmZXIuY29uY2F0KFtvcGFkLCBoYXNoXSkpXG59XG5cbmZ1bmN0aW9uIGhhc2goYWxnLCBrZXkpIHtcbiAgYWxnID0gYWxnIHx8ICdzaGExJ1xuICB2YXIgZm4gPSBhbGdvcml0aG1zW2FsZ11cbiAgdmFyIGJ1ZnMgPSBbXVxuICB2YXIgbGVuZ3RoID0gMFxuICBpZighZm4pIGVycm9yKCdhbGdvcml0aG06JywgYWxnLCAnaXMgbm90IHlldCBzdXBwb3J0ZWQnKVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG4gICAgICAgIFxuICAgICAgYnVmcy5wdXNoKGRhdGEpXG4gICAgICBsZW5ndGggKz0gZGF0YS5sZW5ndGhcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBkaWdlc3Q6IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZnMpXG4gICAgICB2YXIgciA9IGtleSA/IGhtYWMoZm4sIGtleSwgYnVmKSA6IGZuKGJ1ZilcbiAgICAgIGJ1ZnMgPSBudWxsXG4gICAgICByZXR1cm4gZW5jID8gci50b1N0cmluZyhlbmMpIDogclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlcnJvciAoKSB7XG4gIHZhciBtID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKVxuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgIG0sXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cDovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvY3J5cHRvLWJyb3dzZXJpZnknXG4gICAgXS5qb2luKCdcXG4nKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVIYXNoID0gZnVuY3Rpb24gKGFsZykgeyByZXR1cm4gaGFzaChhbGcpIH1cbmV4cG9ydHMuY3JlYXRlSG1hYyA9IGZ1bmN0aW9uIChhbGcsIGtleSkgeyByZXR1cm4gaGFzaChhbGcsIGtleSkgfVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKHNpemUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdW5kZWZpbmVkLCBuZXcgQnVmZmVyKHJuZyhzaXplKSkpXG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycikgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHJuZyhzaXplKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoKGEsIGYpIHtcbiAgZm9yKHZhciBpIGluIGEpXG4gICAgZihhW2ldLCBpKVxufVxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbmVhY2goWydjcmVhdGVDcmVkZW50aWFscydcbiwgJ2NyZWF0ZUNpcGhlcidcbiwgJ2NyZWF0ZUNpcGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURpZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuIiwiLypcclxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxyXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxyXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXHJcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcclxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXHJcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXHJcbiAqL1xyXG5cclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuXHJcbi8qXHJcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xyXG4gKi9cclxuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxyXG57XHJcbiAgcmV0dXJuIGhleF9tZDUoXCJhYmNcIikgPT0gXCI5MDAxNTA5ODNjZDI0ZmIwZDY5NjNmN2QyOGUxN2Y3MlwiO1xyXG59XHJcblxyXG4vKlxyXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3JlX21kNSh4LCBsZW4pXHJcbntcclxuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xyXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xyXG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcclxuXHJcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcclxuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XHJcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcclxuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcclxuICB7XHJcbiAgICB2YXIgb2xkYSA9IGE7XHJcbiAgICB2YXIgb2xkYiA9IGI7XHJcbiAgICB2YXIgb2xkYyA9IGM7XHJcbiAgICB2YXIgb2xkZCA9IGQ7XHJcblxyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xyXG5cclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xyXG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xyXG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xyXG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xyXG4gIH1cclxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XHJcblxyXG59XHJcblxyXG4vKlxyXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XHJcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxyXG57XHJcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcclxuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XHJcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cclxuICovXHJcbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXHJcbntcclxuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWQ1KGJ1Zikge1xyXG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX21kNSwgMTYpO1xyXG59O1xyXG4iLCIvLyBPcmlnaW5hbCBjb2RlIGFkYXB0ZWQgZnJvbSBSb2JlcnQgS2llZmZlci5cbi8vIGRldGFpbHMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIHZhciBtYXRoUk5HLCB3aGF0d2dSTkc7XG5cbiAgLy8gTk9URTogTWF0aC5yYW5kb20oKSBkb2VzIG5vdCBndWFyYW50ZWUgXCJjcnlwdG9ncmFwaGljIHF1YWxpdHlcIlxuICBtYXRoUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgcjtcblxuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgYnl0ZXNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgaWYgKF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB3aGF0d2dSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gd2hhdHdnUk5HIHx8IG1hdGhSTkc7XG5cbn0oKSlcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIFNIQS0xIG9mIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9zaGExKHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gIHhbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcblxuICB2YXIgdyA9IEFycmF5KDgwKTtcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG4gIHZhciBlID0gLTEwMDk1ODk3NzY7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIHZhciBvbGRlID0gZTtcblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGogPCAxNikgd1tqXSA9IHhbaSArIGpdO1xuICAgICAgZWxzZSB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTtcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gcm9sKGIsIDMwKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICAgIGUgPSBzYWZlX2FkZChlLCBvbGRlKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCwgZSk7XG5cbn1cblxuLypcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gKiBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxue1xuICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xuICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gIHJldHVybiBiIF4gYyBeIGQ7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9rdCh0KVxue1xuICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGExKGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9zaGExLCAyMCwgdHJ1ZSk7XG59O1xuIiwiXG4vKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxudmFyIHNhZmVfYWRkID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufTtcblxudmFyIFMgPSBmdW5jdGlvbihYLCBuKSB7XG4gIHJldHVybiAoWCA+Pj4gbikgfCAoWCA8PCAoMzIgLSBuKSk7XG59O1xuXG52YXIgUiA9IGZ1bmN0aW9uKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKTtcbn07XG5cbnZhciBDaCA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKCh+eCkgJiB6KSk7XG59O1xuXG52YXIgTWFqID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoeCAmIHopIF4gKHkgJiB6KSk7XG59O1xuXG52YXIgU2lnbWEwMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgMikgXiBTKHgsIDEzKSBeIFMoeCwgMjIpKTtcbn07XG5cbnZhciBTaWdtYTEyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCA2KSBeIFMoeCwgMTEpIF4gUyh4LCAyNSkpO1xufTtcblxudmFyIEdhbW1hMDI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDcpIF4gUyh4LCAxOCkgXiBSKHgsIDMpKTtcbn07XG5cbnZhciBHYW1tYTEyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCAxNykgXiBTKHgsIDE5KSBeIFIoeCwgMTApKTtcbn07XG5cbnZhciBjb3JlX3NoYTI1NiA9IGZ1bmN0aW9uKG0sIGwpIHtcbiAgdmFyIEsgPSBuZXcgQXJyYXkoMHg0MjhBMkY5OCwweDcxMzc0NDkxLDB4QjVDMEZCQ0YsMHhFOUI1REJBNSwweDM5NTZDMjVCLDB4NTlGMTExRjEsMHg5MjNGODJBNCwweEFCMUM1RUQ1LDB4RDgwN0FBOTgsMHgxMjgzNUIwMSwweDI0MzE4NUJFLDB4NTUwQzdEQzMsMHg3MkJFNUQ3NCwweDgwREVCMUZFLDB4OUJEQzA2QTcsMHhDMTlCRjE3NCwweEU0OUI2OUMxLDB4RUZCRTQ3ODYsMHhGQzE5REM2LDB4MjQwQ0ExQ0MsMHgyREU5MkM2RiwweDRBNzQ4NEFBLDB4NUNCMEE5REMsMHg3NkY5ODhEQSwweDk4M0U1MTUyLDB4QTgzMUM2NkQsMHhCMDAzMjdDOCwweEJGNTk3RkM3LDB4QzZFMDBCRjMsMHhENUE3OTE0NywweDZDQTYzNTEsMHgxNDI5Mjk2NywweDI3QjcwQTg1LDB4MkUxQjIxMzgsMHg0RDJDNkRGQywweDUzMzgwRDEzLDB4NjUwQTczNTQsMHg3NjZBMEFCQiwweDgxQzJDOTJFLDB4OTI3MjJDODUsMHhBMkJGRThBMSwweEE4MUE2NjRCLDB4QzI0QjhCNzAsMHhDNzZDNTFBMywweEQxOTJFODE5LDB4RDY5OTA2MjQsMHhGNDBFMzU4NSwweDEwNkFBMDcwLDB4MTlBNEMxMTYsMHgxRTM3NkMwOCwweDI3NDg3NzRDLDB4MzRCMEJDQjUsMHgzOTFDMENCMywweDRFRDhBQTRBLDB4NUI5Q0NBNEYsMHg2ODJFNkZGMywweDc0OEY4MkVFLDB4NzhBNTYzNkYsMHg4NEM4NzgxNCwweDhDQzcwMjA4LDB4OTBCRUZGRkEsMHhBNDUwNkNFQiwweEJFRjlBM0Y3LDB4QzY3MTc4RjIpO1xuICB2YXIgSEFTSCA9IG5ldyBBcnJheSgweDZBMDlFNjY3LCAweEJCNjdBRTg1LCAweDNDNkVGMzcyLCAweEE1NEZGNTNBLCAweDUxMEU1MjdGLCAweDlCMDU2ODhDLCAweDFGODNEOUFCLCAweDVCRTBDRDE5KTtcbiAgICB2YXIgVyA9IG5ldyBBcnJheSg2NCk7XG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGo7XG4gICAgdmFyIFQxLCBUMjtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgbVtsID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbCAlIDMyKTtcbiAgbVsoKGwgKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBhID0gSEFTSFswXTsgYiA9IEhBU0hbMV07IGMgPSBIQVNIWzJdOyBkID0gSEFTSFszXTsgZSA9IEhBU0hbNF07IGYgPSBIQVNIWzVdOyBnID0gSEFTSFs2XTsgaCA9IEhBU0hbN107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICBpZiAoaiA8IDE2KSB7XG4gICAgICAgIFdbal0gPSBtW2ogKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFdbal0gPSBzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChHYW1tYTEyNTYoV1tqIC0gMl0pLCBXW2ogLSA3XSksIEdhbW1hMDI1NihXW2ogLSAxNV0pKSwgV1tqIC0gMTZdKTtcbiAgICAgIH1cbiAgICAgIFQxID0gc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoaCwgU2lnbWExMjU2KGUpKSwgQ2goZSwgZiwgZykpLCBLW2pdKSwgV1tqXSk7XG4gICAgICBUMiA9IHNhZmVfYWRkKFNpZ21hMDI1NihhKSwgTWFqKGEsIGIsIGMpKTtcbiAgICAgIGggPSBnOyBnID0gZjsgZiA9IGU7IGUgPSBzYWZlX2FkZChkLCBUMSk7IGQgPSBjOyBjID0gYjsgYiA9IGE7IGEgPSBzYWZlX2FkZChUMSwgVDIpO1xuICAgIH1cbiAgICBIQVNIWzBdID0gc2FmZV9hZGQoYSwgSEFTSFswXSk7IEhBU0hbMV0gPSBzYWZlX2FkZChiLCBIQVNIWzFdKTsgSEFTSFsyXSA9IHNhZmVfYWRkKGMsIEhBU0hbMl0pOyBIQVNIWzNdID0gc2FmZV9hZGQoZCwgSEFTSFszXSk7XG4gICAgSEFTSFs0XSA9IHNhZmVfYWRkKGUsIEhBU0hbNF0pOyBIQVNIWzVdID0gc2FmZV9hZGQoZiwgSEFTSFs1XSk7IEhBU0hbNl0gPSBzYWZlX2FkZChnLCBIQVNIWzZdKTsgSEFTSFs3XSA9IHNhZmVfYWRkKGgsIEhBU0hbN10pO1xuICB9XG4gIHJldHVybiBIQVNIO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGEyNTYoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX3NoYTI1NiwgMzIsIHRydWUpO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIl19
