(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var $sf, Page, config, endpoint, utils;

  $sf = require('../node_modules/safeframe/lib/js/ext/ext')(true);

  utils = require('./shared/utils');

  endpoint = require('./controller/endpoint');

  Page = require('./shared/page');

  config = require('./shared/config');

  (function($sf, window) {
    var Controller, e, onUpdate, page, referrer, requests, setSessionInfo;
    Controller = {};
    referrer = document.referrer;
    page = null;
    requests = {};
    document.domain = config.domain;
    utils.defineProperty(Controller, "isController", {
      writeable: false,
      value: true,
      configurable: false
    });
    utils.defineProperty(Controller, "send", {
      writeable: false,
      value: function(request) {
        requests[request.id] = request;
        request.set(page.attributes, {
          silent: true
        });
        return endpoint.send(request);
      },
      configurable: false
    });
    utils.defineProperty(window, "$ad", {
      writeable: false,
      value: Controller,
      configurable: false
    });
    referrer = document.referrer;
    setSessionInfo = function(params) {
      return page.deserialize(params);
    };
    try {
      utils.defineProperty(document, "referrer", {
        get: function() {
          return "";
        }
      });
    } catch (_error) {
      e = _error;
    }
    onUpdate = function(status, data) {
      switch (status) {
        case "cookie-update":
          return setSessionInfo(unescape(data.value));
      }
    };
    $sf.ext.render(true);
    $sf.ext.register(0, 0, onUpdate);
    page = new Page($sf.ext.meta("page", "extended"));
    page.change(function() {
      return endpoint.send(page);
    });
    return endpoint.send(page, {
      global: true
    }, function() {
      var k, r, _i, _len, _results;
      _results = [];
      for (r = _i = 0, _len = requests.length; _i < _len; r = ++_i) {
        k = requests[r];
        _results.push(r.set(page.attributes, {
          silent: true
        }));
      }
      return _results;
    });
  })($sf, window);

}).call(this);

},{"../node_modules/safeframe/lib/js/ext/ext":12,"./controller/endpoint":2,"./shared/config":4,"./shared/page":5,"./shared/utils":6}],2:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var config, utils;

  config = require('../shared/config');

  utils = require('../shared/utils');

  module.exports = (function($sf) {
    var RETRY_TIMEOUT, endpoint, error, isTimeout, pendingRequests, postData, prefix, send, sendData, sendingRequests, success, timeoutValue;
    prefix = config.api;
    pendingRequests = {};
    sendingRequests = {};
    RETRY_TIMEOUT = 100;
    isTimeout = false;
    timeoutValue = null;
    send = function(obj, cb) {
      pendingRequests[obj.id] = [obj, cb];
      return postData();
    };
    success = function(obj, resp, cb) {
      obj.set(resp, {
        silent: true
      });
      delete sendingRequests[obj.id];
      return typeof cb === "function" ? cb(obj) : void 0;
    };
    error = function(obj, err, cb) {};
    sendData = function(params, obj, cb) {
      var requestParams;
      requestParams = {
        data: params,
        success: function(resp) {
          return success(obj, resp, cb);
        },
        error: function(err) {
          return error(obj, err, cb);
        }
      };
      if (prefix.indexOf(document.location.hostname) >= 0) {
        requestParams.method = "post";
        requestParams.url = obj.path;
      } else {
        requestParams.type = "jsonp";
        requestParams.url = prefix + obj.path;
      }
      return utils.sendRequest(requestParams);
    };
    postData = function() {
      var cb, id, k, obj, params, v, _ref, _ref1;
      for (id in pendingRequests) {
        _ref = pendingRequests[id], obj = _ref[0], cb = _ref[1];
        if (!sendingRequests[obj.id]) {
          delete pendingRequests[id];
          params = {};
          _ref1 = obj.changedFields();
          for (k in _ref1) {
            v = _ref1[k];
            params[k] = v;
          }
          sendingRequests[obj.id] = obj;
          sendData(params, obj, cb);
        }
      }
      if ($sf.lib.lang.keys(pendingRequests).length > 0 && !isTimeout) {
        isTimeout = true;
        return timeoutValue = setTimeout(function() {
          isTimeout = false;
          return postData();
        }, RETRY_TIMEOUT);
      }
    };
    endpoint = {
      send: send
    };
    if (process.env.ENV === "test") {
      endpoint.postData = postData;
      endpoint.sendData = sendData;
      endpoint.success = success;
      endpoint.error = error;
      endpoint.sendingRequests = sendingRequests;
      endpoint.pendingRequests = pendingRequests;
      endpoint.clear = function() {
        isTimeout = false;
        sendingRequests = {};
        pendingRequests = {};
        endpoint.sendingRequests = sendingRequests;
        endpoint.pendingRequests = pendingRequests;
        return clearTimeout(timeoutValue);
      };
    }
    return endpoint;
  })($sf);

}).call(this);

}).call(this,require("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"../shared/config":4,"../shared/utils":6,"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":27}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var utils, uuid;

  uuid = require('node-uuid');

  utils = require('./utils');

  module.exports = (function() {
    var Base;
    return Base = (function() {
      function Base() {
        this.id = uuid.v4();
        this.attributes || (this.attributes = {});
        this._events = [];
        this._dirty = {};
      }

      Base.prototype.set = function(attrs, options) {
        var changed, changedAttributes, f, k, v, _i, _len, _ref, _results;
        if (options == null) {
          options = {};
        }
        if (typeof attrs !== "object") {
          throw "attrs must be an object";
        }
        changed = false;
        changedAttributes = [];
        for (k in attrs) {
          v = attrs[k];
          if (this.attributes[k] !== v) {
            changedAttributes.push(k);
            this._dirty[k] = v;
            this.attributes[k] = v;
          }
        }
        if (!options.silent && changedAttributes.length > 0) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, [this, changedAttributes]));
          }
          return _results;
        }
      };

      Base.prototype.change = function(f) {
        var _i, _len, _ref, _results;
        if (f && typeof f === "function") {
          return this._events.push(f);
        } else if (!f) {
          _ref = this._events;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            _results.push(f.apply(this, arguments));
          }
          return _results;
        }
      };

      Base.prototype._cleanDirty = function() {
        return this._dirty = {};
      };

      Base.prototype.changedFields = function() {
        var field, k, params, v, _i, _len, _ref, _ref1;
        params = {};
        _ref = this._dirty;
        for (k in _ref) {
          v = _ref[k];
          params[k] = v;
        }
        _ref1 = this.constantFields;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          field = _ref1[_i];
          if (this.attributes[field]) {
            params[field] = this.attributes[field];
          }
        }
        this._cleanDirty();
        return params;
      };

      Base.prototype.serialize = function() {
        return utils.toQuery(this.attributes);
      };

      Base.prototype.deserialize = function(str) {
        return this.set(utils.fromQuery(str), {
          silent: true
        });
      };

      return Base;

    })();
  })();

}).call(this);

},{"./utils":6,"node-uuid":10}],4:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function() {
    if (process.env.ENV === "test") {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: 'base/lib/html/adjsframe.html',
        controller_url: "base/lib/html/controllerframe.html",
        visit_expiry: 0.03,
        version: "0.0.1",
        domain: "localhost"
      };
    } else if (process.env.ENV === "production") {
      return {
        api: "//api.adjs.net/1",
        cdn_url: "//cdn.adjs.net/html/adjsframe.html",
        visit_expiry: 30,
        version: "0.0.1",
        domain: "adjs.net",
        controller_url: "//cdn.adjs.net/html/controllerframe.html"
      };
    } else {
      return {
        api: '//endpoint.adjs.dev:8080/1',
        cdn_url: '../lib/html/adjsframe.html',
        visit_expiry: 3,
        version: "0.0.1",
        domain: "localhost",
        controller_url: "../lib/html/controllerframe.html"
      };
    }
  })();

}).call(this);

}).call(this,require("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":27}],5:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var Base, config, cookies, moment, utils, uuid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  cookies = require('cookies-js');

  uuid = require('node-uuid');

  Base = require('./base');

  utils = require('./utils');

  config = require('./config');

  moment = require('moment');

  module.exports = (function($sf, window) {
    var COOKIE_KEY, Page;
    COOKIE_KEY = "_ajsk";
    Page = (function(_super) {
      __extends(Page, _super);

      function Page(serializedParams) {
        Page.__super__.constructor.call(this);
        if (serializedParams) {
          this.deserialize(serializedParams);
        } else {
          this.loadCookieData();
          this.initDefaultAttributes();
        }
      }

      Page.prototype.storeCookie = function() {
        var _ref;
        if (($sf != null ? (_ref = $sf.ext) != null ? _ref.cookie : void 0 : void 0) != null) {
          if (this.attributes.site_user_id) {
            $sf.ext.cookie("" + COOKIE_KEY + "_suid", {
              value: this.attributes.site_user_id,
              expires: moment().add("years", 1).toDate()
            });
          }
          if (this.attributes.visit_id) {
            return $sf.ext.cookie("" + COOKIE_KEY + "_vid", {
              value: this.attributes.visit_id,
              expires: moment().add("seconds", config.visit_expiry * 60).toDate()
            });
          }
        } else {
          if (this.attributes.site_user_id) {
            cookies.set("" + COOKIE_KEY + "_suid", this.attributes.site_user_id, {
              expires: moment().add("years", 1).toDate()
            });
          }
          if (this.attributes.visit_id) {
            return cookies.set("" + COOKIE_KEY + "_vid", this.attributes.visit_id, {
              expires: moment().add("seconds", config.visit_expiry * 60).toDate()
            });
          }
        }
      };

      Page.prototype.loadCookieData = function() {
        var _ref;
        if (($sf != null ? (_ref = $sf.ext) != null ? _ref.cookie : void 0 : void 0) != null) {
          return this.set({
            site_user_id: $sf.ext.cookie("" + COOKIE_KEY + "_suid"),
            visit_id: $sf.ext.cookie("" + COOKIE_KEY + "_vid")
          }, {
            silent: true
          });
        } else {
          return this.set({
            site_user_id: cookies.get("" + COOKIE_KEY + "_suid"),
            visit_id: cookies.get("" + COOKIE_KEY + "_vid")
          }, {
            silent: true
          });
        }
      };

      Page.prototype.set = function(attrs, options) {
        if (options == null) {
          options = {};
        }
        Page.__super__.set.call(this, attrs, options);
        return this.storeCookie();
      };

      Page.prototype.initDefaultAttributes = function() {
        if (window === window.top) {
          return this.set({
            full_url: window.document.location.href,
            referrer: window.document.referrer
          }, {
            silent: true
          });
        } else if (window.parent === window.top) {
          return this.set({
            full_url: window.document.referrer
          });
        }
      };

      Page.prototype.verifyUrl = function() {
        if (window.parent === window.top && window.document.referrer) {
          return true;
        }
      };

      Page.prototype.path = "/page";

      Page.prototype.constantFields = ["site_user_id", "page_id", "visit_id", "full_url"];

      return Page;

    })(Base);
    Page.VISITOR_EXPIRY = config.visit_expiry;
    if (process.env.ENV === "test" || ((typeof _TEST !== "undefined" && _TEST !== null) && _TEST)) {
      Page._COOKIE_KEY = COOKIE_KEY;
      Page.clearCookie = function() {
        cookies.set(COOKIE_KEY + "_suid", void 0);
        return cookies.set(COOKIE_KEY + "_vid", void 0);
      };
    }
    return Page;
  })($sf, window);

}).call(this);

}).call(this,require("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./base":3,"./config":4,"./utils":6,"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":27,"cookies-js":7,"moment":9,"node-uuid":10}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var reqwest;

  window.JSON || (window.JSON = require('json'));

  reqwest = require('reqwest');

  window.JSON || (window.JSON = require('json'));

  module.exports = (function($sf) {
    var capitalizeString, countFrames, defineProperty, fromQuery, getFramePosition, keys, nativeReduce, now, reduce, reduceError, sendRequest, toNumber, toQuery;
    sendRequest = function(options) {
      return reqwest(options);
    };
    fromQuery = function(query, delim) {
      var item, key, params, value, _i, _len, _ref, _ref1;
      if (query == null) {
        query = "";
      }
      if (delim == null) {
        delim = "&";
      }
      params = {};
      _ref = query.split(delim);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _ref1 = item.split("="), key = _ref1[0], value = _ref1[1];
        params[key] = decodeURIComponent(value);
      }
      return params;
    };
    toQuery = function(attributes) {
      return reqwest.toQueryString(attributes);
    };
    toNumber = function(val) {
      return $sf != null ? $sf.lib.lang.cnum(val, 0) : void 0;
    };
    now = function() {
      return (new Date()).getTime();
    };
    defineProperty = function(obj, prop, descriptor) {
      var e;
      try {
        if ("defineProperty" in Object) {
          return Object.defineProperty(obj, prop, descriptor);
        } else if ("__defineGetter__" in obj) {
          if (descriptor.value) {
            obj.__defineGetter__(prop, function() {
              return descriptor.value;
            });
            if (descriptor.writable !== false) {
              return obj.__defineSetter__(prop, function(val) {
                return val[prop] = val;
              });
            }
          } else {
            if (descriptor.get != null) {
              obj.__defineGetter__(prop, descriptor.get);
            }
            if (descriptor.set != null) {
              return obj.__defineSetter__(prop, descriptor.set);
            }
          }
        } else {
          if (descriptor.value) {
            return obj[prop] = descriptor.value;
          }
        }
      } catch (_error) {
        e = _error;
      }
    };
    countFrames = function(win) {
      var count, frame, _i, _len, _ref;
      count = win.frames.length;
      _ref = win.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame !== win) {
          count += countFrames(frame);
        }
      }
      return count;
    };
    getFramePosition = function(win) {
      var count;
      count = 0;
      if (win.parent !== win.top) {
        count = 1 + getFramePosition(win.parent);
      }
      return count;
    };
    nativeReduce = Array.prototype.reduce;
    reduceError = 'Reduce of empty array with no initial value';
    reduce = function(obj, iterator, memo, context) {
      var index, initial, value, _fn, _i, _len;
      initial = arguments.length > 2;
      if (obj == null) {
        obj = [];
      }
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) {
          iterator = _.bind(iterator, context);
        }
        return (initial ? obj.reduce(iterator, memo) : obj.reduce(iterator));
      }
      _fn = function(value, index, obj) {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, obj);
        }
      };
      for (index = _i = 0, _len = obj.length; _i < _len; index = ++_i) {
        value = obj[index];
        _fn(value, index, obj);
      }
      if (!initial) {
        throw new TypeError(reduceError);
      }
      return memo;
    };
    keys = function(obj) {
      return $sf != null ? $sf.lib.lang.keys(obj) : void 0;
    };
    capitalizeString = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    return {
      sendRequest: sendRequest,
      toQuery: toQuery,
      fromQuery: fromQuery,
      toNumber: toNumber,
      now: now,
      defineProperty: defineProperty,
      countFrames: countFrames,
      capitalizeString: capitalizeString,
      keys: keys,
      getFramePosition: getFramePosition,
      reduce: reduce
    };
  })($sf);

}).call(this);

},{"json":8,"reqwest":11}],7:[function(require,module,exports){
/*!
 * Cookies.js - 0.3.1
 * Wednesday, April 24 2013 @ 2:28 AM EST
 *
 * Copyright (c) 2013, Scott Hamper
 * Licensed under the MIT license,
 * http://www.opensource.org/licenses/MIT
 */
(function (undefined) {
    'use strict';

    var Cookies = function (key, value, options) {
        return arguments.length === 1 ?
            Cookies.get(key) : Cookies.set(key, value, options);
    };

    // Allows for setter injection in unit tests
    Cookies._document = document;
    Cookies._navigator = navigator;

    Cookies.defaults = {
        path: '/'
    };

    Cookies.get = function (key) {
        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
            Cookies._renewCache();
        }

        return Cookies._cache[key];
    };

    Cookies.set = function (key, value, options) {
        options = Cookies._getExtendedOptions(options);
        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

        return Cookies;
    };

    Cookies.expire = function (key, options) {
        return Cookies.set(key, undefined, options);
    };

    Cookies._getExtendedOptions = function (options) {
        return {
            path: options && options.path || Cookies.defaults.path,
            domain: options && options.domain || Cookies.defaults.domain,
            expires: options && options.expires || Cookies.defaults.expires,
            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
        };
    };

    Cookies._isValidDate = function (date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    };

    Cookies._getExpiresDate = function (expires, now) {
        now = now || new Date();
        switch (typeof expires) {
            case 'number': expires = new Date(now.getTime() + expires * 1000); break;
            case 'string': expires = new Date(expires); break;
        }

        if (expires && !Cookies._isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    };

    Cookies._generateCookieString = function (key, value, options) {
        key = encodeURIComponent(key);
        value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toGMTString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    };

    Cookies._getCookieObjectFromString = function (documentCookie) {
        var cookieObject = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieObject[cookieKvp.key] === undefined) {
                cookieObject[cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieObject;
    };

    Cookies._getKeyValuePairFromCookieString = function (cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        return {
            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
        };
    };

    Cookies._renewCache = function () {
        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);
        Cookies._cachedDocumentCookie = Cookies._document.cookie;
    };

    Cookies._areEnabled = function () {
        return Cookies._navigator.cookieEnabled ||
            Cookies.set('cookies.js', 1).get('cookies.js') === '1';
    };

    Cookies.enabled = Cookies._areEnabled();

    // AMD support
    if (typeof define === 'function' && define.amd) {
        define(function () { return Cookies; });
    // CommonJS and Node.js module support.
    } else if (typeof exports !== 'undefined') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Cookies;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = Cookies;
    } else {
        window.Cookies = Cookies;
    }
})();
},{}],8:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    var global = Function('return this')()
      , JSON = global.JSON
      ;

    if (!JSON) {
      JSON = {};
    }

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }

    global.JSON = JSON;
    module.exports = JSON;
}());

},{}],9:[function(require,module,exports){
(function (global){
//! moment.js
//! version : 2.7.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.7.0",
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _tzm : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
          s: 45,   //seconds to minutes
          m: 45,   //minutes to hours
          h: 22,   //hours to days
          dd: 25,  //days to month (month == 1)
          dm: 45,  //days to months (months > 1)
          dy: 345  //days to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error("Implement me");
        }
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = getLangDefinition(config._l).weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, lang;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            lang = getLangDefinition(config._l);
            dow = lang._week.dow;
            doy = lang._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < relativeTimeThresholds.s  && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= relativeTimeThresholds.dd && ['dd', days] ||
                days <= relativeTimeThresholds.dm && ['M'] ||
                days < relativeTimeThresholds.dy && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
        config._d = new Date(config._i);
    });

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function(threshold, limit) {
      if (relativeTimeThresholds[threshold] === undefined) {
        return false;
      }
      relativeTimeThresholds[threshold] = limit;
      return true;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string' && typeof val === 'string') {
                dur = moment.duration(isNaN(+val) ? +input : +val, isNaN(+val) ? val : input);
            } else if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string' && typeof val === 'string') {
                dur = moment.duration(isNaN(+val) ? +input : +val, isNaN(+val) ? val : input);
            } else if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: deprecate(
                 "moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                "moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LANGUAGES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    "Accessing Moment through the global scope is " +
                    "deprecated, and will be removed in an upcoming " +
                    "release.",
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
(function (Buffer){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

}).call(this,require("buffer").Buffer)
},{"buffer":18,"crypto":22}],11:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , twoHundo = /^(20\d|1223)$/
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (twoHundo.test(r.request.status)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType]) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        self.abort()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || setType(resp.getResponseHeader('Content-Type'))
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
@fileOverview This file contains JavaScript code that handles the HTML document where HTML is rendered for a SafeFrame, as well as defining the External Vendor/Client API.
@author <a href="mailto:ssnider@yahoo-inc.com">Sean Snider</a>
@author <a href="mailto:ccole[AT]emination.com">Chris Cole</a>
@version 1.0.3
 */


/*
@namespace $sf.ext The external vendor / client API for functionality inside a SafeFrame
@name $sf.ext
 */


/*
@ignore
 */

(function() {
  var sf;

  sf = require("../shared/base");

  module.exports = function(isExternal) {
    return (function(window, sf) {
      var COLLAPSE_COMMAND, DG, DOM_WATCH_INTERVAL, DP, DS, ERROR_COMMAND, EXPAND_COMMAND, GUID_VALID_TIME, IE_ATTACH, IE_DETACH, LOAD, MAX_MSG_WAIT_TIME, MSG, NOTIFY_CLICKED, NOTIFY_COLLAPSE, NOTIFY_COLLAPSED, NOTIFY_EXPAND, NOTIFY_FAILURE, NOTIFY_FOCUS_CHANGE, NOTIFY_GEOM_UPDATE, NOTIFY_LOADED, NOTIFY_READ_COOKIE, NOTIFY_RELOAD, NOTIFY_REQUESTED, NOTIFY_UNVIEWED, NOTIFY_VIEWED, NOTIFY_WRITE_COOKIE, OBJ, ONLOAD, ONMSG, ONUNLOAD, ON_STR, OUR_TAG_CLS_NAME, ParamHash, STATUS_COLLAPSED, STATUS_COLLAPSING, STATUS_EXPANDED, STATUS_EXPANDING, TOLOWERCASE, UNLOAD, W3C_ATTACH, W3C_DETACH, adShown, can_use_html5, click, cmdRetries, collapse, cookie, d, deleteMeta, dom, env, err_msg_timer_id, err_msgs, expand, force_collapse, frame_id, geom, geom_info, guid, hasLoaded, host_cname, ie_old_attach, ie_old_detach, iframes, inViewPercentage, init_height, init_width, inline_handler_timer_id, isAdShown, isIE, is_expanded, is_registered, lang, lib, loaded, message, messageQueue, meta, msgclient_fb, originalWrite, orphan_timer_id, par, pending_msg, pos_id, pos_meta, register, reload, render, render_conf, render_params, sandbox_cb, showAd, status, supports, unload_handlers, unviewed, viewed, w3c_old_attach, w3c_old_detach, win, winHasFocus, win_has_focus, _append, _attach, _attach_override, _attr, _call_client_fb, _call_raw_evt_func, _check_orphaned, _cnum, _collapse, _construction, _create_stylesheet, _cstr, _destruction, _detach, _detach_override, _detect_bad_iframe, _elt, _fire_sandbox_callback, _handle_err, _handle_load, _handle_msg, _handle_unload, _nuke_doc, _purge, _reattach_messaging, _receive_msg, _render, _report_errs, _requested, _reset_inline_handlers, _send_cmd, _send_msg, _set_alignment, _set_hyperlink_targets, _setup_win_evt_props, _shiftMessageQueue, _tags, _ue, _wrapiFrame;
      win = window;
      LOAD = "load";
      ON_STR = "on";
      MSG = "message";
      UNLOAD = "un" + LOAD;
      ONUNLOAD = ON_STR + UNLOAD;
      ONMSG = ON_STR + MSG;
      ONLOAD = ON_STR + LOAD;
      DG = "__defineGetter__";
      DS = "__defineSetter__";
      DP = "__defineProperty__";
      W3C_ATTACH = "addEventListener";
      W3C_DETACH = "removeEventListener";
      IE_ATTACH = "attachEvent";
      IE_DETACH = "detachEvent";
      TOLOWERCASE = "toLowerCase";
      EXPAND_COMMAND = "exp-ovr";
      COLLAPSE_COMMAND = "collapse";
      ERROR_COMMAND = "error";
      NOTIFY_GEOM_UPDATE = "geom-update";
      NOTIFY_EXPAND = "expand";
      NOTIFY_FOCUS_CHANGE = "focus-change";
      NOTIFY_COLLAPSE = COLLAPSE_COMMAND;
      NOTIFY_COLLAPSED = NOTIFY_COLLAPSE + "d";
      NOTIFY_FAILURE = "failed";
      NOTIFY_READ_COOKIE = "read-cookie";
      NOTIFY_WRITE_COOKIE = "write-cookie";
      NOTIFY_CLICKED = "clicked";
      NOTIFY_VIEWED = "viewed";
      NOTIFY_UNVIEWED = "unviewed";
      NOTIFY_LOADED = "loaded";
      NOTIFY_REQUESTED = "requested";
      NOTIFY_RELOAD = "reload";
      STATUS_COLLAPSED = NOTIFY_COLLAPSED;
      STATUS_EXPANDED = NOTIFY_EXPAND + "ed";
      STATUS_COLLAPSING = "collapsing";
      STATUS_EXPANDING = NOTIFY_EXPAND + "ing";
      OUR_TAG_CLS_NAME = "sf";
      MAX_MSG_WAIT_TIME = 4000;
      DOM_WATCH_INTERVAL = 3000;
      GUID_VALID_TIME = 30000;
      OBJ = "object";
      d = win && win.document;
      par = win && win.parent;
      lib = sf.lib;
      env = sf.env;
      lang = lib.lang;
      ParamHash = lang.ParamHash;
      dom = lib.dom;
      iframes = dom.iframes;
      msgclient_fb = dom.msgclient_fb;
      isIE = env.isIE;
      _ue = win.unescape;
      _cstr = lang.cstr;
      _cnum = lang.cnum;
      _append = dom.append;
      _tags = dom.tags;
      _elt = dom && dom.elt;
      _purge = dom && dom.purge;
      _attach = dom && dom.attach;
      _detach = dom && dom.detach;
      _attr = dom && dom.attr;
      hasLoaded = false;
      is_expanded = false;
      force_collapse = false;
      is_registered = false;
      init_width = 0;
      init_height = 0;
      sandbox_cb = null;
      pending_msg = null;
      messageQueue = [];
      geom_info = null;
      pos_meta = null;
      win_has_focus = false;
      guid = "";
      host_cname = "";
      can_use_html5 = false;
      frame_id = "";
      pos_id = "";
      err_msg_timer_id = 0;
      orphan_timer_id = 0;
      inline_handler_timer_id = 0;
      err_msgs = [];
      unload_handlers = [];
      render_params = void 0;
      render_conf = void 0;
      ie_old_attach = void 0;
      w3c_old_attach = void 0;
      ie_old_detach = void 0;
      w3c_old_detach = void 0;
      isAdShown = false;

      /*
      Creates and appends a style sheet for any custom CSS passed
      
      @name $sf.ext-_create_stylesheet
      @function
      @static
      @private
      @param {String} cssText A string of CSS rules, or a URL string
      @param {String} [id] The id attribute of the tag created and appended
       */
      _create_stylesheet = function(cssText, id) {
        var e, oHead, oSS, oTxt;
        oHead = void 0;
        oSS = void 0;
        oTxt = void 0;
        e = void 0;
        try {
          oHead = _tags("head")[0];
          if (cssText.search(/\{[^\}]*}/g) === -1) {
            oSS = dom.make("link");
            oSS.type = "text/css";
            oSS.rel = "stylesheet";
            oSS.href = cssText;
          } else {
            oSS = dom.make("style");
            oSS.type = "text/css";
            if (isIE) {
              oSS.styleSheet.cssText = cssText;
            } else {
              oTxt = d.createTextNode(cssText);
              _append(oSS, oTxt);
            }
          }
          if (id) {
            oSS.id = id;
          }
          _append(oHead, oSS);
        } catch (_error) {}
      };

      /*
      Fires of unload event handlers and performs the necessary clean up when a SafeFrame is destroyed
      
      @name $sf.ext-_destruction
      @function
      @static
      @private
      @param {HTMLEvent} [evt] The raw dom event object if it exists
       */
      _destruction = function(evt) {
        var e, grand_par, handler, success, w;
        handler = void 0;
        w = window;
        success = 1;
        e = void 0;
        try {
          evt = evt || w.event || {};
        } catch (_error) {
          e = _error;
          evt = {
            type: UNLOAD
          };
        }
        while (handler = unload_handlers.shift()) {
          try {
            handler(evt);
          } catch (_error) {}
        }
        try {
          if (ie_old_attach) {
            w[IE_ATTACH] = ie_old_attach;
            w[IE_DETACH] = ie_old_detach;
          }
        } catch (_error) {}
        try {
          if (w3c_old_attach) {
            w[W3C_ATTACH] = w3c_old_attach;
            w[W3C_DETACH] = w3c_old_detach;
          }
        } catch (_error) {}
        if (!hasLoaded) {
          _detach(w, LOAD, _handle_load);
        }
        _detach(w, UNLOAD, _handle_unload);
        try {
          w.onerror = null;
        } catch (_error) {}
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (orphan_timer_id) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        w = ie_old_attach = w3c_old_attach = ie_old_detach = w3c_old_detach = d = _ue = par = handler = grand_par = null;
        return success;
      };

      /*
      Maintains that the window.onmessage property remains unset.
      We don't want content in our document listening to HTML5 messages.
      We override attaching to listeners below to maintain that functionality,
      however IE won't let you override properties directly hangning off of the
      window object, so we have a timer as a fallback for that purpose
      
      @name $sf.ext-_reset_inline_handlers
      @function
      @static
      @private
       */
      _reset_inline_handlers = function() {
        var e;
        e = void 0;
        try {
          if (inline_handler_timer_id) {
            clearTimeout(inline_handler_timer_id);
            inline_handler_timer_id = 0;
          }
        } catch (_error) {}
        try {
          if (isIE && win.onmessage) {
            win.onmessage = null;
          }
        } catch (_error) {}
        try {
          win.onerror = _handle_err;
        } catch (_error) {}
        inline_handler_timer_id = setTimeout(_reset_inline_handlers, DOM_WATCH_INTERVAL);
      };

      /*
      Clears out the HTML document (which will force an unload event as well).
      
      @name $sf.ext-_nuke_doc
      @function
      @static
      @private
       */
      _nuke_doc = function() {
        var e;
        e = void 0;
        try {
          document.open("text/html", "replace");
          document.write("");
          document.close();
        } catch (_error) {}
      };

      /*
      Iteratively checks to see if the IFRAME HTML document is no longer
      attached to the main dom, doing this by checking that our internal
      window reference is still valid. . .as well as running the checks to make
      sure invalid iframes (iframes from origin) are not created.
      
      If we detect that the IFRAME has been removed from the main dom of the
      publisher, then we call to destroy the HTML document, forcing onunload
      event and subsquent cleanup
      
      @name $sf.ext-_check_orphaned
      @function
      @static
      @private
       */
      _check_orphaned = function() {
        var e, is_orphaned;
        is_orphaned = false;
        e = void 0;
        _detect_bad_iframe();
        if (!isIE) {
          return;
        }
        try {
          if (orphan_timer_id && orphan_timer_id !== -1) {
            clearTimeout(orphan_timer_id);
            orphan_timer_id = 0;
          }
        } catch (_error) {}
        try {
          is_orphaned = win === top && orphan_timer_id !== -1;
        } catch (_error) {
          e = _error;
          is_orphaned = false;
        }
        if (is_orphaned) {
          orphan_timer_id = -1;
          _destruction();
          _nuke_doc();
          return;
        }
        try {
          if (!orphan_timer_id) {
            orphan_timer_id = setTimeout(_check_orphaned, DOM_WATCH_INTERVAL);
          }
        } catch (_error) {}
      };

      /*
      Detect whether or not an IFRAME tag has been inserted into the DOM that has the same
      origin / cname as the publisher, which should not be allowed as it's a security issue
      If said IFRAME tag(s) are found, remove them.
      
      @name $sf.ext-_detect_bad_iframe
      @function
      @static
      @private
       */
      _detect_bad_iframe = function() {
        var idx, srcHost, tag, written;
        iframes = _tags("iframe");
        idx = 0;
        srcHost = "";
        written = false;
        tag = void 0;
        if (host_cname) {
          while (tag = iframes[idx++]) {
            srcHost = _attr(tag, "src");
            srcHost = (srcHost && srcHost.length >= 9 ? srcHost.substring(0, srcHost.indexOf("/", 9))[TOLOWERCASE]() : "");
            if (srcHost && srcHost === host_cname && tag.className !== OUR_TAG_CLS_NAME) {
              try {
                _purge(tag);
              } catch (_error) {}
            }
          }
        }
      };

      /*
      Make sure that all hyperlinks in the document are set with the property "target" attribute
      such that links will navigate to the right window properly.
      
      @name $sf.ext-_set_hyperlink_targets
      @function
      @static
      @private
       */
      _set_hyperlink_targets = function() {
        var atgt, idx, ln, lns, ttgt;
        idx = 0;
        ttgt = (render_conf && render_conf.tgt) || "_top";
        ln = void 0;
        atgt = void 0;
        lns = void 0;
        lns = _tags("a");
        if (ttgt === "_self") {
          ttgt = "_top";
        }
        while (ln = lns[idx++]) {
          atgt = _attr(ln, "target");
          if (atgt !== ttgt) {
            _attr(ln, "target", ttgt);
          }
          if (idx > 10) {
            break;
          }
        }
      };

      /*
      Handle the onunload event from the HTML document of the IFRAME, which in turn will trigger clean up
      
      @name $sf.ext-_handle_unload
      @function
      @static
      @private
      @param {HTMLEvent} evt The raw DOM event object
       */
      _handle_unload = function(evt) {
        _destruction(evt);
        _nuke_doc();
      };

      /*
      Handle the load event from the HTML document of the IFRAME, which will also setup
      to make sure link targets are set properly
      
      @name $sf.ext-_handle_load
      @function
      @static
      @private
       */
      _handle_load = function() {
        if (loaded) {
          return;
        }
        hasLoaded = true;
        _detach(win, LOAD, _handle_load);
        _set_hyperlink_targets();
      };

      /*
      Handle onmessage HTML5 x-domain events. We always cancel the event
      never allowing it to go to other listeners besides our own, as we don't allow HTML5 messaging
      beyond us and the publisher / host.
      
      @name $sf.ext-_handle_msg
      @function
      @static
      @private
       */
      _handle_msg = function(evt) {
        var e, msg_guid, msg_obj, msg_params, org, src, str;
        str = void 0;
        src = void 0;
        org = void 0;
        e = void 0;
        msg_params = void 0;
        msg_guid = void 0;
        msg_obj = void 0;

        /*
        TODO, also validate origin
         */
        try {
          str = evt.data;
          src = evt.source;
          org = evt.origin;
        } catch (_error) {}
        dom.evtCncl(evt);
        if (str && src && src === top) {
          msg_params = ParamHash(str, null, null, true, true);
          msg_guid = msg_params.guid;
          msg_obj = msg_params.msg;
          if (guid === msg_guid && msg_obj && typeof msg_obj === OBJ) {
            try {
              setTimeout((function() {
                _receive_msg(msg_obj, evt);
                msg_params = evt = msg_guid = msg_obj = null;
              }), 1);
            } catch (_error) {}
          }
        }
      };

      /*
      This SafeFrames implementation internally handles all event attachment to maintain that the listener order
      for events that it cares about (onload, onunload, onbeforeunload, onmessage).
      This is done to make sure that proper clean up and intialization happens, as well as to enforce
      security.
      
      For events that it SafeFrames does not care about we allow the attachment listeners
      to proceed as normal, so we call the raw attachEvent / addEventListener functions.
      
      @name $sf.ext-_call_raw_evt_func
      @function
      @static
      @private
      @param {String} type The name of the event for which to attach/detach a listener
      @param {Function} f The callback function to use as a listener for said event
      @param {Boolean} [remove] If set to true, remove/detach this function as a listener, otherwise add
       */
      _call_raw_evt_func = function(type, f, remove) {
        var bOK, e, ie_f, w3c_f;
        bOK = false;
        ie_f = void 0;
        w3c_f = void 0;
        e = void 0;
        if (remove) {
          ie_f = ie_old_detach || w3c_old_detach;
          w3c_f = w3c_old_detach;
        } else {
          ie_f = ie_old_attach || w3c_old_attach;
          w3c_f = w3c_old_attach;
        }
        if (ie_f) {
          try {
            ie_f(type, f);
            bOK = true;
          } catch (_error) {
            e = _error;
            bOK = false;
          }
          if (!bOK) {
            try {
              ie_f.call(win, type, f);
              bOK = true;
            } catch (_error) {
              e = _error;
              bOK = false;
            }
          }
        }
        if (w3c_f && !bOK) {
          try {
            w3c_f.call(win, type, f, false);
          } catch (_error) {}
        }
      };

      /*
      Override default event attachment, and send load, beforeunload, and unload handlers into our
      own ques, so that we can enforce the proper firing order.  if message event is passed in,
      we do not allow attachment, since we do not want n-party code listening to HTML5 messages
      
      @name $sf.ext-_attach_override
      @function
      @static
      @private
      @param {String} type the event name to listen too
      @param {Function} f The function to be called whenever the event fires
       */
      _attach_override = function(type, f) {
        var bDoDefault;
        bDoDefault = false;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            unload_handlers.push(f);
            break;
          case MSG:
          case ONMSG:
            true;
            break;
          default:
            bDoDefault = true;
        }
        if (bDoDefault) {
          _call_raw_evt_func(type, f);
        }
      };

      /*
      Override default event detachment, and remove load, beforeunload, and unload handlers
      from our own que.  if message event is passed in, we do nothing (since we don't alllow
      attachment either).  If not one of those event types, then we call the default event detachment
      
      @name $sf.ext-_detach_override
      @function
      @static
      @private
      @param {String} type the event name to unlisten too
      @param {Function} f The function to no longer be called for the specific event
       */
      _detach_override = function(type, f) {
        var handler, handlers, idx;
        idx = 0;
        handler = void 0;
        handlers = void 0;
        type = _cstr(type)[TOLOWERCASE]();
        switch (type) {
          case UNLOAD:
          case ONUNLOAD:
            handlers = unload_handlers;
            break;
          case MSG:
          case ONMSG:
            true;
        }
        if (handlers != null ? handlers.length : void 0) {
          while (handler = handlers[idx]) {
            if (handler === f) {
              handlers.splice(idx, 1);
              break;
            }
            idx++;
          }
        } else {

        }
        _call_raw_evt_func(type, f, true);
      };

      /*
      Report any internal uncaught JavaScript errors up to the publisher / host
      
      @name $sf.ext-_report_errs
      @static
      @function
      @private
       */
      _report_errs = function() {
        var cmd_str, e, errs;
        e = void 0;
        errs = void 0;
        try {
          if (err_msgs.length > 0) {
            errs = err_msgs[0];
            cmd_str = ["cmd=", ERROR_COMMAND, "&pos=", pos_id, "&errors=", errs];
            _send_msg(_cstr(cmd_str), ERROR_COMMAND);
          }
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
        } catch (_error) {}
        err_msgs = [];
      };

      /*
      Handle any uncaught JavaScript errors
      
      @name $sf.ext-_handle_err
      @static
      @function
      @private
      @param {String} a The the error message / description string
      @param {String} b The URL / file that the JavaScript error occured within
      @param {Number} c The line number that the error occured on. . .
       */
      _handle_err = function(a, b, c) {
        var e;
        e = void 0;
        err_msgs.push(_cstr(["Error occurred inside SafeFrame:\nMessage: ", a, "\nURL:", b, "\nLine:", c]));
        try {
          if (err_msg_timer_id) {
            clearTimeout(err_msg_timer_id);
            err_msg_timer_id = 0;
          }
          err_msg_timer_id = setTimeout(_report_errs, DOM_WATCH_INTERVAL);
        } catch (_error) {}
        return true;
      };

      /*
      Override native window methods and properties so that we can control
      how the events that we need to manage
      
      @name $sf.ext-_setup_win_evt_props
      @static
      @function
      @private
      @param {Object} obj The window object / prototype
       */
      _setup_win_evt_props = function(obj) {
        var O, e, n, nobj, ret;
        n = lang.noop;
        O = Object;
        nobj = {
          get: n,
          set: n
        };
        ret = false;
        if (obj) {
          if (ie_old_attach) {
            obj[IE_ATTACH] = _attach_override;
            obj[IE_DETACH] = _detach_override;
          }
          if (w3c_old_attach) {
            obj[W3C_ATTACH] = _attach_override;
            obj[W3C_DETACH] = _detach_override;
          }
          if (obj[DG]) {
            try {
              obj[DG](ONLOAD, n);
              obj[DS](ONLOAD, n);
              obj[DG](ONUNLOAD, n);
              obj[DS](ONUNLOAD, n);
              obj[DG](ONMSG, n);
              obj[DS](ONMSG, n);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
          if (!ret && O[DP]) {
            try {
              O[DP](obj, ONLOAD, nobj);
              O[DP](obj, ONUNLOAD, nobj);
              O[DP](obj, ONMSG, nobg);
              ret = true;
            } catch (_error) {
              e = _error;
              ret = false;
            }
          }
        }
        return ret;
      };

      /*
      Intialize / setup the safeframe, the environment according to the configuration found within the serialized
      window.name property.
      
      @name $sf.ext-_construction
      @param {Object} [details] An optional object to pass in status / error information into
      @static
      @private
      @function
       */
      _construction = function(details) {
        var cont, cur_time, e, el, guid_time, nm, ret, temp, time_delta;
        cont = false;
        ret = true;
        el = void 0;
        nm = void 0;
        temp = void 0;
        cur_time = void 0;
        guid_time = void 0;
        time_delta = void 0;
        e = void 0;
        details = (details && (details instanceof Object) ? details : {});
        try {
          nm = win.name;
        } catch (_error) {}
        try {
          win.name = "";
        } catch (_error) {}
        if (!nm) {
          details.status = 500.101;
          return cont;
        }
        try {
          if (top === par) {
            render_params = ParamHash(nm, null, null, true, true);
            cur_time = lang.time();
            guid = render_params.guid;
            guid_time = _cnum(guid.replace(/[^_]*_(\d+)_\d+_\d+/g, "$1"), 0);
            time_delta = cur_time - guid_time;
            cont = guid && guid_time && time_delta > 0 && time_delta < GUID_VALID_TIME;
            if (render_params.loc) {
              render_params.loc = unescape(render_params.loc);
            }
            if (!cont) {
              details.status = 500.104;
            }
          } else {
            details.status = 500.102;
          }
        } catch (_error) {
          e = _error;
          render_params = guid = null;
          cont = false;
          details.status = 500.103;
        }
        if (cont) {
          try {
            render_conf = render_params.conf;
            frame_id = win.name = render_conf.dest;
            pos_id = render_conf.id;
            pos_meta = render_params.meta;
            host_cname = render_params.host;
            geom_info = render_params.geom;
            can_use_html5 = lang.cbool(render_params.html5);
            win_has_focus = lang.cbool(render_params.has_focus);
            temp = render_conf.bg;
            if (geom_info) {
              geom_info = ParamHash(_ue(geom_info), null, null, true, true);
              if (!geom_info.self || !geom_info.exp) {
                geom_info = null;
              }
            }
            if (!host_cname) {
              host_cname = d.referrer;
              host_cname = host_cname.substring(0, host_cname.indexOf("/", 9));
            }
            if (temp) {
              _create_stylesheet(_cstr(["#sf_body { background-color: ", temp, "; }"]), "sf_bg_css");
            }
            temp = render_conf.tgt;
            if (temp === "_self") {
              render_conf.tgt = "_top";
            }
            if (!temp) {
              render_conf.tgt = "_top";
            }
            if (temp !== "_top") {
              while (_purge(_tags("base")[0])) {
                true;
              }
            }
            el = dom.make("base");
            _attr(el, "target", temp);
            _append(_tags("head")[0], el);
            if (isIE) {
              ie_old_attach = win[IE_ATTACH];
              ie_old_detach = win[IE_DETACH];
            }
            w3c_old_attach = win[W3C_ATTACH];
            w3c_old_detach = win[W3C_DETACH];
            _attach(win, UNLOAD, _handle_unload);
            _attach(win, LOAD, _handle_load);
            _attach(win, MSG, _handle_msg);
            _setup_win_evt_props(win);
            _setup_win_evt_props(win.__proto__);
            _setup_win_evt_props(win.Window && win.Window.prototype);
          } catch (_error) {
            e = _error;
            details.status = 500.105;
            render_params = render_conf = guid = null;
            ret = false;
          }
        } else {
          render_params = guid = null;
          ret = false;
        }
        return ret;
      };
      _wrapiFrame = function(html, cbName) {
        return "<iframe style=\"width:100%;height:100%;\" allowtransparency=\"true\"\nscrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" onload='" + cbName + "()'>\n<html><head><base target=\"_top\"></head><body style=\"margin: 0; padding: 0\">\n<script>\n  $ad = window.parent.$ad\n  $sf = window.parent.$sf\n</script>\n  " + html + "\n</html>\n</iframe>";
      };
      originalWrite = document.write;

      /*
      Render the HTML and CSS content passed in through the window.name message via a document.write
      
      @name $sf.ext-_render
      @function
      @static
      @private
       */
      _render = function(callback) {
        var cbName, css, e, html, otherCallbackApplied;
        if (callback == null) {
          callback = function() {};
        }
        cbName = lib.lang.guid("load_cb");
        otherCallbackApplied = false;
        window[cbName] = function(fromFrame) {
          return (sf.lib.lang.wrap(callback, function() {
            if (fromFrame || !otherCallbackApplied) {
              callback.apply(sf, arguments);
              _handle_load();
              loaded();
              document.write = originalWrite;
              return delete window[cbName];
            }
          }))();
        };
        document.write = function(str) {
          var domElem, iframe, oldOnload, _i, _len, _ref;
          if (!(hasLoaded || otherCallbackApplied)) {
            domElem = document.createElement("div");
            domElem.innerHTML = "_" + str;
            _ref = domElem.getElementsByTagName("iframe");
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              iframe = _ref[_i];
              if (_cnum(_attr(iframe, "width"), 0) > 1) {
                otherCallbackApplied = true;
                if (oldOnload = _attr(iframe, "onload")) {
                  _attr(iframe, "onload", "" + cbName + "(true);" + oldOnload + ";");
                } else {
                  _attr(iframe, "onload", "" + cbName + "(true);");
                }
                break;
              }
            }
            if (otherCallbackApplied) {
              str = domElem.innerHTML.substring(1);
            }
          }
          return originalWrite.call(this, str);
        };
        html = void 0;
        css = void 0;
        isAdShown = true;
        css = _cstr(render_conf && render_conf.css);
        html = _cstr(render_params && render_params.html);
        if (css) {
          css = _ue(css);
          _create_stylesheet(css, "sf_custom_css");
        }
        if (html) {
          html = _ue(html);
          try {
            _reattach_messaging();
            _requested();
            document.write(html + "<scr" + ("ipt> " + cbName + "() ;</scr") + "ipt>");
            _check_orphaned();
            _reset_inline_handlers();
          } catch (_error) {
            e = _error;
            _handle_err("Error while rendering content: " + e[MSG]);
          }
        }
      };

      /*
      Call into the fallback x-msging library client if possible when no HTML5 style messaging
      exists
      
      @name $sf.ext-_call_client_fb
      @function
      @private
      @static
      @param {String} methName The name of the message in the library to call
      @param {*} [arg1] An arbitrary argument to hand into the library
      @param {*} [arg2] An arbitrary argument to hand into the library
       */
      _call_client_fb = function(methName, arg1, arg2) {
        var msg_clientfb;
        if (msgclient_fb) {
          msg_clientfb = dom.msgclient_fb;
        }
        return methName && msgclient_fb && msgclient_fb[methName] && msgclient_fb[methName](arg1, arg2);
      };

      /*
      Process a validated message to notify the contents of the SafeFrame of state updates
      
      @name $sf.ext-_receive_msg
      @function
      @private
      @static
      @param {$sf.lib.lang.ParamHash} params The message parameter hash object containing information about what has occured
      @param {HTMLEvent} [evt] The raw DOM event from the x-domain message
      @return {Boolean} Whether or not the message received could be handled
       */
      _receive_msg = function(params, evt) {
        var cmd, data, e, g, msg, ret;
        ret = false;
        msg = void 0;
        cmd = void 0;
        g = void 0;
        e = void 0;
        data = {};
        if (params) {
          g = params.geom || "";
          cmd = params.cmd;
          if (g) {
            geom_info = ParamHash(_ue(g), null, null, true, true);
          }
        }
        data.cmd = cmd;
        data.value = data.info = params && params.value;
        data.reason = params && params.reason;
        if (cmd === NOTIFY_COLLAPSED) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            force_collapse = true;
            _collapse();
            force_collapse = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_COLLAPSE) {
          ret = true;
          if (is_expanded) {
            pending_msg = null;
            is_expanded = false;
            _fire_sandbox_callback(NOTIFY_COLLAPSED);
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_EXPAND) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            is_expanded = true;
            _fire_sandbox_callback(NOTIFY_EXPAND + "ed");
            _shiftMessageQueue();
          }
        } else if (cmd === NOTIFY_GEOM_UPDATE) {
          _fire_sandbox_callback(NOTIFY_GEOM_UPDATE);
        } else if (cmd === NOTIFY_FOCUS_CHANGE) {
          data.info = data.value = lang.cbool(data.value);
          win_has_focus = data.value;
          _fire_sandbox_callback(NOTIFY_FOCUS_CHANGE, data);
        } else if (cmd === NOTIFY_READ_COOKIE) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
            data = params && params.value;
            _fire_sandbox_callback(NOTIFY_READ_COOKIE, data);
            _shiftMessageQueue();
          }
        } else if ([NOTIFY_WRITE_COOKIE, NOTIFY_FAILURE, NOTIFY_CLICKED, NOTIFY_VIEWED, NOTIFY_UNVIEWED, NOTIFY_LOADED, NOTIFY_REQUESTED, NOTIFY_RELOAD].indexOf(cmd) > -1) {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
          _shiftMessageQueue();
        } else {
          ret = true;
          if (pending_msg) {
            pending_msg = null;
          }
          _fire_sandbox_callback(cmd, data);
          _shiftMessageQueue();
        }
        params = null;
        return ret;
      };
      cmdRetries = {};

      /*
       */
      _shiftMessageQueue = function() {
        var result;
        if (result = messageQueue.shift()) {
          return _send_msg.apply(this, result);
        }
      };

      /*
      Send a command message up to the SafeFrames publisher / host code
      
      @name $sf.ext-_send_msg
      @private
      @function
      @static
      @param {String} str An encoded string (query-string/$sf.lib.lang.ParamHash format) that contains the command message to send
      @param {String} cmd The command to be sent itself (note that this string should also be present in the 1st argument)
       */
      _send_msg = function(str, cmd) {
        var e, id, params, sent, sent_time;
        id = lang.guid("sf_pnd_cmd");
        frame_id = render_params.dest;
        sent = false;
        sent_time = lang.time();
        params = void 0;
        if (!str || !cmd || pending_msg) {
          if (pending_msg) {
            messageQueue.push([str, cmd]);
          }
          return;
        }
        params = ParamHash({
          msg: str,
          id: frame_id,
          guid: guid,
          cmd: cmd
        });
        pending_msg = {
          id: id,
          sent: sent_time,
          cmd: cmd
        };
        setTimeout((function() {
          if (pending_msg && pending_msg.id === id) {
            if (cmd === EXPAND_COMMAND || cmd === "exp-push") {
              force_collapse = true;
              _collapse();
              force_collapse = false;
            }
            _fire_sandbox_callback(NOTIFY_FAILURE + ":" + cmd + ":timeout");
          }
          id = sent = sent_time = cmd = str = pending_msg = params = null;
          _shiftMessageQueue();
        }), MAX_MSG_WAIT_TIME);
        if (can_use_html5) {
          try {
            top.postMessage(params.toString(), (host_cname === "file" || host_cname === "" ? "*" : host_cname));
            sent = true;
          } catch (_error) {
            e = _error;
            sent = false;
          }
        }
        if (!sent) {
          _call_client_fb("send", params);
        }
      };

      /*
      Fire a notification off to the SafeFrame contents if a callback function was specified
      
      @name $sf.ext-_fire_sandbox_callback
      @private
      @function
      @static
      @param {String} msg The status update / message to send
      @param {Object} data The data from the response
       */
      _fire_sandbox_callback = function(msg, data) {
        var e;
        e = void 0;
        try {
          if (typeof sandbox_cb === "function") {
            sandbox_cb(msg, data);
          }
        } catch (_error) {}
      };

      /*
      Set the alignment of our internal DIV whenever expansion occurs uni-directionaly
      
      @name $sf.ext-_set_alignment
      @private
      @function
      @static
      @param {Boolean} xn Whether or not horizontal axis is growing to the left or right (xn == true == left)
      @param {Boolean} yn Whether or not vertical axis is growing to the top or bottom (yn == true == top)
       */
      _set_alignment = function(xn, yn) {
        var fcDiv, fcDivStyle, preTxt, xTxt, yTxt;
        fcDiv = _elt("sf_align");
        fcDivStyle = fcDiv.style;
        xTxt = void 0;
        yTxt = void 0;
        preTxt = "position:absolute;";
        if (xn) {
          xTxt = "right:0px;";
        } else {
          xTxt = "left:0px;";
        }
        if (yn) {
          yTxt = "bottom:0px;";
        } else {
          yTxt = "top:0px;";
        }
        fcDivStyle.cssText = preTxt + xTxt + yTxt;
        fcDiv = fcDivStyle = null;
      };

      /*
      Internal function for collapsing the SafeFrame, which checks that there is
      not some other pending state which may get in the way
      
      @name $sf.ext._collapse
      @private
      @function
      @static
       */
      _collapse = function() {
        if (!force_collapse && (!is_registered || !is_expanded || pending_msg)) {
          return false;
        }
        _set_alignment(0, 0);
        return true;
      };
      _reattach_messaging = function() {
        if (ie_old_attach) {
          ie_old_detach(ONMSG, _handle_msg);
          return ie_old_attach(ONMSG, _handle_msg);
        } else if (w3c_old_attach) {
          w3c_old_detach(MSG, _handle_msg);
          return w3c_old_attach(MSG, _handle_msg);
        }
      };

      /*
      Intialize the SafeFrame external vendor/client API, so that other features may be used
      This method MUST be called prior to using any other rich-media functionality (like expansion).
      
      @name $sf.ext.register
      @public
      @function
      @static
      @param {Number} initWidth The initial width (in pixels) expected of the content within the SafeFrame container
      @param {Number} initHeight The initial height (in pixels) expected of the content within the SafeFrame container
      @param {Function} [notify] A callback function that content can specify to be notified of status updates
       */
      register = function(initWidth, initHeight, notify) {
        if (is_registered || !guid) {
          return;
        }
        initWidth = _cnum(initWidth, 0, 0);
        initHeight = _cnum(initHeight, 0, 0);
        init_width = initWidth;
        init_height = initHeight;
        is_registered = true;
        if (lang.callable(notify)) {
          sandbox_cb = notify;
        } else {
          sandbox_cb = null;
        }
      };

      /*
      Make a request to expand the SafeFrame container to a certain size. Note that you may only call $sf.ext.expand
      to expand to the largest size needed, followed by calling collapse (and then repeat the same process if needed).
      Tweening or animation done, should be reserved for your own content, and you cannot make multiple calls to expand
      without a corresponding collapse.
      
      Note that when setting t, l, b, and r offset values, expansion will not cause the content inside the SafeFrame
      to hold it's current alignment, whereas using dx/dy or only setting partial offfsets (e.g {t:100,l:100} ==  dx:-100,dy:-100) will cause expansion to
      hold it's current alignment.
      
      @name $sf.ext.expand
      @public
      @static
      @function
      @param {Number|Object} deltaXorDesc If a number is specifed, SafeFrame will grow in size by this amount in pixels along the horizontal axis. Specifiy a negative value to grow to the left, and a postive value to grow to the right. <br />
      If an object is specified, it should contain "t","l","r","b" properties (top,left,bottom,right) for the amount in pixels to grow the container in each dimension
      @param {Number} deltaXorDesc.t Specifies to shift the top position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.l Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to original location (negative values not allowed).
      @param {Number} deltaXorDesc.b Specifies to shift the bottom position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Number} deltaXorDesc.r Specifies to shift the left position of the SafeFrame container by the number of pixels specified, relative to the original location (negative values not allowed).
      @param {Boolean}deltaXorDesc.push  When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      @param {Number} deltaY If a number is specifed, SafeFrame will grow in size by this amount in pixels along the vertical axis. Specifiy a negative value to grow to the top, and a postive value to grow to the bottom. <br />
      Note that this value is ignored if deltaXorDesc is passed in as an object.
      
      @param {Boolean} push When expanding, push other page content rather than doing an overlay.  Note that setting this value to true will only work if the publisher / host explicitly allows push expansion
      Check $sf.ext.supports("exp-push"), ahead of time to verify
      
      
      @return {Boolean} true/false if the request to expand the container was sent. This does not mean that expansion is complete as expansion is an asynchronous process. Pass in a callback function to $sf.ext.register to get status updates.
       */
      expand = function(deltaXorDesc, deltaY, p) {
        var align_buffer, align_el, align_el_st, b, cmd_nm, cmd_str, doAlign, dx, dy, l, r, t, xn, yn;
        xn = false;
        yn = false;
        doAlign = false;
        cmd_nm = (p ? "exp-push" : EXPAND_COMMAND);
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id];
        dx = 0;
        dy = 0;
        r = void 0;
        b = void 0;
        t = void 0;
        l = void 0;
        align_el = void 0;
        align_el_st = void 0;
        align_buffer = void 0;
        if (!is_registered || pending_msg) {
          return;
        }
        if (p && !supports("exp-push")) {
          return;
        }
        if (deltaXorDesc && typeof deltaXorDesc === OBJ) {
          r = _cnum(deltaXorDesc.r, 0, 0);
          b = _cnum(deltaXorDesc.b, 0, 0);
          t = _cnum(deltaXorDesc.t, 0, 0);
          l = _cnum(deltaXorDesc.l, 0, 0);
          if (deltaXorDesc.push) {
            if (!supports("exp-push")) {
              return;
            }
            cmd_nm = "exp-push";
            cmd_str[1] = cmd_nm;
          }
          if (!r && l) {
            xn = true;
            dx = -1 * l;
          }
          if (r && !l) {
            dx = r;
          }
          if (!b && t) {
            yn = true;
            dy = -1 * t;
          }
          if (b && !t) {
            dy = b;
          }
          if ((t && b) || (l && r)) {
            doAlign = false;
          } else {
            doAlign = true;
          }
          if (doAlign) {
            _set_alignment(xn, yn);
            cmd_str.push("&dx=", dx, "&dy=", dy);
            _send_msg(_cstr(cmd_str), cmd_nm);
          } else {
            align_el = _elt("sf_align");
            align_el_st = align_el && align_el.style;
            align_buffer = ["position:absolute;"];
            if (t && b) {
              align_buffer.push("top:", t, "px;");
            } else if (t) {
              align_buffer.push("bottom:0px;");
            } else {
              if (b) {
                align_buffer.push("top:0px;");
              }
            }
            if (l && r) {
              align_buffer.push("left:", l, "px;");
            } else if (l) {
              align_buffer.push("right:0px;");
            } else {
              if (b) {
                align_buffer.push("left:0px;");
              }
            }
            if (align_el_st) {
              align_el_st.cssText = _cstr(align_buffer);
            }
            cmd_str.push("&exp_obj=", escape(ParamHash(deltaXorDesc)));
            _send_msg(_cstr(cmd_str), cmd_nm);
          }
        } else {
          deltaXorDesc = _cnum(deltaXorDesc, 0);
          deltaY = _cnum(deltaY, 0);
          if (deltaXorDesc <= 0 && deltaY <= 0) {
            return;
          }
          xn = deltaXorDesc <= 0;
          yn = deltaY <= 0;
          _set_alignment(xn, yn);
          cmd_str.push("&dx=", deltaXorDesc, "&dy=", deltaY);
          _send_msg(_cstr(cmd_str), cmd_nm);
        }
        return true;
      };

      /*
      Collapse the SafeFrame container after having called to expand. If no previous call to expand has been made, this call will do nothing.
      
      @name $sf.ext.collapse
      @public
      @static
      @function
       */
      collapse = function() {
        if (_collapse()) {
          _send_msg(_cstr(["cmd=", COLLAPSE_COMMAND, "&pos=", pos_id]), COLLAPSE_COMMAND);
        }
      };
      click = function() {
        return _send_cmd(NOTIFY_CLICKED);
      };
      viewed = function() {
        return _send_cmd(NOTIFY_VIEWED);
      };
      loaded = function() {
        return _send_cmd(NOTIFY_LOADED);
      };
      unviewed = function() {
        return _send_cmd(NOTIFY_UNVIEWED);
      };
      reload = function() {
        return _send_cmd(NOTIFY_RELOAD);
      };
      _requested = function() {
        _fire_sandbox_callback(NOTIFY_REQUESTED);
        return _send_cmd(NOTIFY_REQUESTED);
      };
      _send_cmd = function(cmd) {
        return _send_msg(_cstr(["cmd=", cmd, "&pos=", pos_id]), cmd);
      };

      /*
      Return geometric information about the SafeFrame container and it's status within a page
      
      @name $sf.ext.geom
      @public
      @static
      @function
      @return {Object} geom_info
       */
      geom = function() {
        return geom_info;
      };

      /*
      Return meta-data information that may have been specified by the publisher / host.
      
      @name $sf.ext.meta
      @public
      @static
      @function
      @param {String} propName the key name of the meta-data value to be retrieved
      @param {String} [owner_key] the super key name of the data to be retrieved
      @return {String} The value of some meta-data that may have been specified by the publisher / host or "".
       */
      meta = function(propName, owner_key) {
        var ret, shared;
        ret = "";
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              ret = _cstr(pos_meta[owner_key][propName]);
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                ret = _cstr(pos_meta.non_shared[owner_key][propName]);
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              ret = _cstr(shared[propName]);
            }
          }
        }
        return ret;
      };
      deleteMeta = function(propName, owner_key) {
        var shared;
        shared = void 0;
        if (pos_meta) {
          if (owner_key) {
            if (owner_key in pos_meta) {
              return delete pos_meta[owner_key][propName];
            } else {
              if (pos_meta.non_shared && owner_key in pos_meta.non_shared) {
                return delete pos_meta.non_shared[owner_key][propName];
              }
            }
          } else {
            shared = pos_meta.shared;
            if (shared && typeof shared === OBJ) {
              return delete shared[propName];
            }
          }
        }
      };

      /*
      Return the current status of the SafeFrame container, in cases where
      a command may be pending. If an empty string is returned ("") container is idle.
      
      @name $sf.ext.status
      @public
      @static
      @function
      @return {String} of any pending status, otherwise empty string.
       */
      status = function() {
        if (pending_msg) {
          if (pending_msg.cmd === EXPAND_COMMAND) {
            return STATUS_EXPANDING;
          } else {
            if (pending_msg.cmd === COLLAPSE_COMMAND) {
              return STATUS;
            }
          }
        }
        if (is_expanded) {
          return STATUS_EXPANDED;
        } else {
          return STATUS_COLLAPSED;
        }
      };

      /*
      Requests the host read or write a cookie to the host domain.
      The host domain must grant permission for the cookie to be written.
      
      @name $sf.ext.cookie
      @public
      @static
      @function
      @param {String} [cookieName] The name of the cookie to set or read
      @param {Object} [cookieData] An object hash containing the value and an optional expires
      @return {Number}
       */
      cookie = function(cookieName, cookieData) {
        var cmd_nm, cmd_str, isRead;
        isRead = !(cookieData != null);
        cmd_nm = (isRead ? "read-cookie" : "write-cookie");
        cmd_str = ["cmd=", cmd_nm, "&pos=", pos_id, "&cookie=", cookieName];
        if (!isRead) {
          cmd_str.push("&value=");
          cmd_str.push(cookieData.value);
        }
        _send_msg(_cstr(cmd_str), cmd_nm);
      };

      /*
      Send a message to the host
      
      @name $sf.ext.message
      @public
      @static
      @function
       */
      message = function(content) {
        _send_msg(_cstr(["cmd=", "msg", "&pos=", pos_id, "&msg=", content]), "msg");
      };

      /*
      Return the percentage that the SafeFrame container is viewable within the browser window
      
      @name $sf.ext.inViewPercentage
      @public
      @static
      @function
      @return {Number}
       */
      inViewPercentage = function() {
        var iv, tv;
        iv = _cnum(geom_info && geom_info.self && geom_info.self.iv, -1, 0);
        tv = void 0;
        if (iv >= 0) {
          tv = Math.floor(iv * 100);
        }
        return tv;
      };
      winHasFocus = function() {
        return win_has_focus;
      };

      /*
      Return whether or not a particular feature is supported, or an object containing
      key/value pairs denoting all features and whether or not they are supported
      
      By default SafeFrames version 1 supports the following feature:
      
      "exp-ovr": Expansion of the container by overlaying on top of other content
      
      Later in other versions there are expexted to be more feature with their own
      string name, that can be checked by the content in the SafeFrame, so that
      it knows what things can be done.
      
      @name $sf.ext.supports
      @public
      @static
      @function
      @param {String} [key] If specifed, checks to see if that specific feature has been enabled
      @return {Boolean|Object}
       */
      supports = function(key) {
        var conf, sup;
        conf = render_params.conf;
        sup = (conf && conf.supports) || false;
        if (sup) {
          key = _cstr(key);
          if (key) {
            sup = sup[key] || false;
            if (sup === "0") {
              sup = false;
            }
          } else {
            sup = lang.mix({}, sup);
          }
        }
        return sup;
      };
      render = function(showAd, cb) {
        var err_info;
        err_info = {};
        if (_construction(err_info)) {
          if (showAd) {
            return _render(cb);
          }
        }
      };
      showAd = function(cb) {
        if (!isAdShown) {
          return _render(cb);
        }
      };
      adShown = function() {
        return isAdShown;
      };
      lang.mix(sf.ext, {
        register: register,
        expand: expand,
        collapse: collapse,
        geom: geom,
        meta: meta,
        deleteMeta: deleteMeta,
        status: status,
        supports: supports,
        cookie: cookie,
        message: message,
        inViewPercentage: inViewPercentage,
        winHasFocus: winHasFocus,
        click: click,
        viewed: viewed,
        unviewed: unviewed,
        showAd: showAd,
        adShown: adShown,
        reload: reload
      });
      if (!isExternal) {
        window.$sf = sf;
        render();
      } else {
        window.$sf = sf;
        sf.ext.render = render;
      }
      return sf;
    })(window, sf);
  };

}).call(this);

},{"../shared/base":13}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var dom, env, lang, logger;

  lang = require('./lang');

  env = require('./env');

  dom = require('./dom');

  logger = require('./logger');

  module.exports = (function(lang, env, dom, logger) {
    return {
      ver: "1-1-0",
      specVersion: "1.1",
      lib: {
        lang: lang,
        dom: dom,
        logger: logger
      },
      env: env,
      host: {},
      ext: {},
      info: {
        errs: [],
        list: []
      }
    };
  })(lang, env, dom, logger);

}).call(this);

},{"./dom":14,"./env":15,"./lang":16,"./logger":17}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var env, lang;

  lang = require('./lang');

  env = require('./env');

  module.exports = (function(window, lang, env) {
    var BLANK_URL, EVT_CNCL_METHODS, GC, IE_GC_INTERVAL, IFRAME, append, attach, attr, clone_iframe, css, detach, doc, dom, dom_is_ready, dom_last_known_child_node, dom_last_known_tag_count, dom_ready_chk_max_tries, dom_ready_chk_timer_id, dom_ready_chk_tries, dom_ready_chk_try_interval, elt, evtCncl, evtTgt, evt_tgt_prop_a, evt_tgt_prop_b, gc, gc_timer_id, ie_attach, ie_detach, iframe_cbs_attached, iframe_msg_host_lib, iframe_next_id, iframe_view, isIE, make_element, make_iframe, par, purge, ready, replace_iframe, tagName, tags, theDocument, useOldStyleAttrMethods, use_attach, use_detach, use_ie_old_attach, view, w3c_attach, w3c_detach, wait, win, _bind_iframe_onload, _byID, _call_xmsg_host, _callable, _clear_ready_timer_check, _clone_iframe, _cstr, _env, _handle_dom_load_evt, _lang, _ready_state_check, _unbind_iframe_onload;
    dom = {};
    _lang = lang;
    _env = env;
    win = window;
    IFRAME = "iframe";
    GC = "CollectGarbage";
    ie_attach = "attachEvent";
    w3c_attach = "addEventListener";
    ie_detach = "detachEvent";
    w3c_detach = "removeEventListener";
    use_attach = "";
    use_detach = "";
    use_ie_old_attach = false;
    IE_GC_INTERVAL = 3000;
    EVT_CNCL_METHODS = {
      "preventDefault": 0,
      "stopImmediatePropagation": 0,
      "stopPropagation": 0,
      "preventBubble": 0
    };
    isIE = env.isIE;
    useOldStyleAttrMethods = false;
    gc_timer_id = 0;
    dom_is_ready = null;
    dom_last_known_tag_count = 0;
    dom_last_known_child_node = null;
    dom_ready_chk_max_tries = 300;
    dom_ready_chk_try_interval = 50;
    dom_ready_chk_tries = 0;
    dom_ready_chk_timer_id = 0;
    iframe_next_id = 0;
    iframe_cbs_attached = {};
    evt_tgt_prop_a = "";
    evt_tgt_prop_b = "";
    iframe_msg_host_lib = null;
    theDocument = win.document;
    BLANK_URL = "about:blank";
    _cstr = lang.cstr;
    _callable = lang.callable;

    /*
    Clear out the timer function used as a fallback when ready state of the DOM
    cannot be directly detected
    
    @name $sf.lib.dom-_clear_ready_timer_check
    @private
    @static
    @function
     */
    _clear_ready_timer_check = function() {
      if (dom_ready_chk_timer_id) {
        clearTimeout(dom_ready_chk_timer_id);
        dom_ready_chk_timer_id = 0;
      }
    };
    _handle_dom_load_evt = function(evt) {
      detach(win, "load", _handle_dom_load_evt);
      detach(win, "DOMContentLoaded", _handle_dom_load_evt);
      dom_is_ready = true;
    };

    /*
    Checks to see if the DOM is ready to be manipulated, without the need for event hooking.
    Often times you'll see folks use the onload event or DOMContentLoaded event.  However
    the problem with those, is that your JavaScript code may have been loaded asynchronously,
    after either one of those events have fired, and in which case you still don't know if the DOM is really
    ready.  Most modern browsers (including IE), implement a document.readyState property that we can
    check, but not all.  In the case where this property is not implemented, we do a series of node
    checks and tag counts via timers.  Of course this means that on the very 1st call, we will always
    appear to be not ready eventhough the DOM itself may be in a ready state, but our timeout interval
    is small enough that this is OK.
    
    @name $sf.lib.dom-_ready_state_check
    @private
    @static
    @function
     */
    _ready_state_check = function() {
      var b, e, kids, lst, tag_cnt;
      _clear_ready_timer_check();
      if (dom_ready_chk_tries >= dom_ready_chk_max_tries) {
        dom_last_known_child_node = null;
        dom_is_ready = true;
      }
      if (dom_is_ready === null) {
        try {
          b = theDocument && theDocument.body;
          kids = b && tags("*", b);
          tag_cnt = kids && kids[LEN];
          lst = b && b.lastChild;
        } catch (_error) {
          e = _error;
          dom_last_known_tag_count = 0;
          dom_last_known_child_node = null;
        }
        if (dom_last_known_tag_count && tag_cnt === dom_last_known_tag_count && lst === dom_last_known_child_node) {
          dom_last_known_child_node = null;
          dom_is_ready = true;
        } else {
          dom_last_known_tag_count = tag_cnt;
          dom_last_known_child_node = lst;
          dom_ready_chk_tries += 1;
          dom_ready_chk_timer_id = setTimeout(_ready_state_check, dom_ready_chk_try_interval);
        }
      } else {
        dom_last_known_child_node = null;
      }
    };

    /*
    Detach onload handlers on iframes that we have created
    
    @name $sf.lib.dom.iframes-_unbind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to unbind from
     */
    _unbind_iframe_onload = function(el) {
      var id, oldCB;
      id = attr(el, "id");
      oldCB = void 0;
      oldCB = id && iframe_cbs_attached[id];
      if (oldCB) {
        detach(el, "load", oldCB);
        iframe_cbs_attached[id] = null;
        delete iframe_cbs_attached[id];
      }
    };

    /*
    A default onload event handler for IFrames. We don't
    want to attach to onload events for IFrames via attributes
    b/c we don't want others to see what handlers are there.
    In turn we also make sure the "this" reference for the outside
    handle gets set properly, and it allows us to make sure
    that unbinding of the event handler also gets handled always
    so as not to create memory leak issues.
    
    @name $sf.lib.dom.iframes-_bind_iframe_onload
    @private
    @static
    @function
    @param {HTMLElement} el the iframe element to bind too
    @param {Function} cb The onload handler from the outside
     */
    _bind_iframe_onload = function(el, cb) {
      var id, newCB;
      newCB = void 0;
      id = void 0;
      if (_callable(cb)) {

        /*
        @ignore
         */
        newCB = function(evt) {
          var e, tgt;
          tgt = evtTgt(evt);
          e = void 0;
          _unbind_iframe_onload(tgt);
          if (tgt && cb) {
            try {
              cb.call(tgt, evt);
            } catch (_error) {}
          }
          tgt = el = cb = newCB = id = null;
        };
        id = attr(el, "id");
        _unbind_iframe_onload(el);
        if (id) {
          iframe_cbs_attached[id] = newCB;
        }
        attach(el, "load", newCB);
      }
      newCB = null;
    };

    /*
    Return the element reference passed in, and if its a string value passed
    in use that to lookup the element by id attribute.
    
    @name $sf.lib.dom-_byID
    @private
    @static
    @function
    @param {HTMLElement|String} el  the element id / element reference
    @return {HTMLElement|el}
     */
    _byID = function(el) {
      if (el && typeof el === "string") {
        return elt(el) || el;
      } else {
        return el;
      }
    };

    /*
    A proxy wrapper for calling into the cross-domain messaging host library
    
    @name $sf.lib.dom.iframes-_call_xmsg_host
    @private
    @static
    @function
    @param {String} methName The method name in the msg host library to call
    @param {*} arg1 An arbitrary argument to pass to said method as the 1st arg
    @param {*} arg2 An arbitrary argument to pass to said method as the 2nd arg
    @param {*} arg3 An arbitrary argument to pass to said method as the 3rd arg
    @return {*} whatever comes back from the method
     */
    _call_xmsg_host = function(methName, arg1, arg2, arg3) {
      var e;
      e = void 0;
      try {
        if (!iframe_msg_host_lib) {
          iframe_msg_host_lib = dom.msghost;
        }
      } catch (_error) {
        e = _error;
        iframe_msg_host_lib = null;
      }
      if (win !== top) {
        return;
      }
      return methName && iframe_msg_host_lib && iframe_msg_host_lib[methName] && iframe_msg_host_lib[methName](arg1, arg2, arg3);
    };

    /*
    Retrieve a document for a given HTML Element
    
    @memberOf $sf.lib.dom
    @exports doc as $sf.lib.dom.doc
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element for which you wish to find it's parent document
    @return {Document|null} null if nothing found
     */
    doc = function(el) {
      var e, localD;
      localD = null;
      try {
        if (el) {
          if (el.nodeType === 9) {
            localD = el;
          } else {
            localD = el.document || el.ownerDocument || null;
          }
        }
      } catch (_error) {
        e = _error;
        localD = null;
      }
      return localD;
    };

    /*
    Retrieve the host window object for a given HTML Element/document. Note that this is NOT the same as $sf.lib.dom.iframes.view, which
    returns the window reference INSIDE the IFRAME element.
    
    @memberOf $sf.lib.dom
    @exports view as $sf.lib.dom.view
    @public
    @static
    @function
    @param {HTMLElement|HTMLDocument} el the HTML element/document for which you wish to find it's parent window
    @return {Document|null} null if nothing found
     */
    view = function(el) {
      var e, localD, prop1, prop2, w;
      w = null;
      localD = void 0;
      prop1 = "parentWindow";
      prop2 = "defaultView";
      try {
        if (el) {
          w = el[prop1] || el[prop2] || null;
          if (!w) {
            localD = doc(el);
            w = (localD && (localD[prop1] || localD[prop2])) || null;
          }
        }
      } catch (_error) {
        e = _error;
        w = null;
      }
      return w;
    };

    /*
    Retrieve an element by its ID. . basically a short hand wrapper around document.getElementById.
    
    @memberOf $sf.lib.dom
    @exports elt as $sf.lib.dom.elt
    @public
    @static
    @function
    @param {String} id (Required) the id of the HTML element to find
    @param {HTMLElement|HTMLWindow|HTMLDocument} [par] The parent element,document,window to look for the given element
    @return {HTMLElement|null} null if nothing found
     */
    elt = function(id) {
      var args, dc, len;
      args = arguments;
      len = args.length;
      dc = void 0;
      if (len > 1) {
        dc = doc(args[1]);
      } else {
        dc = theDocument;
      }
      return (dc && dc.getElementById(id)) || null;
    };

    /*
    A wrapper around retrieving the tagName of an HTML element (normalizes values to lower case strings).
    
    @memberOf $sf.lib.dom
    @exports tagName as $sf.lib.dom.tagName
    @static
    @public
    @function
    @param {HTMLElement} el The HTML element for which to get the tag name.
    @return {String} The tag name in all lower case of an HTML element, if it cannot be successfully retrieved, alwasys returns an empty string (which will evaluate to false).
     */
    tagName = function(el) {
      return (el && el.nodeType === 1 && el.tagName.toLowerCase()) || "";
    };

    /*
    A wrapper around retrieving a list of tags by name.
    
    @memberOf $sf.lib.dom
    @exports tags as $sf.lib.dom.tags
    @static
    @public
    @function
    @param {String} name The name of the tags that you wish to look for, note that you can pass in "*" to find all.
    @param {HTMLElement|Document} [parNode] the parent node that you wish to look in
    @return {HTMLElementCollection} List of tags found. Note that is NOT a real JavaScript Array
     */
    tags = function(name, parNode) {
      var e, ret;
      ret = [];
      e = void 0;
      try {
        if (parNode && parNode.getElementsByTagName) {
          ret = parNode.getElementsByTagName(name) || ret;
        } else {
          ret = theDocument.getElementsByTagName(name) || ret;
        }
      } catch (_error) {
        e = _error;
        ret = [];
      }
      return ret;
    };

    /*
    Retrive the parent element of an HTML element
    
    @memberOf $sf.lib.dom
    @exports par as $sf.lib.dom.par
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to check
    return {HTMLElement} the new reference to the parent element or null
     */
    par = function(el) {
      return el && (el.parentNode || el.parentElement);
    };

    /*
    Retrieve/Set/Delete an element's attribute. Note that this handle's
    slight differences in the way HTML attributes are handled across browsers
    as well as being shorthand
    
    @memberOf $sf.lib.dom
    @exports attr as $sf.lib.dom.attr
    @static
    @public
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} attrName the attribute to set/get
    @param {String} [attrVal], if specified will set the value of the attribute for this element.  Passing null will remove the attribute completely
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    attr = function(el, attrName, attrVal) {
      var e;
      e = void 0;
      try {
        if (arguments.length > 2) {
          if (attrVal === null) {
            if (useOldStyleAttrMethods) {
              el.removeAttribute(attrName, 0);
            } else {
              el.removeAttribute(attrName);
            }
          } else {
            attrVal = _cstr(attrVal);
            if (attrName.toLowerCase() === "class") {
              el.className = attrVal;
            } else {
              if (useOldStyleAttrMethods) {
                el.setAttribute(attrName, attrVal, 0);
              } else {
                el.setAttribute(attrName, attrVal);
              }
            }
          }
        } else {
          if (useOldStyleAttrMethods) {
            attrVal = _cstr(el.getAttribute(attrName, 0));
          } else {
            attrVal = _cstr(el.getAttribute(attrName));
          }
        }
      } catch (_error) {
        e = _error;
        attrVal = "";
      }
      return attrVal;
    };

    /*
    Set/Get the CSS text of an HTML element
    
    @memberOf $sf.lib.dom
    @exports css as $sf.lib.dom.css
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to manipulate
    @param {String} [val] the CSS string to set if specified (e.g. "background-color:transparent;position:absolute;top:0px;left:0px").
    @return {String} the value of the attribute normalized to a string (may be empty)
     */
    css = function(el, val) {
      var e, st;
      st = void 0;
      try {
        st = el.style;
        if (arguments.length > 1) {
          st.cssText = _cstr(val);
        } else {
          val = st.cssText;
        }
      } catch (_error) {
        e = _error;
        val = "";
      }
      return val;
    };

    /*
    Make a new element
    
    @name $sf.lib.dom.make
    @exports make_element as $sf.lib.dom.make
    @static
    @public
    @function
    @param {String} tagName
    @param {Document|HTMLElement|Window} [parent] element, document, or window to make the tag in, optional.
    @return {HTMLElement}
     */
    make_element = function(tagName, par) {
      return ((arguments.length > 1 && doc(par)) || theDocument).createElement(tagName);
    };

    /*
    Append and HTMLElement to another HTMLElement
    
    @memberOf $sf.lib.dom
    @exports append as $sf.lib.dom.append
    @public
    @static
    @function
    @param {HTMLElement} parNode the HTML element to manipulate
    @param {HTMLElement} child (Required) the new HTML element to add to the parent
    return {HTMLElement|Boolean} the new reference to the child element that was appended, or false if failure
     */
    append = function(parNode, child) {
      var e, success;
      success = false;
      e = void 0;
      try {
        if (parNode) {
          success = parNode.appendChild(child);
        }
      } catch (_error) {
        e = _error;
        success = false;
      }
      return success;
    };

    /*
    A wrapper method for removing elements from a document rather than calling parentNode.removeChild raw.
    Has special processing to ensure that contents of IFRAME tags gets released from memory as well
    
    @memberOf $sf.lib.dom
    @exports purge as $sf.lib.dom.purge
    @static
    @public
    @function
    @param {HTMLElement} node The HTML element to be removed from the dom
    @return {Boolean} Whether or not the element was successfully removed
     */
    purge = function(node) {
      var e, isIFrame, parNode, success;
      success = false;
      parNode = void 0;
      isIFrame = tagName(node) === IFRAME;
      e = void 0;
      if (isIFrame) {
        _call_xmsg_host("detach", node);
        _unbind_iframe_onload(node);
        if (!isIE) {
          attr(node, "src", BLANK_URL);
        }
      }
      try {
        parNode = par(node);
        if (parNode) {
          parNode.removeChild(node);
          success = true;
          if (isIE && isIFrame) {
            gc();
          }
        }
      } catch (_error) {}
      node = parNode = null;
      return success;
    };

    /*
    Attach an event handler to an HTMLElement.  Note normalize event names to lower case / w3c standards.
    See example.
    
    @memberOf $sf.lib.dom
    @exports attach as $sf.lib.dom.attach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} name the name of the event to listen too
    @param {Function} cb the function used to handle the particular event
    
    @example
    var el = $sf.lib.dom.elt("my_element");
    function handle_click(evt)
    {
    alert('i was clicked');
    }
    
    $sf.lib.dom.attach(el,"click",handle_click);
     */
    attach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj[use_attach]("on" + name, cb);
        } else {
          obj[use_attach](name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Detach an event handler to an HTMLElement
    
    @memberOf $sf.lib.dom
    @exports detach as $sf.lib.dom.detach
    @public
    @static
    @function
    @param {HTMLElement} el the HTML element to attach an event handler too
    @param {String} namethe name of the event to listen too
    @param {Function} cb the function used to handle the particular event
     */
    detach = function(obj, name, cb) {
      try {
        if (use_ie_old_attach) {
          obj.detachEvent("on" + name, cb);
        } else {
          obj.removeEventListener(name, cb, false);
        }
      } catch (_error) {}
      obj = cb = null;
    };

    /*
    Returns whether or not the DOM is ready to be manipulated
    
    @memberOf $sf.lib.dom
    @exports ready as $sf.lib.dom.ready
    @public
    @static
    @function
    @return {Boolean}
     */
    ready = function() {
      var rs;
      rs = void 0;
      _clear_ready_timer_check();
      if (dom_is_ready) {
        dom_last_known_child_node = null;
        return true;
      }
      rs = theDocument.readyState;
      if (rs) {
        dom_last_known_child_node = null;
        if (rs === "loaded" || rs === "complete") {
          dom_is_ready = true;
        } else {
          dom_is_ready = false;
        }
      }
      dom_last_known_child_node = null;
      dom_ready_chk_tries = dom_last_known_tag_count = 0;
      _ready_state_check();
      return !!dom_is_ready;
    };

    /*
    Fire off a particular function when it is detected that the DOM is ready
    Useful when you don't know for sure if the DOM of the browser is ready or not, so this will detect and fire
    your function for you.
    
    @memberOf $sf.lib.dom
    @exports wait as $sf.lib.dom.wait
    @public
    @static
    @function
    @param {Function} cb A function reference to be called when the DOM is ready
     */
    wait = function(cb) {
      var e, rdy;
      rdy = ready();
      e = void 0;
      if (rdy) {
        try {
          if (lang.callable(cb)) {
            cb();
          }
        } catch (_error) {
          e = _error;
          e = null;
        }
        return;
      }
      setTimeout((function() {
        wait(cb);
        cb = null;
      }), dom_ready_chk_try_interval + 1);
    };

    /*
    Cancel the the default action of a particular DOM event
    
    @memberOf $sf.lib.dom
    @exports evtCncl as $sf.lib.dom.evtCncl
    @public
    @static
    @function
    @param {HTMLEvent} evt  The raw HTML event
     */
    evtCncl = function(evt) {
      var e, prop;
      prop = "";
      e = void 0;
      evt = evt || win.event;
      if (evt) {
        try {
          evt.returnValue = false;
        } catch (_error) {}
        try {
          evt.cancelBubble = true;
        } catch (_error) {}
        try {
          evt.stopped = true;
        } catch (_error) {}
        for (prop in EVT_CNCL_METHODS) {
          if (EVT_CNCL_METHODS[prop]) {
            try {
              evt[prop]();
            } catch (_error) {}
          }
        }
      }
      return false;
    };

    /*
    Return the target/srcElement of an event from an HTML element
    
    @memberOf $sf.lib.dom
    @exports evtTgt as $sf.lib.dom.evtTgt
    @public
    @static
    @function
    @param {HTMLEvent} evt The raw HTML event
     */
    evtTgt = function(evt) {
      var e, tgt;
      tgt = null;
      try {
        evt = evt || win.event;
        tgt = (evt ? evt[evt_tgt_prop_a] || evt[evt_tgt_prop_b] : null);
      } catch (_error) {
        e = _error;
        tgt = null;
      }
      return tgt;
    };

    /*
    @namespace $sf.lib.dom.iframes Defines helper functions for dealing specifically with IFRAME tags, which is key to SafeFrames tech in a browser.
    @name $sf.lib.dom.iframes
    @requires $sf.lib.lang
     */

    /*
    Clones an iframe. . .
    This code creates / clones iframe tags in a very specific way to ensure both optimal performance and stability.
    We use string buffers to build markup internally, which is typically faster than using all DOM APIs.  Also
    we allow the usage of the "name" attribute as a data pipeline, which in turn allows for synchronous downward
    x-domain messaging.
    
    @name $sf.lib.dom.iframes.clone
    @static
    @public
    @function
    @param {HTMLElement/String} el  An iframe element or id of an iframe element to clone
    @param {Object} [attrs]  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An optional callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An optional call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    clone_iframe = function(el, attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(el, attrs, cssText, cb, xmsgCB);
    };

    /*
    @ignore
     */
    _clone_iframe = function(el, attrs, cssText, cb, xmsgCB, iframe_skip_clone) {
      var attrStr, bufferHTML, cl, html, newCl, prop, temp, xmsgPipe;
      bufferHTML = ["<", IFRAME, " "];
      xmsgPipe = "";
      prop = void 0;
      temp = void 0;
      cl = void 0;
      newCl = void 0;
      html = void 0;
      attrStr = void 0;
      if (!iframe_skip_clone) {
        el = _byID(el);
        if (tagName(el) !== IFRAME) {
          return null;
        }
        cl = el.cloneNode(false);
      } else {
        cl = el;
      }
      attrs = attrs || {};
      if ("src" in attrs) {
        attr(cl, "src", null);
      } else {
        attrs.src = attr(el, "src") || BLANK_URL;
      }
      if ("name" in attrs) {
        attr(cl, "name", null);
      } else {
        attrs.name = attr(el, "name");
      }
      if (!attrs.src) {
        attrs.src = BLANK_URL;
      }
      xmsgPipe = xmsgCB && _call_xmsg_host("prep", attrs);
      if (!iframe_skip_clone) {
        attr(cl, "width", null);
        attr(cl, "height", null);
      }
      if (cssText) {
        temp = css(cl);
        if (temp && temp.charAt(temp.length - 1) !== ";") {
          temp += ";";
        }
        css(cl, [temp, _cstr(cssText)]);
      }
      temp = make_element("div");
      append(temp, cl);
      html = temp.innerHTML;
      attrStr = html.replace(/<iframe(.*?)>(.*?)<\/iframe>/g, "$1");
      bufferHTML.push("name=\"", attrs.name, "\" ", attrStr, "></", IFRAME, ">");
      delete attrs.name;
      temp.innerHTML = _cstr(bufferHTML);
      newCl = temp.firstChild;
      for (prop in attrs) {
        attr(newCl, prop, attrs[prop]);
      }
      if (!attr(newCl, "id")) {
        attr(newCl, "id", "sf_" + IFRAME + "_" + iframe_next_id);
        iframe_next_id++;
      }
      attr(newCl, "FRAMEBORDER", "no");
      attr(newCl, "SCROLLING", "no");
      attr(newCl, "ALLOWTRANSPARENCY", true);
      attr(newCl, "HIDEFOCUS", true);
      attr(newCl, "TABINDEX", -1);
      attr(newCl, "MARGINWIDTH", 0);
      attr(newCl, "MARGINHEIGHT", 0);
      _bind_iframe_onload(newCl, cb);
      if (xmsgPipe) {
        _call_xmsg_host("attach", newCl, xmsgPipe, xmsgCB);
      }
      xmsgPipe = xmsgCB = cl = cb = el = temp = null;
      return newCl;
    };

    /*
    Make a new iframe
    
    @name $sf.lib.dom.iframes.make
    @static
    @public
    @function
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    @return {HTMLElement}  the iframe node if succesfully created or null.  Note that this does not insert the iframe into the document for you. . .
     */
    make_iframe = function(attrs, cssText, cb, xmsgCB) {
      return _clone_iframe(make_element(IFRAME), attrs, cssText, cb, xmsgCB, true);
    };

    /*
    A method to insert or replace an HTML tag with an IFRAME tag, with a new URL and attributes.
    
    Used for 3 reasons:
    <ol>
    <li>It avoids click sounds on IE.</li>
    <li>It allows always resetting the window.name property of the iframes underlying HTMLWindow object, unforunately IE will not let you set this attribute on a clone.</li>
    <li>It ensures that event handlers in the underlying document for unloading are executed.</li>
    <li>Changing the src attribute directly will result in a browser history update, which we do not want.</li>
    </ol>
    
    We could just change location.href property or call location.replace, however that is not always  possible since
    the frame could be x-domain.
    
    @name $sf.lib.dom.iframes.replace
    @function
    @static
    @public
    @param {Object} attrs  A hash map of other attributes to be set on the iframe.  Do not set style properties for the frame here, see the next argument for that.
    @param {String} [cssText]  The style string (as in what you would use in HTML markup, e.g. "background-color:red;border:solid 3px blue;"), to use for this iframe
    @param {HTMLElement|String} [parRef]  An parent element or parent element id, to be used only if a new iframe is created, the iframe will be append to that parent, if not specified document body is used
    @param {Function} [cb]  An callback function to specify for when the iframe loads.
    @param {Function} [xmsgCB] An call back for receiving messages from the iframe
    
    @return {HTMLElement} a reference to the newly created iframe element if successfully inserted, otherwise null.
     */
    replace_iframe = function(attrs, cssText, parRef, cb, xmsgCB) {
      var cl, e, el, elID, frameEl, parNode, tgn;
      cl = void 0;
      el = void 0;
      frameEl = void 0;
      elID = void 0;
      tgn = void 0;
      parNode = void 0;
      e = void 0;
      attrs = attrs || {};
      elID = attrs.id;
      el = elID && _byID(elID);
      tgn = tagName(el);
      el = (tgn ? el : null);
      frameEl = (tgn === IFRAME ? el : null);
      if (frameEl) {
        _call_xmsg_host("detach", frameEl);
        _unbind_iframe_onload(frameEl);
        parNode = par(frameEl);
        cl = clone_iframe(frameEl, attrs, cssText, cb, xmsgCB);
        attr(cl, "onload", null);
        attr(cl, "onreadystatechange", null);
      } else {
        if (parRef) {
          parRef = _byID(parRef);
          if (tagName(parRef)) {
            parNode = parRef;
          }
        }
        if (!parNode && el) {
          parNode = par(el);
        }
        cssText = _cstr(cssText) || css(el) || "";
        cl = make_iframe(attrs, cssText, cb, xmsgCB);
      }
      try {
        if (!parNode) {
          append(theDocument.body, cl);
        } else {
          if (frameEl) {
            parNode.replaceChild(cl, frameEl);
          } else {
            if (el) {
              parNode.replaceChild(cl, el);
            } else {
              append(parNode, cl);
            }
          }
        }
      } catch (_error) {}
      cl = el = attrs = frameEl = parNode = cb = null;
      return elt(elID);
    };

    /*
    Retrieve the window reference inside of an IFRAME. Not to be confused with $sf.lib.dom.view which
    returns the parent window reference of an element.
    
    Note that even in cross-domain scenarios, you are supposed to able to get access to the window reference.
    In a cross-domain scenario, you would not be able to then acesss most properties / methods / objects of that
    window, but the reference itself is allowed.
    
    @name $sf.lib.dom.iframes.view
    @public
    @static
    @function
    @param {HTMLElement} el The iframe element to safely get back the window
    @return {HTMLWindow} the window reference inside the iframe.
     */
    iframe_view = function(el) {
      var e, elDoc, elWin, err, fe, frame, frame_list, idx, localWin;
      localWin = void 0;
      elWin = void 0;
      elDoc = void 0;
      frame_list = void 0;
      frame = void 0;
      fe = void 0;
      idx = 0;
      e = void 0;
      err = void 0;
      try {
        localWin = el.contentWindow || null;
        if (!win) {
          elDoc = doc(el);
          elWin = elDoc && view(elDoc);
          frame_list = (elWin && elWin.frames) || [];
          while (frame = frame_list[idx++]) {
            try {
              fe = frame.frameElement;
            } catch (_error) {
              err = _error;
              fe = null;
            }
            if (fe && fe === el) {
              localWin = frame;
              break;
            }
          }
        }
      } catch (_error) {
        e = _error;
        localWin = null;
      }
      return localWin;
    };

    /*
    @ignore
     */
    gc = _lang.noop;
    (function() {
      var ATTR_NAME, CREATE_EVENT, EVT_TYPE, err, obj, prop;
      obj = void 0;
      ATTR_NAME = "SCROLLING";
      CREATE_EVENT = "createEvent";
      EVT_TYPE = "UIEvent";
      prop = void 0;
      err = void 0;
      if (isIE) {
        evt_tgt_prop_a = "srcElement";
        evt_tgt_prop_b = "target";
        obj = make_element(IFRAME);
        attr(obj, ATTR_NAME, "no");
        useOldStyleAttrMethods = attr(obj, ATTR_NAME) !== "no";
        if (GC in win) {

          /*
          @ignore
           */
          gc = function() {
            if (gc_timer_id) {
              clearTimeout(gc_timer_id);
            }
            gc_timer_ig(setTimeout(function() {
              try {
                win[GC]();
              } catch (_error) {}
            }, IE_GC_INTERVAL));
          };
        } else {
          gc = _lang.noop;
        }
      } else {
        evt_tgt_prop_a = "target";
        evt_tgt_prop_b = "currentTarget";
      }
      if (win[w3c_attach] && !isIE) {
        use_attach = w3c_attach;
        use_detach = w3c_detach;
      } else if (isIE) {
        use_ie_old_attach = true;
        use_attach = ie_attach;
        use_detach = ie_detach;
      }
      obj = null;
      try {
        obj = theDocument[CREATE_EVENT](EVT_TYPE);
      } catch (_error) {
        err = _error;
        obj = null;
      }
      if (!obj) {
        try {
          obj = theDocument[CREATE_EVENT](EVT_TYPE + "s");
        } catch (_error) {
          err = _error;
          obj = null;
        }
      }
      if (obj) {
        for (prop in EVT_CNCL_METHODS) {
          if (obj[prop]) {
            EVT_CNCL_METHODS[prop] = 1;
          }
        }
      }
      obj = null;
      attach(win, "load", _handle_dom_load_evt);
      return attach(win, "DOMContentLoaded", _handle_dom_load_evt);
    })();
    return dom = {
      doc: doc,
      view: view,
      elt: elt,
      tagName: tagName,
      tags: tags,
      par: par,
      make: make_element,
      css: css,
      attr: attr,
      gc: gc,
      append: append,
      purge: purge,
      attach: attach,
      detach: detach,
      ready: ready,
      wait: wait,
      evtCncl: evtCncl,
      evtTgt: evtTgt,
      iframes: {
        make: make_iframe,
        clone: clone_iframe,
        replace: replace_iframe,
        view: iframe_view
      }
    };
  })(window, lang, env);

}).call(this);

},{"./env":15,"./lang":16}],15:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var lang,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lang = require('./lang');

  module.exports = (function(window) {
    var cached_ua, isIE, isIE11, navigator, theDocument, ua, userAgent, win;
    win = window;
    navigator = window.navigator;
    theDocument = window.document;
    userAgent = (navigator != null ? navigator.userAgent : void 0) || "";
    isIE11 = !window.ActiveXObject && __indexOf.call(window, "ActiveXObject") >= 0;
    isIE = !isIE11 && (win && (__indexOf.call(win, "ActiveXObject") >= 0));
    cached_ua = null;
    ua = (function() {

      /*
      Convert a version string into a numeric value
      
      @name $sf.env.ua-_numberify
      @static
      @private
      @function
      @param {String} s The string representing a version number (e.g. 'major.minor.revision')
      @returns {Number}
       */
      var parse_ua, _matchIt, _numberify, _testIt;
      _numberify = function(s) {
        var c;
        c = 0;
        return parseFloat(s.replace(/\./g, function() {
          if (c++ === 1) {
            return "";
          } else {
            return ".";
          }
        }));
      };

      /*
      Wrapper method for returning values from a regular expression match safely.
      
      @name $sf.env.ua-_matchIt
      @static
      @private
      @function
      @param {String} str The string to match against
      @param {RegExp} regEx The regular expression to use for matching
      @param {Number} [idx] The index number of a match to pull from
      @returns {String}
       */
      _matchIt = function(str, regEx, idx) {
        var m;
        m = str && str.match(regEx);
        if (!(idx != null)) {
          return m;
        } else {
          return (m && m[idx]) || null;
        }
      };

      /*
      Wrapper method for testing a string against a regular expression
      
      @name $sf.env.ua-_testIt
      @static
      @private
      @function
      @param {RegExp} regEx The regular expression to test with
      @param {String} str The string to test against
      @param {Boolean}
       */
      _testIt = function(regEx, str) {
        return regEx.test(str);
      };

      /*
      Parse a user-agent string from the browser and gather pertinent browser, and OS information
      
      @name $sf.env.ua.parse
      @static
      @public
      @function
      @param {String} [subUA] An alternate user-agent string to parse. If no valid string is passed in, function will return an object based on the known user-agent
      @returns {Object} <b>parsed</b> Browser and OS information<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ie  The major version number of the Internet Explorer browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.opera The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.gecko The major version number of the Gecko (Firefox) browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webkit The major version number of the WebKit browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.safari The major version number of the Safari browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.chrome The major version number of the Chrome browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.air The major version number of the AIR SDK being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipod Whether or not an iPod device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ipad Whether or not an iPad device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.iphone Whether or not an iPhone device is being used 1 for true, 0 for false.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.android The major version number of the Android OS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.webos The major version number of the WebOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.silk The major version number of the Silk browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.nodejs The major version number of the NodeJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.phantomjs The major version number of the PhantomJS environment being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {String} <b>parsed</b>.mobile A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.ios The major version number of the iOS being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Boolean} <b>parsed</b>.accel Whether or not the browser / environment in question is hardware accelerated.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @returns {Number} <b>parsed</b>.cajaVersion The major version number of the CAJA environment or 0 if not.
       */
      parse_ua = function(subUA) {
        var date, e, match, ret;
        ret = {};
        date = new Date();
        if (!subUA && cached_ua) {
          return cached_ua;
        }
        ret.ie = ret.opera = ret.gecko = ret.webkit = ret.safari = ret.chrome = ret.air = ret.ipod = ret.ipad = ret.iphone = ret.android = ret.webos = ret.silk = ret.nodejs = ret.phantomjs = 0;
        ret.mobile = ret.ios = ret.os = null;
        ret.accel = false;
        ret.caja = navigator && navigator.cajaVersion;
        ret.cks = false;
        subUA = subUA || userAgent || "";
        if (subUA) {
          if (_testIt(/windows|win32/i, subUA)) {
            ret.os = "windows";
          } else if (_testIt(/macintosh|mac_powerpc/i, subUA)) {
            ret.os = "macintosh";
          } else if (_testIt(/android/i, subUA)) {
            ret.os = "android";
          } else if (_testIt(/symbos/i, subUA)) {
            ret.os = "symbos";
          } else if (_testIt(/linux/i, subUA)) {
            ret.os = "linux";
          } else {
            if (_testIt(/rhino/i, subUA)) {
              ret.os = "rhino";
            }
          }
          if (_testIt(/KHTML/, subUA)) {
            ret.webkit = 1;
          }
          if (_testIt(/IEMobile|XBLWP7/, subUA)) {
            ret.mobile = "windows";
          }
          if (_testIt(/Fennec/, subUA)) {
            ret.mobile = "gecko";
          }
          match = _matchIt(subUA, /AppleWebKit\/([^\s]*)/, 1);
          if (match) {
            ret.webkit = _numberify(match);
            ret.safari = ret.webkit;
            if (_testIt(/PhantomJS/, subUA)) {
              match = _matchIt(subUA, /PhantomJS\/([^\s]*)/, 1);
              if (match) {
                ret.phantomjs = _numberify(match);
              }
            }
            if (_testIt(RegExp(" Mobile\\/"), subUA) || _testIt(/iPad|iPod|iPhone/, subUA)) {
              ret.mobile = "Apple";
              match = _matchIt(subUA, /OS ([^\s]*)/, 1);
              match = match && _numberify(match.replace("_", "."));
              ret.ios = match;
              ret.ipad = ret.ipod = ret.iphone = 0;
              match = _matchIt(subUA, /iPad|iPod|iPhone/, 0);
              if (match) {
                ret[match.toLowerCase()] = ret.ios;
              }
            } else {
              match = _matchIt(subUA, /NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/, 0);
              if (match) {
                ret.mobile = match;
              }
              if (_testIt(/webOS/, subUA)) {
                ret.mobile = "WebOS";
                match = _matchIt(subUA, /webOS\/([^\s]*);/, 1);
                if (match) {
                  ret.webos = _numberify(match);
                }
              }
              if (_testIt(RegExp(" Android"), subUA)) {
                ret.mobile = "Android";
                match = _matchIt(subUA, /Android ([^\s]*);/, 1);
                if (match) {
                  ret.android = _numberify(match);
                }
              }
              if (_testIt(/Silk/, subUA)) {
                match = _matchIt(subUA, /Silk\/([^\s]*)\)/, 1);
                if (match) {
                  ret.silk = _numberify(match);
                }
                if (!ret.android) {
                  ret.android = 2.34;
                  ret.os = "Android";
                }
                if (_testIt(/Accelerated=true/, subUA)) {
                  ret.accel = true;
                }
              }
            }
            match = subUA.match(/(Chrome|CrMo)\/([^\s]*)/);
            if (match && match[1] && match[2]) {
              ret.chrome = _numberify(match[2]);
              ret.safari = 0;
              if (match[1] === "CrMo") {
                ret.mobile = "chrome";
              }
            } else {
              match = _matchIt(subUA, /AdobeAIR\/([^\s]*)/);
              if (match) {
                ret.air = match[0];
              }
            }
          }
          if (!ret.webkit) {
            match = _matchIt(subUA, /Opera[\s\/]([^\s]*)/, 1);
            if (match) {
              ret.opera = _numberify(match);
              match = _matchIt(subUA, /Opera Mini[^;]*/, 0);
              if (match) {
                ret.mobile = match;
              }
            } else {
              match = _matchIt(subUA, /MSIE\s([^;]*)/, 1);
              if (match) {
                ret.ie = _numberify(match);
              } else {
                match = _matchIt(subUA, /Gecko\/([^\s]*)/);
                if (match) {
                  ret.gecko = 1;
                  match = _matchIt(subUA, /rv:([^\s\)]*)/, 1);
                  if (match) {
                    ret.gecko = _numberify(match);
                  }
                }
              }
            }
          }
        }
        try {
          date.setTime(date.getTime() + 1000);
          theDocument.cookie = lang.cstr(["sf_ck_tst=test; expires=", date.toGMTString(), "; path=/"]);
          if (theDocument.cookie.indexOf("sf_ck_tst") !== -1) {
            ret.cks = true;
          }
        } catch (_error) {
          e = _error;
          ret.cks = false;
        }
        try {
          if (typeof process === "object") {
            if (process.versions && process.versions.node) {
              ret.os = process.platform;
              ret.nodejs = numberify(process.versions.node);
            }
          }
        } catch (_error) {
          e = _error;
          ret.nodejs = 0;
        }
        return ret;
      };

      /*
      The major version number of the Internet Explorer browser being used, or 0 if not.
      
      @name $sf.env.ua.ie
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Opera browser being used, or 0 if not.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      @name $sf.env.ua.opera
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Gecko (Firefox) browser being used, or 0 if not.
      @name $sf.env.ua.gecko
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebKit browser being used, or 0 if not.
      @name $sf.env.ua.webkit
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Safari browser being used, or 0 if not.
      @name $sf.env.ua.safari
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Chrome browser being used, or 0 if not.
      @name $sf.env.ua.chrome
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the AIR SDK being used, or 0 if not.
      @name $sf.env.ua.air
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPod device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipod
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPad device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.ipad
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not an iPhone device is being used, 0 for false, &gt; 0 == true
      @name $sf.env.ua.iphone
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Android OS being used, or 0 if not.
      @name $sf.env.ua.android
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the WebOS being used, or 0 if not.
      @name $sf.env.ua.webos
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the Silk browser being used, or 0 if not.
      @name $sf.env.ua.silk
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the NodeJS environment being used, or 0 if not.
      @name $sf.env.ua.nodejs
      @type {Number}
      @public
      @static
       */

      /*
      The major version number of the PhantomJS environment being used, or 0 if not.
      @name $sf.env.ua.phantomjs
      @type {Number}
      @public
      @static
       */

      /*
      A string representing whether or not the browser / os is a mobile device  and it's type. Possible values are 'windows', 'android', 'symbos', 'linux', 'macintosh', 'rhino', 'gecko', 'Apple', 'chrome'.
      
      @name $sf.env.ua.mobile
      @type {String}
      @public
      @static
       */

      /*
      The major version number of the iOS being used, or 0 if not.
      @name $sf.env.ua.ios
      @type {Number}
      @public
      @static
       */

      /*
      Whether or not the browser / environment in question is hardware accelerated.
      @name $sf.env.ua.accel
      @type {Boolean}
      @public
      @static
       */

      /*
      The major version number of the CAJA environment or 0 if not
      @name $sf.env.ua.cajaVersion
      @type {Number}
      @public
      @static
       */
      cached_ua = parse_ua();
      cached_ua.parse = parse_ua;
      return cached_ua;
    })();
    return {
      ua: ua,
      isIE: isIE
    };
  })(window);

}).call(this);

}).call(this,require("/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./lang":16,"/usr/local/lib/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":27}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var ParamHash, backSlash, callable, cbool, cnum, cstr, def, entityMap, entityRegexes, guid, isArray, jssafe_html, keys, lang, mix, next_id, noop, ns, proto, rand, scrip_str, time, toString, trim, win, wrap, _es, _ue;
    next_id = 0;
    win = window;
    backSlash = String.fromCharCode(92);
    scrip_str = 'scr"+"ipt';
    _es = win.escape;
    _ue = win.unescape;

    /*
    A function reference that does nothing.
    
    @memberOf $sf.lib.lang
    @exports noop as $sf.lib.lang.noop
    @static
    @function
    @public
    @return undefined
     */
    noop = function() {

      /*
      Forces type conversion of any JavaScript variable to a string value.
      Note that "falsy" values or values that cannot be converted will be returned
      as an empty string ("").
      
      @memberOf $sf.lib.lang
      @exports cstr as $sf.lib.lang.cstr
      @static
      @public
      @function
      @param {*} str  Any object that needs to be converted to a string value.
      @return {String}  The normalized string value.
       */
    };
    cstr = function(str) {
      var typ;
      typ = typeof str;
      if (typ === "string") {
        return str;
      }
      if (typ === "number" && !str) {
        return "0";
      }
      if (typ === "object" && str && str.join) {
        return str.join("");
      }
      if (typ === "boolean") {
        return str.toString();
      }
      if (str) {
        return String(str);
      } else {
        return "";
      }
    };

    /*
    Forces type conversion of any JavaScript variable to a boolean.
    "Falsy" values such as "", 0, null, and undefined all return false
    String values of  "0", "false", "no", "undefined", "null" also return false
    
    @memberOf $sf.lib.lang
    @exports cbool as $sf.lib.lang.cbool
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @return {Boolean} The normalized boolean value
     */
    cbool = function(val) {
      if (!val || val === "0" || val === "false" || val === "no" || val === "undefined" || val === "null") {
        return false;
      } else {
        return true;
      }
    };
    keys = function(obj) {
      var k, _v;
      return (typeof Object.keys === "function" ? Object.keys(obj) : void 0) || ((function() {
        var _results;
        _results = [];
        for (k in obj) {
          _v = obj[k];
          _results.push(k);
        }
        return _results;
      })());
    };

    /*
    Forces type conversion of any JavaScript variable to a number.
    Values / objects that cannot be converted, will be returned as NaN, unless
    a default value is specified, in which case the default value is used.
    
    @memberOf $sf.lib.lang
    @exports cnum as $sf.lib.lang.cnum
    @static
    @public
    @function
    @param {*} val Any JavaScript reference / value
    @param {*} [defVal] use this value if original value cannot be converted to a number, or if value is less than min value, or if value is less than max value.
    @param {Number} [minVal] specifies the lowest numerical value, if original value is less than this value, the defVal will be returned.
    @param {Number} [maxVal] specifies the greatest numerical value, if original value is greater than this value, the defVal will be returned.
    @return {Number|NaN|*} the converted value, otherwise NaN or default value
     */
    cnum = function(val, defVal, minVal, maxVal) {
      var e;
      if (typeof val !== "number") {
        try {
          if (!val) {
            val = Number.NaN;
          } else {
            val = parseFloat(val);
          }
        } catch (_error) {
          e = _error;
          val = Number.NaN;
        }
      }
      if (maxVal == null) {
        maxVal = Number.MAX_VALUE;
      }
      if (minVal == null) {
        minVal = -Number.MAX_VALUE;
      }
      if ((isNaN(val) || val < minVal || val > maxVal) && (defVal != null)) {
        return defVal;
      } else {
        return val;
      }
    };

    /*
    Checks that a function reference can be called safely.  Sometimes function references are part
    of objects that may have been garbage collected (such as a function reference from another window or dom element).
    This method checks the reference by making sure it has a constructor and toString properties.
    
    Note that this doesn't mean that the function itself when called (or its subsquent call stack), can't throw an error. . .
    simply that you are able to call it. . .
    
    this can problem be removed in lieu of func?() in cs
    
    @memberOf $sf.lib.lang
    @exports callable as $sf.lib.lang.callable
    @static
    @public
    @function
    @param {Function} A reference to a JavaScript function
    @return {Boolean} true if function can be called safely, otherwise false.
     */
    callable = function(f) {
      var e;
      try {
        f = (f && typeof f === "function" && f.toString() && (new f.constructor()) ? f : null);
      } catch (_error) {
        e = _error;
        f = null;
      }
      return !!f;
    };

    /*
    Generate a unique id string
    
    @memberOf $sf.lib.lang
    @exports guid as $sf.lib.lang.guid
    @static
    @public
    @function
    @param {String} [prefix] a substring to use a prefix
    @return {String} unique id string
     */
    guid = function(prefix) {
      return cstr([prefix || "", "_", time(), "_", rand(), "_", next_id++]);
    };

    /*
    Mixed the properties of one object into another object.
    Note that this function is recursive
    
    
    
    @memberOf $sf.lib.lang
    @exports mix as $sf.lib.lang.mix
    @static
    @public
    @function
    @param {Object}  r  The object that will receive properties
    @param {Object}  s  The object that will deliever properties
    @param {Boolean} [owned] Whether or not to skip over properties that are part of the object prototype
    @param {Boolean} [skipFuncs] Whether or not to skip over function references
    @param {Boolean} [no_ovr] Whether or not to overwrite properties that may have already been filled out
    @return {Object} The receiver object passed in with potentially new properties added
     */
    mix = function(r, s, owned, skipFuncs, no_ovr) {
      var item, p, typ;
      if (!s || !r) {
        return r;
      }
      for (p in s) {
        item = s[p];
        typ = typeof item;
        if (owned && !s.hasOwnProperty(p)) {
          continue;
        }
        if (no_ovr && (p in r)) {
          continue;
        }
        if (skipFuncs && typ === "function") {
          continue;
        }
        if (typ === "object" && item) {
          if (item.slice) {
            item = mix([], item);
          } else {
            item = mix({}, item);
          }
        }
        r[p] = item;
      }
      return r;
    };

    /*
    Return the current time in milliseconds, from the epoch
    
    @memberOf $sf.lib.lang
    @exports time as $sf.lib.lang.time
    @public
    @function
    @static
    @return {Number} current time
     */
    time = function() {
      return (new Date()).getTime();
    };

    /*
    Return a random integer anywhere from 0 to 99
    
    @memberOf $sf.lib.lang
    @exports rand as $sf.lib.lang.rand
    @public
    @static
    @function
    @return {Number} random number
     */
    rand = function() {
      return Math.round(Math.random() * 100);
    };

    /*
    Trim the begining and ending whitespace from a string.
    Note that this function will convert an argument to a string first
    for type safety purposes. If string cannot be converted, and empty string is returned
    
    @memberOf $sf.lib.lang
    @exports trim as $sf.lib.lang.trim
    @return {String} trimmed string
    @public
    @function
    @static
     */
    trim = function(str) {
      var ret;
      ret = cstr(str);
      return ret && ret.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    };

    /*
    Define a JavaScript Namespace within a given context
    
    @memberOf $sf.lib.lang
    @exports def as $sf.lib.lang.def
    @param {String} str_ns  The name of the namespace in dot notation as a string (e.g. "Foo.bar")
    @param {Object} [aug] defines the object at the end of the namespace.  If namespace is already specified, and this object is provided, the namespace will be augmented with properties from this object. If nothing is passed in, defaults to using an empty object.
    @param {Object} [root] the root object from which the namespace is defined.  If not passed in defaults to the global/window object
    @param {Boolean} [no_ovr] if true, properties already defined on root with the same name will be ignored
    @public
    @function
    @static
    @return {Object} The object at the end of the namespace
     */
    def = function(str_ns, aug, root, no_ovr) {
      var ar, idx, item, obj, per, ret;
      obj = (root && typeof root === "object" ? root : win);
      idx = 0;
      per = ".";
      ret = null;
      if (str_ns) {
        str_ns = cstr(str_ns);
        aug = (aug && typeof aug === "object" ? aug : null);
        if (str_ns.indexOf(per)) {
          ar = str_ns.split(per);
          while (item = ar[idx++]) {
            item = trim(item);
            if (idx === ar.length) {
              if (obj[item] && aug) {
                ret = obj[item] = mix(obj[item], aug, false, null, no_ovr);
              } else {
                if (no_ovr && (item in obj)) {
                  ret = obj[item];
                } else {
                  ret = obj[item] = obj[item] || aug || {};
                }
              }
            } else {
              if (no_ovr && (item in obj)) {
                ret = obj[item];
              } else {
                ret = obj[item] = obj[item] || {};
              }
            }
            obj = obj[item];
          }
        } else {
          if (obj[str_ns] && aug) {
            ret = obj[str_ns] = mix(obj[str_ns], aug, false, null, no_ovr);
          } else {
            ret = obj[str_ns] = obj[str_ns] || aug || {};
          }
        }
      }
      return ret;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.ns
    @param {String} str_ns  A string with . or [] notation of a JavaScript namesace (e.g. "foo.bar.show", or "foo['bar']['show']").
    @param {Object} [root] the root object to check within. .defaults to global / window
    @return {*} The endpoint reference of the namespace or false if not found
    @public
    @function
    @static
     */
    ns = function(str_ns, root) {
      var exists, exp, exp2, exp3, exp4, idx, matches, obj, prop, rootStr;
      exp = /(\[(.{1,})\])|(\.\w+)/g;
      exp2 = /\[(('|")?)((\s|.)*?)(('|")?)\]/g;
      exp3 = /(\[.*)|(\..*)/g;
      exp4 = /\./g;
      idx = 0;
      rootStr = "";
      exists = true;
      obj = root = root || win;
      if (str_ns) {
        str_ns = cstr(str_ns);
        if (str_ns) {
          str_ns = trim(str_ns);
          matches = str_ns.match(exp);
          if (matches) {
            rootStr = str_ns.replace(exp3, "");
            matches.unshift(rootStr);
            while (prop = matches[idx++]) {
              prop = prop.replace(exp2, "$3").replace(exp4, "");
              if (!obj[prop]) {
                exists = false;
                break;
              }
              obj = obj[prop];
            }
          } else {
            prop = str_ns;
            obj = obj[prop];
          }
        } else {
          exists = false;
        }
      } else {
        exists = false;
      }
      return (exists && obj) || false;
    };

    /*
    @function
    Tests to see if the object passed in is an array
     */
    isArray = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === "string") {
        return false;
      }
      if ((obj.length != null) && obj.constructor === Array) {
        return true;
      }
      return false;
    };

    /*
    Checks for the existence of a JavaScript namespace
    as opposed to def, which will automatically define the namespace
    with a given context.         via underscore.js
    
    @memberOf $sf.lib.lang
    @exports ns as $sf.lib.lang.wrap
    @param {Function} function to be wrapped
    @param {Function} wrapper function
    @return {Function}
    @public
    @function
    @static
     */
    wrap = function(func, wrapper) {
      return function() {
        var args;
        args = [func];
        Array.prototype.push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    };

    /*
    Given a string of HTML escape quote marks and seperate script tags so that browsers don't get tripped up
    during processing.
    
    @memberOf $sf.lib.lang
    @exports jssafe_html as $sf.lib.lang.jssafe_html
    @param {String} str A string of HTML markup to be processed
    @return {String}
    @function
    @static
    @public
     */
    entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;'
      }
    };
    entityRegexes = {
      escape: new RegExp('[' + keys(entityMap.escape).join('') + ']', 'g')
    };
    jssafe_html = function(str) {
      if (str == null) {
        return '';
      }
      return ('' + string).replace(entityRegexes.escape, function(match) {
        return entityMap.escape[match];
      });
    };

    /*
    @class Intantiable class used to convert a delimited string into an object.<br />
    For example querystrings: "name_1=value_1&name_2=value_2" ==> {name_1:value_1,name_2:value_2};<br/><br />
    
    Note that property values could also contain the same sPropDelim and sValueDelim strings.  Proper string encoding should occur
    to not trip up the parsing of the string.  Said values may be ascii escaped, and in turn, along with the <i><b>bRecurse</b></i> constructor parameter set to true, will cause nested ParamHash objects to be created.
    
    @constructor
    @memberOf $sf.lib.lang
    @exports ParamHash as $sf.lib.lang.ParamHash
    @param {String} [sString]  The delimited string to be converted
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [bNoOverwrite=false]  If true, when a name is encountered more than 1 time in the string it will be ignored.
    @param {Boolean} [bRecurse=false]  If true, when a value of a property that is parsed also has both the sPropDelim and sValueDelim inside, convert that value to another ParamHash object automatically
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1");
    alert(ph.x); // == 1
    alert(ph.y); // == 1
    alert(ph.z); // == 1
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x:1;y:2;z:3", ";", ":");
    alert(ph.x); // == 1
    alert(ph.y); // == 2
    alert(ph.z); // == 3
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2");
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 2 b/c of 2 properties with the same name
    
    @example
    var ph = new $sf.lib.lang.ParamHash("x=1&y=1&z=1&z=2",null,null,true); //null for sPropDelim and sValueDelim == use default values of "&" and "=" respectively
    alert(ph.x); // == 1
    alert(ph.y); // 1
    alert(ph.z); //Note that z == 1 b/c bNoOverwrite was set to true
    
    @example
    //You can also do recursive processing if need be
    var points	= new $sf.lib.lang.ParamHash(),
    point_1	= new $sf.lib.lang.ParamHash(),
    point_2	= new $sf.lib.lang.ParamHash();
    
    point_1.x = 100;
    point_1.y = 75;
    
    point_2.x = 200;
    point_2.y = 150;
    
    points.point_1	= point_1;
    points.point_2	= point_2;
    
    var point_str	= points.toString();  // == "point_1=x%3D100%26y%3D75%26&point_2=x%3D200%26y%3D150%26&";
    var points_copy	= new $sf.lib.lang.ParamHash(point_str, null, null, true, true); //note passing true, b/c we want to recurse
    
    alert(points_copy.point_1.x) // == "100";
     */
    ParamHash = function(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse) {
      var added, cnt, doAdd, idx, idx2, idx3, io, len, len2, me, nm, nv, obj, pairs, sTemp, sTemp2, sTemp3, ss;
      me = this;
      io = "indexOf";
      ss = "substring";
      doAdd = false;
      if (!(me instanceof ParamHash)) {
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
      }
      if (!arguments.length) {
        return me;
      }
      if (sString && typeof sString === "object") {
        return mix(new ParamHash("", sPropDelim, sValueDelim, bNoOverwrite, bRecurse), sString);
      }
      sString = cstr(sString);
      sPropDelim = cstr(sPropDelim) || "&";
      sValueDelim = cstr(sValueDelim) || "=";
      if (!sString) {
        return me;
      }
      if (sPropDelim !== "?" && sValueDelim !== "?" && sString.charAt(0) === "?") {
        sString = sString[ss](1);
      }
      idx = sString[io]("?");
      idx2 = sString[io](sValueDelim);
      if (idx !== -1 && idx2 !== -1 && idx > idx2) {
        sTemp = _es(sString[ss](idx2 + 1));
        sTemp2 = sString.substr(0, idx2 + 1);
        sString = sTemp2 + sTemp;
      } else if (idx !== -1) {
        sString = sString[ss](idx + 1);
        return new ParamHash(sString, sPropDelim, sValueDelim, bNoOverwrite);
      }
      if (sString.charAt(0) === sPropDelim) {
        sString = sString[ss](1);
      }
      pairs = sString.split(sPropDelim);
      cnt = pairs.length;
      idx = 0;
      while (cnt--) {
        sTemp = pairs[idx++];
        added = false;
        doAdd = false;
        if (sTemp) {
          nv = sTemp.split(sValueDelim);
          len = nv.length;
          if (len > 2) {
            nm = _ue(nv[0]);
            nv.shift();
            if (bRecurse) {
              sTemp2 = nm + sValueDelim;
              idx2 = sString[io](sTemp2);
              len = sTemp2[LEN];
              sTemp3 = sString[ss](idx2 + len);
              sTemp2 = sPropDelim + sPropDelim;
              len2 = sTemp2[LEN];
              idx3 = sTemp3[io](sTemp2);
              if (idx3 !== -1) {
                sTemp3 = sString.substr(idx2 + len, idx3 + len2);
                obj = new ParamHash(sTemp3, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
                sTemp3 = "";
                len = 0;
                for (sTemp3 in obj) {
                  continue;
                }
                if (len > 0) {
                  idx += len - 1;
                }
                sTemp = obj;
              } else {
                sTemp = _ue(nv.join(sValueDelim));
              }
            } else {
              sTemp = _ue(nv.join(sValueDelim));
            }
            doAdd = true;
          } else if (len === 2) {
            nm = _ue(nv[0]);
            sTemp = _ue(nv[1]);
            doAdd = true;
          }
          if (doAdd) {
            if (bNoOverwrite) {
              if (!(nm in me)) {
                me[nm] = sTemp;
                added = true;
              }
            } else {
              me[nm] = sTemp;
              added = true;
            }
            if (bRecurse && added && nm && sTemp && typeof sTemp !== "object" && (sTemp[io](sPropDelim) >= 0 || sTemp[io](sValueDelim) >= 0)) {
              me[nm] = new ParamHash(sTemp, sPropDelim, sValueDelim, bNoOverwrite, bRecurse);
            }
          }
        }
      }
    };

    /*
    Converts a ParamHash object back into a string using the property and value delimiters specifed (defaults to "&" and "=").
    Again this method works recursively.  If an object is found as a property, it will convert that object into a ParamHash string
    and then escape it. Note also that this class's valueOf method is equal to this method.
    
    @methodOf ParamHash#
    @public
    @function
    @param {String} [sPropDelim="&"]  The substring delimiter used to seperate properties. Default is "&".
    @param {String} [sValueDelim="="]  The substring delimited used to seperate values.  Default is "=".
    @param {Boolean} [escapeProp=false] Whether or not to ascii escape the name of a property
    @param {Boolean} [dontEscapeValue=false] Do not escape values or properties automatically
    @return {String} the encoded string representation of the object.
     */
    toString = function(sPropDelim, sValueDelim, escapeProp, dontEscapeValue) {
      var buffer, item, itemType, me, prop;
      prop = void 0;
      buffer = [];
      me = this;
      itemType = void 0;
      item = void 0;
      sPropDelim = sPropDelim || "&";
      sValueDelim = sValueDelim || "=";
      for (prop in me) {
        item = me[prop];
        itemType = typeof item;
        if (item && itemType === "function") {
          continue;
        }
        if (item && itemType === "object") {
          item = toString.apply(item, [sPropDelim, sValueDelim, escapeProp, dontEscapeValue]);
        }
        if (escapeProp) {
          prop = _es(prop);
        }
        if (!dontEscapeValue) {
          item = _es(item);
        }
        buffer.push(prop, sValueDelim, item, sPropDelim);
      }
      return cstr(buffer);
    };
    proto = ParamHash.prototype;
    if (!String.prototype.trim) {
      String.prototype.trim = trim;
    }

    /*
    @ignore
     */
    proto.toString = proto.valueOf = toString;
    lang = {
      ParamHash: ParamHash,
      cstr: cstr,
      cnum: cnum,
      cbool: cbool,
      noop: noop,
      trim: trim,
      callable: callable,
      guid: guid,
      mix: mix,
      time: time,
      rand: rand,
      def: def,
      ns: ns,
      jssafe_html: jssafe_html,
      isArray: isArray,
      wrap: wrap,
      keys: keys
    };
    if (typeof exports !== "undefined" && exports !== null) {
      return exports.lang = lang;
    } else {
      return lang;
    }
  })(window);

}).call(this);

},{}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  module.exports = (function(window) {
    var logError, logInfo, win;
    win = window;

    /*
    Write an entry to the console log and fire any log listeners
    
    @message  The log message
     */
    logInfo = function(message) {
      if (win.console && console.log) {
        console.log(message);
      }
    };

    /*
    Write an entry to the console error log and fire any log listeners
    
    @message  The log message
     */
    logError = function(message) {
      if (win.console && console.error) {
        console.error(message);
      } else {
        if (win.console && console.log) {
          console.log(message);
        }
      }
    };
    return {
      info: logInfo,
      error: logError
    };
  })(window);

}).call(this);

},{}],18:[function(require,module,exports){
/**
 * The buffer module from node.js, for the browser.
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install buffer`
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
  if (typeof Uint8Array !== 'function' || typeof ArrayBuffer !== 'function')
    return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Bug in Firefox 4-29, now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":19,"ieee754":20}],19:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],20:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],21:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":18}],22:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":23,"./rng":24,"./sha":25,"./sha256":26,"buffer":18}],23:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":21}],24:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],25:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":21}],26:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":21}],27:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1])